generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ConsentScope {
  VIEW
  STORE
  SHARE
}

enum ConsentStatus {
  GRANTED
  WITHDRAWN
}

enum RtbfStatus {
  REQUESTED
  IN_REVIEW
  APPROVED
  REJECTED
  FULFILLED
}

enum EncounterType {
  OPD
  IPD
  ER
}

enum FacilityCategory {
  SERVICE
  CLINICAL
  SUPPORT
}

enum BedState {
  VACANT
  OCCUPIED
  CLEANING
  MAINTENANCE
}

enum OutboxStatus {
  PENDING
  PROCESSING
  SENT
  FAILED
}

model Branch {
  id   String @id @default(cuid())
  code String @unique @db.VarChar(32)
  name String
  city String

  /// India GSTIN (15 characters). Used by Accounting/Tax.
  gstNumber String? @db.VarChar(15)

  address       String? @db.VarChar(240)
  contactPhone1 String? @db.VarChar(20)
  contactPhone2 String? @db.VarChar(20)
  contactEmail  String? @db.VarChar(120)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  departments Department[]
  users       User[]
  patients    Patient[]
  wards       Ward[]
  oTs         OT[]
  tariffPlans TariffPlan[]
  assets      Asset[]
  Specialty   Specialty[]
  Staff       Staff[]
  Encounter   Encounter[]
  Bed         Bed[]
  Admission   Admission[]

  // Facilities enabled for this branch (multi-select from FacilityCatalog)
  branchFacilities BranchFacility[]
  rooms            Room[]
  // Opposite relations (required for Prisma validation)
  statutoryCases   StatutoryCase[]
  auditEvents      AuditEvent[]

  // âœ… Policy Governance (opposite relations)
  policyVersions        PolicyVersion[]       @relation("PolicyVersion_Branch")
  policyVersionBranches PolicyVersionBranch[] @relation("PolicyTarget_Branch")
}

model FacilityCatalog {
  id       String           @id @default(cuid())
  code     String           @unique @db.VarChar(48)
  name     String           @db.VarChar(160)
  category FacilityCategory

  isActive  Boolean @default(true)
  sortOrder Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Branch enablement (multi-select)
  branchLinks BranchFacility[]

  // Departments created under this facility
  departments Department[]

  @@index([category, isActive, sortOrder])
}

model BranchFacility {
  id String @id @default(cuid())

  branchId String
  branch   Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  facilityId String
  facility   FacilityCatalog @relation(fields: [facilityId], references: [id], onDelete: Cascade)

  isEnabled Boolean  @default(true)
  enabledAt DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([branchId, facilityId])
  @@index([branchId, isEnabled])
  @@index([facilityId, isEnabled])
}

model Department {
  id       String @id @default(cuid())
  branchId String
  branch   Branch @relation(fields: [branchId], references: [id])

  facilityId String
  facility   FacilityCatalog @relation(fields: [facilityId], references: [id])
  code       String
  name       String

  headStaffId String?
  headStaff   Staff?  @relation("DepartmentHead", fields: [headStaffId], references: [id], onDelete: SetNull)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  staff       Staff[]     @relation("DepartmentStaff")
  departmentSpecialties DepartmentSpecialty[]

  doctorAssignments DepartmentDoctor[]

  @@unique([branchId, facilityId, code])
  @@index([branchId, facilityId, isActive])
}

model DepartmentDoctor {
  id String @id @default(cuid())

  departmentId String
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  staffId String
  staff   Staff  @relation(fields: [staffId], references: [id], onDelete: Cascade)

  isPrimary  Boolean  @default(false)
  assignedAt DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([departmentId, staffId])
  @@index([departmentId])
  @@index([staffId])
}

model Specialty {
  id       String @id @default(cuid())
  branchId String
  branch   Branch @relation(fields: [branchId], references: [id])

  code     String
  name     String
  isActive Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Staff can optionally be tagged to a primary specialty
  staff Staff[]

  // Mapping to Departments (many-to-many)
  departmentLinks DepartmentSpecialty[]

  @@unique([branchId, code])
  @@index([branchId, isActive])
}

model DepartmentSpecialty {
  id String @id @default(cuid())

  departmentId String
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  specialtyId String
  specialty   Specialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)

  isPrimary Boolean @default(false)
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([departmentId, specialtyId])
  @@index([departmentId, isActive])
  @@index([specialtyId, isActive])
}

model Staff {
  id           String      @id @default(cuid())
  branchId     String
  branch       Branch      @relation(fields: [branchId], references: [id])
  departmentId String?
  department   Department? @relation("DepartmentStaff", fields: [departmentId], references: [id])
  specialtyId  String?
  specialty    Specialty?  @relation(fields: [specialtyId], references: [id])

  empCode           String
  name              String
  designation       String
  phone             String?
  email             String?
  isActive          Boolean            @default(true)
  // Doctor assignment to departments (many-to-many)
  doctorAssignments DepartmentDoctor[]

  // Departments where this staff is Head of Department
  headedDepartments Department[] @relation("DepartmentHead")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User?

  @@unique([branchId, empCode])
}

model User {
  id    String @id @default(cuid())
  email String @unique
  name  String

  // Keep a simple role string for UI/back-compat (your code references this)
  role String @default("BRANCH_ADMIN")

  phone    String?
  branchId String?
  branch   Branch? @relation(fields: [branchId], references: [id])

  staffId String? @unique
  staff   Staff?  @relation(fields: [staffId], references: [id])

  isActive Boolean @default(true)

  passwordHash       String?
  mustChangePassword Boolean @default(false)

  passwordResetToken   String?              @unique
  passwordResetExpires DateTime?
  roleVersionId        String?
  roleVersion          RoleTemplateVersion? @relation("UserRoleVersion", fields: [roleVersionId], references: [id])

  createdRoleVersions RoleTemplateVersion[] @relation("RoleVersionCreatedBy")
  auditEventsAsActor  AuditEvent[]          @relation("AuditActor")

  // Policy governance opposite relations
  policyVersionsCreatedBy   PolicyVersion[] @relation("PolicyVersionCreatedBy")
  policyVersionsSubmittedBy PolicyVersion[] @relation("PolicyVersionSubmittedBy")
  policyVersionsApprovedBy  PolicyVersion[] @relation("PolicyVersionApprovedBy")
  policyVersionsRejectedBy  PolicyVersion[] @relation("PolicyVersionRejectedBy")
  policyVersionsRetiredBy   PolicyVersion[] @relation("PolicyVersionRetiredBy")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Patient {
  id       String @id @default(cuid())
  branchId String
  branch   Branch @relation(fields: [branchId], references: [id])

  uhid    String
  name    String
  gender  String?
  dob     DateTime?
  phone   String?
  email   String?
  address String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  encounters Encounter[]
  Admission  Admission[]

  // Opposite relations (required for Prisma validation)
  consentRecords ConsentRecord[]
  rtbfRequests   RtbfRequest[]
  statutoryCases StatutoryCase[]

  @@unique([branchId, uhid])
}

model Encounter {
  id        String  @id @default(cuid())
  branchId  String
  branch    Branch  @relation(fields: [branchId], references: [id])
  patientId String
  patient   Patient @relation(fields: [patientId], references: [id])

  type      EncounterType
  startedAt DateTime      @default(now())
  endedAt   DateTime?
  status    String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  admissions Admission[]
}

model Ward {
  id       String @id @default(cuid())
  branchId String
  branch   Branch @relation(fields: [branchId], references: [id])

  code      String
  name      String
  specialty String?
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  rooms Room[]

  @@unique([branchId, code])
}

model Room {
  id       String @id @default(cuid())
  branchId String
  branch   Branch @relation(fields: [branchId], references: [id])
  wardId   String
  ward     Ward   @relation(fields: [wardId], references: [id])

  code     String
  name     String
  floor    String?
  type     String?
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  beds Bed[]

  @@unique([wardId, code])
  @@index([branchId, wardId, isActive])
}

model Bed {
  id       String @id @default(cuid())
  branchId String
  branch   Branch @relation(fields: [branchId], references: [id])
  roomId   String
  room     Room   @relation(fields: [roomId], references: [id])

  code     String
  state    BedState @default(VACANT)
  isActive Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  admissions Admission[]

  @@unique([roomId, code])
  @@index([branchId, roomId, isActive])
}

model Admission {
  id       String @id @default(cuid())
  branchId String
  branch   Branch @relation(fields: [branchId], references: [id])

  encounterId String?
  encounter   Encounter? @relation(fields: [encounterId], references: [id])

  patientId String
  patient   Patient @relation(fields: [patientId], references: [id])

  bedId String?
  bed   Bed?    @relation(fields: [bedId], references: [id])

  admittedAt   DateTime  @default(now())
  dischargedAt DateTime?
  status       String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model OT {
  id       String @id @default(cuid())
  branchId String
  branch   Branch @relation(fields: [branchId], references: [id])

  code     String
  name     String
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([branchId, code])
}

model Asset {
  id       String @id @default(cuid())
  branchId String
  branch   Branch @relation(fields: [branchId], references: [id])

  code      String
  name      String
  category  String
  location  String?
  status    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([branchId, code])
}

model TariffPlan {
  id       String @id @default(cuid())
  branchId String
  branch   Branch @relation(fields: [branchId], references: [id])

  code   String
  name   String
  status String

  // Fields your billing controller expects
  payerType     String
  effectiveFrom DateTime
  effectiveTo   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations your billing controller expects
  rates TariffRate[]

  @@unique([branchId, code])
  @@index([branchId, effectiveFrom])
}

model ServiceCatalogItem {
  id        String   @id @default(cuid())
  code      String   @unique
  name      String
  category  String
  unit      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model TariffRate {
  id           String     @id @default(cuid())
  tariffPlanId String
  tariffPlan   TariffPlan @relation(fields: [tariffPlanId], references: [id], onDelete: Cascade)

  serviceCode String
  amount      Decimal @db.Decimal(12, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tariffPlanId, serviceCode])
  @@index([tariffPlanId])
}

model ConsentRecord {
  id        String  @id @default(cuid())
  patientId String
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  scope   ConsentScope
  purpose String
  status  ConsentStatus @default(GRANTED)

  createdAt DateTime @default(now())

  @@index([patientId, createdAt])
}

model RtbfRequest {
  id        String  @id @default(cuid())
  patientId String
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  reason String
  status RtbfStatus @default(REQUESTED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, createdAt])
  @@index([patientId, createdAt])
}

model StatutoryCase {
  id       String @id @default(cuid())
  branchId String
  branch   Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  patientId String
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  program String
  disease String
  status  String @default("DRAFT")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([branchId, updatedAt])
  @@index([program, updatedAt])
  @@index([patientId, updatedAt])
}

model AuditEvent {
  id String @id @default(cuid())

  branchId String?
  branch   Branch? @relation(fields: [branchId], references: [id], onDelete: SetNull)

  actorUserId String?
  actorUser   User?   @relation("AuditActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  action   String
  entity   String
  entityId String?
  meta     Json?

  createdAt DateTime @default(now())

  @@index([branchId, createdAt])
  @@index([actorUserId, createdAt])
  @@index([action, createdAt])
  @@index([entity, entityId])
}

model OutboxEvent {
  id          String       @id @default(cuid())
  topic       String
  key         String?
  payload     Json
  status      OutboxStatus @default(PENDING)
  attempts    Int          @default(0)
  availableAt DateTime     @default(now())
  lockedAt    DateTime?
  sentAt      DateTime?
  error       String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([status, availableAt])
}

enum RoleScope {
  GLOBAL
  BRANCH
}

enum RoleVersionStatus {
  DRAFT
  ACTIVE
  RETIRED
}

model Permission {
  id          String   @id @default(cuid())
  code        String   @unique
  name        String
  category    String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  roleGrants RoleTemplatePermission[]
}

model RoleTemplate {
  id          String    @id @default(cuid())
  code        String    @unique
  name        String
  scope       RoleScope @default(BRANCH)
  description String?
  isSystem    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  versions RoleTemplateVersion[]
}

model RoleTemplateVersion {
  id             String            @id @default(cuid())
  roleTemplateId String
  roleTemplate   RoleTemplate      @relation(fields: [roleTemplateId], references: [id])
  version        Int
  status         RoleVersionStatus @default(DRAFT)
  notes          String?

  createdByUserId String?
  createdByUser   User?   @relation("RoleVersionCreatedBy", fields: [createdByUserId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  permissions RoleTemplatePermission[]

  // NAME THIS RELATION TOO (users assigned to this role version)
  users User[] @relation("UserRoleVersion")

  @@unique([roleTemplateId, version])
}

model RoleTemplatePermission {
  id            String              @id @default(cuid())
  roleVersionId String
  roleVersion   RoleTemplateVersion @relation(fields: [roleVersionId], references: [id])
  permissionId  String
  permission    Permission          @relation(fields: [permissionId], references: [id])

  // allow/deny flag for future; keep allow-only for now
  allowed Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([roleVersionId, permissionId])
}

// ---------------------------------------------------------------------------
// Policy Governance (global baselines + branch overrides with maker-checker)
// ---------------------------------------------------------------------------

enum PolicyScope {
  GLOBAL
  BRANCH_OVERRIDE
}

enum PolicyVersionStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
  RETIRED
}

model PolicyDefinition {
  id          String  @id @default(cuid())
  code        String  @unique
  name        String
  type        String
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Canonical versions for this definition
  versions PolicyVersion[] @relation("PolicyDefinitionVersions")
}

model PolicyVersion {
  id String @id @default(cuid())

  // FK to the policy definition catalog (governance.service.ts expects this)
  policyId String
  policy   PolicyDefinition @relation("PolicyDefinitionVersions", fields: [policyId], references: [id])
  scope    PolicyScope      @default(GLOBAL)
  branchId String?
  branch   Branch?          @relation("PolicyVersion_Branch", fields: [branchId], references: [id], onDelete: SetNull)

  version Int
  status  PolicyVersionStatus @default(DRAFT)

  effectiveAt DateTime @default(now())
  notes       String?
  payload     Json

  applyToAllBranches Boolean               @default(true)
  branches           PolicyVersionBranch[]

  createdByUserId String?
  createdByUser   User?   @relation("PolicyVersionCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)

  submittedAt       DateTime?
  submittedByUserId String?
  submittedByUser   User?     @relation("PolicyVersionSubmittedBy", fields: [submittedByUserId], references: [id], onDelete: SetNull)

  approvedAt       DateTime?
  approvedByUserId String?
  approvedByUser   User?     @relation("PolicyVersionApprovedBy", fields: [approvedByUserId], references: [id], onDelete: SetNull)
  approvalNote     String?

  rejectedAt       DateTime?
  rejectedByUserId String?
  rejectedByUser   User?     @relation("PolicyVersionRejectedBy", fields: [rejectedByUserId], references: [id], onDelete: SetNull)
  rejectionReason  String?

  retiredAt       DateTime?
  retiredByUserId String?
  retiredByUser   User?     @relation("PolicyVersionRetiredBy", fields: [retiredByUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // NOTE: We intentionally model the relation via policyId.
  // Any legacy/experimental policyDefinitionId field was removed to keep the schema unambiguous.

  @@index([policyId, scope, status])
  @@index([branchId, status])
  @@index([policyId, scope, version])
  @@index([policyId, branchId, version])
}

model PolicyVersionBranch {
  id              String        @id @default(cuid())
  policyVersionId String
  policyVersion   PolicyVersion @relation(fields: [policyVersionId], references: [id], onDelete: Cascade)

  branchId String
  branch   Branch @relation("PolicyTarget_Branch", fields: [branchId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([policyVersionId, branchId])
  @@index([branchId])
}
