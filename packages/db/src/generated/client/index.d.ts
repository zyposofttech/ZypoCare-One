
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model FacilityCatalog
 * 
 */
export type FacilityCatalog = $Result.DefaultSelection<Prisma.$FacilityCatalogPayload>
/**
 * Model BranchFacility
 * 
 */
export type BranchFacility = $Result.DefaultSelection<Prisma.$BranchFacilityPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model DepartmentDoctor
 * 
 */
export type DepartmentDoctor = $Result.DefaultSelection<Prisma.$DepartmentDoctorPayload>
/**
 * Model Specialty
 * 
 */
export type Specialty = $Result.DefaultSelection<Prisma.$SpecialtyPayload>
/**
 * Model DepartmentSpecialty
 * 
 */
export type DepartmentSpecialty = $Result.DefaultSelection<Prisma.$DepartmentSpecialtyPayload>
/**
 * Model Staff
 * 
 */
export type Staff = $Result.DefaultSelection<Prisma.$StaffPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Encounter
 * 
 */
export type Encounter = $Result.DefaultSelection<Prisma.$EncounterPayload>
/**
 * Model Ward
 * 
 */
export type Ward = $Result.DefaultSelection<Prisma.$WardPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Bed
 * 
 */
export type Bed = $Result.DefaultSelection<Prisma.$BedPayload>
/**
 * Model Admission
 * 
 */
export type Admission = $Result.DefaultSelection<Prisma.$AdmissionPayload>
/**
 * Model OT
 * 
 */
export type OT = $Result.DefaultSelection<Prisma.$OTPayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model TariffPlan
 * 
 */
export type TariffPlan = $Result.DefaultSelection<Prisma.$TariffPlanPayload>
/**
 * Model ServiceCatalogItem
 * 
 */
export type ServiceCatalogItem = $Result.DefaultSelection<Prisma.$ServiceCatalogItemPayload>
/**
 * Model TariffRate
 * 
 */
export type TariffRate = $Result.DefaultSelection<Prisma.$TariffRatePayload>
/**
 * Model ConsentRecord
 * 
 */
export type ConsentRecord = $Result.DefaultSelection<Prisma.$ConsentRecordPayload>
/**
 * Model RtbfRequest
 * 
 */
export type RtbfRequest = $Result.DefaultSelection<Prisma.$RtbfRequestPayload>
/**
 * Model StatutoryCase
 * 
 */
export type StatutoryCase = $Result.DefaultSelection<Prisma.$StatutoryCasePayload>
/**
 * Model AuditEvent
 * 
 */
export type AuditEvent = $Result.DefaultSelection<Prisma.$AuditEventPayload>
/**
 * Model OutboxEvent
 * 
 */
export type OutboxEvent = $Result.DefaultSelection<Prisma.$OutboxEventPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RoleTemplate
 * 
 */
export type RoleTemplate = $Result.DefaultSelection<Prisma.$RoleTemplatePayload>
/**
 * Model RoleTemplateVersion
 * 
 */
export type RoleTemplateVersion = $Result.DefaultSelection<Prisma.$RoleTemplateVersionPayload>
/**
 * Model RoleTemplatePermission
 * 
 */
export type RoleTemplatePermission = $Result.DefaultSelection<Prisma.$RoleTemplatePermissionPayload>
/**
 * Model PolicyDefinition
 * 
 */
export type PolicyDefinition = $Result.DefaultSelection<Prisma.$PolicyDefinitionPayload>
/**
 * Model PolicyVersion
 * 
 */
export type PolicyVersion = $Result.DefaultSelection<Prisma.$PolicyVersionPayload>
/**
 * Model PolicyVersionBranch
 * 
 */
export type PolicyVersionBranch = $Result.DefaultSelection<Prisma.$PolicyVersionBranchPayload>
/**
 * Model LocationNode
 * 
 */
export type LocationNode = $Result.DefaultSelection<Prisma.$LocationNodePayload>
/**
 * Model LocationNodeRevision
 * 
 */
export type LocationNodeRevision = $Result.DefaultSelection<Prisma.$LocationNodeRevisionPayload>
/**
 * Model UnitTypeCatalog
 * 
 */
export type UnitTypeCatalog = $Result.DefaultSelection<Prisma.$UnitTypeCatalogPayload>
/**
 * Model BranchUnitType
 * 
 */
export type BranchUnitType = $Result.DefaultSelection<Prisma.$BranchUnitTypePayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model UnitRoom
 * 
 */
export type UnitRoom = $Result.DefaultSelection<Prisma.$UnitRoomPayload>
/**
 * Model UnitResource
 * 
 */
export type UnitResource = $Result.DefaultSelection<Prisma.$UnitResourcePayload>
/**
 * Model EquipmentAsset
 * 
 */
export type EquipmentAsset = $Result.DefaultSelection<Prisma.$EquipmentAssetPayload>
/**
 * Model DowntimeTicket
 * 
 */
export type DowntimeTicket = $Result.DefaultSelection<Prisma.$DowntimeTicketPayload>
/**
 * Model ChargeMasterItem
 * 
 */
export type ChargeMasterItem = $Result.DefaultSelection<Prisma.$ChargeMasterItemPayload>
/**
 * Model ServiceItem
 * 
 */
export type ServiceItem = $Result.DefaultSelection<Prisma.$ServiceItemPayload>
/**
 * Model ServiceChargeMapping
 * 
 */
export type ServiceChargeMapping = $Result.DefaultSelection<Prisma.$ServiceChargeMappingPayload>
/**
 * Model FixItTask
 * 
 */
export type FixItTask = $Result.DefaultSelection<Prisma.$FixItTaskPayload>
/**
 * Model BulkImportJob
 * 
 */
export type BulkImportJob = $Result.DefaultSelection<Prisma.$BulkImportJobPayload>
/**
 * Model ProcedureBooking
 * 
 */
export type ProcedureBooking = $Result.DefaultSelection<Prisma.$ProcedureBookingPayload>
/**
 * Model GoLiveReport
 * 
 */
export type GoLiveReport = $Result.DefaultSelection<Prisma.$GoLiveReportPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FacilityCategory: {
  SERVICE: 'SERVICE',
  CLINICAL: 'CLINICAL',
  SUPPORT: 'SUPPORT'
};

export type FacilityCategory = (typeof FacilityCategory)[keyof typeof FacilityCategory]


export const EncounterType: {
  OPD: 'OPD',
  IPD: 'IPD',
  ER: 'ER'
};

export type EncounterType = (typeof EncounterType)[keyof typeof EncounterType]


export const BedState: {
  VACANT: 'VACANT',
  OCCUPIED: 'OCCUPIED',
  CLEANING: 'CLEANING',
  MAINTENANCE: 'MAINTENANCE'
};

export type BedState = (typeof BedState)[keyof typeof BedState]


export const ConsentScope: {
  VIEW: 'VIEW',
  STORE: 'STORE',
  SHARE: 'SHARE'
};

export type ConsentScope = (typeof ConsentScope)[keyof typeof ConsentScope]


export const ConsentStatus: {
  GRANTED: 'GRANTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type ConsentStatus = (typeof ConsentStatus)[keyof typeof ConsentStatus]


export const RtbfStatus: {
  REQUESTED: 'REQUESTED',
  IN_REVIEW: 'IN_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  FULFILLED: 'FULFILLED'
};

export type RtbfStatus = (typeof RtbfStatus)[keyof typeof RtbfStatus]


export const OutboxStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  SENT: 'SENT',
  FAILED: 'FAILED'
};

export type OutboxStatus = (typeof OutboxStatus)[keyof typeof OutboxStatus]


export const RoleScope: {
  GLOBAL: 'GLOBAL',
  BRANCH: 'BRANCH'
};

export type RoleScope = (typeof RoleScope)[keyof typeof RoleScope]


export const RoleVersionStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  RETIRED: 'RETIRED'
};

export type RoleVersionStatus = (typeof RoleVersionStatus)[keyof typeof RoleVersionStatus]


export const PolicyScope: {
  GLOBAL: 'GLOBAL',
  BRANCH_OVERRIDE: 'BRANCH_OVERRIDE'
};

export type PolicyScope = (typeof PolicyScope)[keyof typeof PolicyScope]


export const PolicyVersionStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  RETIRED: 'RETIRED'
};

export type PolicyVersionStatus = (typeof PolicyVersionStatus)[keyof typeof PolicyVersionStatus]


export const LocationKind: {
  CAMPUS: 'CAMPUS',
  BUILDING: 'BUILDING',
  FLOOR: 'FLOOR',
  ZONE: 'ZONE'
};

export type LocationKind = (typeof LocationKind)[keyof typeof LocationKind]


export const UnitResourceType: {
  BED: 'BED',
  BAY: 'BAY',
  CHAIR: 'CHAIR',
  OT_TABLE: 'OT_TABLE',
  PROCEDURE_TABLE: 'PROCEDURE_TABLE',
  DIALYSIS_STATION: 'DIALYSIS_STATION',
  RECOVERY_BAY: 'RECOVERY_BAY',
  EXAM_SLOT: 'EXAM_SLOT',
  INCUBATOR: 'INCUBATOR'
};

export type UnitResourceType = (typeof UnitResourceType)[keyof typeof UnitResourceType]


export const UnitResourceState: {
  AVAILABLE: 'AVAILABLE',
  OCCUPIED: 'OCCUPIED',
  CLEANING: 'CLEANING',
  MAINTENANCE: 'MAINTENANCE',
  INACTIVE: 'INACTIVE'
};

export type UnitResourceState = (typeof UnitResourceState)[keyof typeof UnitResourceState]


export const EquipmentComplianceCategory: {
  GENERAL: 'GENERAL',
  RADIOLOGY: 'RADIOLOGY',
  ULTRASOUND: 'ULTRASOUND'
};

export type EquipmentComplianceCategory = (typeof EquipmentComplianceCategory)[keyof typeof EquipmentComplianceCategory]


export const EquipmentOperationalStatus: {
  OPERATIONAL: 'OPERATIONAL',
  DOWN: 'DOWN',
  MAINTENANCE: 'MAINTENANCE',
  RETIRED: 'RETIRED'
};

export type EquipmentOperationalStatus = (typeof EquipmentOperationalStatus)[keyof typeof EquipmentOperationalStatus]


export const DowntimeStatus: {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED'
};

export type DowntimeStatus = (typeof DowntimeStatus)[keyof typeof DowntimeStatus]


export const FixItType: {
  SERVICE_CHARGE_MAPPING_MISSING: 'SERVICE_CHARGE_MAPPING_MISSING'
};

export type FixItType = (typeof FixItType)[keyof typeof FixItType]


export const FixItStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  DISMISSED: 'DISMISSED'
};

export type FixItStatus = (typeof FixItStatus)[keyof typeof FixItStatus]


export const ImportEntityType: {
  LOCATIONS: 'LOCATIONS',
  UNITS: 'UNITS',
  ROOMS: 'ROOMS',
  RESOURCES: 'RESOURCES',
  EQUIPMENT: 'EQUIPMENT',
  SERVICE_ITEMS: 'SERVICE_ITEMS',
  CHARGE_MASTER: 'CHARGE_MASTER'
};

export type ImportEntityType = (typeof ImportEntityType)[keyof typeof ImportEntityType]


export const ImportJobStatus: {
  DRAFT: 'DRAFT',
  VALIDATED: 'VALIDATED',
  COMMITTED: 'COMMITTED',
  FAILED: 'FAILED'
};

export type ImportJobStatus = (typeof ImportJobStatus)[keyof typeof ImportJobStatus]


export const BookingStatus: {
  SCHEDULED: 'SCHEDULED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]

}

export type FacilityCategory = $Enums.FacilityCategory

export const FacilityCategory: typeof $Enums.FacilityCategory

export type EncounterType = $Enums.EncounterType

export const EncounterType: typeof $Enums.EncounterType

export type BedState = $Enums.BedState

export const BedState: typeof $Enums.BedState

export type ConsentScope = $Enums.ConsentScope

export const ConsentScope: typeof $Enums.ConsentScope

export type ConsentStatus = $Enums.ConsentStatus

export const ConsentStatus: typeof $Enums.ConsentStatus

export type RtbfStatus = $Enums.RtbfStatus

export const RtbfStatus: typeof $Enums.RtbfStatus

export type OutboxStatus = $Enums.OutboxStatus

export const OutboxStatus: typeof $Enums.OutboxStatus

export type RoleScope = $Enums.RoleScope

export const RoleScope: typeof $Enums.RoleScope

export type RoleVersionStatus = $Enums.RoleVersionStatus

export const RoleVersionStatus: typeof $Enums.RoleVersionStatus

export type PolicyScope = $Enums.PolicyScope

export const PolicyScope: typeof $Enums.PolicyScope

export type PolicyVersionStatus = $Enums.PolicyVersionStatus

export const PolicyVersionStatus: typeof $Enums.PolicyVersionStatus

export type LocationKind = $Enums.LocationKind

export const LocationKind: typeof $Enums.LocationKind

export type UnitResourceType = $Enums.UnitResourceType

export const UnitResourceType: typeof $Enums.UnitResourceType

export type UnitResourceState = $Enums.UnitResourceState

export const UnitResourceState: typeof $Enums.UnitResourceState

export type EquipmentComplianceCategory = $Enums.EquipmentComplianceCategory

export const EquipmentComplianceCategory: typeof $Enums.EquipmentComplianceCategory

export type EquipmentOperationalStatus = $Enums.EquipmentOperationalStatus

export const EquipmentOperationalStatus: typeof $Enums.EquipmentOperationalStatus

export type DowntimeStatus = $Enums.DowntimeStatus

export const DowntimeStatus: typeof $Enums.DowntimeStatus

export type FixItType = $Enums.FixItType

export const FixItType: typeof $Enums.FixItType

export type FixItStatus = $Enums.FixItStatus

export const FixItStatus: typeof $Enums.FixItStatus

export type ImportEntityType = $Enums.ImportEntityType

export const ImportEntityType: typeof $Enums.ImportEntityType

export type ImportJobStatus = $Enums.ImportJobStatus

export const ImportJobStatus: typeof $Enums.ImportJobStatus

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Branches
 * const branches = await prisma.branch.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Branches
   * const branches = await prisma.branch.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs>;

  /**
   * `prisma.facilityCatalog`: Exposes CRUD operations for the **FacilityCatalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FacilityCatalogs
    * const facilityCatalogs = await prisma.facilityCatalog.findMany()
    * ```
    */
  get facilityCatalog(): Prisma.FacilityCatalogDelegate<ExtArgs>;

  /**
   * `prisma.branchFacility`: Exposes CRUD operations for the **BranchFacility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BranchFacilities
    * const branchFacilities = await prisma.branchFacility.findMany()
    * ```
    */
  get branchFacility(): Prisma.BranchFacilityDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs>;

  /**
   * `prisma.departmentDoctor`: Exposes CRUD operations for the **DepartmentDoctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentDoctors
    * const departmentDoctors = await prisma.departmentDoctor.findMany()
    * ```
    */
  get departmentDoctor(): Prisma.DepartmentDoctorDelegate<ExtArgs>;

  /**
   * `prisma.specialty`: Exposes CRUD operations for the **Specialty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specialties
    * const specialties = await prisma.specialty.findMany()
    * ```
    */
  get specialty(): Prisma.SpecialtyDelegate<ExtArgs>;

  /**
   * `prisma.departmentSpecialty`: Exposes CRUD operations for the **DepartmentSpecialty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepartmentSpecialties
    * const departmentSpecialties = await prisma.departmentSpecialty.findMany()
    * ```
    */
  get departmentSpecialty(): Prisma.DepartmentSpecialtyDelegate<ExtArgs>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs>;

  /**
   * `prisma.encounter`: Exposes CRUD operations for the **Encounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encounters
    * const encounters = await prisma.encounter.findMany()
    * ```
    */
  get encounter(): Prisma.EncounterDelegate<ExtArgs>;

  /**
   * `prisma.ward`: Exposes CRUD operations for the **Ward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wards
    * const wards = await prisma.ward.findMany()
    * ```
    */
  get ward(): Prisma.WardDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.bed`: Exposes CRUD operations for the **Bed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beds
    * const beds = await prisma.bed.findMany()
    * ```
    */
  get bed(): Prisma.BedDelegate<ExtArgs>;

  /**
   * `prisma.admission`: Exposes CRUD operations for the **Admission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admissions
    * const admissions = await prisma.admission.findMany()
    * ```
    */
  get admission(): Prisma.AdmissionDelegate<ExtArgs>;

  /**
   * `prisma.oT`: Exposes CRUD operations for the **OT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OTS
    * const oTS = await prisma.oT.findMany()
    * ```
    */
  get oT(): Prisma.OTDelegate<ExtArgs>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs>;

  /**
   * `prisma.tariffPlan`: Exposes CRUD operations for the **TariffPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TariffPlans
    * const tariffPlans = await prisma.tariffPlan.findMany()
    * ```
    */
  get tariffPlan(): Prisma.TariffPlanDelegate<ExtArgs>;

  /**
   * `prisma.serviceCatalogItem`: Exposes CRUD operations for the **ServiceCatalogItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCatalogItems
    * const serviceCatalogItems = await prisma.serviceCatalogItem.findMany()
    * ```
    */
  get serviceCatalogItem(): Prisma.ServiceCatalogItemDelegate<ExtArgs>;

  /**
   * `prisma.tariffRate`: Exposes CRUD operations for the **TariffRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TariffRates
    * const tariffRates = await prisma.tariffRate.findMany()
    * ```
    */
  get tariffRate(): Prisma.TariffRateDelegate<ExtArgs>;

  /**
   * `prisma.consentRecord`: Exposes CRUD operations for the **ConsentRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsentRecords
    * const consentRecords = await prisma.consentRecord.findMany()
    * ```
    */
  get consentRecord(): Prisma.ConsentRecordDelegate<ExtArgs>;

  /**
   * `prisma.rtbfRequest`: Exposes CRUD operations for the **RtbfRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RtbfRequests
    * const rtbfRequests = await prisma.rtbfRequest.findMany()
    * ```
    */
  get rtbfRequest(): Prisma.RtbfRequestDelegate<ExtArgs>;

  /**
   * `prisma.statutoryCase`: Exposes CRUD operations for the **StatutoryCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatutoryCases
    * const statutoryCases = await prisma.statutoryCase.findMany()
    * ```
    */
  get statutoryCase(): Prisma.StatutoryCaseDelegate<ExtArgs>;

  /**
   * `prisma.auditEvent`: Exposes CRUD operations for the **AuditEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditEvents
    * const auditEvents = await prisma.auditEvent.findMany()
    * ```
    */
  get auditEvent(): Prisma.AuditEventDelegate<ExtArgs>;

  /**
   * `prisma.outboxEvent`: Exposes CRUD operations for the **OutboxEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutboxEvents
    * const outboxEvents = await prisma.outboxEvent.findMany()
    * ```
    */
  get outboxEvent(): Prisma.OutboxEventDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.roleTemplate`: Exposes CRUD operations for the **RoleTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleTemplates
    * const roleTemplates = await prisma.roleTemplate.findMany()
    * ```
    */
  get roleTemplate(): Prisma.RoleTemplateDelegate<ExtArgs>;

  /**
   * `prisma.roleTemplateVersion`: Exposes CRUD operations for the **RoleTemplateVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleTemplateVersions
    * const roleTemplateVersions = await prisma.roleTemplateVersion.findMany()
    * ```
    */
  get roleTemplateVersion(): Prisma.RoleTemplateVersionDelegate<ExtArgs>;

  /**
   * `prisma.roleTemplatePermission`: Exposes CRUD operations for the **RoleTemplatePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleTemplatePermissions
    * const roleTemplatePermissions = await prisma.roleTemplatePermission.findMany()
    * ```
    */
  get roleTemplatePermission(): Prisma.RoleTemplatePermissionDelegate<ExtArgs>;

  /**
   * `prisma.policyDefinition`: Exposes CRUD operations for the **PolicyDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PolicyDefinitions
    * const policyDefinitions = await prisma.policyDefinition.findMany()
    * ```
    */
  get policyDefinition(): Prisma.PolicyDefinitionDelegate<ExtArgs>;

  /**
   * `prisma.policyVersion`: Exposes CRUD operations for the **PolicyVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PolicyVersions
    * const policyVersions = await prisma.policyVersion.findMany()
    * ```
    */
  get policyVersion(): Prisma.PolicyVersionDelegate<ExtArgs>;

  /**
   * `prisma.policyVersionBranch`: Exposes CRUD operations for the **PolicyVersionBranch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PolicyVersionBranches
    * const policyVersionBranches = await prisma.policyVersionBranch.findMany()
    * ```
    */
  get policyVersionBranch(): Prisma.PolicyVersionBranchDelegate<ExtArgs>;

  /**
   * `prisma.locationNode`: Exposes CRUD operations for the **LocationNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationNodes
    * const locationNodes = await prisma.locationNode.findMany()
    * ```
    */
  get locationNode(): Prisma.LocationNodeDelegate<ExtArgs>;

  /**
   * `prisma.locationNodeRevision`: Exposes CRUD operations for the **LocationNodeRevision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationNodeRevisions
    * const locationNodeRevisions = await prisma.locationNodeRevision.findMany()
    * ```
    */
  get locationNodeRevision(): Prisma.LocationNodeRevisionDelegate<ExtArgs>;

  /**
   * `prisma.unitTypeCatalog`: Exposes CRUD operations for the **UnitTypeCatalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitTypeCatalogs
    * const unitTypeCatalogs = await prisma.unitTypeCatalog.findMany()
    * ```
    */
  get unitTypeCatalog(): Prisma.UnitTypeCatalogDelegate<ExtArgs>;

  /**
   * `prisma.branchUnitType`: Exposes CRUD operations for the **BranchUnitType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BranchUnitTypes
    * const branchUnitTypes = await prisma.branchUnitType.findMany()
    * ```
    */
  get branchUnitType(): Prisma.BranchUnitTypeDelegate<ExtArgs>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs>;

  /**
   * `prisma.unitRoom`: Exposes CRUD operations for the **UnitRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitRooms
    * const unitRooms = await prisma.unitRoom.findMany()
    * ```
    */
  get unitRoom(): Prisma.UnitRoomDelegate<ExtArgs>;

  /**
   * `prisma.unitResource`: Exposes CRUD operations for the **UnitResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitResources
    * const unitResources = await prisma.unitResource.findMany()
    * ```
    */
  get unitResource(): Prisma.UnitResourceDelegate<ExtArgs>;

  /**
   * `prisma.equipmentAsset`: Exposes CRUD operations for the **EquipmentAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentAssets
    * const equipmentAssets = await prisma.equipmentAsset.findMany()
    * ```
    */
  get equipmentAsset(): Prisma.EquipmentAssetDelegate<ExtArgs>;

  /**
   * `prisma.downtimeTicket`: Exposes CRUD operations for the **DowntimeTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DowntimeTickets
    * const downtimeTickets = await prisma.downtimeTicket.findMany()
    * ```
    */
  get downtimeTicket(): Prisma.DowntimeTicketDelegate<ExtArgs>;

  /**
   * `prisma.chargeMasterItem`: Exposes CRUD operations for the **ChargeMasterItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChargeMasterItems
    * const chargeMasterItems = await prisma.chargeMasterItem.findMany()
    * ```
    */
  get chargeMasterItem(): Prisma.ChargeMasterItemDelegate<ExtArgs>;

  /**
   * `prisma.serviceItem`: Exposes CRUD operations for the **ServiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceItems
    * const serviceItems = await prisma.serviceItem.findMany()
    * ```
    */
  get serviceItem(): Prisma.ServiceItemDelegate<ExtArgs>;

  /**
   * `prisma.serviceChargeMapping`: Exposes CRUD operations for the **ServiceChargeMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceChargeMappings
    * const serviceChargeMappings = await prisma.serviceChargeMapping.findMany()
    * ```
    */
  get serviceChargeMapping(): Prisma.ServiceChargeMappingDelegate<ExtArgs>;

  /**
   * `prisma.fixItTask`: Exposes CRUD operations for the **FixItTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FixItTasks
    * const fixItTasks = await prisma.fixItTask.findMany()
    * ```
    */
  get fixItTask(): Prisma.FixItTaskDelegate<ExtArgs>;

  /**
   * `prisma.bulkImportJob`: Exposes CRUD operations for the **BulkImportJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BulkImportJobs
    * const bulkImportJobs = await prisma.bulkImportJob.findMany()
    * ```
    */
  get bulkImportJob(): Prisma.BulkImportJobDelegate<ExtArgs>;

  /**
   * `prisma.procedureBooking`: Exposes CRUD operations for the **ProcedureBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProcedureBookings
    * const procedureBookings = await prisma.procedureBooking.findMany()
    * ```
    */
  get procedureBooking(): Prisma.ProcedureBookingDelegate<ExtArgs>;

  /**
   * `prisma.goLiveReport`: Exposes CRUD operations for the **GoLiveReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoLiveReports
    * const goLiveReports = await prisma.goLiveReport.findMany()
    * ```
    */
  get goLiveReport(): Prisma.GoLiveReportDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Branch: 'Branch',
    FacilityCatalog: 'FacilityCatalog',
    BranchFacility: 'BranchFacility',
    Department: 'Department',
    DepartmentDoctor: 'DepartmentDoctor',
    Specialty: 'Specialty',
    DepartmentSpecialty: 'DepartmentSpecialty',
    Staff: 'Staff',
    User: 'User',
    Patient: 'Patient',
    Encounter: 'Encounter',
    Ward: 'Ward',
    Room: 'Room',
    Bed: 'Bed',
    Admission: 'Admission',
    OT: 'OT',
    Asset: 'Asset',
    TariffPlan: 'TariffPlan',
    ServiceCatalogItem: 'ServiceCatalogItem',
    TariffRate: 'TariffRate',
    ConsentRecord: 'ConsentRecord',
    RtbfRequest: 'RtbfRequest',
    StatutoryCase: 'StatutoryCase',
    AuditEvent: 'AuditEvent',
    OutboxEvent: 'OutboxEvent',
    Permission: 'Permission',
    RoleTemplate: 'RoleTemplate',
    RoleTemplateVersion: 'RoleTemplateVersion',
    RoleTemplatePermission: 'RoleTemplatePermission',
    PolicyDefinition: 'PolicyDefinition',
    PolicyVersion: 'PolicyVersion',
    PolicyVersionBranch: 'PolicyVersionBranch',
    LocationNode: 'LocationNode',
    LocationNodeRevision: 'LocationNodeRevision',
    UnitTypeCatalog: 'UnitTypeCatalog',
    BranchUnitType: 'BranchUnitType',
    Unit: 'Unit',
    UnitRoom: 'UnitRoom',
    UnitResource: 'UnitResource',
    EquipmentAsset: 'EquipmentAsset',
    DowntimeTicket: 'DowntimeTicket',
    ChargeMasterItem: 'ChargeMasterItem',
    ServiceItem: 'ServiceItem',
    ServiceChargeMapping: 'ServiceChargeMapping',
    FixItTask: 'FixItTask',
    BulkImportJob: 'BulkImportJob',
    ProcedureBooking: 'ProcedureBooking',
    GoLiveReport: 'GoLiveReport'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "branch" | "facilityCatalog" | "branchFacility" | "department" | "departmentDoctor" | "specialty" | "departmentSpecialty" | "staff" | "user" | "patient" | "encounter" | "ward" | "room" | "bed" | "admission" | "oT" | "asset" | "tariffPlan" | "serviceCatalogItem" | "tariffRate" | "consentRecord" | "rtbfRequest" | "statutoryCase" | "auditEvent" | "outboxEvent" | "permission" | "roleTemplate" | "roleTemplateVersion" | "roleTemplatePermission" | "policyDefinition" | "policyVersion" | "policyVersionBranch" | "locationNode" | "locationNodeRevision" | "unitTypeCatalog" | "branchUnitType" | "unit" | "unitRoom" | "unitResource" | "equipmentAsset" | "downtimeTicket" | "chargeMasterItem" | "serviceItem" | "serviceChargeMapping" | "fixItTask" | "bulkImportJob" | "procedureBooking" | "goLiveReport"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      FacilityCatalog: {
        payload: Prisma.$FacilityCatalogPayload<ExtArgs>
        fields: Prisma.FacilityCatalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityCatalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityCatalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityCatalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityCatalogPayload>
          }
          findFirst: {
            args: Prisma.FacilityCatalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityCatalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityCatalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityCatalogPayload>
          }
          findMany: {
            args: Prisma.FacilityCatalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityCatalogPayload>[]
          }
          create: {
            args: Prisma.FacilityCatalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityCatalogPayload>
          }
          createMany: {
            args: Prisma.FacilityCatalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilityCatalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityCatalogPayload>[]
          }
          delete: {
            args: Prisma.FacilityCatalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityCatalogPayload>
          }
          update: {
            args: Prisma.FacilityCatalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityCatalogPayload>
          }
          deleteMany: {
            args: Prisma.FacilityCatalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityCatalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FacilityCatalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityCatalogPayload>
          }
          aggregate: {
            args: Prisma.FacilityCatalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacilityCatalog>
          }
          groupBy: {
            args: Prisma.FacilityCatalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityCatalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityCatalogCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityCatalogCountAggregateOutputType> | number
          }
        }
      }
      BranchFacility: {
        payload: Prisma.$BranchFacilityPayload<ExtArgs>
        fields: Prisma.BranchFacilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFacilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchFacilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFacilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchFacilityPayload>
          }
          findFirst: {
            args: Prisma.BranchFacilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchFacilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFacilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchFacilityPayload>
          }
          findMany: {
            args: Prisma.BranchFacilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchFacilityPayload>[]
          }
          create: {
            args: Prisma.BranchFacilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchFacilityPayload>
          }
          createMany: {
            args: Prisma.BranchFacilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchFacilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchFacilityPayload>[]
          }
          delete: {
            args: Prisma.BranchFacilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchFacilityPayload>
          }
          update: {
            args: Prisma.BranchFacilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchFacilityPayload>
          }
          deleteMany: {
            args: Prisma.BranchFacilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchFacilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchFacilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchFacilityPayload>
          }
          aggregate: {
            args: Prisma.BranchFacilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranchFacility>
          }
          groupBy: {
            args: Prisma.BranchFacilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchFacilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchFacilityCountArgs<ExtArgs>
            result: $Utils.Optional<BranchFacilityCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      DepartmentDoctor: {
        payload: Prisma.$DepartmentDoctorPayload<ExtArgs>
        fields: Prisma.DepartmentDoctorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentDoctorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDoctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentDoctorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDoctorPayload>
          }
          findFirst: {
            args: Prisma.DepartmentDoctorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDoctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentDoctorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDoctorPayload>
          }
          findMany: {
            args: Prisma.DepartmentDoctorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDoctorPayload>[]
          }
          create: {
            args: Prisma.DepartmentDoctorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDoctorPayload>
          }
          createMany: {
            args: Prisma.DepartmentDoctorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentDoctorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDoctorPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDoctorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDoctorPayload>
          }
          update: {
            args: Prisma.DepartmentDoctorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDoctorPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDoctorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentDoctorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentDoctorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentDoctorPayload>
          }
          aggregate: {
            args: Prisma.DepartmentDoctorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentDoctor>
          }
          groupBy: {
            args: Prisma.DepartmentDoctorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentDoctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentDoctorCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentDoctorCountAggregateOutputType> | number
          }
        }
      }
      Specialty: {
        payload: Prisma.$SpecialtyPayload<ExtArgs>
        fields: Prisma.SpecialtyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialtyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialtyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          findFirst: {
            args: Prisma.SpecialtyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialtyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          findMany: {
            args: Prisma.SpecialtyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          create: {
            args: Prisma.SpecialtyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          createMany: {
            args: Prisma.SpecialtyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecialtyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          delete: {
            args: Prisma.SpecialtyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          update: {
            args: Prisma.SpecialtyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          deleteMany: {
            args: Prisma.SpecialtyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialtyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpecialtyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          aggregate: {
            args: Prisma.SpecialtyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecialty>
          }
          groupBy: {
            args: Prisma.SpecialtyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecialtyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialtyCountArgs<ExtArgs>
            result: $Utils.Optional<SpecialtyCountAggregateOutputType> | number
          }
        }
      }
      DepartmentSpecialty: {
        payload: Prisma.$DepartmentSpecialtyPayload<ExtArgs>
        fields: Prisma.DepartmentSpecialtyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentSpecialtyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSpecialtyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentSpecialtyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSpecialtyPayload>
          }
          findFirst: {
            args: Prisma.DepartmentSpecialtyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSpecialtyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentSpecialtyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSpecialtyPayload>
          }
          findMany: {
            args: Prisma.DepartmentSpecialtyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSpecialtyPayload>[]
          }
          create: {
            args: Prisma.DepartmentSpecialtyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSpecialtyPayload>
          }
          createMany: {
            args: Prisma.DepartmentSpecialtyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentSpecialtyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSpecialtyPayload>[]
          }
          delete: {
            args: Prisma.DepartmentSpecialtyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSpecialtyPayload>
          }
          update: {
            args: Prisma.DepartmentSpecialtyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSpecialtyPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentSpecialtyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentSpecialtyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentSpecialtyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentSpecialtyPayload>
          }
          aggregate: {
            args: Prisma.DepartmentSpecialtyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartmentSpecialty>
          }
          groupBy: {
            args: Prisma.DepartmentSpecialtyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentSpecialtyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentSpecialtyCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentSpecialtyCountAggregateOutputType> | number
          }
        }
      }
      Staff: {
        payload: Prisma.$StaffPayload<ExtArgs>
        fields: Prisma.StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Encounter: {
        payload: Prisma.$EncounterPayload<ExtArgs>
        fields: Prisma.EncounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findFirst: {
            args: Prisma.EncounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findMany: {
            args: Prisma.EncounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          create: {
            args: Prisma.EncounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          createMany: {
            args: Prisma.EncounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          delete: {
            args: Prisma.EncounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          update: {
            args: Prisma.EncounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          aggregate: {
            args: Prisma.EncounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounter>
          }
          groupBy: {
            args: Prisma.EncounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterCountAggregateOutputType> | number
          }
        }
      }
      Ward: {
        payload: Prisma.$WardPayload<ExtArgs>
        fields: Prisma.WardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          findFirst: {
            args: Prisma.WardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          findMany: {
            args: Prisma.WardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          create: {
            args: Prisma.WardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          createMany: {
            args: Prisma.WardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          delete: {
            args: Prisma.WardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          update: {
            args: Prisma.WardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          deleteMany: {
            args: Prisma.WardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          aggregate: {
            args: Prisma.WardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWard>
          }
          groupBy: {
            args: Prisma.WardGroupByArgs<ExtArgs>
            result: $Utils.Optional<WardGroupByOutputType>[]
          }
          count: {
            args: Prisma.WardCountArgs<ExtArgs>
            result: $Utils.Optional<WardCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Bed: {
        payload: Prisma.$BedPayload<ExtArgs>
        fields: Prisma.BedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          findFirst: {
            args: Prisma.BedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          findMany: {
            args: Prisma.BedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          create: {
            args: Prisma.BedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          createMany: {
            args: Prisma.BedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          delete: {
            args: Prisma.BedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          update: {
            args: Prisma.BedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          deleteMany: {
            args: Prisma.BedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          aggregate: {
            args: Prisma.BedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBed>
          }
          groupBy: {
            args: Prisma.BedGroupByArgs<ExtArgs>
            result: $Utils.Optional<BedGroupByOutputType>[]
          }
          count: {
            args: Prisma.BedCountArgs<ExtArgs>
            result: $Utils.Optional<BedCountAggregateOutputType> | number
          }
        }
      }
      Admission: {
        payload: Prisma.$AdmissionPayload<ExtArgs>
        fields: Prisma.AdmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findFirst: {
            args: Prisma.AdmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findMany: {
            args: Prisma.AdmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          create: {
            args: Prisma.AdmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          createMany: {
            args: Prisma.AdmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          delete: {
            args: Prisma.AdmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          update: {
            args: Prisma.AdmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          aggregate: {
            args: Prisma.AdmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmission>
          }
          groupBy: {
            args: Prisma.AdmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionCountAggregateOutputType> | number
          }
        }
      }
      OT: {
        payload: Prisma.$OTPayload<ExtArgs>
        fields: Prisma.OTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          findFirst: {
            args: Prisma.OTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          findMany: {
            args: Prisma.OTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>[]
          }
          create: {
            args: Prisma.OTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          createMany: {
            args: Prisma.OTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>[]
          }
          delete: {
            args: Prisma.OTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          update: {
            args: Prisma.OTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          deleteMany: {
            args: Prisma.OTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          aggregate: {
            args: Prisma.OTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOT>
          }
          groupBy: {
            args: Prisma.OTGroupByArgs<ExtArgs>
            result: $Utils.Optional<OTGroupByOutputType>[]
          }
          count: {
            args: Prisma.OTCountArgs<ExtArgs>
            result: $Utils.Optional<OTCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      TariffPlan: {
        payload: Prisma.$TariffPlanPayload<ExtArgs>
        fields: Prisma.TariffPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TariffPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TariffPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          findFirst: {
            args: Prisma.TariffPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TariffPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          findMany: {
            args: Prisma.TariffPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>[]
          }
          create: {
            args: Prisma.TariffPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          createMany: {
            args: Prisma.TariffPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TariffPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>[]
          }
          delete: {
            args: Prisma.TariffPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          update: {
            args: Prisma.TariffPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          deleteMany: {
            args: Prisma.TariffPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TariffPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TariffPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          aggregate: {
            args: Prisma.TariffPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTariffPlan>
          }
          groupBy: {
            args: Prisma.TariffPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TariffPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TariffPlanCountArgs<ExtArgs>
            result: $Utils.Optional<TariffPlanCountAggregateOutputType> | number
          }
        }
      }
      ServiceCatalogItem: {
        payload: Prisma.$ServiceCatalogItemPayload<ExtArgs>
        fields: Prisma.ServiceCatalogItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCatalogItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCatalogItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          findFirst: {
            args: Prisma.ServiceCatalogItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCatalogItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          findMany: {
            args: Prisma.ServiceCatalogItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>[]
          }
          create: {
            args: Prisma.ServiceCatalogItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          createMany: {
            args: Prisma.ServiceCatalogItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCatalogItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>[]
          }
          delete: {
            args: Prisma.ServiceCatalogItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          update: {
            args: Prisma.ServiceCatalogItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCatalogItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCatalogItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceCatalogItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          aggregate: {
            args: Prisma.ServiceCatalogItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCatalogItem>
          }
          groupBy: {
            args: Prisma.ServiceCatalogItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCatalogItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCatalogItemCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCatalogItemCountAggregateOutputType> | number
          }
        }
      }
      TariffRate: {
        payload: Prisma.$TariffRatePayload<ExtArgs>
        fields: Prisma.TariffRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TariffRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TariffRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          findFirst: {
            args: Prisma.TariffRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TariffRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          findMany: {
            args: Prisma.TariffRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>[]
          }
          create: {
            args: Prisma.TariffRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          createMany: {
            args: Prisma.TariffRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TariffRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>[]
          }
          delete: {
            args: Prisma.TariffRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          update: {
            args: Prisma.TariffRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          deleteMany: {
            args: Prisma.TariffRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TariffRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TariffRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          aggregate: {
            args: Prisma.TariffRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTariffRate>
          }
          groupBy: {
            args: Prisma.TariffRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TariffRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TariffRateCountArgs<ExtArgs>
            result: $Utils.Optional<TariffRateCountAggregateOutputType> | number
          }
        }
      }
      ConsentRecord: {
        payload: Prisma.$ConsentRecordPayload<ExtArgs>
        fields: Prisma.ConsentRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsentRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsentRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          findFirst: {
            args: Prisma.ConsentRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsentRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          findMany: {
            args: Prisma.ConsentRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>[]
          }
          create: {
            args: Prisma.ConsentRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          createMany: {
            args: Prisma.ConsentRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsentRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>[]
          }
          delete: {
            args: Prisma.ConsentRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          update: {
            args: Prisma.ConsentRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          deleteMany: {
            args: Prisma.ConsentRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsentRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsentRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          aggregate: {
            args: Prisma.ConsentRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsentRecord>
          }
          groupBy: {
            args: Prisma.ConsentRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsentRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsentRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ConsentRecordCountAggregateOutputType> | number
          }
        }
      }
      RtbfRequest: {
        payload: Prisma.$RtbfRequestPayload<ExtArgs>
        fields: Prisma.RtbfRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RtbfRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RtbfRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          findFirst: {
            args: Prisma.RtbfRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RtbfRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          findMany: {
            args: Prisma.RtbfRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>[]
          }
          create: {
            args: Prisma.RtbfRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          createMany: {
            args: Prisma.RtbfRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RtbfRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>[]
          }
          delete: {
            args: Prisma.RtbfRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          update: {
            args: Prisma.RtbfRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          deleteMany: {
            args: Prisma.RtbfRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RtbfRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RtbfRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          aggregate: {
            args: Prisma.RtbfRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRtbfRequest>
          }
          groupBy: {
            args: Prisma.RtbfRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RtbfRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RtbfRequestCountArgs<ExtArgs>
            result: $Utils.Optional<RtbfRequestCountAggregateOutputType> | number
          }
        }
      }
      StatutoryCase: {
        payload: Prisma.$StatutoryCasePayload<ExtArgs>
        fields: Prisma.StatutoryCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatutoryCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatutoryCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          findFirst: {
            args: Prisma.StatutoryCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatutoryCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          findMany: {
            args: Prisma.StatutoryCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>[]
          }
          create: {
            args: Prisma.StatutoryCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          createMany: {
            args: Prisma.StatutoryCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatutoryCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>[]
          }
          delete: {
            args: Prisma.StatutoryCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          update: {
            args: Prisma.StatutoryCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          deleteMany: {
            args: Prisma.StatutoryCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatutoryCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StatutoryCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          aggregate: {
            args: Prisma.StatutoryCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatutoryCase>
          }
          groupBy: {
            args: Prisma.StatutoryCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatutoryCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatutoryCaseCountArgs<ExtArgs>
            result: $Utils.Optional<StatutoryCaseCountAggregateOutputType> | number
          }
        }
      }
      AuditEvent: {
        payload: Prisma.$AuditEventPayload<ExtArgs>
        fields: Prisma.AuditEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findFirst: {
            args: Prisma.AuditEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findMany: {
            args: Prisma.AuditEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          create: {
            args: Prisma.AuditEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          createMany: {
            args: Prisma.AuditEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          delete: {
            args: Prisma.AuditEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          update: {
            args: Prisma.AuditEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          deleteMany: {
            args: Prisma.AuditEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          aggregate: {
            args: Prisma.AuditEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditEvent>
          }
          groupBy: {
            args: Prisma.AuditEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditEventCountArgs<ExtArgs>
            result: $Utils.Optional<AuditEventCountAggregateOutputType> | number
          }
        }
      }
      OutboxEvent: {
        payload: Prisma.$OutboxEventPayload<ExtArgs>
        fields: Prisma.OutboxEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutboxEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutboxEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          findFirst: {
            args: Prisma.OutboxEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutboxEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          findMany: {
            args: Prisma.OutboxEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>[]
          }
          create: {
            args: Prisma.OutboxEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          createMany: {
            args: Prisma.OutboxEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutboxEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>[]
          }
          delete: {
            args: Prisma.OutboxEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          update: {
            args: Prisma.OutboxEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          deleteMany: {
            args: Prisma.OutboxEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutboxEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OutboxEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          aggregate: {
            args: Prisma.OutboxEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutboxEvent>
          }
          groupBy: {
            args: Prisma.OutboxEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutboxEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutboxEventCountArgs<ExtArgs>
            result: $Utils.Optional<OutboxEventCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RoleTemplate: {
        payload: Prisma.$RoleTemplatePayload<ExtArgs>
        fields: Prisma.RoleTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          findFirst: {
            args: Prisma.RoleTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          findMany: {
            args: Prisma.RoleTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>[]
          }
          create: {
            args: Prisma.RoleTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          createMany: {
            args: Prisma.RoleTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>[]
          }
          delete: {
            args: Prisma.RoleTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          update: {
            args: Prisma.RoleTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          deleteMany: {
            args: Prisma.RoleTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          aggregate: {
            args: Prisma.RoleTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleTemplate>
          }
          groupBy: {
            args: Prisma.RoleTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplateCountAggregateOutputType> | number
          }
        }
      }
      RoleTemplateVersion: {
        payload: Prisma.$RoleTemplateVersionPayload<ExtArgs>
        fields: Prisma.RoleTemplateVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleTemplateVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleTemplateVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          findFirst: {
            args: Prisma.RoleTemplateVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleTemplateVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          findMany: {
            args: Prisma.RoleTemplateVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>[]
          }
          create: {
            args: Prisma.RoleTemplateVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          createMany: {
            args: Prisma.RoleTemplateVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleTemplateVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>[]
          }
          delete: {
            args: Prisma.RoleTemplateVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          update: {
            args: Prisma.RoleTemplateVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          deleteMany: {
            args: Prisma.RoleTemplateVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleTemplateVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleTemplateVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          aggregate: {
            args: Prisma.RoleTemplateVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleTemplateVersion>
          }
          groupBy: {
            args: Prisma.RoleTemplateVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplateVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleTemplateVersionCountArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplateVersionCountAggregateOutputType> | number
          }
        }
      }
      RoleTemplatePermission: {
        payload: Prisma.$RoleTemplatePermissionPayload<ExtArgs>
        fields: Prisma.RoleTemplatePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleTemplatePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleTemplatePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          findFirst: {
            args: Prisma.RoleTemplatePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleTemplatePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          findMany: {
            args: Prisma.RoleTemplatePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>[]
          }
          create: {
            args: Prisma.RoleTemplatePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          createMany: {
            args: Prisma.RoleTemplatePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleTemplatePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>[]
          }
          delete: {
            args: Prisma.RoleTemplatePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          update: {
            args: Prisma.RoleTemplatePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RoleTemplatePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleTemplatePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleTemplatePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          aggregate: {
            args: Prisma.RoleTemplatePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleTemplatePermission>
          }
          groupBy: {
            args: Prisma.RoleTemplatePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplatePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleTemplatePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplatePermissionCountAggregateOutputType> | number
          }
        }
      }
      PolicyDefinition: {
        payload: Prisma.$PolicyDefinitionPayload<ExtArgs>
        fields: Prisma.PolicyDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyDefinitionPayload>
          }
          findFirst: {
            args: Prisma.PolicyDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyDefinitionPayload>
          }
          findMany: {
            args: Prisma.PolicyDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyDefinitionPayload>[]
          }
          create: {
            args: Prisma.PolicyDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyDefinitionPayload>
          }
          createMany: {
            args: Prisma.PolicyDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyDefinitionPayload>[]
          }
          delete: {
            args: Prisma.PolicyDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyDefinitionPayload>
          }
          update: {
            args: Prisma.PolicyDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.PolicyDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PolicyDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyDefinitionPayload>
          }
          aggregate: {
            args: Prisma.PolicyDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicyDefinition>
          }
          groupBy: {
            args: Prisma.PolicyDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyDefinitionCountAggregateOutputType> | number
          }
        }
      }
      PolicyVersion: {
        payload: Prisma.$PolicyVersionPayload<ExtArgs>
        fields: Prisma.PolicyVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionPayload>
          }
          findFirst: {
            args: Prisma.PolicyVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionPayload>
          }
          findMany: {
            args: Prisma.PolicyVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionPayload>[]
          }
          create: {
            args: Prisma.PolicyVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionPayload>
          }
          createMany: {
            args: Prisma.PolicyVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionPayload>[]
          }
          delete: {
            args: Prisma.PolicyVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionPayload>
          }
          update: {
            args: Prisma.PolicyVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionPayload>
          }
          deleteMany: {
            args: Prisma.PolicyVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PolicyVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionPayload>
          }
          aggregate: {
            args: Prisma.PolicyVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicyVersion>
          }
          groupBy: {
            args: Prisma.PolicyVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyVersionCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyVersionCountAggregateOutputType> | number
          }
        }
      }
      PolicyVersionBranch: {
        payload: Prisma.$PolicyVersionBranchPayload<ExtArgs>
        fields: Prisma.PolicyVersionBranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyVersionBranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionBranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyVersionBranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionBranchPayload>
          }
          findFirst: {
            args: Prisma.PolicyVersionBranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionBranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyVersionBranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionBranchPayload>
          }
          findMany: {
            args: Prisma.PolicyVersionBranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionBranchPayload>[]
          }
          create: {
            args: Prisma.PolicyVersionBranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionBranchPayload>
          }
          createMany: {
            args: Prisma.PolicyVersionBranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyVersionBranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionBranchPayload>[]
          }
          delete: {
            args: Prisma.PolicyVersionBranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionBranchPayload>
          }
          update: {
            args: Prisma.PolicyVersionBranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionBranchPayload>
          }
          deleteMany: {
            args: Prisma.PolicyVersionBranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyVersionBranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PolicyVersionBranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyVersionBranchPayload>
          }
          aggregate: {
            args: Prisma.PolicyVersionBranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicyVersionBranch>
          }
          groupBy: {
            args: Prisma.PolicyVersionBranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyVersionBranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyVersionBranchCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyVersionBranchCountAggregateOutputType> | number
          }
        }
      }
      LocationNode: {
        payload: Prisma.$LocationNodePayload<ExtArgs>
        fields: Prisma.LocationNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodePayload>
          }
          findFirst: {
            args: Prisma.LocationNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodePayload>
          }
          findMany: {
            args: Prisma.LocationNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodePayload>[]
          }
          create: {
            args: Prisma.LocationNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodePayload>
          }
          createMany: {
            args: Prisma.LocationNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodePayload>[]
          }
          delete: {
            args: Prisma.LocationNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodePayload>
          }
          update: {
            args: Prisma.LocationNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodePayload>
          }
          deleteMany: {
            args: Prisma.LocationNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodePayload>
          }
          aggregate: {
            args: Prisma.LocationNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationNode>
          }
          groupBy: {
            args: Prisma.LocationNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationNodeCountArgs<ExtArgs>
            result: $Utils.Optional<LocationNodeCountAggregateOutputType> | number
          }
        }
      }
      LocationNodeRevision: {
        payload: Prisma.$LocationNodeRevisionPayload<ExtArgs>
        fields: Prisma.LocationNodeRevisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationNodeRevisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodeRevisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationNodeRevisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodeRevisionPayload>
          }
          findFirst: {
            args: Prisma.LocationNodeRevisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodeRevisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationNodeRevisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodeRevisionPayload>
          }
          findMany: {
            args: Prisma.LocationNodeRevisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodeRevisionPayload>[]
          }
          create: {
            args: Prisma.LocationNodeRevisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodeRevisionPayload>
          }
          createMany: {
            args: Prisma.LocationNodeRevisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationNodeRevisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodeRevisionPayload>[]
          }
          delete: {
            args: Prisma.LocationNodeRevisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodeRevisionPayload>
          }
          update: {
            args: Prisma.LocationNodeRevisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodeRevisionPayload>
          }
          deleteMany: {
            args: Prisma.LocationNodeRevisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationNodeRevisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationNodeRevisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationNodeRevisionPayload>
          }
          aggregate: {
            args: Prisma.LocationNodeRevisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationNodeRevision>
          }
          groupBy: {
            args: Prisma.LocationNodeRevisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationNodeRevisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationNodeRevisionCountArgs<ExtArgs>
            result: $Utils.Optional<LocationNodeRevisionCountAggregateOutputType> | number
          }
        }
      }
      UnitTypeCatalog: {
        payload: Prisma.$UnitTypeCatalogPayload<ExtArgs>
        fields: Prisma.UnitTypeCatalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitTypeCatalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypeCatalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitTypeCatalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypeCatalogPayload>
          }
          findFirst: {
            args: Prisma.UnitTypeCatalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypeCatalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitTypeCatalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypeCatalogPayload>
          }
          findMany: {
            args: Prisma.UnitTypeCatalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypeCatalogPayload>[]
          }
          create: {
            args: Prisma.UnitTypeCatalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypeCatalogPayload>
          }
          createMany: {
            args: Prisma.UnitTypeCatalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitTypeCatalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypeCatalogPayload>[]
          }
          delete: {
            args: Prisma.UnitTypeCatalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypeCatalogPayload>
          }
          update: {
            args: Prisma.UnitTypeCatalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypeCatalogPayload>
          }
          deleteMany: {
            args: Prisma.UnitTypeCatalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitTypeCatalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitTypeCatalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitTypeCatalogPayload>
          }
          aggregate: {
            args: Prisma.UnitTypeCatalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitTypeCatalog>
          }
          groupBy: {
            args: Prisma.UnitTypeCatalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitTypeCatalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitTypeCatalogCountArgs<ExtArgs>
            result: $Utils.Optional<UnitTypeCatalogCountAggregateOutputType> | number
          }
        }
      }
      BranchUnitType: {
        payload: Prisma.$BranchUnitTypePayload<ExtArgs>
        fields: Prisma.BranchUnitTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchUnitTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchUnitTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchUnitTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchUnitTypePayload>
          }
          findFirst: {
            args: Prisma.BranchUnitTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchUnitTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchUnitTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchUnitTypePayload>
          }
          findMany: {
            args: Prisma.BranchUnitTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchUnitTypePayload>[]
          }
          create: {
            args: Prisma.BranchUnitTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchUnitTypePayload>
          }
          createMany: {
            args: Prisma.BranchUnitTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchUnitTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchUnitTypePayload>[]
          }
          delete: {
            args: Prisma.BranchUnitTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchUnitTypePayload>
          }
          update: {
            args: Prisma.BranchUnitTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchUnitTypePayload>
          }
          deleteMany: {
            args: Prisma.BranchUnitTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUnitTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUnitTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchUnitTypePayload>
          }
          aggregate: {
            args: Prisma.BranchUnitTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranchUnitType>
          }
          groupBy: {
            args: Prisma.BranchUnitTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchUnitTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchUnitTypeCountArgs<ExtArgs>
            result: $Utils.Optional<BranchUnitTypeCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      UnitRoom: {
        payload: Prisma.$UnitRoomPayload<ExtArgs>
        fields: Prisma.UnitRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitRoomPayload>
          }
          findFirst: {
            args: Prisma.UnitRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitRoomPayload>
          }
          findMany: {
            args: Prisma.UnitRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitRoomPayload>[]
          }
          create: {
            args: Prisma.UnitRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitRoomPayload>
          }
          createMany: {
            args: Prisma.UnitRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitRoomPayload>[]
          }
          delete: {
            args: Prisma.UnitRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitRoomPayload>
          }
          update: {
            args: Prisma.UnitRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitRoomPayload>
          }
          deleteMany: {
            args: Prisma.UnitRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitRoomPayload>
          }
          aggregate: {
            args: Prisma.UnitRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitRoom>
          }
          groupBy: {
            args: Prisma.UnitRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitRoomCountArgs<ExtArgs>
            result: $Utils.Optional<UnitRoomCountAggregateOutputType> | number
          }
        }
      }
      UnitResource: {
        payload: Prisma.$UnitResourcePayload<ExtArgs>
        fields: Prisma.UnitResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitResourcePayload>
          }
          findFirst: {
            args: Prisma.UnitResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitResourcePayload>
          }
          findMany: {
            args: Prisma.UnitResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitResourcePayload>[]
          }
          create: {
            args: Prisma.UnitResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitResourcePayload>
          }
          createMany: {
            args: Prisma.UnitResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitResourcePayload>[]
          }
          delete: {
            args: Prisma.UnitResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitResourcePayload>
          }
          update: {
            args: Prisma.UnitResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitResourcePayload>
          }
          deleteMany: {
            args: Prisma.UnitResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnitResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitResourcePayload>
          }
          aggregate: {
            args: Prisma.UnitResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitResource>
          }
          groupBy: {
            args: Prisma.UnitResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitResourceCountArgs<ExtArgs>
            result: $Utils.Optional<UnitResourceCountAggregateOutputType> | number
          }
        }
      }
      EquipmentAsset: {
        payload: Prisma.$EquipmentAssetPayload<ExtArgs>
        fields: Prisma.EquipmentAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentAssetPayload>
          }
          findFirst: {
            args: Prisma.EquipmentAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentAssetPayload>
          }
          findMany: {
            args: Prisma.EquipmentAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentAssetPayload>[]
          }
          create: {
            args: Prisma.EquipmentAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentAssetPayload>
          }
          createMany: {
            args: Prisma.EquipmentAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentAssetPayload>[]
          }
          delete: {
            args: Prisma.EquipmentAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentAssetPayload>
          }
          update: {
            args: Prisma.EquipmentAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentAssetPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentAssetPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentAsset>
          }
          groupBy: {
            args: Prisma.EquipmentAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentAssetCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentAssetCountAggregateOutputType> | number
          }
        }
      }
      DowntimeTicket: {
        payload: Prisma.$DowntimeTicketPayload<ExtArgs>
        fields: Prisma.DowntimeTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DowntimeTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DowntimeTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DowntimeTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DowntimeTicketPayload>
          }
          findFirst: {
            args: Prisma.DowntimeTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DowntimeTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DowntimeTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DowntimeTicketPayload>
          }
          findMany: {
            args: Prisma.DowntimeTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DowntimeTicketPayload>[]
          }
          create: {
            args: Prisma.DowntimeTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DowntimeTicketPayload>
          }
          createMany: {
            args: Prisma.DowntimeTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DowntimeTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DowntimeTicketPayload>[]
          }
          delete: {
            args: Prisma.DowntimeTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DowntimeTicketPayload>
          }
          update: {
            args: Prisma.DowntimeTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DowntimeTicketPayload>
          }
          deleteMany: {
            args: Prisma.DowntimeTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DowntimeTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DowntimeTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DowntimeTicketPayload>
          }
          aggregate: {
            args: Prisma.DowntimeTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDowntimeTicket>
          }
          groupBy: {
            args: Prisma.DowntimeTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<DowntimeTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.DowntimeTicketCountArgs<ExtArgs>
            result: $Utils.Optional<DowntimeTicketCountAggregateOutputType> | number
          }
        }
      }
      ChargeMasterItem: {
        payload: Prisma.$ChargeMasterItemPayload<ExtArgs>
        fields: Prisma.ChargeMasterItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChargeMasterItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargeMasterItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChargeMasterItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargeMasterItemPayload>
          }
          findFirst: {
            args: Prisma.ChargeMasterItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargeMasterItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChargeMasterItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargeMasterItemPayload>
          }
          findMany: {
            args: Prisma.ChargeMasterItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargeMasterItemPayload>[]
          }
          create: {
            args: Prisma.ChargeMasterItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargeMasterItemPayload>
          }
          createMany: {
            args: Prisma.ChargeMasterItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChargeMasterItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargeMasterItemPayload>[]
          }
          delete: {
            args: Prisma.ChargeMasterItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargeMasterItemPayload>
          }
          update: {
            args: Prisma.ChargeMasterItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargeMasterItemPayload>
          }
          deleteMany: {
            args: Prisma.ChargeMasterItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChargeMasterItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChargeMasterItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargeMasterItemPayload>
          }
          aggregate: {
            args: Prisma.ChargeMasterItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChargeMasterItem>
          }
          groupBy: {
            args: Prisma.ChargeMasterItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChargeMasterItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChargeMasterItemCountArgs<ExtArgs>
            result: $Utils.Optional<ChargeMasterItemCountAggregateOutputType> | number
          }
        }
      }
      ServiceItem: {
        payload: Prisma.$ServiceItemPayload<ExtArgs>
        fields: Prisma.ServiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          findFirst: {
            args: Prisma.ServiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          findMany: {
            args: Prisma.ServiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>[]
          }
          create: {
            args: Prisma.ServiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          createMany: {
            args: Prisma.ServiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>[]
          }
          delete: {
            args: Prisma.ServiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          update: {
            args: Prisma.ServiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          deleteMany: {
            args: Prisma.ServiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceItemPayload>
          }
          aggregate: {
            args: Prisma.ServiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceItem>
          }
          groupBy: {
            args: Prisma.ServiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceItemCountAggregateOutputType> | number
          }
        }
      }
      ServiceChargeMapping: {
        payload: Prisma.$ServiceChargeMappingPayload<ExtArgs>
        fields: Prisma.ServiceChargeMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceChargeMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChargeMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceChargeMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChargeMappingPayload>
          }
          findFirst: {
            args: Prisma.ServiceChargeMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChargeMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceChargeMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChargeMappingPayload>
          }
          findMany: {
            args: Prisma.ServiceChargeMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChargeMappingPayload>[]
          }
          create: {
            args: Prisma.ServiceChargeMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChargeMappingPayload>
          }
          createMany: {
            args: Prisma.ServiceChargeMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceChargeMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChargeMappingPayload>[]
          }
          delete: {
            args: Prisma.ServiceChargeMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChargeMappingPayload>
          }
          update: {
            args: Prisma.ServiceChargeMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChargeMappingPayload>
          }
          deleteMany: {
            args: Prisma.ServiceChargeMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceChargeMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceChargeMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChargeMappingPayload>
          }
          aggregate: {
            args: Prisma.ServiceChargeMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceChargeMapping>
          }
          groupBy: {
            args: Prisma.ServiceChargeMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceChargeMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceChargeMappingCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceChargeMappingCountAggregateOutputType> | number
          }
        }
      }
      FixItTask: {
        payload: Prisma.$FixItTaskPayload<ExtArgs>
        fields: Prisma.FixItTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FixItTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixItTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FixItTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixItTaskPayload>
          }
          findFirst: {
            args: Prisma.FixItTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixItTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FixItTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixItTaskPayload>
          }
          findMany: {
            args: Prisma.FixItTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixItTaskPayload>[]
          }
          create: {
            args: Prisma.FixItTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixItTaskPayload>
          }
          createMany: {
            args: Prisma.FixItTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FixItTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixItTaskPayload>[]
          }
          delete: {
            args: Prisma.FixItTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixItTaskPayload>
          }
          update: {
            args: Prisma.FixItTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixItTaskPayload>
          }
          deleteMany: {
            args: Prisma.FixItTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FixItTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FixItTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixItTaskPayload>
          }
          aggregate: {
            args: Prisma.FixItTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFixItTask>
          }
          groupBy: {
            args: Prisma.FixItTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<FixItTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.FixItTaskCountArgs<ExtArgs>
            result: $Utils.Optional<FixItTaskCountAggregateOutputType> | number
          }
        }
      }
      BulkImportJob: {
        payload: Prisma.$BulkImportJobPayload<ExtArgs>
        fields: Prisma.BulkImportJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BulkImportJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BulkImportJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportJobPayload>
          }
          findFirst: {
            args: Prisma.BulkImportJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BulkImportJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportJobPayload>
          }
          findMany: {
            args: Prisma.BulkImportJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportJobPayload>[]
          }
          create: {
            args: Prisma.BulkImportJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportJobPayload>
          }
          createMany: {
            args: Prisma.BulkImportJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BulkImportJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportJobPayload>[]
          }
          delete: {
            args: Prisma.BulkImportJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportJobPayload>
          }
          update: {
            args: Prisma.BulkImportJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportJobPayload>
          }
          deleteMany: {
            args: Prisma.BulkImportJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BulkImportJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BulkImportJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulkImportJobPayload>
          }
          aggregate: {
            args: Prisma.BulkImportJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBulkImportJob>
          }
          groupBy: {
            args: Prisma.BulkImportJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<BulkImportJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.BulkImportJobCountArgs<ExtArgs>
            result: $Utils.Optional<BulkImportJobCountAggregateOutputType> | number
          }
        }
      }
      ProcedureBooking: {
        payload: Prisma.$ProcedureBookingPayload<ExtArgs>
        fields: Prisma.ProcedureBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcedureBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcedureBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureBookingPayload>
          }
          findFirst: {
            args: Prisma.ProcedureBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcedureBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureBookingPayload>
          }
          findMany: {
            args: Prisma.ProcedureBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureBookingPayload>[]
          }
          create: {
            args: Prisma.ProcedureBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureBookingPayload>
          }
          createMany: {
            args: Prisma.ProcedureBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcedureBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureBookingPayload>[]
          }
          delete: {
            args: Prisma.ProcedureBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureBookingPayload>
          }
          update: {
            args: Prisma.ProcedureBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureBookingPayload>
          }
          deleteMany: {
            args: Prisma.ProcedureBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcedureBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcedureBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcedureBookingPayload>
          }
          aggregate: {
            args: Prisma.ProcedureBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcedureBooking>
          }
          groupBy: {
            args: Prisma.ProcedureBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcedureBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcedureBookingCountArgs<ExtArgs>
            result: $Utils.Optional<ProcedureBookingCountAggregateOutputType> | number
          }
        }
      }
      GoLiveReport: {
        payload: Prisma.$GoLiveReportPayload<ExtArgs>
        fields: Prisma.GoLiveReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoLiveReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoLiveReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoLiveReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoLiveReportPayload>
          }
          findFirst: {
            args: Prisma.GoLiveReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoLiveReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoLiveReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoLiveReportPayload>
          }
          findMany: {
            args: Prisma.GoLiveReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoLiveReportPayload>[]
          }
          create: {
            args: Prisma.GoLiveReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoLiveReportPayload>
          }
          createMany: {
            args: Prisma.GoLiveReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoLiveReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoLiveReportPayload>[]
          }
          delete: {
            args: Prisma.GoLiveReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoLiveReportPayload>
          }
          update: {
            args: Prisma.GoLiveReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoLiveReportPayload>
          }
          deleteMany: {
            args: Prisma.GoLiveReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoLiveReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoLiveReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoLiveReportPayload>
          }
          aggregate: {
            args: Prisma.GoLiveReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoLiveReport>
          }
          groupBy: {
            args: Prisma.GoLiveReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoLiveReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoLiveReportCountArgs<ExtArgs>
            result: $Utils.Optional<GoLiveReportCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    departments: number
    users: number
    patients: number
    wards: number
    oTs: number
    tariffPlans: number
    assets: number
    Specialty: number
    Staff: number
    Encounter: number
    Bed: number
    Admission: number
    branchFacilities: number
    rooms: number
    statutoryCases: number
    auditEvents: number
    policyVersions: number
    policyVersionBranches: number
    locationNodes: number
    unitTypesEnabled: number
    units: number
    unitRooms: number
    unitResources: number
    equipmentAssets: number
    serviceItems: number
    chargeMasterItems: number
    serviceMappings: number
    fixItTasks: number
    importJobs: number
    procedureBookings: number
    goLiveReports: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | BranchCountOutputTypeCountDepartmentsArgs
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    patients?: boolean | BranchCountOutputTypeCountPatientsArgs
    wards?: boolean | BranchCountOutputTypeCountWardsArgs
    oTs?: boolean | BranchCountOutputTypeCountOTsArgs
    tariffPlans?: boolean | BranchCountOutputTypeCountTariffPlansArgs
    assets?: boolean | BranchCountOutputTypeCountAssetsArgs
    Specialty?: boolean | BranchCountOutputTypeCountSpecialtyArgs
    Staff?: boolean | BranchCountOutputTypeCountStaffArgs
    Encounter?: boolean | BranchCountOutputTypeCountEncounterArgs
    Bed?: boolean | BranchCountOutputTypeCountBedArgs
    Admission?: boolean | BranchCountOutputTypeCountAdmissionArgs
    branchFacilities?: boolean | BranchCountOutputTypeCountBranchFacilitiesArgs
    rooms?: boolean | BranchCountOutputTypeCountRoomsArgs
    statutoryCases?: boolean | BranchCountOutputTypeCountStatutoryCasesArgs
    auditEvents?: boolean | BranchCountOutputTypeCountAuditEventsArgs
    policyVersions?: boolean | BranchCountOutputTypeCountPolicyVersionsArgs
    policyVersionBranches?: boolean | BranchCountOutputTypeCountPolicyVersionBranchesArgs
    locationNodes?: boolean | BranchCountOutputTypeCountLocationNodesArgs
    unitTypesEnabled?: boolean | BranchCountOutputTypeCountUnitTypesEnabledArgs
    units?: boolean | BranchCountOutputTypeCountUnitsArgs
    unitRooms?: boolean | BranchCountOutputTypeCountUnitRoomsArgs
    unitResources?: boolean | BranchCountOutputTypeCountUnitResourcesArgs
    equipmentAssets?: boolean | BranchCountOutputTypeCountEquipmentAssetsArgs
    serviceItems?: boolean | BranchCountOutputTypeCountServiceItemsArgs
    chargeMasterItems?: boolean | BranchCountOutputTypeCountChargeMasterItemsArgs
    serviceMappings?: boolean | BranchCountOutputTypeCountServiceMappingsArgs
    fixItTasks?: boolean | BranchCountOutputTypeCountFixItTasksArgs
    importJobs?: boolean | BranchCountOutputTypeCountImportJobsArgs
    procedureBookings?: boolean | BranchCountOutputTypeCountProcedureBookingsArgs
    goLiveReports?: boolean | BranchCountOutputTypeCountGoLiveReportsArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountWardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountOTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountTariffPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffPlanWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSpecialtyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialtyWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountEncounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountBedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountBranchFacilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchFacilityWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountStatutoryCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatutoryCaseWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAuditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountPolicyVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyVersionWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountPolicyVersionBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyVersionBranchWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountLocationNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationNodeWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUnitTypesEnabledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchUnitTypeWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUnitRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitRoomWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUnitResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitResourceWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountEquipmentAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentAssetWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountServiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceItemWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountChargeMasterItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChargeMasterItemWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountServiceMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceChargeMappingWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountFixItTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixItTaskWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountImportJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkImportJobWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountProcedureBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureBookingWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountGoLiveReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoLiveReportWhereInput
  }


  /**
   * Count Type FacilityCatalogCountOutputType
   */

  export type FacilityCatalogCountOutputType = {
    branchLinks: number
    departments: number
  }

  export type FacilityCatalogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branchLinks?: boolean | FacilityCatalogCountOutputTypeCountBranchLinksArgs
    departments?: boolean | FacilityCatalogCountOutputTypeCountDepartmentsArgs
  }

  // Custom InputTypes
  /**
   * FacilityCatalogCountOutputType without action
   */
  export type FacilityCatalogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalogCountOutputType
     */
    select?: FacilityCatalogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacilityCatalogCountOutputType without action
   */
  export type FacilityCatalogCountOutputTypeCountBranchLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchFacilityWhereInput
  }

  /**
   * FacilityCatalogCountOutputType without action
   */
  export type FacilityCatalogCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    staff: number
    departmentSpecialties: number
    doctorAssignments: number
    units: number
    equipmentOwned: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | DepartmentCountOutputTypeCountStaffArgs
    departmentSpecialties?: boolean | DepartmentCountOutputTypeCountDepartmentSpecialtiesArgs
    doctorAssignments?: boolean | DepartmentCountOutputTypeCountDoctorAssignmentsArgs
    units?: boolean | DepartmentCountOutputTypeCountUnitsArgs
    equipmentOwned?: boolean | DepartmentCountOutputTypeCountEquipmentOwnedArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountDepartmentSpecialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentSpecialtyWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountDoctorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentDoctorWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountEquipmentOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentAssetWhereInput
  }


  /**
   * Count Type SpecialtyCountOutputType
   */

  export type SpecialtyCountOutputType = {
    staff: number
    departmentLinks: number
  }

  export type SpecialtyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | SpecialtyCountOutputTypeCountStaffArgs
    departmentLinks?: boolean | SpecialtyCountOutputTypeCountDepartmentLinksArgs
  }

  // Custom InputTypes
  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialtyCountOutputType
     */
    select?: SpecialtyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }

  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeCountDepartmentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentSpecialtyWhereInput
  }


  /**
   * Count Type StaffCountOutputType
   */

  export type StaffCountOutputType = {
    doctorAssignments: number
    headedDepartments: number
  }

  export type StaffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctorAssignments?: boolean | StaffCountOutputTypeCountDoctorAssignmentsArgs
    headedDepartments?: boolean | StaffCountOutputTypeCountHeadedDepartmentsArgs
  }

  // Custom InputTypes
  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffCountOutputType
     */
    select?: StaffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountDoctorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentDoctorWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountHeadedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdRoleVersions: number
    auditEventsAsActor: number
    policyVersionsCreatedBy: number
    policyVersionsSubmittedBy: number
    policyVersionsApprovedBy: number
    policyVersionsRejectedBy: number
    policyVersionsRetiredBy: number
    createdLocationRevisions: number
    createdImportJobs: number
    assignedFixIts: number
    createdBookings: number
    createdGoLiveReports: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdRoleVersions?: boolean | UserCountOutputTypeCountCreatedRoleVersionsArgs
    auditEventsAsActor?: boolean | UserCountOutputTypeCountAuditEventsAsActorArgs
    policyVersionsCreatedBy?: boolean | UserCountOutputTypeCountPolicyVersionsCreatedByArgs
    policyVersionsSubmittedBy?: boolean | UserCountOutputTypeCountPolicyVersionsSubmittedByArgs
    policyVersionsApprovedBy?: boolean | UserCountOutputTypeCountPolicyVersionsApprovedByArgs
    policyVersionsRejectedBy?: boolean | UserCountOutputTypeCountPolicyVersionsRejectedByArgs
    policyVersionsRetiredBy?: boolean | UserCountOutputTypeCountPolicyVersionsRetiredByArgs
    createdLocationRevisions?: boolean | UserCountOutputTypeCountCreatedLocationRevisionsArgs
    createdImportJobs?: boolean | UserCountOutputTypeCountCreatedImportJobsArgs
    assignedFixIts?: boolean | UserCountOutputTypeCountAssignedFixItsArgs
    createdBookings?: boolean | UserCountOutputTypeCountCreatedBookingsArgs
    createdGoLiveReports?: boolean | UserCountOutputTypeCountCreatedGoLiveReportsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedRoleVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplateVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditEventsAsActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPolicyVersionsCreatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPolicyVersionsSubmittedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPolicyVersionsApprovedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPolicyVersionsRejectedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPolicyVersionsRetiredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedLocationRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationNodeRevisionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedImportJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkImportJobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedFixItsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixItTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureBookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedGoLiveReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoLiveReportWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    encounters: number
    Admission: number
    consentRecords: number
    rtbfRequests: number
    statutoryCases: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | PatientCountOutputTypeCountEncountersArgs
    Admission?: boolean | PatientCountOutputTypeCountAdmissionArgs
    consentRecords?: boolean | PatientCountOutputTypeCountConsentRecordsArgs
    rtbfRequests?: boolean | PatientCountOutputTypeCountRtbfRequestsArgs
    statutoryCases?: boolean | PatientCountOutputTypeCountStatutoryCasesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountConsentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentRecordWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountRtbfRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RtbfRequestWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountStatutoryCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatutoryCaseWhereInput
  }


  /**
   * Count Type EncounterCountOutputType
   */

  export type EncounterCountOutputType = {
    admissions: number
  }

  export type EncounterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admissions?: boolean | EncounterCountOutputTypeCountAdmissionsArgs
  }

  // Custom InputTypes
  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCountOutputType
     */
    select?: EncounterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }


  /**
   * Count Type WardCountOutputType
   */

  export type WardCountOutputType = {
    rooms: number
  }

  export type WardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | WardCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes
  /**
   * WardCountOutputType without action
   */
  export type WardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardCountOutputType
     */
    select?: WardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WardCountOutputType without action
   */
  export type WardCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    beds: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beds?: boolean | RoomCountOutputTypeCountBedsArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountBedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
  }


  /**
   * Count Type BedCountOutputType
   */

  export type BedCountOutputType = {
    admissions: number
  }

  export type BedCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admissions?: boolean | BedCountOutputTypeCountAdmissionsArgs
  }

  // Custom InputTypes
  /**
   * BedCountOutputType without action
   */
  export type BedCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedCountOutputType
     */
    select?: BedCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BedCountOutputType without action
   */
  export type BedCountOutputTypeCountAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }


  /**
   * Count Type TariffPlanCountOutputType
   */

  export type TariffPlanCountOutputType = {
    rates: number
  }

  export type TariffPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rates?: boolean | TariffPlanCountOutputTypeCountRatesArgs
  }

  // Custom InputTypes
  /**
   * TariffPlanCountOutputType without action
   */
  export type TariffPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlanCountOutputType
     */
    select?: TariffPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TariffPlanCountOutputType without action
   */
  export type TariffPlanCountOutputTypeCountRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffRateWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roleGrants: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleGrants?: boolean | PermissionCountOutputTypeCountRoleGrantsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRoleGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplatePermissionWhereInput
  }


  /**
   * Count Type RoleTemplateCountOutputType
   */

  export type RoleTemplateCountOutputType = {
    versions: number
  }

  export type RoleTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | RoleTemplateCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * RoleTemplateCountOutputType without action
   */
  export type RoleTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateCountOutputType
     */
    select?: RoleTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleTemplateCountOutputType without action
   */
  export type RoleTemplateCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplateVersionWhereInput
  }


  /**
   * Count Type RoleTemplateVersionCountOutputType
   */

  export type RoleTemplateVersionCountOutputType = {
    permissions: number
    users: number
  }

  export type RoleTemplateVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleTemplateVersionCountOutputTypeCountPermissionsArgs
    users?: boolean | RoleTemplateVersionCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleTemplateVersionCountOutputType without action
   */
  export type RoleTemplateVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersionCountOutputType
     */
    select?: RoleTemplateVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleTemplateVersionCountOutputType without action
   */
  export type RoleTemplateVersionCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplatePermissionWhereInput
  }

  /**
   * RoleTemplateVersionCountOutputType without action
   */
  export type RoleTemplateVersionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type PolicyDefinitionCountOutputType
   */

  export type PolicyDefinitionCountOutputType = {
    versions: number
  }

  export type PolicyDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | PolicyDefinitionCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * PolicyDefinitionCountOutputType without action
   */
  export type PolicyDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinitionCountOutputType
     */
    select?: PolicyDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PolicyDefinitionCountOutputType without action
   */
  export type PolicyDefinitionCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyVersionWhereInput
  }


  /**
   * Count Type PolicyVersionCountOutputType
   */

  export type PolicyVersionCountOutputType = {
    branches: number
  }

  export type PolicyVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branches?: boolean | PolicyVersionCountOutputTypeCountBranchesArgs
  }

  // Custom InputTypes
  /**
   * PolicyVersionCountOutputType without action
   */
  export type PolicyVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionCountOutputType
     */
    select?: PolicyVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PolicyVersionCountOutputType without action
   */
  export type PolicyVersionCountOutputTypeCountBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyVersionBranchWhereInput
  }


  /**
   * Count Type LocationNodeCountOutputType
   */

  export type LocationNodeCountOutputType = {
    children: number
    revisions: number
    EquipmentAsset: number
  }

  export type LocationNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | LocationNodeCountOutputTypeCountChildrenArgs
    revisions?: boolean | LocationNodeCountOutputTypeCountRevisionsArgs
    EquipmentAsset?: boolean | LocationNodeCountOutputTypeCountEquipmentAssetArgs
  }

  // Custom InputTypes
  /**
   * LocationNodeCountOutputType without action
   */
  export type LocationNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeCountOutputType
     */
    select?: LocationNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationNodeCountOutputType without action
   */
  export type LocationNodeCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationNodeWhereInput
  }

  /**
   * LocationNodeCountOutputType without action
   */
  export type LocationNodeCountOutputTypeCountRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationNodeRevisionWhereInput
  }

  /**
   * LocationNodeCountOutputType without action
   */
  export type LocationNodeCountOutputTypeCountEquipmentAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentAssetWhereInput
  }


  /**
   * Count Type UnitTypeCatalogCountOutputType
   */

  export type UnitTypeCatalogCountOutputType = {
    branchLinks: number
    units: number
  }

  export type UnitTypeCatalogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branchLinks?: boolean | UnitTypeCatalogCountOutputTypeCountBranchLinksArgs
    units?: boolean | UnitTypeCatalogCountOutputTypeCountUnitsArgs
  }

  // Custom InputTypes
  /**
   * UnitTypeCatalogCountOutputType without action
   */
  export type UnitTypeCatalogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalogCountOutputType
     */
    select?: UnitTypeCatalogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitTypeCatalogCountOutputType without action
   */
  export type UnitTypeCatalogCountOutputTypeCountBranchLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchUnitTypeWhereInput
  }

  /**
   * UnitTypeCatalogCountOutputType without action
   */
  export type UnitTypeCatalogCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    rooms: number
    resources: number
    equipment: number
    bookings: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | UnitCountOutputTypeCountRoomsArgs
    resources?: boolean | UnitCountOutputTypeCountResourcesArgs
    equipment?: boolean | UnitCountOutputTypeCountEquipmentArgs
    bookings?: boolean | UnitCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitRoomWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitResourceWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentAssetWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureBookingWhereInput
  }


  /**
   * Count Type UnitRoomCountOutputType
   */

  export type UnitRoomCountOutputType = {
    resources: number
    equipment: number
  }

  export type UnitRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | UnitRoomCountOutputTypeCountResourcesArgs
    equipment?: boolean | UnitRoomCountOutputTypeCountEquipmentArgs
  }

  // Custom InputTypes
  /**
   * UnitRoomCountOutputType without action
   */
  export type UnitRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoomCountOutputType
     */
    select?: UnitRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitRoomCountOutputType without action
   */
  export type UnitRoomCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitResourceWhereInput
  }

  /**
   * UnitRoomCountOutputType without action
   */
  export type UnitRoomCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentAssetWhereInput
  }


  /**
   * Count Type UnitResourceCountOutputType
   */

  export type UnitResourceCountOutputType = {
    bookings: number
  }

  export type UnitResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | UnitResourceCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * UnitResourceCountOutputType without action
   */
  export type UnitResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResourceCountOutputType
     */
    select?: UnitResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitResourceCountOutputType without action
   */
  export type UnitResourceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureBookingWhereInput
  }


  /**
   * Count Type EquipmentAssetCountOutputType
   */

  export type EquipmentAssetCountOutputType = {
    downtimeTickets: number
  }

  export type EquipmentAssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    downtimeTickets?: boolean | EquipmentAssetCountOutputTypeCountDowntimeTicketsArgs
  }

  // Custom InputTypes
  /**
   * EquipmentAssetCountOutputType without action
   */
  export type EquipmentAssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAssetCountOutputType
     */
    select?: EquipmentAssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentAssetCountOutputType without action
   */
  export type EquipmentAssetCountOutputTypeCountDowntimeTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DowntimeTicketWhereInput
  }


  /**
   * Count Type ChargeMasterItemCountOutputType
   */

  export type ChargeMasterItemCountOutputType = {
    mappings: number
  }

  export type ChargeMasterItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mappings?: boolean | ChargeMasterItemCountOutputTypeCountMappingsArgs
  }

  // Custom InputTypes
  /**
   * ChargeMasterItemCountOutputType without action
   */
  export type ChargeMasterItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItemCountOutputType
     */
    select?: ChargeMasterItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChargeMasterItemCountOutputType without action
   */
  export type ChargeMasterItemCountOutputTypeCountMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceChargeMappingWhereInput
  }


  /**
   * Count Type ServiceItemCountOutputType
   */

  export type ServiceItemCountOutputType = {
    mappings: number
    fixIts: number
  }

  export type ServiceItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mappings?: boolean | ServiceItemCountOutputTypeCountMappingsArgs
    fixIts?: boolean | ServiceItemCountOutputTypeCountFixItsArgs
  }

  // Custom InputTypes
  /**
   * ServiceItemCountOutputType without action
   */
  export type ServiceItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItemCountOutputType
     */
    select?: ServiceItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceItemCountOutputType without action
   */
  export type ServiceItemCountOutputTypeCountMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceChargeMappingWhereInput
  }

  /**
   * ServiceItemCountOutputType without action
   */
  export type ServiceItemCountOutputTypeCountFixItsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixItTaskWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    city: string | null
    gstNumber: string | null
    address: string | null
    contactPhone1: string | null
    contactPhone2: string | null
    contactEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    city: string | null
    gstNumber: string | null
    address: string | null
    contactPhone1: string | null
    contactPhone2: string | null
    contactEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    code: number
    name: number
    city: number
    gstNumber: number
    address: number
    contactPhone1: number
    contactPhone2: number
    contactEmail: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    city?: true
    gstNumber?: true
    address?: true
    contactPhone1?: true
    contactPhone2?: true
    contactEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    city?: true
    gstNumber?: true
    address?: true
    contactPhone1?: true
    contactPhone2?: true
    contactEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    city?: true
    gstNumber?: true
    address?: true
    contactPhone1?: true
    contactPhone2?: true
    contactEmail?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    code: string
    name: string
    city: string
    gstNumber: string | null
    address: string | null
    contactPhone1: string | null
    contactPhone2: string | null
    contactEmail: string | null
    createdAt: Date
    updatedAt: Date
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    city?: boolean
    gstNumber?: boolean
    address?: boolean
    contactPhone1?: boolean
    contactPhone2?: boolean
    contactEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departments?: boolean | Branch$departmentsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    patients?: boolean | Branch$patientsArgs<ExtArgs>
    wards?: boolean | Branch$wardsArgs<ExtArgs>
    oTs?: boolean | Branch$oTsArgs<ExtArgs>
    tariffPlans?: boolean | Branch$tariffPlansArgs<ExtArgs>
    assets?: boolean | Branch$assetsArgs<ExtArgs>
    Specialty?: boolean | Branch$SpecialtyArgs<ExtArgs>
    Staff?: boolean | Branch$StaffArgs<ExtArgs>
    Encounter?: boolean | Branch$EncounterArgs<ExtArgs>
    Bed?: boolean | Branch$BedArgs<ExtArgs>
    Admission?: boolean | Branch$AdmissionArgs<ExtArgs>
    branchFacilities?: boolean | Branch$branchFacilitiesArgs<ExtArgs>
    rooms?: boolean | Branch$roomsArgs<ExtArgs>
    statutoryCases?: boolean | Branch$statutoryCasesArgs<ExtArgs>
    auditEvents?: boolean | Branch$auditEventsArgs<ExtArgs>
    policyVersions?: boolean | Branch$policyVersionsArgs<ExtArgs>
    policyVersionBranches?: boolean | Branch$policyVersionBranchesArgs<ExtArgs>
    locationNodes?: boolean | Branch$locationNodesArgs<ExtArgs>
    unitTypesEnabled?: boolean | Branch$unitTypesEnabledArgs<ExtArgs>
    units?: boolean | Branch$unitsArgs<ExtArgs>
    unitRooms?: boolean | Branch$unitRoomsArgs<ExtArgs>
    unitResources?: boolean | Branch$unitResourcesArgs<ExtArgs>
    equipmentAssets?: boolean | Branch$equipmentAssetsArgs<ExtArgs>
    serviceItems?: boolean | Branch$serviceItemsArgs<ExtArgs>
    chargeMasterItems?: boolean | Branch$chargeMasterItemsArgs<ExtArgs>
    serviceMappings?: boolean | Branch$serviceMappingsArgs<ExtArgs>
    fixItTasks?: boolean | Branch$fixItTasksArgs<ExtArgs>
    importJobs?: boolean | Branch$importJobsArgs<ExtArgs>
    procedureBookings?: boolean | Branch$procedureBookingsArgs<ExtArgs>
    goLiveReports?: boolean | Branch$goLiveReportsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    city?: boolean
    gstNumber?: boolean
    address?: boolean
    contactPhone1?: boolean
    contactPhone2?: boolean
    contactEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    city?: boolean
    gstNumber?: boolean
    address?: boolean
    contactPhone1?: boolean
    contactPhone2?: boolean
    contactEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | Branch$departmentsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    patients?: boolean | Branch$patientsArgs<ExtArgs>
    wards?: boolean | Branch$wardsArgs<ExtArgs>
    oTs?: boolean | Branch$oTsArgs<ExtArgs>
    tariffPlans?: boolean | Branch$tariffPlansArgs<ExtArgs>
    assets?: boolean | Branch$assetsArgs<ExtArgs>
    Specialty?: boolean | Branch$SpecialtyArgs<ExtArgs>
    Staff?: boolean | Branch$StaffArgs<ExtArgs>
    Encounter?: boolean | Branch$EncounterArgs<ExtArgs>
    Bed?: boolean | Branch$BedArgs<ExtArgs>
    Admission?: boolean | Branch$AdmissionArgs<ExtArgs>
    branchFacilities?: boolean | Branch$branchFacilitiesArgs<ExtArgs>
    rooms?: boolean | Branch$roomsArgs<ExtArgs>
    statutoryCases?: boolean | Branch$statutoryCasesArgs<ExtArgs>
    auditEvents?: boolean | Branch$auditEventsArgs<ExtArgs>
    policyVersions?: boolean | Branch$policyVersionsArgs<ExtArgs>
    policyVersionBranches?: boolean | Branch$policyVersionBranchesArgs<ExtArgs>
    locationNodes?: boolean | Branch$locationNodesArgs<ExtArgs>
    unitTypesEnabled?: boolean | Branch$unitTypesEnabledArgs<ExtArgs>
    units?: boolean | Branch$unitsArgs<ExtArgs>
    unitRooms?: boolean | Branch$unitRoomsArgs<ExtArgs>
    unitResources?: boolean | Branch$unitResourcesArgs<ExtArgs>
    equipmentAssets?: boolean | Branch$equipmentAssetsArgs<ExtArgs>
    serviceItems?: boolean | Branch$serviceItemsArgs<ExtArgs>
    chargeMasterItems?: boolean | Branch$chargeMasterItemsArgs<ExtArgs>
    serviceMappings?: boolean | Branch$serviceMappingsArgs<ExtArgs>
    fixItTasks?: boolean | Branch$fixItTasksArgs<ExtArgs>
    importJobs?: boolean | Branch$importJobsArgs<ExtArgs>
    procedureBookings?: boolean | Branch$procedureBookingsArgs<ExtArgs>
    goLiveReports?: boolean | Branch$goLiveReportsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      patients: Prisma.$PatientPayload<ExtArgs>[]
      wards: Prisma.$WardPayload<ExtArgs>[]
      oTs: Prisma.$OTPayload<ExtArgs>[]
      tariffPlans: Prisma.$TariffPlanPayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
      Specialty: Prisma.$SpecialtyPayload<ExtArgs>[]
      Staff: Prisma.$StaffPayload<ExtArgs>[]
      Encounter: Prisma.$EncounterPayload<ExtArgs>[]
      Bed: Prisma.$BedPayload<ExtArgs>[]
      Admission: Prisma.$AdmissionPayload<ExtArgs>[]
      branchFacilities: Prisma.$BranchFacilityPayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      statutoryCases: Prisma.$StatutoryCasePayload<ExtArgs>[]
      auditEvents: Prisma.$AuditEventPayload<ExtArgs>[]
      policyVersions: Prisma.$PolicyVersionPayload<ExtArgs>[]
      policyVersionBranches: Prisma.$PolicyVersionBranchPayload<ExtArgs>[]
      locationNodes: Prisma.$LocationNodePayload<ExtArgs>[]
      unitTypesEnabled: Prisma.$BranchUnitTypePayload<ExtArgs>[]
      units: Prisma.$UnitPayload<ExtArgs>[]
      unitRooms: Prisma.$UnitRoomPayload<ExtArgs>[]
      unitResources: Prisma.$UnitResourcePayload<ExtArgs>[]
      equipmentAssets: Prisma.$EquipmentAssetPayload<ExtArgs>[]
      serviceItems: Prisma.$ServiceItemPayload<ExtArgs>[]
      chargeMasterItems: Prisma.$ChargeMasterItemPayload<ExtArgs>[]
      serviceMappings: Prisma.$ServiceChargeMappingPayload<ExtArgs>[]
      fixItTasks: Prisma.$FixItTaskPayload<ExtArgs>[]
      importJobs: Prisma.$BulkImportJobPayload<ExtArgs>[]
      procedureBookings: Prisma.$ProcedureBookingPayload<ExtArgs>[]
      goLiveReports: Prisma.$GoLiveReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      city: string
      /**
       * India GSTIN (15 characters). Used by Accounting/Tax.
       */
      gstNumber: string | null
      address: string | null
      contactPhone1: string | null
      contactPhone2: string | null
      contactEmail: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departments<T extends Branch$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    patients<T extends Branch$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany"> | Null>
    wards<T extends Branch$wardsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$wardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findMany"> | Null>
    oTs<T extends Branch$oTsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$oTsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findMany"> | Null>
    tariffPlans<T extends Branch$tariffPlansArgs<ExtArgs> = {}>(args?: Subset<T, Branch$tariffPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findMany"> | Null>
    assets<T extends Branch$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    Specialty<T extends Branch$SpecialtyArgs<ExtArgs> = {}>(args?: Subset<T, Branch$SpecialtyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findMany"> | Null>
    Staff<T extends Branch$StaffArgs<ExtArgs> = {}>(args?: Subset<T, Branch$StaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany"> | Null>
    Encounter<T extends Branch$EncounterArgs<ExtArgs> = {}>(args?: Subset<T, Branch$EncounterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    Bed<T extends Branch$BedArgs<ExtArgs> = {}>(args?: Subset<T, Branch$BedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany"> | Null>
    Admission<T extends Branch$AdmissionArgs<ExtArgs> = {}>(args?: Subset<T, Branch$AdmissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany"> | Null>
    branchFacilities<T extends Branch$branchFacilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$branchFacilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "findMany"> | Null>
    rooms<T extends Branch$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany"> | Null>
    statutoryCases<T extends Branch$statutoryCasesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$statutoryCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findMany"> | Null>
    auditEvents<T extends Branch$auditEventsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$auditEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany"> | Null>
    policyVersions<T extends Branch$policyVersionsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$policyVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findMany"> | Null>
    policyVersionBranches<T extends Branch$policyVersionBranchesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$policyVersionBranchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "findMany"> | Null>
    locationNodes<T extends Branch$locationNodesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$locationNodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "findMany"> | Null>
    unitTypesEnabled<T extends Branch$unitTypesEnabledArgs<ExtArgs> = {}>(args?: Subset<T, Branch$unitTypesEnabledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "findMany"> | Null>
    units<T extends Branch$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany"> | Null>
    unitRooms<T extends Branch$unitRoomsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$unitRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "findMany"> | Null>
    unitResources<T extends Branch$unitResourcesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$unitResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "findMany"> | Null>
    equipmentAssets<T extends Branch$equipmentAssetsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$equipmentAssetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "findMany"> | Null>
    serviceItems<T extends Branch$serviceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$serviceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    chargeMasterItems<T extends Branch$chargeMasterItemsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$chargeMasterItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "findMany"> | Null>
    serviceMappings<T extends Branch$serviceMappingsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$serviceMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "findMany"> | Null>
    fixItTasks<T extends Branch$fixItTasksArgs<ExtArgs> = {}>(args?: Subset<T, Branch$fixItTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "findMany"> | Null>
    importJobs<T extends Branch$importJobsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$importJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "findMany"> | Null>
    procedureBookings<T extends Branch$procedureBookingsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$procedureBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "findMany"> | Null>
    goLiveReports<T extends Branch$goLiveReportsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$goLiveReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */ 
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly code: FieldRef<"Branch", 'String'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly city: FieldRef<"Branch", 'String'>
    readonly gstNumber: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly contactPhone1: FieldRef<"Branch", 'String'>
    readonly contactPhone2: FieldRef<"Branch", 'String'>
    readonly contactEmail: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }

  /**
   * Branch.departments
   */
  export type Branch$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.patients
   */
  export type Branch$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Branch.wards
   */
  export type Branch$wardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    where?: WardWhereInput
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    cursor?: WardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Branch.oTs
   */
  export type Branch$oTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    where?: OTWhereInput
    orderBy?: OTOrderByWithRelationInput | OTOrderByWithRelationInput[]
    cursor?: OTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OTScalarFieldEnum | OTScalarFieldEnum[]
  }

  /**
   * Branch.tariffPlans
   */
  export type Branch$tariffPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    where?: TariffPlanWhereInput
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    cursor?: TariffPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * Branch.assets
   */
  export type Branch$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Branch.Specialty
   */
  export type Branch$SpecialtyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    where?: SpecialtyWhereInput
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    cursor?: SpecialtyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Branch.Staff
   */
  export type Branch$StaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Branch.Encounter
   */
  export type Branch$EncounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Branch.Bed
   */
  export type Branch$BedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    where?: BedWhereInput
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    cursor?: BedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Branch.Admission
   */
  export type Branch$AdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Branch.branchFacilities
   */
  export type Branch$branchFacilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
    where?: BranchFacilityWhereInput
    orderBy?: BranchFacilityOrderByWithRelationInput | BranchFacilityOrderByWithRelationInput[]
    cursor?: BranchFacilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchFacilityScalarFieldEnum | BranchFacilityScalarFieldEnum[]
  }

  /**
   * Branch.rooms
   */
  export type Branch$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Branch.statutoryCases
   */
  export type Branch$statutoryCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    where?: StatutoryCaseWhereInput
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    cursor?: StatutoryCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatutoryCaseScalarFieldEnum | StatutoryCaseScalarFieldEnum[]
  }

  /**
   * Branch.auditEvents
   */
  export type Branch$auditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    cursor?: AuditEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * Branch.policyVersions
   */
  export type Branch$policyVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    where?: PolicyVersionWhereInput
    orderBy?: PolicyVersionOrderByWithRelationInput | PolicyVersionOrderByWithRelationInput[]
    cursor?: PolicyVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyVersionScalarFieldEnum | PolicyVersionScalarFieldEnum[]
  }

  /**
   * Branch.policyVersionBranches
   */
  export type Branch$policyVersionBranchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
    where?: PolicyVersionBranchWhereInput
    orderBy?: PolicyVersionBranchOrderByWithRelationInput | PolicyVersionBranchOrderByWithRelationInput[]
    cursor?: PolicyVersionBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyVersionBranchScalarFieldEnum | PolicyVersionBranchScalarFieldEnum[]
  }

  /**
   * Branch.locationNodes
   */
  export type Branch$locationNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    where?: LocationNodeWhereInput
    orderBy?: LocationNodeOrderByWithRelationInput | LocationNodeOrderByWithRelationInput[]
    cursor?: LocationNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationNodeScalarFieldEnum | LocationNodeScalarFieldEnum[]
  }

  /**
   * Branch.unitTypesEnabled
   */
  export type Branch$unitTypesEnabledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
    where?: BranchUnitTypeWhereInput
    orderBy?: BranchUnitTypeOrderByWithRelationInput | BranchUnitTypeOrderByWithRelationInput[]
    cursor?: BranchUnitTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchUnitTypeScalarFieldEnum | BranchUnitTypeScalarFieldEnum[]
  }

  /**
   * Branch.units
   */
  export type Branch$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Branch.unitRooms
   */
  export type Branch$unitRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    where?: UnitRoomWhereInput
    orderBy?: UnitRoomOrderByWithRelationInput | UnitRoomOrderByWithRelationInput[]
    cursor?: UnitRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitRoomScalarFieldEnum | UnitRoomScalarFieldEnum[]
  }

  /**
   * Branch.unitResources
   */
  export type Branch$unitResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    where?: UnitResourceWhereInput
    orderBy?: UnitResourceOrderByWithRelationInput | UnitResourceOrderByWithRelationInput[]
    cursor?: UnitResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitResourceScalarFieldEnum | UnitResourceScalarFieldEnum[]
  }

  /**
   * Branch.equipmentAssets
   */
  export type Branch$equipmentAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    where?: EquipmentAssetWhereInput
    orderBy?: EquipmentAssetOrderByWithRelationInput | EquipmentAssetOrderByWithRelationInput[]
    cursor?: EquipmentAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentAssetScalarFieldEnum | EquipmentAssetScalarFieldEnum[]
  }

  /**
   * Branch.serviceItems
   */
  export type Branch$serviceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    where?: ServiceItemWhereInput
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    cursor?: ServiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceItemScalarFieldEnum | ServiceItemScalarFieldEnum[]
  }

  /**
   * Branch.chargeMasterItems
   */
  export type Branch$chargeMasterItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemInclude<ExtArgs> | null
    where?: ChargeMasterItemWhereInput
    orderBy?: ChargeMasterItemOrderByWithRelationInput | ChargeMasterItemOrderByWithRelationInput[]
    cursor?: ChargeMasterItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChargeMasterItemScalarFieldEnum | ChargeMasterItemScalarFieldEnum[]
  }

  /**
   * Branch.serviceMappings
   */
  export type Branch$serviceMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    where?: ServiceChargeMappingWhereInput
    orderBy?: ServiceChargeMappingOrderByWithRelationInput | ServiceChargeMappingOrderByWithRelationInput[]
    cursor?: ServiceChargeMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceChargeMappingScalarFieldEnum | ServiceChargeMappingScalarFieldEnum[]
  }

  /**
   * Branch.fixItTasks
   */
  export type Branch$fixItTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    where?: FixItTaskWhereInput
    orderBy?: FixItTaskOrderByWithRelationInput | FixItTaskOrderByWithRelationInput[]
    cursor?: FixItTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FixItTaskScalarFieldEnum | FixItTaskScalarFieldEnum[]
  }

  /**
   * Branch.importJobs
   */
  export type Branch$importJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
    where?: BulkImportJobWhereInput
    orderBy?: BulkImportJobOrderByWithRelationInput | BulkImportJobOrderByWithRelationInput[]
    cursor?: BulkImportJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BulkImportJobScalarFieldEnum | BulkImportJobScalarFieldEnum[]
  }

  /**
   * Branch.procedureBookings
   */
  export type Branch$procedureBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    where?: ProcedureBookingWhereInput
    orderBy?: ProcedureBookingOrderByWithRelationInput | ProcedureBookingOrderByWithRelationInput[]
    cursor?: ProcedureBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedureBookingScalarFieldEnum | ProcedureBookingScalarFieldEnum[]
  }

  /**
   * Branch.goLiveReports
   */
  export type Branch$goLiveReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
    where?: GoLiveReportWhereInput
    orderBy?: GoLiveReportOrderByWithRelationInput | GoLiveReportOrderByWithRelationInput[]
    cursor?: GoLiveReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoLiveReportScalarFieldEnum | GoLiveReportScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model FacilityCatalog
   */

  export type AggregateFacilityCatalog = {
    _count: FacilityCatalogCountAggregateOutputType | null
    _avg: FacilityCatalogAvgAggregateOutputType | null
    _sum: FacilityCatalogSumAggregateOutputType | null
    _min: FacilityCatalogMinAggregateOutputType | null
    _max: FacilityCatalogMaxAggregateOutputType | null
  }

  export type FacilityCatalogAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type FacilityCatalogSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type FacilityCatalogMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: $Enums.FacilityCategory | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityCatalogMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: $Enums.FacilityCategory | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityCatalogCountAggregateOutputType = {
    id: number
    code: number
    name: number
    category: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacilityCatalogAvgAggregateInputType = {
    sortOrder?: true
  }

  export type FacilityCatalogSumAggregateInputType = {
    sortOrder?: true
  }

  export type FacilityCatalogMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityCatalogMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityCatalogCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacilityCatalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityCatalog to aggregate.
     */
    where?: FacilityCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityCatalogs to fetch.
     */
    orderBy?: FacilityCatalogOrderByWithRelationInput | FacilityCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FacilityCatalogs
    **/
    _count?: true | FacilityCatalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacilityCatalogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacilityCatalogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityCatalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityCatalogMaxAggregateInputType
  }

  export type GetFacilityCatalogAggregateType<T extends FacilityCatalogAggregateArgs> = {
        [P in keyof T & keyof AggregateFacilityCatalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilityCatalog[P]>
      : GetScalarType<T[P], AggregateFacilityCatalog[P]>
  }




  export type FacilityCatalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityCatalogWhereInput
    orderBy?: FacilityCatalogOrderByWithAggregationInput | FacilityCatalogOrderByWithAggregationInput[]
    by: FacilityCatalogScalarFieldEnum[] | FacilityCatalogScalarFieldEnum
    having?: FacilityCatalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityCatalogCountAggregateInputType | true
    _avg?: FacilityCatalogAvgAggregateInputType
    _sum?: FacilityCatalogSumAggregateInputType
    _min?: FacilityCatalogMinAggregateInputType
    _max?: FacilityCatalogMaxAggregateInputType
  }

  export type FacilityCatalogGroupByOutputType = {
    id: string
    code: string
    name: string
    category: $Enums.FacilityCategory
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: FacilityCatalogCountAggregateOutputType | null
    _avg: FacilityCatalogAvgAggregateOutputType | null
    _sum: FacilityCatalogSumAggregateOutputType | null
    _min: FacilityCatalogMinAggregateOutputType | null
    _max: FacilityCatalogMaxAggregateOutputType | null
  }

  type GetFacilityCatalogGroupByPayload<T extends FacilityCatalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityCatalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityCatalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityCatalogGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityCatalogGroupByOutputType[P]>
        }
      >
    >


  export type FacilityCatalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branchLinks?: boolean | FacilityCatalog$branchLinksArgs<ExtArgs>
    departments?: boolean | FacilityCatalog$departmentsArgs<ExtArgs>
    _count?: boolean | FacilityCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilityCatalog"]>

  export type FacilityCatalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["facilityCatalog"]>

  export type FacilityCatalogSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FacilityCatalogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branchLinks?: boolean | FacilityCatalog$branchLinksArgs<ExtArgs>
    departments?: boolean | FacilityCatalog$departmentsArgs<ExtArgs>
    _count?: boolean | FacilityCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacilityCatalogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FacilityCatalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FacilityCatalog"
    objects: {
      branchLinks: Prisma.$BranchFacilityPayload<ExtArgs>[]
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      category: $Enums.FacilityCategory
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["facilityCatalog"]>
    composites: {}
  }

  type FacilityCatalogGetPayload<S extends boolean | null | undefined | FacilityCatalogDefaultArgs> = $Result.GetResult<Prisma.$FacilityCatalogPayload, S>

  type FacilityCatalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FacilityCatalogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacilityCatalogCountAggregateInputType | true
    }

  export interface FacilityCatalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FacilityCatalog'], meta: { name: 'FacilityCatalog' } }
    /**
     * Find zero or one FacilityCatalog that matches the filter.
     * @param {FacilityCatalogFindUniqueArgs} args - Arguments to find a FacilityCatalog
     * @example
     * // Get one FacilityCatalog
     * const facilityCatalog = await prisma.facilityCatalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityCatalogFindUniqueArgs>(args: SelectSubset<T, FacilityCatalogFindUniqueArgs<ExtArgs>>): Prisma__FacilityCatalogClient<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FacilityCatalog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FacilityCatalogFindUniqueOrThrowArgs} args - Arguments to find a FacilityCatalog
     * @example
     * // Get one FacilityCatalog
     * const facilityCatalog = await prisma.facilityCatalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityCatalogFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityCatalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityCatalogClient<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FacilityCatalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCatalogFindFirstArgs} args - Arguments to find a FacilityCatalog
     * @example
     * // Get one FacilityCatalog
     * const facilityCatalog = await prisma.facilityCatalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityCatalogFindFirstArgs>(args?: SelectSubset<T, FacilityCatalogFindFirstArgs<ExtArgs>>): Prisma__FacilityCatalogClient<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FacilityCatalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCatalogFindFirstOrThrowArgs} args - Arguments to find a FacilityCatalog
     * @example
     * // Get one FacilityCatalog
     * const facilityCatalog = await prisma.facilityCatalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityCatalogFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityCatalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityCatalogClient<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FacilityCatalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCatalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacilityCatalogs
     * const facilityCatalogs = await prisma.facilityCatalog.findMany()
     * 
     * // Get first 10 FacilityCatalogs
     * const facilityCatalogs = await prisma.facilityCatalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityCatalogWithIdOnly = await prisma.facilityCatalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacilityCatalogFindManyArgs>(args?: SelectSubset<T, FacilityCatalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FacilityCatalog.
     * @param {FacilityCatalogCreateArgs} args - Arguments to create a FacilityCatalog.
     * @example
     * // Create one FacilityCatalog
     * const FacilityCatalog = await prisma.facilityCatalog.create({
     *   data: {
     *     // ... data to create a FacilityCatalog
     *   }
     * })
     * 
     */
    create<T extends FacilityCatalogCreateArgs>(args: SelectSubset<T, FacilityCatalogCreateArgs<ExtArgs>>): Prisma__FacilityCatalogClient<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FacilityCatalogs.
     * @param {FacilityCatalogCreateManyArgs} args - Arguments to create many FacilityCatalogs.
     * @example
     * // Create many FacilityCatalogs
     * const facilityCatalog = await prisma.facilityCatalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityCatalogCreateManyArgs>(args?: SelectSubset<T, FacilityCatalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FacilityCatalogs and returns the data saved in the database.
     * @param {FacilityCatalogCreateManyAndReturnArgs} args - Arguments to create many FacilityCatalogs.
     * @example
     * // Create many FacilityCatalogs
     * const facilityCatalog = await prisma.facilityCatalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FacilityCatalogs and only return the `id`
     * const facilityCatalogWithIdOnly = await prisma.facilityCatalog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilityCatalogCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilityCatalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FacilityCatalog.
     * @param {FacilityCatalogDeleteArgs} args - Arguments to delete one FacilityCatalog.
     * @example
     * // Delete one FacilityCatalog
     * const FacilityCatalog = await prisma.facilityCatalog.delete({
     *   where: {
     *     // ... filter to delete one FacilityCatalog
     *   }
     * })
     * 
     */
    delete<T extends FacilityCatalogDeleteArgs>(args: SelectSubset<T, FacilityCatalogDeleteArgs<ExtArgs>>): Prisma__FacilityCatalogClient<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FacilityCatalog.
     * @param {FacilityCatalogUpdateArgs} args - Arguments to update one FacilityCatalog.
     * @example
     * // Update one FacilityCatalog
     * const facilityCatalog = await prisma.facilityCatalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityCatalogUpdateArgs>(args: SelectSubset<T, FacilityCatalogUpdateArgs<ExtArgs>>): Prisma__FacilityCatalogClient<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FacilityCatalogs.
     * @param {FacilityCatalogDeleteManyArgs} args - Arguments to filter FacilityCatalogs to delete.
     * @example
     * // Delete a few FacilityCatalogs
     * const { count } = await prisma.facilityCatalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityCatalogDeleteManyArgs>(args?: SelectSubset<T, FacilityCatalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FacilityCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCatalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacilityCatalogs
     * const facilityCatalog = await prisma.facilityCatalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityCatalogUpdateManyArgs>(args: SelectSubset<T, FacilityCatalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FacilityCatalog.
     * @param {FacilityCatalogUpsertArgs} args - Arguments to update or create a FacilityCatalog.
     * @example
     * // Update or create a FacilityCatalog
     * const facilityCatalog = await prisma.facilityCatalog.upsert({
     *   create: {
     *     // ... data to create a FacilityCatalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacilityCatalog we want to update
     *   }
     * })
     */
    upsert<T extends FacilityCatalogUpsertArgs>(args: SelectSubset<T, FacilityCatalogUpsertArgs<ExtArgs>>): Prisma__FacilityCatalogClient<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FacilityCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCatalogCountArgs} args - Arguments to filter FacilityCatalogs to count.
     * @example
     * // Count the number of FacilityCatalogs
     * const count = await prisma.facilityCatalog.count({
     *   where: {
     *     // ... the filter for the FacilityCatalogs we want to count
     *   }
     * })
    **/
    count<T extends FacilityCatalogCountArgs>(
      args?: Subset<T, FacilityCatalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityCatalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FacilityCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCatalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityCatalogAggregateArgs>(args: Subset<T, FacilityCatalogAggregateArgs>): Prisma.PrismaPromise<GetFacilityCatalogAggregateType<T>>

    /**
     * Group by FacilityCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCatalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityCatalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityCatalogGroupByArgs['orderBy'] }
        : { orderBy?: FacilityCatalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityCatalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityCatalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FacilityCatalog model
   */
  readonly fields: FacilityCatalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacilityCatalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityCatalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branchLinks<T extends FacilityCatalog$branchLinksArgs<ExtArgs> = {}>(args?: Subset<T, FacilityCatalog$branchLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "findMany"> | Null>
    departments<T extends FacilityCatalog$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, FacilityCatalog$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FacilityCatalog model
   */ 
  interface FacilityCatalogFieldRefs {
    readonly id: FieldRef<"FacilityCatalog", 'String'>
    readonly code: FieldRef<"FacilityCatalog", 'String'>
    readonly name: FieldRef<"FacilityCatalog", 'String'>
    readonly category: FieldRef<"FacilityCatalog", 'FacilityCategory'>
    readonly isActive: FieldRef<"FacilityCatalog", 'Boolean'>
    readonly sortOrder: FieldRef<"FacilityCatalog", 'Int'>
    readonly createdAt: FieldRef<"FacilityCatalog", 'DateTime'>
    readonly updatedAt: FieldRef<"FacilityCatalog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FacilityCatalog findUnique
   */
  export type FacilityCatalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalog
     */
    select?: FacilityCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityCatalogInclude<ExtArgs> | null
    /**
     * Filter, which FacilityCatalog to fetch.
     */
    where: FacilityCatalogWhereUniqueInput
  }

  /**
   * FacilityCatalog findUniqueOrThrow
   */
  export type FacilityCatalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalog
     */
    select?: FacilityCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityCatalogInclude<ExtArgs> | null
    /**
     * Filter, which FacilityCatalog to fetch.
     */
    where: FacilityCatalogWhereUniqueInput
  }

  /**
   * FacilityCatalog findFirst
   */
  export type FacilityCatalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalog
     */
    select?: FacilityCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityCatalogInclude<ExtArgs> | null
    /**
     * Filter, which FacilityCatalog to fetch.
     */
    where?: FacilityCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityCatalogs to fetch.
     */
    orderBy?: FacilityCatalogOrderByWithRelationInput | FacilityCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityCatalogs.
     */
    cursor?: FacilityCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityCatalogs.
     */
    distinct?: FacilityCatalogScalarFieldEnum | FacilityCatalogScalarFieldEnum[]
  }

  /**
   * FacilityCatalog findFirstOrThrow
   */
  export type FacilityCatalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalog
     */
    select?: FacilityCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityCatalogInclude<ExtArgs> | null
    /**
     * Filter, which FacilityCatalog to fetch.
     */
    where?: FacilityCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityCatalogs to fetch.
     */
    orderBy?: FacilityCatalogOrderByWithRelationInput | FacilityCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FacilityCatalogs.
     */
    cursor?: FacilityCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FacilityCatalogs.
     */
    distinct?: FacilityCatalogScalarFieldEnum | FacilityCatalogScalarFieldEnum[]
  }

  /**
   * FacilityCatalog findMany
   */
  export type FacilityCatalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalog
     */
    select?: FacilityCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityCatalogInclude<ExtArgs> | null
    /**
     * Filter, which FacilityCatalogs to fetch.
     */
    where?: FacilityCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FacilityCatalogs to fetch.
     */
    orderBy?: FacilityCatalogOrderByWithRelationInput | FacilityCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FacilityCatalogs.
     */
    cursor?: FacilityCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FacilityCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FacilityCatalogs.
     */
    skip?: number
    distinct?: FacilityCatalogScalarFieldEnum | FacilityCatalogScalarFieldEnum[]
  }

  /**
   * FacilityCatalog create
   */
  export type FacilityCatalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalog
     */
    select?: FacilityCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityCatalogInclude<ExtArgs> | null
    /**
     * The data needed to create a FacilityCatalog.
     */
    data: XOR<FacilityCatalogCreateInput, FacilityCatalogUncheckedCreateInput>
  }

  /**
   * FacilityCatalog createMany
   */
  export type FacilityCatalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FacilityCatalogs.
     */
    data: FacilityCatalogCreateManyInput | FacilityCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityCatalog createManyAndReturn
   */
  export type FacilityCatalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalog
     */
    select?: FacilityCatalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FacilityCatalogs.
     */
    data: FacilityCatalogCreateManyInput | FacilityCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FacilityCatalog update
   */
  export type FacilityCatalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalog
     */
    select?: FacilityCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityCatalogInclude<ExtArgs> | null
    /**
     * The data needed to update a FacilityCatalog.
     */
    data: XOR<FacilityCatalogUpdateInput, FacilityCatalogUncheckedUpdateInput>
    /**
     * Choose, which FacilityCatalog to update.
     */
    where: FacilityCatalogWhereUniqueInput
  }

  /**
   * FacilityCatalog updateMany
   */
  export type FacilityCatalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FacilityCatalogs.
     */
    data: XOR<FacilityCatalogUpdateManyMutationInput, FacilityCatalogUncheckedUpdateManyInput>
    /**
     * Filter which FacilityCatalogs to update
     */
    where?: FacilityCatalogWhereInput
  }

  /**
   * FacilityCatalog upsert
   */
  export type FacilityCatalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalog
     */
    select?: FacilityCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityCatalogInclude<ExtArgs> | null
    /**
     * The filter to search for the FacilityCatalog to update in case it exists.
     */
    where: FacilityCatalogWhereUniqueInput
    /**
     * In case the FacilityCatalog found by the `where` argument doesn't exist, create a new FacilityCatalog with this data.
     */
    create: XOR<FacilityCatalogCreateInput, FacilityCatalogUncheckedCreateInput>
    /**
     * In case the FacilityCatalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityCatalogUpdateInput, FacilityCatalogUncheckedUpdateInput>
  }

  /**
   * FacilityCatalog delete
   */
  export type FacilityCatalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalog
     */
    select?: FacilityCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityCatalogInclude<ExtArgs> | null
    /**
     * Filter which FacilityCatalog to delete.
     */
    where: FacilityCatalogWhereUniqueInput
  }

  /**
   * FacilityCatalog deleteMany
   */
  export type FacilityCatalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FacilityCatalogs to delete
     */
    where?: FacilityCatalogWhereInput
  }

  /**
   * FacilityCatalog.branchLinks
   */
  export type FacilityCatalog$branchLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
    where?: BranchFacilityWhereInput
    orderBy?: BranchFacilityOrderByWithRelationInput | BranchFacilityOrderByWithRelationInput[]
    cursor?: BranchFacilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchFacilityScalarFieldEnum | BranchFacilityScalarFieldEnum[]
  }

  /**
   * FacilityCatalog.departments
   */
  export type FacilityCatalog$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * FacilityCatalog without action
   */
  export type FacilityCatalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilityCatalog
     */
    select?: FacilityCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityCatalogInclude<ExtArgs> | null
  }


  /**
   * Model BranchFacility
   */

  export type AggregateBranchFacility = {
    _count: BranchFacilityCountAggregateOutputType | null
    _min: BranchFacilityMinAggregateOutputType | null
    _max: BranchFacilityMaxAggregateOutputType | null
  }

  export type BranchFacilityMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    facilityId: string | null
    isEnabled: boolean | null
    enabledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchFacilityMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    facilityId: string | null
    isEnabled: boolean | null
    enabledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchFacilityCountAggregateOutputType = {
    id: number
    branchId: number
    facilityId: number
    isEnabled: number
    enabledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchFacilityMinAggregateInputType = {
    id?: true
    branchId?: true
    facilityId?: true
    isEnabled?: true
    enabledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchFacilityMaxAggregateInputType = {
    id?: true
    branchId?: true
    facilityId?: true
    isEnabled?: true
    enabledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchFacilityCountAggregateInputType = {
    id?: true
    branchId?: true
    facilityId?: true
    isEnabled?: true
    enabledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchFacilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchFacility to aggregate.
     */
    where?: BranchFacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchFacilities to fetch.
     */
    orderBy?: BranchFacilityOrderByWithRelationInput | BranchFacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchFacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchFacilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchFacilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BranchFacilities
    **/
    _count?: true | BranchFacilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchFacilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchFacilityMaxAggregateInputType
  }

  export type GetBranchFacilityAggregateType<T extends BranchFacilityAggregateArgs> = {
        [P in keyof T & keyof AggregateBranchFacility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranchFacility[P]>
      : GetScalarType<T[P], AggregateBranchFacility[P]>
  }




  export type BranchFacilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchFacilityWhereInput
    orderBy?: BranchFacilityOrderByWithAggregationInput | BranchFacilityOrderByWithAggregationInput[]
    by: BranchFacilityScalarFieldEnum[] | BranchFacilityScalarFieldEnum
    having?: BranchFacilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchFacilityCountAggregateInputType | true
    _min?: BranchFacilityMinAggregateInputType
    _max?: BranchFacilityMaxAggregateInputType
  }

  export type BranchFacilityGroupByOutputType = {
    id: string
    branchId: string
    facilityId: string
    isEnabled: boolean
    enabledAt: Date
    createdAt: Date
    updatedAt: Date
    _count: BranchFacilityCountAggregateOutputType | null
    _min: BranchFacilityMinAggregateOutputType | null
    _max: BranchFacilityMaxAggregateOutputType | null
  }

  type GetBranchFacilityGroupByPayload<T extends BranchFacilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchFacilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchFacilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchFacilityGroupByOutputType[P]>
            : GetScalarType<T[P], BranchFacilityGroupByOutputType[P]>
        }
      >
    >


  export type BranchFacilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    facilityId?: boolean
    isEnabled?: boolean
    enabledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    facility?: boolean | FacilityCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchFacility"]>

  export type BranchFacilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    facilityId?: boolean
    isEnabled?: boolean
    enabledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    facility?: boolean | FacilityCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchFacility"]>

  export type BranchFacilitySelectScalar = {
    id?: boolean
    branchId?: boolean
    facilityId?: boolean
    isEnabled?: boolean
    enabledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchFacilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    facility?: boolean | FacilityCatalogDefaultArgs<ExtArgs>
  }
  export type BranchFacilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    facility?: boolean | FacilityCatalogDefaultArgs<ExtArgs>
  }

  export type $BranchFacilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BranchFacility"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      facility: Prisma.$FacilityCatalogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      facilityId: string
      isEnabled: boolean
      enabledAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branchFacility"]>
    composites: {}
  }

  type BranchFacilityGetPayload<S extends boolean | null | undefined | BranchFacilityDefaultArgs> = $Result.GetResult<Prisma.$BranchFacilityPayload, S>

  type BranchFacilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFacilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchFacilityCountAggregateInputType | true
    }

  export interface BranchFacilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BranchFacility'], meta: { name: 'BranchFacility' } }
    /**
     * Find zero or one BranchFacility that matches the filter.
     * @param {BranchFacilityFindUniqueArgs} args - Arguments to find a BranchFacility
     * @example
     * // Get one BranchFacility
     * const branchFacility = await prisma.branchFacility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFacilityFindUniqueArgs>(args: SelectSubset<T, BranchFacilityFindUniqueArgs<ExtArgs>>): Prisma__BranchFacilityClient<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BranchFacility that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchFacilityFindUniqueOrThrowArgs} args - Arguments to find a BranchFacility
     * @example
     * // Get one BranchFacility
     * const branchFacility = await prisma.branchFacility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFacilityFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFacilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchFacilityClient<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BranchFacility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFacilityFindFirstArgs} args - Arguments to find a BranchFacility
     * @example
     * // Get one BranchFacility
     * const branchFacility = await prisma.branchFacility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFacilityFindFirstArgs>(args?: SelectSubset<T, BranchFacilityFindFirstArgs<ExtArgs>>): Prisma__BranchFacilityClient<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BranchFacility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFacilityFindFirstOrThrowArgs} args - Arguments to find a BranchFacility
     * @example
     * // Get one BranchFacility
     * const branchFacility = await prisma.branchFacility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFacilityFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFacilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchFacilityClient<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BranchFacilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFacilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BranchFacilities
     * const branchFacilities = await prisma.branchFacility.findMany()
     * 
     * // Get first 10 BranchFacilities
     * const branchFacilities = await prisma.branchFacility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchFacilityWithIdOnly = await prisma.branchFacility.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFacilityFindManyArgs>(args?: SelectSubset<T, BranchFacilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BranchFacility.
     * @param {BranchFacilityCreateArgs} args - Arguments to create a BranchFacility.
     * @example
     * // Create one BranchFacility
     * const BranchFacility = await prisma.branchFacility.create({
     *   data: {
     *     // ... data to create a BranchFacility
     *   }
     * })
     * 
     */
    create<T extends BranchFacilityCreateArgs>(args: SelectSubset<T, BranchFacilityCreateArgs<ExtArgs>>): Prisma__BranchFacilityClient<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BranchFacilities.
     * @param {BranchFacilityCreateManyArgs} args - Arguments to create many BranchFacilities.
     * @example
     * // Create many BranchFacilities
     * const branchFacility = await prisma.branchFacility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchFacilityCreateManyArgs>(args?: SelectSubset<T, BranchFacilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BranchFacilities and returns the data saved in the database.
     * @param {BranchFacilityCreateManyAndReturnArgs} args - Arguments to create many BranchFacilities.
     * @example
     * // Create many BranchFacilities
     * const branchFacility = await prisma.branchFacility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BranchFacilities and only return the `id`
     * const branchFacilityWithIdOnly = await prisma.branchFacility.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchFacilityCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchFacilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BranchFacility.
     * @param {BranchFacilityDeleteArgs} args - Arguments to delete one BranchFacility.
     * @example
     * // Delete one BranchFacility
     * const BranchFacility = await prisma.branchFacility.delete({
     *   where: {
     *     // ... filter to delete one BranchFacility
     *   }
     * })
     * 
     */
    delete<T extends BranchFacilityDeleteArgs>(args: SelectSubset<T, BranchFacilityDeleteArgs<ExtArgs>>): Prisma__BranchFacilityClient<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BranchFacility.
     * @param {BranchFacilityUpdateArgs} args - Arguments to update one BranchFacility.
     * @example
     * // Update one BranchFacility
     * const branchFacility = await prisma.branchFacility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchFacilityUpdateArgs>(args: SelectSubset<T, BranchFacilityUpdateArgs<ExtArgs>>): Prisma__BranchFacilityClient<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BranchFacilities.
     * @param {BranchFacilityDeleteManyArgs} args - Arguments to filter BranchFacilities to delete.
     * @example
     * // Delete a few BranchFacilities
     * const { count } = await prisma.branchFacility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchFacilityDeleteManyArgs>(args?: SelectSubset<T, BranchFacilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BranchFacilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BranchFacilities
     * const branchFacility = await prisma.branchFacility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchFacilityUpdateManyArgs>(args: SelectSubset<T, BranchFacilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BranchFacility.
     * @param {BranchFacilityUpsertArgs} args - Arguments to update or create a BranchFacility.
     * @example
     * // Update or create a BranchFacility
     * const branchFacility = await prisma.branchFacility.upsert({
     *   create: {
     *     // ... data to create a BranchFacility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BranchFacility we want to update
     *   }
     * })
     */
    upsert<T extends BranchFacilityUpsertArgs>(args: SelectSubset<T, BranchFacilityUpsertArgs<ExtArgs>>): Prisma__BranchFacilityClient<$Result.GetResult<Prisma.$BranchFacilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BranchFacilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFacilityCountArgs} args - Arguments to filter BranchFacilities to count.
     * @example
     * // Count the number of BranchFacilities
     * const count = await prisma.branchFacility.count({
     *   where: {
     *     // ... the filter for the BranchFacilities we want to count
     *   }
     * })
    **/
    count<T extends BranchFacilityCountArgs>(
      args?: Subset<T, BranchFacilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchFacilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BranchFacility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchFacilityAggregateArgs>(args: Subset<T, BranchFacilityAggregateArgs>): Prisma.PrismaPromise<GetBranchFacilityAggregateType<T>>

    /**
     * Group by BranchFacility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchFacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchFacilityGroupByArgs['orderBy'] }
        : { orderBy?: BranchFacilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchFacilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchFacilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BranchFacility model
   */
  readonly fields: BranchFacilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BranchFacility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchFacilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    facility<T extends FacilityCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityCatalogDefaultArgs<ExtArgs>>): Prisma__FacilityCatalogClient<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BranchFacility model
   */ 
  interface BranchFacilityFieldRefs {
    readonly id: FieldRef<"BranchFacility", 'String'>
    readonly branchId: FieldRef<"BranchFacility", 'String'>
    readonly facilityId: FieldRef<"BranchFacility", 'String'>
    readonly isEnabled: FieldRef<"BranchFacility", 'Boolean'>
    readonly enabledAt: FieldRef<"BranchFacility", 'DateTime'>
    readonly createdAt: FieldRef<"BranchFacility", 'DateTime'>
    readonly updatedAt: FieldRef<"BranchFacility", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BranchFacility findUnique
   */
  export type BranchFacilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
    /**
     * Filter, which BranchFacility to fetch.
     */
    where: BranchFacilityWhereUniqueInput
  }

  /**
   * BranchFacility findUniqueOrThrow
   */
  export type BranchFacilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
    /**
     * Filter, which BranchFacility to fetch.
     */
    where: BranchFacilityWhereUniqueInput
  }

  /**
   * BranchFacility findFirst
   */
  export type BranchFacilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
    /**
     * Filter, which BranchFacility to fetch.
     */
    where?: BranchFacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchFacilities to fetch.
     */
    orderBy?: BranchFacilityOrderByWithRelationInput | BranchFacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchFacilities.
     */
    cursor?: BranchFacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchFacilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchFacilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchFacilities.
     */
    distinct?: BranchFacilityScalarFieldEnum | BranchFacilityScalarFieldEnum[]
  }

  /**
   * BranchFacility findFirstOrThrow
   */
  export type BranchFacilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
    /**
     * Filter, which BranchFacility to fetch.
     */
    where?: BranchFacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchFacilities to fetch.
     */
    orderBy?: BranchFacilityOrderByWithRelationInput | BranchFacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchFacilities.
     */
    cursor?: BranchFacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchFacilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchFacilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchFacilities.
     */
    distinct?: BranchFacilityScalarFieldEnum | BranchFacilityScalarFieldEnum[]
  }

  /**
   * BranchFacility findMany
   */
  export type BranchFacilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
    /**
     * Filter, which BranchFacilities to fetch.
     */
    where?: BranchFacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchFacilities to fetch.
     */
    orderBy?: BranchFacilityOrderByWithRelationInput | BranchFacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BranchFacilities.
     */
    cursor?: BranchFacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchFacilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchFacilities.
     */
    skip?: number
    distinct?: BranchFacilityScalarFieldEnum | BranchFacilityScalarFieldEnum[]
  }

  /**
   * BranchFacility create
   */
  export type BranchFacilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
    /**
     * The data needed to create a BranchFacility.
     */
    data: XOR<BranchFacilityCreateInput, BranchFacilityUncheckedCreateInput>
  }

  /**
   * BranchFacility createMany
   */
  export type BranchFacilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BranchFacilities.
     */
    data: BranchFacilityCreateManyInput | BranchFacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BranchFacility createManyAndReturn
   */
  export type BranchFacilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BranchFacilities.
     */
    data: BranchFacilityCreateManyInput | BranchFacilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BranchFacility update
   */
  export type BranchFacilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
    /**
     * The data needed to update a BranchFacility.
     */
    data: XOR<BranchFacilityUpdateInput, BranchFacilityUncheckedUpdateInput>
    /**
     * Choose, which BranchFacility to update.
     */
    where: BranchFacilityWhereUniqueInput
  }

  /**
   * BranchFacility updateMany
   */
  export type BranchFacilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BranchFacilities.
     */
    data: XOR<BranchFacilityUpdateManyMutationInput, BranchFacilityUncheckedUpdateManyInput>
    /**
     * Filter which BranchFacilities to update
     */
    where?: BranchFacilityWhereInput
  }

  /**
   * BranchFacility upsert
   */
  export type BranchFacilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
    /**
     * The filter to search for the BranchFacility to update in case it exists.
     */
    where: BranchFacilityWhereUniqueInput
    /**
     * In case the BranchFacility found by the `where` argument doesn't exist, create a new BranchFacility with this data.
     */
    create: XOR<BranchFacilityCreateInput, BranchFacilityUncheckedCreateInput>
    /**
     * In case the BranchFacility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchFacilityUpdateInput, BranchFacilityUncheckedUpdateInput>
  }

  /**
   * BranchFacility delete
   */
  export type BranchFacilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
    /**
     * Filter which BranchFacility to delete.
     */
    where: BranchFacilityWhereUniqueInput
  }

  /**
   * BranchFacility deleteMany
   */
  export type BranchFacilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchFacilities to delete
     */
    where?: BranchFacilityWhereInput
  }

  /**
   * BranchFacility without action
   */
  export type BranchFacilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchFacility
     */
    select?: BranchFacilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchFacilityInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    facilityId: string | null
    code: string | null
    name: string | null
    headStaffId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    facilityId: string | null
    code: string | null
    name: string | null
    headStaffId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    branchId: number
    facilityId: number
    code: number
    name: number
    headStaffId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    branchId?: true
    facilityId?: true
    code?: true
    name?: true
    headStaffId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    branchId?: true
    facilityId?: true
    code?: true
    name?: true
    headStaffId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    branchId?: true
    facilityId?: true
    code?: true
    name?: true
    headStaffId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    branchId: string
    facilityId: string
    code: string
    name: string
    headStaffId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    facilityId?: boolean
    code?: boolean
    name?: boolean
    headStaffId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    facility?: boolean | FacilityCatalogDefaultArgs<ExtArgs>
    headStaff?: boolean | Department$headStaffArgs<ExtArgs>
    staff?: boolean | Department$staffArgs<ExtArgs>
    departmentSpecialties?: boolean | Department$departmentSpecialtiesArgs<ExtArgs>
    doctorAssignments?: boolean | Department$doctorAssignmentsArgs<ExtArgs>
    units?: boolean | Department$unitsArgs<ExtArgs>
    equipmentOwned?: boolean | Department$equipmentOwnedArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    facilityId?: boolean
    code?: boolean
    name?: boolean
    headStaffId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    facility?: boolean | FacilityCatalogDefaultArgs<ExtArgs>
    headStaff?: boolean | Department$headStaffArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    branchId?: boolean
    facilityId?: boolean
    code?: boolean
    name?: boolean
    headStaffId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    facility?: boolean | FacilityCatalogDefaultArgs<ExtArgs>
    headStaff?: boolean | Department$headStaffArgs<ExtArgs>
    staff?: boolean | Department$staffArgs<ExtArgs>
    departmentSpecialties?: boolean | Department$departmentSpecialtiesArgs<ExtArgs>
    doctorAssignments?: boolean | Department$doctorAssignmentsArgs<ExtArgs>
    units?: boolean | Department$unitsArgs<ExtArgs>
    equipmentOwned?: boolean | Department$equipmentOwnedArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    facility?: boolean | FacilityCatalogDefaultArgs<ExtArgs>
    headStaff?: boolean | Department$headStaffArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      facility: Prisma.$FacilityCatalogPayload<ExtArgs>
      headStaff: Prisma.$StaffPayload<ExtArgs> | null
      staff: Prisma.$StaffPayload<ExtArgs>[]
      departmentSpecialties: Prisma.$DepartmentSpecialtyPayload<ExtArgs>[]
      doctorAssignments: Prisma.$DepartmentDoctorPayload<ExtArgs>[]
      units: Prisma.$UnitPayload<ExtArgs>[]
      equipmentOwned: Prisma.$EquipmentAssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      facilityId: string
      code: string
      name: string
      headStaffId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    facility<T extends FacilityCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilityCatalogDefaultArgs<ExtArgs>>): Prisma__FacilityCatalogClient<$Result.GetResult<Prisma.$FacilityCatalogPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    headStaff<T extends Department$headStaffArgs<ExtArgs> = {}>(args?: Subset<T, Department$headStaffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    staff<T extends Department$staffArgs<ExtArgs> = {}>(args?: Subset<T, Department$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany"> | Null>
    departmentSpecialties<T extends Department$departmentSpecialtiesArgs<ExtArgs> = {}>(args?: Subset<T, Department$departmentSpecialtiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "findMany"> | Null>
    doctorAssignments<T extends Department$doctorAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Department$doctorAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "findMany"> | Null>
    units<T extends Department$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Department$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany"> | Null>
    equipmentOwned<T extends Department$equipmentOwnedArgs<ExtArgs> = {}>(args?: Subset<T, Department$equipmentOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly branchId: FieldRef<"Department", 'String'>
    readonly facilityId: FieldRef<"Department", 'String'>
    readonly code: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly headStaffId: FieldRef<"Department", 'String'>
    readonly isActive: FieldRef<"Department", 'Boolean'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department.headStaff
   */
  export type Department$headStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * Department.staff
   */
  export type Department$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Department.departmentSpecialties
   */
  export type Department$departmentSpecialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
    where?: DepartmentSpecialtyWhereInput
    orderBy?: DepartmentSpecialtyOrderByWithRelationInput | DepartmentSpecialtyOrderByWithRelationInput[]
    cursor?: DepartmentSpecialtyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentSpecialtyScalarFieldEnum | DepartmentSpecialtyScalarFieldEnum[]
  }

  /**
   * Department.doctorAssignments
   */
  export type Department$doctorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
    where?: DepartmentDoctorWhereInput
    orderBy?: DepartmentDoctorOrderByWithRelationInput | DepartmentDoctorOrderByWithRelationInput[]
    cursor?: DepartmentDoctorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentDoctorScalarFieldEnum | DepartmentDoctorScalarFieldEnum[]
  }

  /**
   * Department.units
   */
  export type Department$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Department.equipmentOwned
   */
  export type Department$equipmentOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    where?: EquipmentAssetWhereInput
    orderBy?: EquipmentAssetOrderByWithRelationInput | EquipmentAssetOrderByWithRelationInput[]
    cursor?: EquipmentAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentAssetScalarFieldEnum | EquipmentAssetScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentDoctor
   */

  export type AggregateDepartmentDoctor = {
    _count: DepartmentDoctorCountAggregateOutputType | null
    _min: DepartmentDoctorMinAggregateOutputType | null
    _max: DepartmentDoctorMaxAggregateOutputType | null
  }

  export type DepartmentDoctorMinAggregateOutputType = {
    id: string | null
    departmentId: string | null
    staffId: string | null
    isPrimary: boolean | null
    assignedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentDoctorMaxAggregateOutputType = {
    id: string | null
    departmentId: string | null
    staffId: string | null
    isPrimary: boolean | null
    assignedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentDoctorCountAggregateOutputType = {
    id: number
    departmentId: number
    staffId: number
    isPrimary: number
    assignedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentDoctorMinAggregateInputType = {
    id?: true
    departmentId?: true
    staffId?: true
    isPrimary?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentDoctorMaxAggregateInputType = {
    id?: true
    departmentId?: true
    staffId?: true
    isPrimary?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentDoctorCountAggregateInputType = {
    id?: true
    departmentId?: true
    staffId?: true
    isPrimary?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentDoctorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentDoctor to aggregate.
     */
    where?: DepartmentDoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentDoctors to fetch.
     */
    orderBy?: DepartmentDoctorOrderByWithRelationInput | DepartmentDoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentDoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentDoctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentDoctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentDoctors
    **/
    _count?: true | DepartmentDoctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentDoctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentDoctorMaxAggregateInputType
  }

  export type GetDepartmentDoctorAggregateType<T extends DepartmentDoctorAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentDoctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentDoctor[P]>
      : GetScalarType<T[P], AggregateDepartmentDoctor[P]>
  }




  export type DepartmentDoctorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentDoctorWhereInput
    orderBy?: DepartmentDoctorOrderByWithAggregationInput | DepartmentDoctorOrderByWithAggregationInput[]
    by: DepartmentDoctorScalarFieldEnum[] | DepartmentDoctorScalarFieldEnum
    having?: DepartmentDoctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentDoctorCountAggregateInputType | true
    _min?: DepartmentDoctorMinAggregateInputType
    _max?: DepartmentDoctorMaxAggregateInputType
  }

  export type DepartmentDoctorGroupByOutputType = {
    id: string
    departmentId: string
    staffId: string
    isPrimary: boolean
    assignedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: DepartmentDoctorCountAggregateOutputType | null
    _min: DepartmentDoctorMinAggregateOutputType | null
    _max: DepartmentDoctorMaxAggregateOutputType | null
  }

  type GetDepartmentDoctorGroupByPayload<T extends DepartmentDoctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentDoctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentDoctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentDoctorGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentDoctorGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentDoctorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    staffId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentDoctor"]>

  export type DepartmentDoctorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    staffId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentDoctor"]>

  export type DepartmentDoctorSelectScalar = {
    id?: boolean
    departmentId?: boolean
    staffId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentDoctorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }
  export type DepartmentDoctorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    staff?: boolean | StaffDefaultArgs<ExtArgs>
  }

  export type $DepartmentDoctorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentDoctor"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      staff: Prisma.$StaffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      departmentId: string
      staffId: string
      isPrimary: boolean
      assignedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["departmentDoctor"]>
    composites: {}
  }

  type DepartmentDoctorGetPayload<S extends boolean | null | undefined | DepartmentDoctorDefaultArgs> = $Result.GetResult<Prisma.$DepartmentDoctorPayload, S>

  type DepartmentDoctorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentDoctorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentDoctorCountAggregateInputType | true
    }

  export interface DepartmentDoctorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentDoctor'], meta: { name: 'DepartmentDoctor' } }
    /**
     * Find zero or one DepartmentDoctor that matches the filter.
     * @param {DepartmentDoctorFindUniqueArgs} args - Arguments to find a DepartmentDoctor
     * @example
     * // Get one DepartmentDoctor
     * const departmentDoctor = await prisma.departmentDoctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentDoctorFindUniqueArgs>(args: SelectSubset<T, DepartmentDoctorFindUniqueArgs<ExtArgs>>): Prisma__DepartmentDoctorClient<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DepartmentDoctor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentDoctorFindUniqueOrThrowArgs} args - Arguments to find a DepartmentDoctor
     * @example
     * // Get one DepartmentDoctor
     * const departmentDoctor = await prisma.departmentDoctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentDoctorFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentDoctorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentDoctorClient<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DepartmentDoctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDoctorFindFirstArgs} args - Arguments to find a DepartmentDoctor
     * @example
     * // Get one DepartmentDoctor
     * const departmentDoctor = await prisma.departmentDoctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentDoctorFindFirstArgs>(args?: SelectSubset<T, DepartmentDoctorFindFirstArgs<ExtArgs>>): Prisma__DepartmentDoctorClient<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DepartmentDoctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDoctorFindFirstOrThrowArgs} args - Arguments to find a DepartmentDoctor
     * @example
     * // Get one DepartmentDoctor
     * const departmentDoctor = await prisma.departmentDoctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentDoctorFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentDoctorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentDoctorClient<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DepartmentDoctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDoctorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentDoctors
     * const departmentDoctors = await prisma.departmentDoctor.findMany()
     * 
     * // Get first 10 DepartmentDoctors
     * const departmentDoctors = await prisma.departmentDoctor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentDoctorWithIdOnly = await prisma.departmentDoctor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentDoctorFindManyArgs>(args?: SelectSubset<T, DepartmentDoctorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DepartmentDoctor.
     * @param {DepartmentDoctorCreateArgs} args - Arguments to create a DepartmentDoctor.
     * @example
     * // Create one DepartmentDoctor
     * const DepartmentDoctor = await prisma.departmentDoctor.create({
     *   data: {
     *     // ... data to create a DepartmentDoctor
     *   }
     * })
     * 
     */
    create<T extends DepartmentDoctorCreateArgs>(args: SelectSubset<T, DepartmentDoctorCreateArgs<ExtArgs>>): Prisma__DepartmentDoctorClient<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DepartmentDoctors.
     * @param {DepartmentDoctorCreateManyArgs} args - Arguments to create many DepartmentDoctors.
     * @example
     * // Create many DepartmentDoctors
     * const departmentDoctor = await prisma.departmentDoctor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentDoctorCreateManyArgs>(args?: SelectSubset<T, DepartmentDoctorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepartmentDoctors and returns the data saved in the database.
     * @param {DepartmentDoctorCreateManyAndReturnArgs} args - Arguments to create many DepartmentDoctors.
     * @example
     * // Create many DepartmentDoctors
     * const departmentDoctor = await prisma.departmentDoctor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepartmentDoctors and only return the `id`
     * const departmentDoctorWithIdOnly = await prisma.departmentDoctor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentDoctorCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentDoctorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DepartmentDoctor.
     * @param {DepartmentDoctorDeleteArgs} args - Arguments to delete one DepartmentDoctor.
     * @example
     * // Delete one DepartmentDoctor
     * const DepartmentDoctor = await prisma.departmentDoctor.delete({
     *   where: {
     *     // ... filter to delete one DepartmentDoctor
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDoctorDeleteArgs>(args: SelectSubset<T, DepartmentDoctorDeleteArgs<ExtArgs>>): Prisma__DepartmentDoctorClient<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DepartmentDoctor.
     * @param {DepartmentDoctorUpdateArgs} args - Arguments to update one DepartmentDoctor.
     * @example
     * // Update one DepartmentDoctor
     * const departmentDoctor = await prisma.departmentDoctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentDoctorUpdateArgs>(args: SelectSubset<T, DepartmentDoctorUpdateArgs<ExtArgs>>): Prisma__DepartmentDoctorClient<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DepartmentDoctors.
     * @param {DepartmentDoctorDeleteManyArgs} args - Arguments to filter DepartmentDoctors to delete.
     * @example
     * // Delete a few DepartmentDoctors
     * const { count } = await prisma.departmentDoctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDoctorDeleteManyArgs>(args?: SelectSubset<T, DepartmentDoctorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentDoctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDoctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentDoctors
     * const departmentDoctor = await prisma.departmentDoctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentDoctorUpdateManyArgs>(args: SelectSubset<T, DepartmentDoctorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DepartmentDoctor.
     * @param {DepartmentDoctorUpsertArgs} args - Arguments to update or create a DepartmentDoctor.
     * @example
     * // Update or create a DepartmentDoctor
     * const departmentDoctor = await prisma.departmentDoctor.upsert({
     *   create: {
     *     // ... data to create a DepartmentDoctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentDoctor we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentDoctorUpsertArgs>(args: SelectSubset<T, DepartmentDoctorUpsertArgs<ExtArgs>>): Prisma__DepartmentDoctorClient<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DepartmentDoctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDoctorCountArgs} args - Arguments to filter DepartmentDoctors to count.
     * @example
     * // Count the number of DepartmentDoctors
     * const count = await prisma.departmentDoctor.count({
     *   where: {
     *     // ... the filter for the DepartmentDoctors we want to count
     *   }
     * })
    **/
    count<T extends DepartmentDoctorCountArgs>(
      args?: Subset<T, DepartmentDoctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentDoctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentDoctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentDoctorAggregateArgs>(args: Subset<T, DepartmentDoctorAggregateArgs>): Prisma.PrismaPromise<GetDepartmentDoctorAggregateType<T>>

    /**
     * Group by DepartmentDoctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentDoctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentDoctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentDoctorGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentDoctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentDoctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentDoctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentDoctor model
   */
  readonly fields: DepartmentDoctorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentDoctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentDoctorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    staff<T extends StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffDefaultArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentDoctor model
   */ 
  interface DepartmentDoctorFieldRefs {
    readonly id: FieldRef<"DepartmentDoctor", 'String'>
    readonly departmentId: FieldRef<"DepartmentDoctor", 'String'>
    readonly staffId: FieldRef<"DepartmentDoctor", 'String'>
    readonly isPrimary: FieldRef<"DepartmentDoctor", 'Boolean'>
    readonly assignedAt: FieldRef<"DepartmentDoctor", 'DateTime'>
    readonly createdAt: FieldRef<"DepartmentDoctor", 'DateTime'>
    readonly updatedAt: FieldRef<"DepartmentDoctor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentDoctor findUnique
   */
  export type DepartmentDoctorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentDoctor to fetch.
     */
    where: DepartmentDoctorWhereUniqueInput
  }

  /**
   * DepartmentDoctor findUniqueOrThrow
   */
  export type DepartmentDoctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentDoctor to fetch.
     */
    where: DepartmentDoctorWhereUniqueInput
  }

  /**
   * DepartmentDoctor findFirst
   */
  export type DepartmentDoctorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentDoctor to fetch.
     */
    where?: DepartmentDoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentDoctors to fetch.
     */
    orderBy?: DepartmentDoctorOrderByWithRelationInput | DepartmentDoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentDoctors.
     */
    cursor?: DepartmentDoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentDoctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentDoctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentDoctors.
     */
    distinct?: DepartmentDoctorScalarFieldEnum | DepartmentDoctorScalarFieldEnum[]
  }

  /**
   * DepartmentDoctor findFirstOrThrow
   */
  export type DepartmentDoctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentDoctor to fetch.
     */
    where?: DepartmentDoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentDoctors to fetch.
     */
    orderBy?: DepartmentDoctorOrderByWithRelationInput | DepartmentDoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentDoctors.
     */
    cursor?: DepartmentDoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentDoctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentDoctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentDoctors.
     */
    distinct?: DepartmentDoctorScalarFieldEnum | DepartmentDoctorScalarFieldEnum[]
  }

  /**
   * DepartmentDoctor findMany
   */
  export type DepartmentDoctorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentDoctors to fetch.
     */
    where?: DepartmentDoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentDoctors to fetch.
     */
    orderBy?: DepartmentDoctorOrderByWithRelationInput | DepartmentDoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentDoctors.
     */
    cursor?: DepartmentDoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentDoctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentDoctors.
     */
    skip?: number
    distinct?: DepartmentDoctorScalarFieldEnum | DepartmentDoctorScalarFieldEnum[]
  }

  /**
   * DepartmentDoctor create
   */
  export type DepartmentDoctorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentDoctor.
     */
    data: XOR<DepartmentDoctorCreateInput, DepartmentDoctorUncheckedCreateInput>
  }

  /**
   * DepartmentDoctor createMany
   */
  export type DepartmentDoctorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentDoctors.
     */
    data: DepartmentDoctorCreateManyInput | DepartmentDoctorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentDoctor createManyAndReturn
   */
  export type DepartmentDoctorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DepartmentDoctors.
     */
    data: DepartmentDoctorCreateManyInput | DepartmentDoctorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentDoctor update
   */
  export type DepartmentDoctorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentDoctor.
     */
    data: XOR<DepartmentDoctorUpdateInput, DepartmentDoctorUncheckedUpdateInput>
    /**
     * Choose, which DepartmentDoctor to update.
     */
    where: DepartmentDoctorWhereUniqueInput
  }

  /**
   * DepartmentDoctor updateMany
   */
  export type DepartmentDoctorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentDoctors.
     */
    data: XOR<DepartmentDoctorUpdateManyMutationInput, DepartmentDoctorUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentDoctors to update
     */
    where?: DepartmentDoctorWhereInput
  }

  /**
   * DepartmentDoctor upsert
   */
  export type DepartmentDoctorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentDoctor to update in case it exists.
     */
    where: DepartmentDoctorWhereUniqueInput
    /**
     * In case the DepartmentDoctor found by the `where` argument doesn't exist, create a new DepartmentDoctor with this data.
     */
    create: XOR<DepartmentDoctorCreateInput, DepartmentDoctorUncheckedCreateInput>
    /**
     * In case the DepartmentDoctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentDoctorUpdateInput, DepartmentDoctorUncheckedUpdateInput>
  }

  /**
   * DepartmentDoctor delete
   */
  export type DepartmentDoctorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
    /**
     * Filter which DepartmentDoctor to delete.
     */
    where: DepartmentDoctorWhereUniqueInput
  }

  /**
   * DepartmentDoctor deleteMany
   */
  export type DepartmentDoctorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentDoctors to delete
     */
    where?: DepartmentDoctorWhereInput
  }

  /**
   * DepartmentDoctor without action
   */
  export type DepartmentDoctorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
  }


  /**
   * Model Specialty
   */

  export type AggregateSpecialty = {
    _count: SpecialtyCountAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  export type SpecialtyMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialtyMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialtyCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpecialtyMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialtyMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialtyCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpecialtyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialty to aggregate.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Specialties
    **/
    _count?: true | SpecialtyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialtyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialtyMaxAggregateInputType
  }

  export type GetSpecialtyAggregateType<T extends SpecialtyAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialty[P]>
      : GetScalarType<T[P], AggregateSpecialty[P]>
  }




  export type SpecialtyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialtyWhereInput
    orderBy?: SpecialtyOrderByWithAggregationInput | SpecialtyOrderByWithAggregationInput[]
    by: SpecialtyScalarFieldEnum[] | SpecialtyScalarFieldEnum
    having?: SpecialtyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialtyCountAggregateInputType | true
    _min?: SpecialtyMinAggregateInputType
    _max?: SpecialtyMaxAggregateInputType
  }

  export type SpecialtyGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SpecialtyCountAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  type GetSpecialtyGroupByPayload<T extends SpecialtyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialtyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialtyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
        }
      >
    >


  export type SpecialtySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    staff?: boolean | Specialty$staffArgs<ExtArgs>
    departmentLinks?: boolean | Specialty$departmentLinksArgs<ExtArgs>
    _count?: boolean | SpecialtyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpecialtyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    staff?: boolean | Specialty$staffArgs<ExtArgs>
    departmentLinks?: boolean | Specialty$departmentLinksArgs<ExtArgs>
    _count?: boolean | SpecialtyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpecialtyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $SpecialtyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Specialty"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      staff: Prisma.$StaffPayload<ExtArgs>[]
      departmentLinks: Prisma.$DepartmentSpecialtyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["specialty"]>
    composites: {}
  }

  type SpecialtyGetPayload<S extends boolean | null | undefined | SpecialtyDefaultArgs> = $Result.GetResult<Prisma.$SpecialtyPayload, S>

  type SpecialtyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpecialtyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpecialtyCountAggregateInputType | true
    }

  export interface SpecialtyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Specialty'], meta: { name: 'Specialty' } }
    /**
     * Find zero or one Specialty that matches the filter.
     * @param {SpecialtyFindUniqueArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecialtyFindUniqueArgs>(args: SelectSubset<T, SpecialtyFindUniqueArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Specialty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpecialtyFindUniqueOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecialtyFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecialtyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Specialty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecialtyFindFirstArgs>(args?: SelectSubset<T, SpecialtyFindFirstArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Specialty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecialtyFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecialtyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Specialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specialties
     * const specialties = await prisma.specialty.findMany()
     * 
     * // Get first 10 Specialties
     * const specialties = await prisma.specialty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialtyWithIdOnly = await prisma.specialty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecialtyFindManyArgs>(args?: SelectSubset<T, SpecialtyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Specialty.
     * @param {SpecialtyCreateArgs} args - Arguments to create a Specialty.
     * @example
     * // Create one Specialty
     * const Specialty = await prisma.specialty.create({
     *   data: {
     *     // ... data to create a Specialty
     *   }
     * })
     * 
     */
    create<T extends SpecialtyCreateArgs>(args: SelectSubset<T, SpecialtyCreateArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Specialties.
     * @param {SpecialtyCreateManyArgs} args - Arguments to create many Specialties.
     * @example
     * // Create many Specialties
     * const specialty = await prisma.specialty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecialtyCreateManyArgs>(args?: SelectSubset<T, SpecialtyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Specialties and returns the data saved in the database.
     * @param {SpecialtyCreateManyAndReturnArgs} args - Arguments to create many Specialties.
     * @example
     * // Create many Specialties
     * const specialty = await prisma.specialty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Specialties and only return the `id`
     * const specialtyWithIdOnly = await prisma.specialty.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecialtyCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecialtyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Specialty.
     * @param {SpecialtyDeleteArgs} args - Arguments to delete one Specialty.
     * @example
     * // Delete one Specialty
     * const Specialty = await prisma.specialty.delete({
     *   where: {
     *     // ... filter to delete one Specialty
     *   }
     * })
     * 
     */
    delete<T extends SpecialtyDeleteArgs>(args: SelectSubset<T, SpecialtyDeleteArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Specialty.
     * @param {SpecialtyUpdateArgs} args - Arguments to update one Specialty.
     * @example
     * // Update one Specialty
     * const specialty = await prisma.specialty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecialtyUpdateArgs>(args: SelectSubset<T, SpecialtyUpdateArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Specialties.
     * @param {SpecialtyDeleteManyArgs} args - Arguments to filter Specialties to delete.
     * @example
     * // Delete a few Specialties
     * const { count } = await prisma.specialty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecialtyDeleteManyArgs>(args?: SelectSubset<T, SpecialtyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specialties
     * const specialty = await prisma.specialty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecialtyUpdateManyArgs>(args: SelectSubset<T, SpecialtyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Specialty.
     * @param {SpecialtyUpsertArgs} args - Arguments to update or create a Specialty.
     * @example
     * // Update or create a Specialty
     * const specialty = await prisma.specialty.upsert({
     *   create: {
     *     // ... data to create a Specialty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specialty we want to update
     *   }
     * })
     */
    upsert<T extends SpecialtyUpsertArgs>(args: SelectSubset<T, SpecialtyUpsertArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyCountArgs} args - Arguments to filter Specialties to count.
     * @example
     * // Count the number of Specialties
     * const count = await prisma.specialty.count({
     *   where: {
     *     // ... the filter for the Specialties we want to count
     *   }
     * })
    **/
    count<T extends SpecialtyCountArgs>(
      args?: Subset<T, SpecialtyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialtyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialtyAggregateArgs>(args: Subset<T, SpecialtyAggregateArgs>): Prisma.PrismaPromise<GetSpecialtyAggregateType<T>>

    /**
     * Group by Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialtyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialtyGroupByArgs['orderBy'] }
        : { orderBy?: SpecialtyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialtyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialtyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Specialty model
   */
  readonly fields: SpecialtyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Specialty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialtyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    staff<T extends Specialty$staffArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany"> | Null>
    departmentLinks<T extends Specialty$departmentLinksArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$departmentLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Specialty model
   */ 
  interface SpecialtyFieldRefs {
    readonly id: FieldRef<"Specialty", 'String'>
    readonly branchId: FieldRef<"Specialty", 'String'>
    readonly code: FieldRef<"Specialty", 'String'>
    readonly name: FieldRef<"Specialty", 'String'>
    readonly isActive: FieldRef<"Specialty", 'Boolean'>
    readonly createdAt: FieldRef<"Specialty", 'DateTime'>
    readonly updatedAt: FieldRef<"Specialty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Specialty findUnique
   */
  export type SpecialtyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty findUniqueOrThrow
   */
  export type SpecialtyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty findFirst
   */
  export type SpecialtyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty findFirstOrThrow
   */
  export type SpecialtyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty findMany
   */
  export type SpecialtyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialties to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty create
   */
  export type SpecialtyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to create a Specialty.
     */
    data: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
  }

  /**
   * Specialty createMany
   */
  export type SpecialtyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Specialties.
     */
    data: SpecialtyCreateManyInput | SpecialtyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Specialty createManyAndReturn
   */
  export type SpecialtyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Specialties.
     */
    data: SpecialtyCreateManyInput | SpecialtyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Specialty update
   */
  export type SpecialtyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to update a Specialty.
     */
    data: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
    /**
     * Choose, which Specialty to update.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty updateMany
   */
  export type SpecialtyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Specialties.
     */
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which Specialties to update
     */
    where?: SpecialtyWhereInput
  }

  /**
   * Specialty upsert
   */
  export type SpecialtyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The filter to search for the Specialty to update in case it exists.
     */
    where: SpecialtyWhereUniqueInput
    /**
     * In case the Specialty found by the `where` argument doesn't exist, create a new Specialty with this data.
     */
    create: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
    /**
     * In case the Specialty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
  }

  /**
   * Specialty delete
   */
  export type SpecialtyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter which Specialty to delete.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty deleteMany
   */
  export type SpecialtyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialties to delete
     */
    where?: SpecialtyWhereInput
  }

  /**
   * Specialty.staff
   */
  export type Specialty$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Specialty.departmentLinks
   */
  export type Specialty$departmentLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
    where?: DepartmentSpecialtyWhereInput
    orderBy?: DepartmentSpecialtyOrderByWithRelationInput | DepartmentSpecialtyOrderByWithRelationInput[]
    cursor?: DepartmentSpecialtyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentSpecialtyScalarFieldEnum | DepartmentSpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty without action
   */
  export type SpecialtyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
  }


  /**
   * Model DepartmentSpecialty
   */

  export type AggregateDepartmentSpecialty = {
    _count: DepartmentSpecialtyCountAggregateOutputType | null
    _min: DepartmentSpecialtyMinAggregateOutputType | null
    _max: DepartmentSpecialtyMaxAggregateOutputType | null
  }

  export type DepartmentSpecialtyMinAggregateOutputType = {
    id: string | null
    departmentId: string | null
    specialtyId: string | null
    isPrimary: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentSpecialtyMaxAggregateOutputType = {
    id: string | null
    departmentId: string | null
    specialtyId: string | null
    isPrimary: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentSpecialtyCountAggregateOutputType = {
    id: number
    departmentId: number
    specialtyId: number
    isPrimary: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentSpecialtyMinAggregateInputType = {
    id?: true
    departmentId?: true
    specialtyId?: true
    isPrimary?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentSpecialtyMaxAggregateInputType = {
    id?: true
    departmentId?: true
    specialtyId?: true
    isPrimary?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentSpecialtyCountAggregateInputType = {
    id?: true
    departmentId?: true
    specialtyId?: true
    isPrimary?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentSpecialtyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentSpecialty to aggregate.
     */
    where?: DepartmentSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSpecialties to fetch.
     */
    orderBy?: DepartmentSpecialtyOrderByWithRelationInput | DepartmentSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepartmentSpecialties
    **/
    _count?: true | DepartmentSpecialtyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentSpecialtyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentSpecialtyMaxAggregateInputType
  }

  export type GetDepartmentSpecialtyAggregateType<T extends DepartmentSpecialtyAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartmentSpecialty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartmentSpecialty[P]>
      : GetScalarType<T[P], AggregateDepartmentSpecialty[P]>
  }




  export type DepartmentSpecialtyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentSpecialtyWhereInput
    orderBy?: DepartmentSpecialtyOrderByWithAggregationInput | DepartmentSpecialtyOrderByWithAggregationInput[]
    by: DepartmentSpecialtyScalarFieldEnum[] | DepartmentSpecialtyScalarFieldEnum
    having?: DepartmentSpecialtyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentSpecialtyCountAggregateInputType | true
    _min?: DepartmentSpecialtyMinAggregateInputType
    _max?: DepartmentSpecialtyMaxAggregateInputType
  }

  export type DepartmentSpecialtyGroupByOutputType = {
    id: string
    departmentId: string
    specialtyId: string
    isPrimary: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DepartmentSpecialtyCountAggregateOutputType | null
    _min: DepartmentSpecialtyMinAggregateOutputType | null
    _max: DepartmentSpecialtyMaxAggregateOutputType | null
  }

  type GetDepartmentSpecialtyGroupByPayload<T extends DepartmentSpecialtyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentSpecialtyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentSpecialtyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentSpecialtyGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentSpecialtyGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSpecialtySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    specialtyId?: boolean
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentSpecialty"]>

  export type DepartmentSpecialtySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    specialtyId?: boolean
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departmentSpecialty"]>

  export type DepartmentSpecialtySelectScalar = {
    id?: boolean
    departmentId?: boolean
    specialtyId?: boolean
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentSpecialtyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }
  export type DepartmentSpecialtyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }

  export type $DepartmentSpecialtyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepartmentSpecialty"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      specialty: Prisma.$SpecialtyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      departmentId: string
      specialtyId: string
      isPrimary: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["departmentSpecialty"]>
    composites: {}
  }

  type DepartmentSpecialtyGetPayload<S extends boolean | null | undefined | DepartmentSpecialtyDefaultArgs> = $Result.GetResult<Prisma.$DepartmentSpecialtyPayload, S>

  type DepartmentSpecialtyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentSpecialtyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentSpecialtyCountAggregateInputType | true
    }

  export interface DepartmentSpecialtyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepartmentSpecialty'], meta: { name: 'DepartmentSpecialty' } }
    /**
     * Find zero or one DepartmentSpecialty that matches the filter.
     * @param {DepartmentSpecialtyFindUniqueArgs} args - Arguments to find a DepartmentSpecialty
     * @example
     * // Get one DepartmentSpecialty
     * const departmentSpecialty = await prisma.departmentSpecialty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentSpecialtyFindUniqueArgs>(args: SelectSubset<T, DepartmentSpecialtyFindUniqueArgs<ExtArgs>>): Prisma__DepartmentSpecialtyClient<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DepartmentSpecialty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentSpecialtyFindUniqueOrThrowArgs} args - Arguments to find a DepartmentSpecialty
     * @example
     * // Get one DepartmentSpecialty
     * const departmentSpecialty = await prisma.departmentSpecialty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentSpecialtyFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentSpecialtyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentSpecialtyClient<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DepartmentSpecialty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSpecialtyFindFirstArgs} args - Arguments to find a DepartmentSpecialty
     * @example
     * // Get one DepartmentSpecialty
     * const departmentSpecialty = await prisma.departmentSpecialty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentSpecialtyFindFirstArgs>(args?: SelectSubset<T, DepartmentSpecialtyFindFirstArgs<ExtArgs>>): Prisma__DepartmentSpecialtyClient<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DepartmentSpecialty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSpecialtyFindFirstOrThrowArgs} args - Arguments to find a DepartmentSpecialty
     * @example
     * // Get one DepartmentSpecialty
     * const departmentSpecialty = await prisma.departmentSpecialty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentSpecialtyFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentSpecialtyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentSpecialtyClient<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DepartmentSpecialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSpecialtyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepartmentSpecialties
     * const departmentSpecialties = await prisma.departmentSpecialty.findMany()
     * 
     * // Get first 10 DepartmentSpecialties
     * const departmentSpecialties = await prisma.departmentSpecialty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentSpecialtyWithIdOnly = await prisma.departmentSpecialty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentSpecialtyFindManyArgs>(args?: SelectSubset<T, DepartmentSpecialtyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DepartmentSpecialty.
     * @param {DepartmentSpecialtyCreateArgs} args - Arguments to create a DepartmentSpecialty.
     * @example
     * // Create one DepartmentSpecialty
     * const DepartmentSpecialty = await prisma.departmentSpecialty.create({
     *   data: {
     *     // ... data to create a DepartmentSpecialty
     *   }
     * })
     * 
     */
    create<T extends DepartmentSpecialtyCreateArgs>(args: SelectSubset<T, DepartmentSpecialtyCreateArgs<ExtArgs>>): Prisma__DepartmentSpecialtyClient<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DepartmentSpecialties.
     * @param {DepartmentSpecialtyCreateManyArgs} args - Arguments to create many DepartmentSpecialties.
     * @example
     * // Create many DepartmentSpecialties
     * const departmentSpecialty = await prisma.departmentSpecialty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentSpecialtyCreateManyArgs>(args?: SelectSubset<T, DepartmentSpecialtyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepartmentSpecialties and returns the data saved in the database.
     * @param {DepartmentSpecialtyCreateManyAndReturnArgs} args - Arguments to create many DepartmentSpecialties.
     * @example
     * // Create many DepartmentSpecialties
     * const departmentSpecialty = await prisma.departmentSpecialty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepartmentSpecialties and only return the `id`
     * const departmentSpecialtyWithIdOnly = await prisma.departmentSpecialty.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentSpecialtyCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentSpecialtyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DepartmentSpecialty.
     * @param {DepartmentSpecialtyDeleteArgs} args - Arguments to delete one DepartmentSpecialty.
     * @example
     * // Delete one DepartmentSpecialty
     * const DepartmentSpecialty = await prisma.departmentSpecialty.delete({
     *   where: {
     *     // ... filter to delete one DepartmentSpecialty
     *   }
     * })
     * 
     */
    delete<T extends DepartmentSpecialtyDeleteArgs>(args: SelectSubset<T, DepartmentSpecialtyDeleteArgs<ExtArgs>>): Prisma__DepartmentSpecialtyClient<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DepartmentSpecialty.
     * @param {DepartmentSpecialtyUpdateArgs} args - Arguments to update one DepartmentSpecialty.
     * @example
     * // Update one DepartmentSpecialty
     * const departmentSpecialty = await prisma.departmentSpecialty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentSpecialtyUpdateArgs>(args: SelectSubset<T, DepartmentSpecialtyUpdateArgs<ExtArgs>>): Prisma__DepartmentSpecialtyClient<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DepartmentSpecialties.
     * @param {DepartmentSpecialtyDeleteManyArgs} args - Arguments to filter DepartmentSpecialties to delete.
     * @example
     * // Delete a few DepartmentSpecialties
     * const { count } = await prisma.departmentSpecialty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentSpecialtyDeleteManyArgs>(args?: SelectSubset<T, DepartmentSpecialtyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepartmentSpecialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSpecialtyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepartmentSpecialties
     * const departmentSpecialty = await prisma.departmentSpecialty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentSpecialtyUpdateManyArgs>(args: SelectSubset<T, DepartmentSpecialtyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DepartmentSpecialty.
     * @param {DepartmentSpecialtyUpsertArgs} args - Arguments to update or create a DepartmentSpecialty.
     * @example
     * // Update or create a DepartmentSpecialty
     * const departmentSpecialty = await prisma.departmentSpecialty.upsert({
     *   create: {
     *     // ... data to create a DepartmentSpecialty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepartmentSpecialty we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentSpecialtyUpsertArgs>(args: SelectSubset<T, DepartmentSpecialtyUpsertArgs<ExtArgs>>): Prisma__DepartmentSpecialtyClient<$Result.GetResult<Prisma.$DepartmentSpecialtyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DepartmentSpecialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSpecialtyCountArgs} args - Arguments to filter DepartmentSpecialties to count.
     * @example
     * // Count the number of DepartmentSpecialties
     * const count = await prisma.departmentSpecialty.count({
     *   where: {
     *     // ... the filter for the DepartmentSpecialties we want to count
     *   }
     * })
    **/
    count<T extends DepartmentSpecialtyCountArgs>(
      args?: Subset<T, DepartmentSpecialtyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentSpecialtyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepartmentSpecialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSpecialtyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentSpecialtyAggregateArgs>(args: Subset<T, DepartmentSpecialtyAggregateArgs>): Prisma.PrismaPromise<GetDepartmentSpecialtyAggregateType<T>>

    /**
     * Group by DepartmentSpecialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentSpecialtyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentSpecialtyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentSpecialtyGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentSpecialtyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentSpecialtyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentSpecialtyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepartmentSpecialty model
   */
  readonly fields: DepartmentSpecialtyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepartmentSpecialty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentSpecialtyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    specialty<T extends SpecialtyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyDefaultArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepartmentSpecialty model
   */ 
  interface DepartmentSpecialtyFieldRefs {
    readonly id: FieldRef<"DepartmentSpecialty", 'String'>
    readonly departmentId: FieldRef<"DepartmentSpecialty", 'String'>
    readonly specialtyId: FieldRef<"DepartmentSpecialty", 'String'>
    readonly isPrimary: FieldRef<"DepartmentSpecialty", 'Boolean'>
    readonly isActive: FieldRef<"DepartmentSpecialty", 'Boolean'>
    readonly createdAt: FieldRef<"DepartmentSpecialty", 'DateTime'>
    readonly updatedAt: FieldRef<"DepartmentSpecialty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepartmentSpecialty findUnique
   */
  export type DepartmentSpecialtyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSpecialty to fetch.
     */
    where: DepartmentSpecialtyWhereUniqueInput
  }

  /**
   * DepartmentSpecialty findUniqueOrThrow
   */
  export type DepartmentSpecialtyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSpecialty to fetch.
     */
    where: DepartmentSpecialtyWhereUniqueInput
  }

  /**
   * DepartmentSpecialty findFirst
   */
  export type DepartmentSpecialtyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSpecialty to fetch.
     */
    where?: DepartmentSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSpecialties to fetch.
     */
    orderBy?: DepartmentSpecialtyOrderByWithRelationInput | DepartmentSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentSpecialties.
     */
    cursor?: DepartmentSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentSpecialties.
     */
    distinct?: DepartmentSpecialtyScalarFieldEnum | DepartmentSpecialtyScalarFieldEnum[]
  }

  /**
   * DepartmentSpecialty findFirstOrThrow
   */
  export type DepartmentSpecialtyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSpecialty to fetch.
     */
    where?: DepartmentSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSpecialties to fetch.
     */
    orderBy?: DepartmentSpecialtyOrderByWithRelationInput | DepartmentSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepartmentSpecialties.
     */
    cursor?: DepartmentSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepartmentSpecialties.
     */
    distinct?: DepartmentSpecialtyScalarFieldEnum | DepartmentSpecialtyScalarFieldEnum[]
  }

  /**
   * DepartmentSpecialty findMany
   */
  export type DepartmentSpecialtyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which DepartmentSpecialties to fetch.
     */
    where?: DepartmentSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepartmentSpecialties to fetch.
     */
    orderBy?: DepartmentSpecialtyOrderByWithRelationInput | DepartmentSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepartmentSpecialties.
     */
    cursor?: DepartmentSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepartmentSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepartmentSpecialties.
     */
    skip?: number
    distinct?: DepartmentSpecialtyScalarFieldEnum | DepartmentSpecialtyScalarFieldEnum[]
  }

  /**
   * DepartmentSpecialty create
   */
  export type DepartmentSpecialtyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to create a DepartmentSpecialty.
     */
    data: XOR<DepartmentSpecialtyCreateInput, DepartmentSpecialtyUncheckedCreateInput>
  }

  /**
   * DepartmentSpecialty createMany
   */
  export type DepartmentSpecialtyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepartmentSpecialties.
     */
    data: DepartmentSpecialtyCreateManyInput | DepartmentSpecialtyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepartmentSpecialty createManyAndReturn
   */
  export type DepartmentSpecialtyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DepartmentSpecialties.
     */
    data: DepartmentSpecialtyCreateManyInput | DepartmentSpecialtyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DepartmentSpecialty update
   */
  export type DepartmentSpecialtyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to update a DepartmentSpecialty.
     */
    data: XOR<DepartmentSpecialtyUpdateInput, DepartmentSpecialtyUncheckedUpdateInput>
    /**
     * Choose, which DepartmentSpecialty to update.
     */
    where: DepartmentSpecialtyWhereUniqueInput
  }

  /**
   * DepartmentSpecialty updateMany
   */
  export type DepartmentSpecialtyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepartmentSpecialties.
     */
    data: XOR<DepartmentSpecialtyUpdateManyMutationInput, DepartmentSpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which DepartmentSpecialties to update
     */
    where?: DepartmentSpecialtyWhereInput
  }

  /**
   * DepartmentSpecialty upsert
   */
  export type DepartmentSpecialtyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
    /**
     * The filter to search for the DepartmentSpecialty to update in case it exists.
     */
    where: DepartmentSpecialtyWhereUniqueInput
    /**
     * In case the DepartmentSpecialty found by the `where` argument doesn't exist, create a new DepartmentSpecialty with this data.
     */
    create: XOR<DepartmentSpecialtyCreateInput, DepartmentSpecialtyUncheckedCreateInput>
    /**
     * In case the DepartmentSpecialty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentSpecialtyUpdateInput, DepartmentSpecialtyUncheckedUpdateInput>
  }

  /**
   * DepartmentSpecialty delete
   */
  export type DepartmentSpecialtyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
    /**
     * Filter which DepartmentSpecialty to delete.
     */
    where: DepartmentSpecialtyWhereUniqueInput
  }

  /**
   * DepartmentSpecialty deleteMany
   */
  export type DepartmentSpecialtyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepartmentSpecialties to delete
     */
    where?: DepartmentSpecialtyWhereInput
  }

  /**
   * DepartmentSpecialty without action
   */
  export type DepartmentSpecialtyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentSpecialty
     */
    select?: DepartmentSpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentSpecialtyInclude<ExtArgs> | null
  }


  /**
   * Model Staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    departmentId: string | null
    specialtyId: string | null
    empCode: string | null
    name: string | null
    designation: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    departmentId: string | null
    specialtyId: string | null
    empCode: string | null
    name: string | null
    designation: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    branchId: number
    departmentId: number
    specialtyId: number
    empCode: number
    name: number
    designation: number
    phone: number
    email: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffMinAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    specialtyId?: true
    empCode?: true
    name?: true
    designation?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    specialtyId?: true
    empCode?: true
    name?: true
    designation?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    specialtyId?: true
    empCode?: true
    name?: true
    designation?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithAggregationInput | StaffOrderByWithAggregationInput[]
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }

  export type StaffGroupByOutputType = {
    id: string
    branchId: string
    departmentId: string | null
    specialtyId: string | null
    empCode: string
    name: string
    designation: string
    phone: string | null
    email: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    specialtyId?: boolean
    empCode?: boolean
    name?: boolean
    designation?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    specialty?: boolean | Staff$specialtyArgs<ExtArgs>
    doctorAssignments?: boolean | Staff$doctorAssignmentsArgs<ExtArgs>
    headedDepartments?: boolean | Staff$headedDepartmentsArgs<ExtArgs>
    user?: boolean | Staff$userArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    specialtyId?: boolean
    empCode?: boolean
    name?: boolean
    designation?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    specialty?: boolean | Staff$specialtyArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    specialtyId?: boolean
    empCode?: boolean
    name?: boolean
    designation?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    specialty?: boolean | Staff$specialtyArgs<ExtArgs>
    doctorAssignments?: boolean | Staff$doctorAssignmentsArgs<ExtArgs>
    headedDepartments?: boolean | Staff$headedDepartmentsArgs<ExtArgs>
    user?: boolean | Staff$userArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    specialty?: boolean | Staff$specialtyArgs<ExtArgs>
  }

  export type $StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Staff"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      specialty: Prisma.$SpecialtyPayload<ExtArgs> | null
      doctorAssignments: Prisma.$DepartmentDoctorPayload<ExtArgs>[]
      headedDepartments: Prisma.$DepartmentPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      departmentId: string | null
      specialtyId: string | null
      empCode: string
      name: string
      designation: string
      phone: string | null
      email: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staff"]>
    composites: {}
  }

  type StaffGetPayload<S extends boolean | null | undefined | StaffDefaultArgs> = $Result.GetResult<Prisma.$StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffFindUniqueArgs>(args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffFindFirstArgs>(args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffFindManyArgs>(args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
     */
    create<T extends StaffCreateArgs>(args: SelectSubset<T, StaffCreateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Staff.
     * @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffCreateManyArgs>(args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {StaffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
     */
    delete<T extends StaffDeleteArgs>(args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffUpdateArgs>(args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffDeleteManyArgs>(args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffUpdateManyArgs>(args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends StaffUpsertArgs>(args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Staff model
   */
  readonly fields: StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    department<T extends Staff$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Staff$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    specialty<T extends Staff$specialtyArgs<ExtArgs> = {}>(args?: Subset<T, Staff$specialtyArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    doctorAssignments<T extends Staff$doctorAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$doctorAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentDoctorPayload<ExtArgs>, T, "findMany"> | Null>
    headedDepartments<T extends Staff$headedDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$headedDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends Staff$userArgs<ExtArgs> = {}>(args?: Subset<T, Staff$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Staff model
   */ 
  interface StaffFieldRefs {
    readonly id: FieldRef<"Staff", 'String'>
    readonly branchId: FieldRef<"Staff", 'String'>
    readonly departmentId: FieldRef<"Staff", 'String'>
    readonly specialtyId: FieldRef<"Staff", 'String'>
    readonly empCode: FieldRef<"Staff", 'String'>
    readonly name: FieldRef<"Staff", 'String'>
    readonly designation: FieldRef<"Staff", 'String'>
    readonly phone: FieldRef<"Staff", 'String'>
    readonly email: FieldRef<"Staff", 'String'>
    readonly isActive: FieldRef<"Staff", 'Boolean'>
    readonly createdAt: FieldRef<"Staff", 'DateTime'>
    readonly updatedAt: FieldRef<"Staff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }

  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Staff createManyAndReturn
   */
  export type StaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
  }

  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }

  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
  }

  /**
   * Staff.department
   */
  export type Staff$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Staff.specialty
   */
  export type Staff$specialtyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    where?: SpecialtyWhereInput
  }

  /**
   * Staff.doctorAssignments
   */
  export type Staff$doctorAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentDoctor
     */
    select?: DepartmentDoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentDoctorInclude<ExtArgs> | null
    where?: DepartmentDoctorWhereInput
    orderBy?: DepartmentDoctorOrderByWithRelationInput | DepartmentDoctorOrderByWithRelationInput[]
    cursor?: DepartmentDoctorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentDoctorScalarFieldEnum | DepartmentDoctorScalarFieldEnum[]
  }

  /**
   * Staff.headedDepartments
   */
  export type Staff$headedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Staff.user
   */
  export type Staff$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Staff without action
   */
  export type StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: string | null
    phone: string | null
    branchId: string | null
    staffId: string | null
    isActive: boolean | null
    passwordHash: string | null
    mustChangePassword: boolean | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    roleVersionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: string | null
    phone: string | null
    branchId: string | null
    staffId: string | null
    isActive: boolean | null
    passwordHash: string | null
    mustChangePassword: boolean | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    roleVersionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    phone: number
    branchId: number
    staffId: number
    isActive: number
    passwordHash: number
    mustChangePassword: number
    passwordResetToken: number
    passwordResetExpires: number
    roleVersionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    phone?: true
    branchId?: true
    staffId?: true
    isActive?: true
    passwordHash?: true
    mustChangePassword?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    roleVersionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    phone?: true
    branchId?: true
    staffId?: true
    isActive?: true
    passwordHash?: true
    mustChangePassword?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    roleVersionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    phone?: true
    branchId?: true
    staffId?: true
    isActive?: true
    passwordHash?: true
    mustChangePassword?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    roleVersionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    role: string
    phone: string | null
    branchId: string | null
    staffId: string | null
    isActive: boolean
    passwordHash: string | null
    mustChangePassword: boolean
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    roleVersionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    phone?: boolean
    branchId?: boolean
    staffId?: boolean
    isActive?: boolean
    passwordHash?: boolean
    mustChangePassword?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    roleVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    roleVersion?: boolean | User$roleVersionArgs<ExtArgs>
    createdRoleVersions?: boolean | User$createdRoleVersionsArgs<ExtArgs>
    auditEventsAsActor?: boolean | User$auditEventsAsActorArgs<ExtArgs>
    policyVersionsCreatedBy?: boolean | User$policyVersionsCreatedByArgs<ExtArgs>
    policyVersionsSubmittedBy?: boolean | User$policyVersionsSubmittedByArgs<ExtArgs>
    policyVersionsApprovedBy?: boolean | User$policyVersionsApprovedByArgs<ExtArgs>
    policyVersionsRejectedBy?: boolean | User$policyVersionsRejectedByArgs<ExtArgs>
    policyVersionsRetiredBy?: boolean | User$policyVersionsRetiredByArgs<ExtArgs>
    createdLocationRevisions?: boolean | User$createdLocationRevisionsArgs<ExtArgs>
    createdImportJobs?: boolean | User$createdImportJobsArgs<ExtArgs>
    assignedFixIts?: boolean | User$assignedFixItsArgs<ExtArgs>
    createdBookings?: boolean | User$createdBookingsArgs<ExtArgs>
    createdGoLiveReports?: boolean | User$createdGoLiveReportsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    phone?: boolean
    branchId?: boolean
    staffId?: boolean
    isActive?: boolean
    passwordHash?: boolean
    mustChangePassword?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    roleVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    roleVersion?: boolean | User$roleVersionArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    phone?: boolean
    branchId?: boolean
    staffId?: boolean
    isActive?: boolean
    passwordHash?: boolean
    mustChangePassword?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    roleVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    roleVersion?: boolean | User$roleVersionArgs<ExtArgs>
    createdRoleVersions?: boolean | User$createdRoleVersionsArgs<ExtArgs>
    auditEventsAsActor?: boolean | User$auditEventsAsActorArgs<ExtArgs>
    policyVersionsCreatedBy?: boolean | User$policyVersionsCreatedByArgs<ExtArgs>
    policyVersionsSubmittedBy?: boolean | User$policyVersionsSubmittedByArgs<ExtArgs>
    policyVersionsApprovedBy?: boolean | User$policyVersionsApprovedByArgs<ExtArgs>
    policyVersionsRejectedBy?: boolean | User$policyVersionsRejectedByArgs<ExtArgs>
    policyVersionsRetiredBy?: boolean | User$policyVersionsRetiredByArgs<ExtArgs>
    createdLocationRevisions?: boolean | User$createdLocationRevisionsArgs<ExtArgs>
    createdImportJobs?: boolean | User$createdImportJobsArgs<ExtArgs>
    assignedFixIts?: boolean | User$assignedFixItsArgs<ExtArgs>
    createdBookings?: boolean | User$createdBookingsArgs<ExtArgs>
    createdGoLiveReports?: boolean | User$createdGoLiveReportsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    roleVersion?: boolean | User$roleVersionArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      staff: Prisma.$StaffPayload<ExtArgs> | null
      roleVersion: Prisma.$RoleTemplateVersionPayload<ExtArgs> | null
      createdRoleVersions: Prisma.$RoleTemplateVersionPayload<ExtArgs>[]
      auditEventsAsActor: Prisma.$AuditEventPayload<ExtArgs>[]
      policyVersionsCreatedBy: Prisma.$PolicyVersionPayload<ExtArgs>[]
      policyVersionsSubmittedBy: Prisma.$PolicyVersionPayload<ExtArgs>[]
      policyVersionsApprovedBy: Prisma.$PolicyVersionPayload<ExtArgs>[]
      policyVersionsRejectedBy: Prisma.$PolicyVersionPayload<ExtArgs>[]
      policyVersionsRetiredBy: Prisma.$PolicyVersionPayload<ExtArgs>[]
      createdLocationRevisions: Prisma.$LocationNodeRevisionPayload<ExtArgs>[]
      createdImportJobs: Prisma.$BulkImportJobPayload<ExtArgs>[]
      assignedFixIts: Prisma.$FixItTaskPayload<ExtArgs>[]
      createdBookings: Prisma.$ProcedureBookingPayload<ExtArgs>[]
      createdGoLiveReports: Prisma.$GoLiveReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      role: string
      phone: string | null
      branchId: string | null
      staffId: string | null
      isActive: boolean
      passwordHash: string | null
      mustChangePassword: boolean
      passwordResetToken: string | null
      passwordResetExpires: Date | null
      roleVersionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    staff<T extends User$staffArgs<ExtArgs> = {}>(args?: Subset<T, User$staffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    roleVersion<T extends User$roleVersionArgs<ExtArgs> = {}>(args?: Subset<T, User$roleVersionArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdRoleVersions<T extends User$createdRoleVersionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdRoleVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findMany"> | Null>
    auditEventsAsActor<T extends User$auditEventsAsActorArgs<ExtArgs> = {}>(args?: Subset<T, User$auditEventsAsActorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany"> | Null>
    policyVersionsCreatedBy<T extends User$policyVersionsCreatedByArgs<ExtArgs> = {}>(args?: Subset<T, User$policyVersionsCreatedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findMany"> | Null>
    policyVersionsSubmittedBy<T extends User$policyVersionsSubmittedByArgs<ExtArgs> = {}>(args?: Subset<T, User$policyVersionsSubmittedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findMany"> | Null>
    policyVersionsApprovedBy<T extends User$policyVersionsApprovedByArgs<ExtArgs> = {}>(args?: Subset<T, User$policyVersionsApprovedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findMany"> | Null>
    policyVersionsRejectedBy<T extends User$policyVersionsRejectedByArgs<ExtArgs> = {}>(args?: Subset<T, User$policyVersionsRejectedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findMany"> | Null>
    policyVersionsRetiredBy<T extends User$policyVersionsRetiredByArgs<ExtArgs> = {}>(args?: Subset<T, User$policyVersionsRetiredByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findMany"> | Null>
    createdLocationRevisions<T extends User$createdLocationRevisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdLocationRevisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "findMany"> | Null>
    createdImportJobs<T extends User$createdImportJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdImportJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "findMany"> | Null>
    assignedFixIts<T extends User$assignedFixItsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedFixItsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "findMany"> | Null>
    createdBookings<T extends User$createdBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "findMany"> | Null>
    createdGoLiveReports<T extends User$createdGoLiveReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdGoLiveReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly branchId: FieldRef<"User", 'String'>
    readonly staffId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly mustChangePassword: FieldRef<"User", 'Boolean'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly passwordResetExpires: FieldRef<"User", 'DateTime'>
    readonly roleVersionId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User.staff
   */
  export type User$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * User.roleVersion
   */
  export type User$roleVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    where?: RoleTemplateVersionWhereInput
  }

  /**
   * User.createdRoleVersions
   */
  export type User$createdRoleVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    where?: RoleTemplateVersionWhereInput
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    cursor?: RoleTemplateVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleTemplateVersionScalarFieldEnum | RoleTemplateVersionScalarFieldEnum[]
  }

  /**
   * User.auditEventsAsActor
   */
  export type User$auditEventsAsActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    cursor?: AuditEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * User.policyVersionsCreatedBy
   */
  export type User$policyVersionsCreatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    where?: PolicyVersionWhereInput
    orderBy?: PolicyVersionOrderByWithRelationInput | PolicyVersionOrderByWithRelationInput[]
    cursor?: PolicyVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyVersionScalarFieldEnum | PolicyVersionScalarFieldEnum[]
  }

  /**
   * User.policyVersionsSubmittedBy
   */
  export type User$policyVersionsSubmittedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    where?: PolicyVersionWhereInput
    orderBy?: PolicyVersionOrderByWithRelationInput | PolicyVersionOrderByWithRelationInput[]
    cursor?: PolicyVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyVersionScalarFieldEnum | PolicyVersionScalarFieldEnum[]
  }

  /**
   * User.policyVersionsApprovedBy
   */
  export type User$policyVersionsApprovedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    where?: PolicyVersionWhereInput
    orderBy?: PolicyVersionOrderByWithRelationInput | PolicyVersionOrderByWithRelationInput[]
    cursor?: PolicyVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyVersionScalarFieldEnum | PolicyVersionScalarFieldEnum[]
  }

  /**
   * User.policyVersionsRejectedBy
   */
  export type User$policyVersionsRejectedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    where?: PolicyVersionWhereInput
    orderBy?: PolicyVersionOrderByWithRelationInput | PolicyVersionOrderByWithRelationInput[]
    cursor?: PolicyVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyVersionScalarFieldEnum | PolicyVersionScalarFieldEnum[]
  }

  /**
   * User.policyVersionsRetiredBy
   */
  export type User$policyVersionsRetiredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    where?: PolicyVersionWhereInput
    orderBy?: PolicyVersionOrderByWithRelationInput | PolicyVersionOrderByWithRelationInput[]
    cursor?: PolicyVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyVersionScalarFieldEnum | PolicyVersionScalarFieldEnum[]
  }

  /**
   * User.createdLocationRevisions
   */
  export type User$createdLocationRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
    where?: LocationNodeRevisionWhereInput
    orderBy?: LocationNodeRevisionOrderByWithRelationInput | LocationNodeRevisionOrderByWithRelationInput[]
    cursor?: LocationNodeRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationNodeRevisionScalarFieldEnum | LocationNodeRevisionScalarFieldEnum[]
  }

  /**
   * User.createdImportJobs
   */
  export type User$createdImportJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
    where?: BulkImportJobWhereInput
    orderBy?: BulkImportJobOrderByWithRelationInput | BulkImportJobOrderByWithRelationInput[]
    cursor?: BulkImportJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BulkImportJobScalarFieldEnum | BulkImportJobScalarFieldEnum[]
  }

  /**
   * User.assignedFixIts
   */
  export type User$assignedFixItsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    where?: FixItTaskWhereInput
    orderBy?: FixItTaskOrderByWithRelationInput | FixItTaskOrderByWithRelationInput[]
    cursor?: FixItTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FixItTaskScalarFieldEnum | FixItTaskScalarFieldEnum[]
  }

  /**
   * User.createdBookings
   */
  export type User$createdBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    where?: ProcedureBookingWhereInput
    orderBy?: ProcedureBookingOrderByWithRelationInput | ProcedureBookingOrderByWithRelationInput[]
    cursor?: ProcedureBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedureBookingScalarFieldEnum | ProcedureBookingScalarFieldEnum[]
  }

  /**
   * User.createdGoLiveReports
   */
  export type User$createdGoLiveReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
    where?: GoLiveReportWhereInput
    orderBy?: GoLiveReportOrderByWithRelationInput | GoLiveReportOrderByWithRelationInput[]
    cursor?: GoLiveReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoLiveReportScalarFieldEnum | GoLiveReportScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    uhid: string | null
    name: string | null
    gender: string | null
    dob: Date | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    uhid: string | null
    name: string | null
    gender: string | null
    dob: Date | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    branchId: number
    uhid: number
    name: number
    gender: number
    dob: number
    phone: number
    email: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    branchId?: true
    uhid?: true
    name?: true
    gender?: true
    dob?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    branchId?: true
    uhid?: true
    name?: true
    gender?: true
    dob?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    branchId?: true
    uhid?: true
    name?: true
    gender?: true
    dob?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    branchId: string
    uhid: string
    name: string
    gender: string | null
    dob: Date | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    uhid?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounters?: boolean | Patient$encountersArgs<ExtArgs>
    Admission?: boolean | Patient$AdmissionArgs<ExtArgs>
    consentRecords?: boolean | Patient$consentRecordsArgs<ExtArgs>
    rtbfRequests?: boolean | Patient$rtbfRequestsArgs<ExtArgs>
    statutoryCases?: boolean | Patient$statutoryCasesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    uhid?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    branchId?: boolean
    uhid?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounters?: boolean | Patient$encountersArgs<ExtArgs>
    Admission?: boolean | Patient$AdmissionArgs<ExtArgs>
    consentRecords?: boolean | Patient$consentRecordsArgs<ExtArgs>
    rtbfRequests?: boolean | Patient$rtbfRequestsArgs<ExtArgs>
    statutoryCases?: boolean | Patient$statutoryCasesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      Admission: Prisma.$AdmissionPayload<ExtArgs>[]
      consentRecords: Prisma.$ConsentRecordPayload<ExtArgs>[]
      rtbfRequests: Prisma.$RtbfRequestPayload<ExtArgs>[]
      statutoryCases: Prisma.$StatutoryCasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      uhid: string
      name: string
      gender: string | null
      dob: Date | null
      phone: string | null
      email: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    encounters<T extends Patient$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Patient$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    Admission<T extends Patient$AdmissionArgs<ExtArgs> = {}>(args?: Subset<T, Patient$AdmissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany"> | Null>
    consentRecords<T extends Patient$consentRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$consentRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findMany"> | Null>
    rtbfRequests<T extends Patient$rtbfRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$rtbfRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findMany"> | Null>
    statutoryCases<T extends Patient$statutoryCasesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$statutoryCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */ 
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly branchId: FieldRef<"Patient", 'String'>
    readonly uhid: FieldRef<"Patient", 'String'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly gender: FieldRef<"Patient", 'String'>
    readonly dob: FieldRef<"Patient", 'DateTime'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly address: FieldRef<"Patient", 'String'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }

  /**
   * Patient.encounters
   */
  export type Patient$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Patient.Admission
   */
  export type Patient$AdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Patient.consentRecords
   */
  export type Patient$consentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    where?: ConsentRecordWhereInput
    orderBy?: ConsentRecordOrderByWithRelationInput | ConsentRecordOrderByWithRelationInput[]
    cursor?: ConsentRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * Patient.rtbfRequests
   */
  export type Patient$rtbfRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    where?: RtbfRequestWhereInput
    orderBy?: RtbfRequestOrderByWithRelationInput | RtbfRequestOrderByWithRelationInput[]
    cursor?: RtbfRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RtbfRequestScalarFieldEnum | RtbfRequestScalarFieldEnum[]
  }

  /**
   * Patient.statutoryCases
   */
  export type Patient$statutoryCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    where?: StatutoryCaseWhereInput
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    cursor?: StatutoryCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatutoryCaseScalarFieldEnum | StatutoryCaseScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Encounter
   */

  export type AggregateEncounter = {
    _count: EncounterCountAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  export type EncounterMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    patientId: string | null
    type: $Enums.EncounterType | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    patientId: string | null
    type: $Enums.EncounterType | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterCountAggregateOutputType = {
    id: number
    branchId: number
    patientId: number
    type: number
    startedAt: number
    endedAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EncounterMinAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    type?: true
    startedAt?: true
    endedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterMaxAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    type?: true
    startedAt?: true
    endedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterCountAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    type?: true
    startedAt?: true
    endedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EncounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounter to aggregate.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encounters
    **/
    _count?: true | EncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterMaxAggregateInputType
  }

  export type GetEncounterAggregateType<T extends EncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounter[P]>
      : GetScalarType<T[P], AggregateEncounter[P]>
  }




  export type EncounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithAggregationInput | EncounterOrderByWithAggregationInput[]
    by: EncounterScalarFieldEnum[] | EncounterScalarFieldEnum
    having?: EncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterCountAggregateInputType | true
    _min?: EncounterMinAggregateInputType
    _max?: EncounterMaxAggregateInputType
  }

  export type EncounterGroupByOutputType = {
    id: string
    branchId: string
    patientId: string
    type: $Enums.EncounterType
    startedAt: Date
    endedAt: Date | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: EncounterCountAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  type GetEncounterGroupByPayload<T extends EncounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    type?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admissions?: boolean | Encounter$admissionsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    type?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectScalar = {
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    type?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EncounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admissions?: boolean | Encounter$admissionsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $EncounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encounter"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      admissions: Prisma.$AdmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      patientId: string
      type: $Enums.EncounterType
      startedAt: Date
      endedAt: Date | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["encounter"]>
    composites: {}
  }

  type EncounterGetPayload<S extends boolean | null | undefined | EncounterDefaultArgs> = $Result.GetResult<Prisma.$EncounterPayload, S>

  type EncounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterCountAggregateInputType | true
    }

  export interface EncounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encounter'], meta: { name: 'Encounter' } }
    /**
     * Find zero or one Encounter that matches the filter.
     * @param {EncounterFindUniqueArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterFindUniqueArgs>(args: SelectSubset<T, EncounterFindUniqueArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Encounter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterFindUniqueOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Encounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterFindFirstArgs>(args?: SelectSubset<T, EncounterFindFirstArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Encounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Encounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encounters
     * const encounters = await prisma.encounter.findMany()
     * 
     * // Get first 10 Encounters
     * const encounters = await prisma.encounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterWithIdOnly = await prisma.encounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterFindManyArgs>(args?: SelectSubset<T, EncounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Encounter.
     * @param {EncounterCreateArgs} args - Arguments to create a Encounter.
     * @example
     * // Create one Encounter
     * const Encounter = await prisma.encounter.create({
     *   data: {
     *     // ... data to create a Encounter
     *   }
     * })
     * 
     */
    create<T extends EncounterCreateArgs>(args: SelectSubset<T, EncounterCreateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Encounters.
     * @param {EncounterCreateManyArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterCreateManyArgs>(args?: SelectSubset<T, EncounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encounters and returns the data saved in the database.
     * @param {EncounterCreateManyAndReturnArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Encounter.
     * @param {EncounterDeleteArgs} args - Arguments to delete one Encounter.
     * @example
     * // Delete one Encounter
     * const Encounter = await prisma.encounter.delete({
     *   where: {
     *     // ... filter to delete one Encounter
     *   }
     * })
     * 
     */
    delete<T extends EncounterDeleteArgs>(args: SelectSubset<T, EncounterDeleteArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Encounter.
     * @param {EncounterUpdateArgs} args - Arguments to update one Encounter.
     * @example
     * // Update one Encounter
     * const encounter = await prisma.encounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterUpdateArgs>(args: SelectSubset<T, EncounterUpdateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Encounters.
     * @param {EncounterDeleteManyArgs} args - Arguments to filter Encounters to delete.
     * @example
     * // Delete a few Encounters
     * const { count } = await prisma.encounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDeleteManyArgs>(args?: SelectSubset<T, EncounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterUpdateManyArgs>(args: SelectSubset<T, EncounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Encounter.
     * @param {EncounterUpsertArgs} args - Arguments to update or create a Encounter.
     * @example
     * // Update or create a Encounter
     * const encounter = await prisma.encounter.upsert({
     *   create: {
     *     // ... data to create a Encounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encounter we want to update
     *   }
     * })
     */
    upsert<T extends EncounterUpsertArgs>(args: SelectSubset<T, EncounterUpsertArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterCountArgs} args - Arguments to filter Encounters to count.
     * @example
     * // Count the number of Encounters
     * const count = await prisma.encounter.count({
     *   where: {
     *     // ... the filter for the Encounters we want to count
     *   }
     * })
    **/
    count<T extends EncounterCountArgs>(
      args?: Subset<T, EncounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterAggregateArgs>(args: Subset<T, EncounterAggregateArgs>): Prisma.PrismaPromise<GetEncounterAggregateType<T>>

    /**
     * Group by Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterGroupByArgs['orderBy'] }
        : { orderBy?: EncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encounter model
   */
  readonly fields: EncounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    admissions<T extends Encounter$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$admissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encounter model
   */ 
  interface EncounterFieldRefs {
    readonly id: FieldRef<"Encounter", 'String'>
    readonly branchId: FieldRef<"Encounter", 'String'>
    readonly patientId: FieldRef<"Encounter", 'String'>
    readonly type: FieldRef<"Encounter", 'EncounterType'>
    readonly startedAt: FieldRef<"Encounter", 'DateTime'>
    readonly endedAt: FieldRef<"Encounter", 'DateTime'>
    readonly status: FieldRef<"Encounter", 'String'>
    readonly createdAt: FieldRef<"Encounter", 'DateTime'>
    readonly updatedAt: FieldRef<"Encounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Encounter findUnique
   */
  export type EncounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findUniqueOrThrow
   */
  export type EncounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findFirst
   */
  export type EncounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findFirstOrThrow
   */
  export type EncounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findMany
   */
  export type EncounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounters to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter create
   */
  export type EncounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to create a Encounter.
     */
    data: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
  }

  /**
   * Encounter createMany
   */
  export type EncounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encounter createManyAndReturn
   */
  export type EncounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter update
   */
  export type EncounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to update a Encounter.
     */
    data: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
    /**
     * Choose, which Encounter to update.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter updateMany
   */
  export type EncounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter upsert
   */
  export type EncounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The filter to search for the Encounter to update in case it exists.
     */
    where: EncounterWhereUniqueInput
    /**
     * In case the Encounter found by the `where` argument doesn't exist, create a new Encounter with this data.
     */
    create: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
    /**
     * In case the Encounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
  }

  /**
   * Encounter delete
   */
  export type EncounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter which Encounter to delete.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter deleteMany
   */
  export type EncounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounters to delete
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter.admissions
   */
  export type Encounter$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Encounter without action
   */
  export type EncounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
  }


  /**
   * Model Ward
   */

  export type AggregateWard = {
    _count: WardCountAggregateOutputType | null
    _min: WardMinAggregateOutputType | null
    _max: WardMaxAggregateOutputType | null
  }

  export type WardMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    specialty: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WardMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    specialty: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WardCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    specialty: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WardMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    specialty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WardMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    specialty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WardCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    specialty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ward to aggregate.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wards
    **/
    _count?: true | WardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WardMaxAggregateInputType
  }

  export type GetWardAggregateType<T extends WardAggregateArgs> = {
        [P in keyof T & keyof AggregateWard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWard[P]>
      : GetScalarType<T[P], AggregateWard[P]>
  }




  export type WardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardWhereInput
    orderBy?: WardOrderByWithAggregationInput | WardOrderByWithAggregationInput[]
    by: WardScalarFieldEnum[] | WardScalarFieldEnum
    having?: WardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WardCountAggregateInputType | true
    _min?: WardMinAggregateInputType
    _max?: WardMaxAggregateInputType
  }

  export type WardGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    specialty: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: WardCountAggregateOutputType | null
    _min: WardMinAggregateOutputType | null
    _max: WardMaxAggregateOutputType | null
  }

  type GetWardGroupByPayload<T extends WardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WardGroupByOutputType[P]>
            : GetScalarType<T[P], WardGroupByOutputType[P]>
        }
      >
    >


  export type WardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    specialty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    rooms?: boolean | Ward$roomsArgs<ExtArgs>
    _count?: boolean | WardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ward"]>

  export type WardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    specialty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ward"]>

  export type WardSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    specialty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    rooms?: boolean | Ward$roomsArgs<ExtArgs>
    _count?: boolean | WardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $WardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ward"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      rooms: Prisma.$RoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      specialty: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ward"]>
    composites: {}
  }

  type WardGetPayload<S extends boolean | null | undefined | WardDefaultArgs> = $Result.GetResult<Prisma.$WardPayload, S>

  type WardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WardCountAggregateInputType | true
    }

  export interface WardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ward'], meta: { name: 'Ward' } }
    /**
     * Find zero or one Ward that matches the filter.
     * @param {WardFindUniqueArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WardFindUniqueArgs>(args: SelectSubset<T, WardFindUniqueArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ward that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WardFindUniqueOrThrowArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WardFindUniqueOrThrowArgs>(args: SelectSubset<T, WardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindFirstArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WardFindFirstArgs>(args?: SelectSubset<T, WardFindFirstArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindFirstOrThrowArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WardFindFirstOrThrowArgs>(args?: SelectSubset<T, WardFindFirstOrThrowArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wards
     * const wards = await prisma.ward.findMany()
     * 
     * // Get first 10 Wards
     * const wards = await prisma.ward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wardWithIdOnly = await prisma.ward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WardFindManyArgs>(args?: SelectSubset<T, WardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ward.
     * @param {WardCreateArgs} args - Arguments to create a Ward.
     * @example
     * // Create one Ward
     * const Ward = await prisma.ward.create({
     *   data: {
     *     // ... data to create a Ward
     *   }
     * })
     * 
     */
    create<T extends WardCreateArgs>(args: SelectSubset<T, WardCreateArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wards.
     * @param {WardCreateManyArgs} args - Arguments to create many Wards.
     * @example
     * // Create many Wards
     * const ward = await prisma.ward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WardCreateManyArgs>(args?: SelectSubset<T, WardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wards and returns the data saved in the database.
     * @param {WardCreateManyAndReturnArgs} args - Arguments to create many Wards.
     * @example
     * // Create many Wards
     * const ward = await prisma.ward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wards and only return the `id`
     * const wardWithIdOnly = await prisma.ward.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WardCreateManyAndReturnArgs>(args?: SelectSubset<T, WardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ward.
     * @param {WardDeleteArgs} args - Arguments to delete one Ward.
     * @example
     * // Delete one Ward
     * const Ward = await prisma.ward.delete({
     *   where: {
     *     // ... filter to delete one Ward
     *   }
     * })
     * 
     */
    delete<T extends WardDeleteArgs>(args: SelectSubset<T, WardDeleteArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ward.
     * @param {WardUpdateArgs} args - Arguments to update one Ward.
     * @example
     * // Update one Ward
     * const ward = await prisma.ward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WardUpdateArgs>(args: SelectSubset<T, WardUpdateArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wards.
     * @param {WardDeleteManyArgs} args - Arguments to filter Wards to delete.
     * @example
     * // Delete a few Wards
     * const { count } = await prisma.ward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WardDeleteManyArgs>(args?: SelectSubset<T, WardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wards
     * const ward = await prisma.ward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WardUpdateManyArgs>(args: SelectSubset<T, WardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ward.
     * @param {WardUpsertArgs} args - Arguments to update or create a Ward.
     * @example
     * // Update or create a Ward
     * const ward = await prisma.ward.upsert({
     *   create: {
     *     // ... data to create a Ward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ward we want to update
     *   }
     * })
     */
    upsert<T extends WardUpsertArgs>(args: SelectSubset<T, WardUpsertArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardCountArgs} args - Arguments to filter Wards to count.
     * @example
     * // Count the number of Wards
     * const count = await prisma.ward.count({
     *   where: {
     *     // ... the filter for the Wards we want to count
     *   }
     * })
    **/
    count<T extends WardCountArgs>(
      args?: Subset<T, WardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WardAggregateArgs>(args: Subset<T, WardAggregateArgs>): Prisma.PrismaPromise<GetWardAggregateType<T>>

    /**
     * Group by Ward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WardGroupByArgs['orderBy'] }
        : { orderBy?: WardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ward model
   */
  readonly fields: WardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rooms<T extends Ward$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Ward$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ward model
   */ 
  interface WardFieldRefs {
    readonly id: FieldRef<"Ward", 'String'>
    readonly branchId: FieldRef<"Ward", 'String'>
    readonly code: FieldRef<"Ward", 'String'>
    readonly name: FieldRef<"Ward", 'String'>
    readonly specialty: FieldRef<"Ward", 'String'>
    readonly isActive: FieldRef<"Ward", 'Boolean'>
    readonly createdAt: FieldRef<"Ward", 'DateTime'>
    readonly updatedAt: FieldRef<"Ward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ward findUnique
   */
  export type WardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward findUniqueOrThrow
   */
  export type WardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward findFirst
   */
  export type WardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wards.
     */
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward findFirstOrThrow
   */
  export type WardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wards.
     */
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward findMany
   */
  export type WardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Wards to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward create
   */
  export type WardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The data needed to create a Ward.
     */
    data: XOR<WardCreateInput, WardUncheckedCreateInput>
  }

  /**
   * Ward createMany
   */
  export type WardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wards.
     */
    data: WardCreateManyInput | WardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ward createManyAndReturn
   */
  export type WardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Wards.
     */
    data: WardCreateManyInput | WardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ward update
   */
  export type WardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The data needed to update a Ward.
     */
    data: XOR<WardUpdateInput, WardUncheckedUpdateInput>
    /**
     * Choose, which Ward to update.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward updateMany
   */
  export type WardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wards.
     */
    data: XOR<WardUpdateManyMutationInput, WardUncheckedUpdateManyInput>
    /**
     * Filter which Wards to update
     */
    where?: WardWhereInput
  }

  /**
   * Ward upsert
   */
  export type WardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The filter to search for the Ward to update in case it exists.
     */
    where: WardWhereUniqueInput
    /**
     * In case the Ward found by the `where` argument doesn't exist, create a new Ward with this data.
     */
    create: XOR<WardCreateInput, WardUncheckedCreateInput>
    /**
     * In case the Ward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WardUpdateInput, WardUncheckedUpdateInput>
  }

  /**
   * Ward delete
   */
  export type WardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter which Ward to delete.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward deleteMany
   */
  export type WardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wards to delete
     */
    where?: WardWhereInput
  }

  /**
   * Ward.rooms
   */
  export type Ward$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Ward without action
   */
  export type WardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    wardId: string | null
    code: string | null
    name: string | null
    floor: string | null
    type: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    wardId: string | null
    code: string | null
    name: string | null
    floor: string | null
    type: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    branchId: number
    wardId: number
    code: number
    name: number
    floor: number
    type: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomMinAggregateInputType = {
    id?: true
    branchId?: true
    wardId?: true
    code?: true
    name?: true
    floor?: true
    type?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    branchId?: true
    wardId?: true
    code?: true
    name?: true
    floor?: true
    type?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    branchId?: true
    wardId?: true
    code?: true
    name?: true
    floor?: true
    type?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    branchId: string
    wardId: string
    code: string
    name: string
    floor: string | null
    type: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    wardId?: boolean
    code?: boolean
    name?: boolean
    floor?: boolean
    type?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
    beds?: boolean | Room$bedsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    wardId?: boolean
    code?: boolean
    name?: boolean
    floor?: boolean
    type?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    branchId?: boolean
    wardId?: boolean
    code?: boolean
    name?: boolean
    floor?: boolean
    type?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
    beds?: boolean | Room$bedsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      ward: Prisma.$WardPayload<ExtArgs>
      beds: Prisma.$BedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      wardId: string
      code: string
      name: string
      floor: string | null
      type: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ward<T extends WardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardDefaultArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    beds<T extends Room$bedsArgs<ExtArgs> = {}>(args?: Subset<T, Room$bedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly branchId: FieldRef<"Room", 'String'>
    readonly wardId: FieldRef<"Room", 'String'>
    readonly code: FieldRef<"Room", 'String'>
    readonly name: FieldRef<"Room", 'String'>
    readonly floor: FieldRef<"Room", 'String'>
    readonly type: FieldRef<"Room", 'String'>
    readonly isActive: FieldRef<"Room", 'Boolean'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }

  /**
   * Room.beds
   */
  export type Room$bedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    where?: BedWhereInput
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    cursor?: BedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model Bed
   */

  export type AggregateBed = {
    _count: BedCountAggregateOutputType | null
    _min: BedMinAggregateOutputType | null
    _max: BedMaxAggregateOutputType | null
  }

  export type BedMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    roomId: string | null
    code: string | null
    state: $Enums.BedState | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BedMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    roomId: string | null
    code: string | null
    state: $Enums.BedState | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BedCountAggregateOutputType = {
    id: number
    branchId: number
    roomId: number
    code: number
    state: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BedMinAggregateInputType = {
    id?: true
    branchId?: true
    roomId?: true
    code?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BedMaxAggregateInputType = {
    id?: true
    branchId?: true
    roomId?: true
    code?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BedCountAggregateInputType = {
    id?: true
    branchId?: true
    roomId?: true
    code?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bed to aggregate.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Beds
    **/
    _count?: true | BedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BedMaxAggregateInputType
  }

  export type GetBedAggregateType<T extends BedAggregateArgs> = {
        [P in keyof T & keyof AggregateBed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBed[P]>
      : GetScalarType<T[P], AggregateBed[P]>
  }




  export type BedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
    orderBy?: BedOrderByWithAggregationInput | BedOrderByWithAggregationInput[]
    by: BedScalarFieldEnum[] | BedScalarFieldEnum
    having?: BedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BedCountAggregateInputType | true
    _min?: BedMinAggregateInputType
    _max?: BedMaxAggregateInputType
  }

  export type BedGroupByOutputType = {
    id: string
    branchId: string
    roomId: string
    code: string
    state: $Enums.BedState
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BedCountAggregateOutputType | null
    _min: BedMinAggregateOutputType | null
    _max: BedMaxAggregateOutputType | null
  }

  type GetBedGroupByPayload<T extends BedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BedGroupByOutputType[P]>
            : GetScalarType<T[P], BedGroupByOutputType[P]>
        }
      >
    >


  export type BedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    roomId?: boolean
    code?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    admissions?: boolean | Bed$admissionsArgs<ExtArgs>
    _count?: boolean | BedCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    roomId?: boolean
    code?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectScalar = {
    id?: boolean
    branchId?: boolean
    roomId?: boolean
    code?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    admissions?: boolean | Bed$admissionsArgs<ExtArgs>
    _count?: boolean | BedCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }

  export type $BedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bed"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
      admissions: Prisma.$AdmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      roomId: string
      code: string
      state: $Enums.BedState
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bed"]>
    composites: {}
  }

  type BedGetPayload<S extends boolean | null | undefined | BedDefaultArgs> = $Result.GetResult<Prisma.$BedPayload, S>

  type BedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BedFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BedCountAggregateInputType | true
    }

  export interface BedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bed'], meta: { name: 'Bed' } }
    /**
     * Find zero or one Bed that matches the filter.
     * @param {BedFindUniqueArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BedFindUniqueArgs>(args: SelectSubset<T, BedFindUniqueArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bed that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BedFindUniqueOrThrowArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BedFindUniqueOrThrowArgs>(args: SelectSubset<T, BedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindFirstArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BedFindFirstArgs>(args?: SelectSubset<T, BedFindFirstArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindFirstOrThrowArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BedFindFirstOrThrowArgs>(args?: SelectSubset<T, BedFindFirstOrThrowArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Beds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beds
     * const beds = await prisma.bed.findMany()
     * 
     * // Get first 10 Beds
     * const beds = await prisma.bed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bedWithIdOnly = await prisma.bed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BedFindManyArgs>(args?: SelectSubset<T, BedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bed.
     * @param {BedCreateArgs} args - Arguments to create a Bed.
     * @example
     * // Create one Bed
     * const Bed = await prisma.bed.create({
     *   data: {
     *     // ... data to create a Bed
     *   }
     * })
     * 
     */
    create<T extends BedCreateArgs>(args: SelectSubset<T, BedCreateArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Beds.
     * @param {BedCreateManyArgs} args - Arguments to create many Beds.
     * @example
     * // Create many Beds
     * const bed = await prisma.bed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BedCreateManyArgs>(args?: SelectSubset<T, BedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Beds and returns the data saved in the database.
     * @param {BedCreateManyAndReturnArgs} args - Arguments to create many Beds.
     * @example
     * // Create many Beds
     * const bed = await prisma.bed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Beds and only return the `id`
     * const bedWithIdOnly = await prisma.bed.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BedCreateManyAndReturnArgs>(args?: SelectSubset<T, BedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bed.
     * @param {BedDeleteArgs} args - Arguments to delete one Bed.
     * @example
     * // Delete one Bed
     * const Bed = await prisma.bed.delete({
     *   where: {
     *     // ... filter to delete one Bed
     *   }
     * })
     * 
     */
    delete<T extends BedDeleteArgs>(args: SelectSubset<T, BedDeleteArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bed.
     * @param {BedUpdateArgs} args - Arguments to update one Bed.
     * @example
     * // Update one Bed
     * const bed = await prisma.bed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BedUpdateArgs>(args: SelectSubset<T, BedUpdateArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Beds.
     * @param {BedDeleteManyArgs} args - Arguments to filter Beds to delete.
     * @example
     * // Delete a few Beds
     * const { count } = await prisma.bed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BedDeleteManyArgs>(args?: SelectSubset<T, BedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beds
     * const bed = await prisma.bed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BedUpdateManyArgs>(args: SelectSubset<T, BedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bed.
     * @param {BedUpsertArgs} args - Arguments to update or create a Bed.
     * @example
     * // Update or create a Bed
     * const bed = await prisma.bed.upsert({
     *   create: {
     *     // ... data to create a Bed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bed we want to update
     *   }
     * })
     */
    upsert<T extends BedUpsertArgs>(args: SelectSubset<T, BedUpsertArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Beds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedCountArgs} args - Arguments to filter Beds to count.
     * @example
     * // Count the number of Beds
     * const count = await prisma.bed.count({
     *   where: {
     *     // ... the filter for the Beds we want to count
     *   }
     * })
    **/
    count<T extends BedCountArgs>(
      args?: Subset<T, BedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BedAggregateArgs>(args: Subset<T, BedAggregateArgs>): Prisma.PrismaPromise<GetBedAggregateType<T>>

    /**
     * Group by Bed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BedGroupByArgs['orderBy'] }
        : { orderBy?: BedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bed model
   */
  readonly fields: BedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    admissions<T extends Bed$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, Bed$admissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bed model
   */ 
  interface BedFieldRefs {
    readonly id: FieldRef<"Bed", 'String'>
    readonly branchId: FieldRef<"Bed", 'String'>
    readonly roomId: FieldRef<"Bed", 'String'>
    readonly code: FieldRef<"Bed", 'String'>
    readonly state: FieldRef<"Bed", 'BedState'>
    readonly isActive: FieldRef<"Bed", 'Boolean'>
    readonly createdAt: FieldRef<"Bed", 'DateTime'>
    readonly updatedAt: FieldRef<"Bed", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bed findUnique
   */
  export type BedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed findUniqueOrThrow
   */
  export type BedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed findFirst
   */
  export type BedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beds.
     */
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed findFirstOrThrow
   */
  export type BedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beds.
     */
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed findMany
   */
  export type BedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Beds to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed create
   */
  export type BedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The data needed to create a Bed.
     */
    data: XOR<BedCreateInput, BedUncheckedCreateInput>
  }

  /**
   * Bed createMany
   */
  export type BedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Beds.
     */
    data: BedCreateManyInput | BedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bed createManyAndReturn
   */
  export type BedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Beds.
     */
    data: BedCreateManyInput | BedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bed update
   */
  export type BedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The data needed to update a Bed.
     */
    data: XOR<BedUpdateInput, BedUncheckedUpdateInput>
    /**
     * Choose, which Bed to update.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed updateMany
   */
  export type BedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Beds.
     */
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyInput>
    /**
     * Filter which Beds to update
     */
    where?: BedWhereInput
  }

  /**
   * Bed upsert
   */
  export type BedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The filter to search for the Bed to update in case it exists.
     */
    where: BedWhereUniqueInput
    /**
     * In case the Bed found by the `where` argument doesn't exist, create a new Bed with this data.
     */
    create: XOR<BedCreateInput, BedUncheckedCreateInput>
    /**
     * In case the Bed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BedUpdateInput, BedUncheckedUpdateInput>
  }

  /**
   * Bed delete
   */
  export type BedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter which Bed to delete.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed deleteMany
   */
  export type BedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Beds to delete
     */
    where?: BedWhereInput
  }

  /**
   * Bed.admissions
   */
  export type Bed$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Bed without action
   */
  export type BedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
  }


  /**
   * Model Admission
   */

  export type AggregateAdmission = {
    _count: AdmissionCountAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  export type AdmissionMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    encounterId: string | null
    patientId: string | null
    bedId: string | null
    admittedAt: Date | null
    dischargedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    encounterId: string | null
    patientId: string | null
    bedId: string | null
    admittedAt: Date | null
    dischargedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionCountAggregateOutputType = {
    id: number
    branchId: number
    encounterId: number
    patientId: number
    bedId: number
    admittedAt: number
    dischargedAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdmissionMinAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    bedId?: true
    admittedAt?: true
    dischargedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionMaxAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    bedId?: true
    admittedAt?: true
    dischargedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionCountAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    bedId?: true
    admittedAt?: true
    dischargedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admission to aggregate.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admissions
    **/
    _count?: true | AdmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionMaxAggregateInputType
  }

  export type GetAdmissionAggregateType<T extends AdmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmission[P]>
      : GetScalarType<T[P], AggregateAdmission[P]>
  }




  export type AdmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithAggregationInput | AdmissionOrderByWithAggregationInput[]
    by: AdmissionScalarFieldEnum[] | AdmissionScalarFieldEnum
    having?: AdmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionCountAggregateInputType | true
    _min?: AdmissionMinAggregateInputType
    _max?: AdmissionMaxAggregateInputType
  }

  export type AdmissionGroupByOutputType = {
    id: string
    branchId: string
    encounterId: string | null
    patientId: string
    bedId: string | null
    admittedAt: Date
    dischargedAt: Date | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AdmissionCountAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  type GetAdmissionGroupByPayload<T extends AdmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    bedId?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounter?: boolean | Admission$encounterArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    bed?: boolean | Admission$bedArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    bedId?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounter?: boolean | Admission$encounterArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    bed?: boolean | Admission$bedArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectScalar = {
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    bedId?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounter?: boolean | Admission$encounterArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    bed?: boolean | Admission$bedArgs<ExtArgs>
  }
  export type AdmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounter?: boolean | Admission$encounterArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    bed?: boolean | Admission$bedArgs<ExtArgs>
  }

  export type $AdmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admission"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      encounter: Prisma.$EncounterPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs>
      bed: Prisma.$BedPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      encounterId: string | null
      patientId: string
      bedId: string | null
      admittedAt: Date
      dischargedAt: Date | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admission"]>
    composites: {}
  }

  type AdmissionGetPayload<S extends boolean | null | undefined | AdmissionDefaultArgs> = $Result.GetResult<Prisma.$AdmissionPayload, S>

  type AdmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdmissionCountAggregateInputType | true
    }

  export interface AdmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admission'], meta: { name: 'Admission' } }
    /**
     * Find zero or one Admission that matches the filter.
     * @param {AdmissionFindUniqueArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionFindUniqueArgs>(args: SelectSubset<T, AdmissionFindUniqueArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdmissionFindUniqueOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionFindFirstArgs>(args?: SelectSubset<T, AdmissionFindFirstArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admissions
     * const admissions = await prisma.admission.findMany()
     * 
     * // Get first 10 Admissions
     * const admissions = await prisma.admission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionWithIdOnly = await prisma.admission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionFindManyArgs>(args?: SelectSubset<T, AdmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admission.
     * @param {AdmissionCreateArgs} args - Arguments to create a Admission.
     * @example
     * // Create one Admission
     * const Admission = await prisma.admission.create({
     *   data: {
     *     // ... data to create a Admission
     *   }
     * })
     * 
     */
    create<T extends AdmissionCreateArgs>(args: SelectSubset<T, AdmissionCreateArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admissions.
     * @param {AdmissionCreateManyArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admission = await prisma.admission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionCreateManyArgs>(args?: SelectSubset<T, AdmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admissions and returns the data saved in the database.
     * @param {AdmissionCreateManyAndReturnArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admission = await prisma.admission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admissions and only return the `id`
     * const admissionWithIdOnly = await prisma.admission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admission.
     * @param {AdmissionDeleteArgs} args - Arguments to delete one Admission.
     * @example
     * // Delete one Admission
     * const Admission = await prisma.admission.delete({
     *   where: {
     *     // ... filter to delete one Admission
     *   }
     * })
     * 
     */
    delete<T extends AdmissionDeleteArgs>(args: SelectSubset<T, AdmissionDeleteArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admission.
     * @param {AdmissionUpdateArgs} args - Arguments to update one Admission.
     * @example
     * // Update one Admission
     * const admission = await prisma.admission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionUpdateArgs>(args: SelectSubset<T, AdmissionUpdateArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admissions.
     * @param {AdmissionDeleteManyArgs} args - Arguments to filter Admissions to delete.
     * @example
     * // Delete a few Admissions
     * const { count } = await prisma.admission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionDeleteManyArgs>(args?: SelectSubset<T, AdmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admissions
     * const admission = await prisma.admission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionUpdateManyArgs>(args: SelectSubset<T, AdmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admission.
     * @param {AdmissionUpsertArgs} args - Arguments to update or create a Admission.
     * @example
     * // Update or create a Admission
     * const admission = await prisma.admission.upsert({
     *   create: {
     *     // ... data to create a Admission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admission we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionUpsertArgs>(args: SelectSubset<T, AdmissionUpsertArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionCountArgs} args - Arguments to filter Admissions to count.
     * @example
     * // Count the number of Admissions
     * const count = await prisma.admission.count({
     *   where: {
     *     // ... the filter for the Admissions we want to count
     *   }
     * })
    **/
    count<T extends AdmissionCountArgs>(
      args?: Subset<T, AdmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionAggregateArgs>(args: Subset<T, AdmissionAggregateArgs>): Prisma.PrismaPromise<GetAdmissionAggregateType<T>>

    /**
     * Group by Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admission model
   */
  readonly fields: AdmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    encounter<T extends Admission$encounterArgs<ExtArgs> = {}>(args?: Subset<T, Admission$encounterArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bed<T extends Admission$bedArgs<ExtArgs> = {}>(args?: Subset<T, Admission$bedArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admission model
   */ 
  interface AdmissionFieldRefs {
    readonly id: FieldRef<"Admission", 'String'>
    readonly branchId: FieldRef<"Admission", 'String'>
    readonly encounterId: FieldRef<"Admission", 'String'>
    readonly patientId: FieldRef<"Admission", 'String'>
    readonly bedId: FieldRef<"Admission", 'String'>
    readonly admittedAt: FieldRef<"Admission", 'DateTime'>
    readonly dischargedAt: FieldRef<"Admission", 'DateTime'>
    readonly status: FieldRef<"Admission", 'String'>
    readonly createdAt: FieldRef<"Admission", 'DateTime'>
    readonly updatedAt: FieldRef<"Admission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admission findUnique
   */
  export type AdmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission findUniqueOrThrow
   */
  export type AdmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission findFirst
   */
  export type AdmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission findFirstOrThrow
   */
  export type AdmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission findMany
   */
  export type AdmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admissions to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission create
   */
  export type AdmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Admission.
     */
    data: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
  }

  /**
   * Admission createMany
   */
  export type AdmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admissions.
     */
    data: AdmissionCreateManyInput | AdmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admission createManyAndReturn
   */
  export type AdmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admissions.
     */
    data: AdmissionCreateManyInput | AdmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admission update
   */
  export type AdmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Admission.
     */
    data: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
    /**
     * Choose, which Admission to update.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission updateMany
   */
  export type AdmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admissions.
     */
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyInput>
    /**
     * Filter which Admissions to update
     */
    where?: AdmissionWhereInput
  }

  /**
   * Admission upsert
   */
  export type AdmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Admission to update in case it exists.
     */
    where: AdmissionWhereUniqueInput
    /**
     * In case the Admission found by the `where` argument doesn't exist, create a new Admission with this data.
     */
    create: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
    /**
     * In case the Admission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
  }

  /**
   * Admission delete
   */
  export type AdmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter which Admission to delete.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission deleteMany
   */
  export type AdmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admissions to delete
     */
    where?: AdmissionWhereInput
  }

  /**
   * Admission.encounter
   */
  export type Admission$encounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
  }

  /**
   * Admission.bed
   */
  export type Admission$bedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    where?: BedWhereInput
  }

  /**
   * Admission without action
   */
  export type AdmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
  }


  /**
   * Model OT
   */

  export type AggregateOT = {
    _count: OTCountAggregateOutputType | null
    _min: OTMinAggregateOutputType | null
    _max: OTMaxAggregateOutputType | null
  }

  export type OTMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OTMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OTCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OTMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OTMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OTCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OT to aggregate.
     */
    where?: OTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTS to fetch.
     */
    orderBy?: OTOrderByWithRelationInput | OTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OTS
    **/
    _count?: true | OTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OTMaxAggregateInputType
  }

  export type GetOTAggregateType<T extends OTAggregateArgs> = {
        [P in keyof T & keyof AggregateOT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOT[P]>
      : GetScalarType<T[P], AggregateOT[P]>
  }




  export type OTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTWhereInput
    orderBy?: OTOrderByWithAggregationInput | OTOrderByWithAggregationInput[]
    by: OTScalarFieldEnum[] | OTScalarFieldEnum
    having?: OTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OTCountAggregateInputType | true
    _min?: OTMinAggregateInputType
    _max?: OTMaxAggregateInputType
  }

  export type OTGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: OTCountAggregateOutputType | null
    _min: OTMinAggregateOutputType | null
    _max: OTMaxAggregateOutputType | null
  }

  type GetOTGroupByPayload<T extends OTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OTGroupByOutputType[P]>
            : GetScalarType<T[P], OTGroupByOutputType[P]>
        }
      >
    >


  export type OTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oT"]>

  export type OTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oT"]>

  export type OTSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type OTIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $OTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OT"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["oT"]>
    composites: {}
  }

  type OTGetPayload<S extends boolean | null | undefined | OTDefaultArgs> = $Result.GetResult<Prisma.$OTPayload, S>

  type OTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OTFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OTCountAggregateInputType | true
    }

  export interface OTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OT'], meta: { name: 'OT' } }
    /**
     * Find zero or one OT that matches the filter.
     * @param {OTFindUniqueArgs} args - Arguments to find a OT
     * @example
     * // Get one OT
     * const oT = await prisma.oT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OTFindUniqueArgs>(args: SelectSubset<T, OTFindUniqueArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OT that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OTFindUniqueOrThrowArgs} args - Arguments to find a OT
     * @example
     * // Get one OT
     * const oT = await prisma.oT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OTFindUniqueOrThrowArgs>(args: SelectSubset<T, OTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTFindFirstArgs} args - Arguments to find a OT
     * @example
     * // Get one OT
     * const oT = await prisma.oT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OTFindFirstArgs>(args?: SelectSubset<T, OTFindFirstArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTFindFirstOrThrowArgs} args - Arguments to find a OT
     * @example
     * // Get one OT
     * const oT = await prisma.oT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OTFindFirstOrThrowArgs>(args?: SelectSubset<T, OTFindFirstOrThrowArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OTS
     * const oTS = await prisma.oT.findMany()
     * 
     * // Get first 10 OTS
     * const oTS = await prisma.oT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oTWithIdOnly = await prisma.oT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OTFindManyArgs>(args?: SelectSubset<T, OTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OT.
     * @param {OTCreateArgs} args - Arguments to create a OT.
     * @example
     * // Create one OT
     * const OT = await prisma.oT.create({
     *   data: {
     *     // ... data to create a OT
     *   }
     * })
     * 
     */
    create<T extends OTCreateArgs>(args: SelectSubset<T, OTCreateArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OTS.
     * @param {OTCreateManyArgs} args - Arguments to create many OTS.
     * @example
     * // Create many OTS
     * const oT = await prisma.oT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OTCreateManyArgs>(args?: SelectSubset<T, OTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OTS and returns the data saved in the database.
     * @param {OTCreateManyAndReturnArgs} args - Arguments to create many OTS.
     * @example
     * // Create many OTS
     * const oT = await prisma.oT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OTS and only return the `id`
     * const oTWithIdOnly = await prisma.oT.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OTCreateManyAndReturnArgs>(args?: SelectSubset<T, OTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OT.
     * @param {OTDeleteArgs} args - Arguments to delete one OT.
     * @example
     * // Delete one OT
     * const OT = await prisma.oT.delete({
     *   where: {
     *     // ... filter to delete one OT
     *   }
     * })
     * 
     */
    delete<T extends OTDeleteArgs>(args: SelectSubset<T, OTDeleteArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OT.
     * @param {OTUpdateArgs} args - Arguments to update one OT.
     * @example
     * // Update one OT
     * const oT = await prisma.oT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OTUpdateArgs>(args: SelectSubset<T, OTUpdateArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OTS.
     * @param {OTDeleteManyArgs} args - Arguments to filter OTS to delete.
     * @example
     * // Delete a few OTS
     * const { count } = await prisma.oT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OTDeleteManyArgs>(args?: SelectSubset<T, OTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OTS
     * const oT = await prisma.oT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OTUpdateManyArgs>(args: SelectSubset<T, OTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OT.
     * @param {OTUpsertArgs} args - Arguments to update or create a OT.
     * @example
     * // Update or create a OT
     * const oT = await prisma.oT.upsert({
     *   create: {
     *     // ... data to create a OT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OT we want to update
     *   }
     * })
     */
    upsert<T extends OTUpsertArgs>(args: SelectSubset<T, OTUpsertArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTCountArgs} args - Arguments to filter OTS to count.
     * @example
     * // Count the number of OTS
     * const count = await prisma.oT.count({
     *   where: {
     *     // ... the filter for the OTS we want to count
     *   }
     * })
    **/
    count<T extends OTCountArgs>(
      args?: Subset<T, OTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OTAggregateArgs>(args: Subset<T, OTAggregateArgs>): Prisma.PrismaPromise<GetOTAggregateType<T>>

    /**
     * Group by OT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OTGroupByArgs['orderBy'] }
        : { orderBy?: OTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OT model
   */
  readonly fields: OTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OT model
   */ 
  interface OTFieldRefs {
    readonly id: FieldRef<"OT", 'String'>
    readonly branchId: FieldRef<"OT", 'String'>
    readonly code: FieldRef<"OT", 'String'>
    readonly name: FieldRef<"OT", 'String'>
    readonly isActive: FieldRef<"OT", 'Boolean'>
    readonly createdAt: FieldRef<"OT", 'DateTime'>
    readonly updatedAt: FieldRef<"OT", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OT findUnique
   */
  export type OTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter, which OT to fetch.
     */
    where: OTWhereUniqueInput
  }

  /**
   * OT findUniqueOrThrow
   */
  export type OTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter, which OT to fetch.
     */
    where: OTWhereUniqueInput
  }

  /**
   * OT findFirst
   */
  export type OTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter, which OT to fetch.
     */
    where?: OTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTS to fetch.
     */
    orderBy?: OTOrderByWithRelationInput | OTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTS.
     */
    cursor?: OTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTS.
     */
    distinct?: OTScalarFieldEnum | OTScalarFieldEnum[]
  }

  /**
   * OT findFirstOrThrow
   */
  export type OTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter, which OT to fetch.
     */
    where?: OTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTS to fetch.
     */
    orderBy?: OTOrderByWithRelationInput | OTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTS.
     */
    cursor?: OTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTS.
     */
    distinct?: OTScalarFieldEnum | OTScalarFieldEnum[]
  }

  /**
   * OT findMany
   */
  export type OTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter, which OTS to fetch.
     */
    where?: OTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTS to fetch.
     */
    orderBy?: OTOrderByWithRelationInput | OTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OTS.
     */
    cursor?: OTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTS.
     */
    skip?: number
    distinct?: OTScalarFieldEnum | OTScalarFieldEnum[]
  }

  /**
   * OT create
   */
  export type OTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * The data needed to create a OT.
     */
    data: XOR<OTCreateInput, OTUncheckedCreateInput>
  }

  /**
   * OT createMany
   */
  export type OTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OTS.
     */
    data: OTCreateManyInput | OTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OT createManyAndReturn
   */
  export type OTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OTS.
     */
    data: OTCreateManyInput | OTCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OT update
   */
  export type OTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * The data needed to update a OT.
     */
    data: XOR<OTUpdateInput, OTUncheckedUpdateInput>
    /**
     * Choose, which OT to update.
     */
    where: OTWhereUniqueInput
  }

  /**
   * OT updateMany
   */
  export type OTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OTS.
     */
    data: XOR<OTUpdateManyMutationInput, OTUncheckedUpdateManyInput>
    /**
     * Filter which OTS to update
     */
    where?: OTWhereInput
  }

  /**
   * OT upsert
   */
  export type OTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * The filter to search for the OT to update in case it exists.
     */
    where: OTWhereUniqueInput
    /**
     * In case the OT found by the `where` argument doesn't exist, create a new OT with this data.
     */
    create: XOR<OTCreateInput, OTUncheckedCreateInput>
    /**
     * In case the OT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OTUpdateInput, OTUncheckedUpdateInput>
  }

  /**
   * OT delete
   */
  export type OTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter which OT to delete.
     */
    where: OTWhereUniqueInput
  }

  /**
   * OT deleteMany
   */
  export type OTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTS to delete
     */
    where?: OTWhereInput
  }

  /**
   * OT without action
   */
  export type OTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    category: string | null
    location: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    category: string | null
    location: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    category: number
    location: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssetMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    category: string
    location: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type AssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      category: string
      location: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */ 
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly branchId: FieldRef<"Asset", 'String'>
    readonly code: FieldRef<"Asset", 'String'>
    readonly name: FieldRef<"Asset", 'String'>
    readonly category: FieldRef<"Asset", 'String'>
    readonly location: FieldRef<"Asset", 'String'>
    readonly status: FieldRef<"Asset", 'String'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly updatedAt: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model TariffPlan
   */

  export type AggregateTariffPlan = {
    _count: TariffPlanCountAggregateOutputType | null
    _min: TariffPlanMinAggregateOutputType | null
    _max: TariffPlanMaxAggregateOutputType | null
  }

  export type TariffPlanMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    status: string | null
    payerType: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffPlanMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    status: string | null
    payerType: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffPlanCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    status: number
    payerType: number
    effectiveFrom: number
    effectiveTo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TariffPlanMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    status?: true
    payerType?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffPlanMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    status?: true
    payerType?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffPlanCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    status?: true
    payerType?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TariffPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffPlan to aggregate.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TariffPlans
    **/
    _count?: true | TariffPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TariffPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TariffPlanMaxAggregateInputType
  }

  export type GetTariffPlanAggregateType<T extends TariffPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateTariffPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTariffPlan[P]>
      : GetScalarType<T[P], AggregateTariffPlan[P]>
  }




  export type TariffPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffPlanWhereInput
    orderBy?: TariffPlanOrderByWithAggregationInput | TariffPlanOrderByWithAggregationInput[]
    by: TariffPlanScalarFieldEnum[] | TariffPlanScalarFieldEnum
    having?: TariffPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TariffPlanCountAggregateInputType | true
    _min?: TariffPlanMinAggregateInputType
    _max?: TariffPlanMaxAggregateInputType
  }

  export type TariffPlanGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date
    effectiveTo: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TariffPlanCountAggregateOutputType | null
    _min: TariffPlanMinAggregateOutputType | null
    _max: TariffPlanMaxAggregateOutputType | null
  }

  type GetTariffPlanGroupByPayload<T extends TariffPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TariffPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TariffPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TariffPlanGroupByOutputType[P]>
            : GetScalarType<T[P], TariffPlanGroupByOutputType[P]>
        }
      >
    >


  export type TariffPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    payerType?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    rates?: boolean | TariffPlan$ratesArgs<ExtArgs>
    _count?: boolean | TariffPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffPlan"]>

  export type TariffPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    payerType?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffPlan"]>

  export type TariffPlanSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    payerType?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TariffPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    rates?: boolean | TariffPlan$ratesArgs<ExtArgs>
    _count?: boolean | TariffPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TariffPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $TariffPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TariffPlan"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      rates: Prisma.$TariffRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      status: string
      payerType: string
      effectiveFrom: Date
      effectiveTo: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tariffPlan"]>
    composites: {}
  }

  type TariffPlanGetPayload<S extends boolean | null | undefined | TariffPlanDefaultArgs> = $Result.GetResult<Prisma.$TariffPlanPayload, S>

  type TariffPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TariffPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TariffPlanCountAggregateInputType | true
    }

  export interface TariffPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TariffPlan'], meta: { name: 'TariffPlan' } }
    /**
     * Find zero or one TariffPlan that matches the filter.
     * @param {TariffPlanFindUniqueArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TariffPlanFindUniqueArgs>(args: SelectSubset<T, TariffPlanFindUniqueArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TariffPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TariffPlanFindUniqueOrThrowArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TariffPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, TariffPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TariffPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanFindFirstArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TariffPlanFindFirstArgs>(args?: SelectSubset<T, TariffPlanFindFirstArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TariffPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanFindFirstOrThrowArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TariffPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, TariffPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TariffPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TariffPlans
     * const tariffPlans = await prisma.tariffPlan.findMany()
     * 
     * // Get first 10 TariffPlans
     * const tariffPlans = await prisma.tariffPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tariffPlanWithIdOnly = await prisma.tariffPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TariffPlanFindManyArgs>(args?: SelectSubset<T, TariffPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TariffPlan.
     * @param {TariffPlanCreateArgs} args - Arguments to create a TariffPlan.
     * @example
     * // Create one TariffPlan
     * const TariffPlan = await prisma.tariffPlan.create({
     *   data: {
     *     // ... data to create a TariffPlan
     *   }
     * })
     * 
     */
    create<T extends TariffPlanCreateArgs>(args: SelectSubset<T, TariffPlanCreateArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TariffPlans.
     * @param {TariffPlanCreateManyArgs} args - Arguments to create many TariffPlans.
     * @example
     * // Create many TariffPlans
     * const tariffPlan = await prisma.tariffPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TariffPlanCreateManyArgs>(args?: SelectSubset<T, TariffPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TariffPlans and returns the data saved in the database.
     * @param {TariffPlanCreateManyAndReturnArgs} args - Arguments to create many TariffPlans.
     * @example
     * // Create many TariffPlans
     * const tariffPlan = await prisma.tariffPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TariffPlans and only return the `id`
     * const tariffPlanWithIdOnly = await prisma.tariffPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TariffPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, TariffPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TariffPlan.
     * @param {TariffPlanDeleteArgs} args - Arguments to delete one TariffPlan.
     * @example
     * // Delete one TariffPlan
     * const TariffPlan = await prisma.tariffPlan.delete({
     *   where: {
     *     // ... filter to delete one TariffPlan
     *   }
     * })
     * 
     */
    delete<T extends TariffPlanDeleteArgs>(args: SelectSubset<T, TariffPlanDeleteArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TariffPlan.
     * @param {TariffPlanUpdateArgs} args - Arguments to update one TariffPlan.
     * @example
     * // Update one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TariffPlanUpdateArgs>(args: SelectSubset<T, TariffPlanUpdateArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TariffPlans.
     * @param {TariffPlanDeleteManyArgs} args - Arguments to filter TariffPlans to delete.
     * @example
     * // Delete a few TariffPlans
     * const { count } = await prisma.tariffPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TariffPlanDeleteManyArgs>(args?: SelectSubset<T, TariffPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TariffPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TariffPlans
     * const tariffPlan = await prisma.tariffPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TariffPlanUpdateManyArgs>(args: SelectSubset<T, TariffPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TariffPlan.
     * @param {TariffPlanUpsertArgs} args - Arguments to update or create a TariffPlan.
     * @example
     * // Update or create a TariffPlan
     * const tariffPlan = await prisma.tariffPlan.upsert({
     *   create: {
     *     // ... data to create a TariffPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TariffPlan we want to update
     *   }
     * })
     */
    upsert<T extends TariffPlanUpsertArgs>(args: SelectSubset<T, TariffPlanUpsertArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TariffPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanCountArgs} args - Arguments to filter TariffPlans to count.
     * @example
     * // Count the number of TariffPlans
     * const count = await prisma.tariffPlan.count({
     *   where: {
     *     // ... the filter for the TariffPlans we want to count
     *   }
     * })
    **/
    count<T extends TariffPlanCountArgs>(
      args?: Subset<T, TariffPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TariffPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TariffPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TariffPlanAggregateArgs>(args: Subset<T, TariffPlanAggregateArgs>): Prisma.PrismaPromise<GetTariffPlanAggregateType<T>>

    /**
     * Group by TariffPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TariffPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TariffPlanGroupByArgs['orderBy'] }
        : { orderBy?: TariffPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TariffPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTariffPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TariffPlan model
   */
  readonly fields: TariffPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TariffPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TariffPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rates<T extends TariffPlan$ratesArgs<ExtArgs> = {}>(args?: Subset<T, TariffPlan$ratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TariffPlan model
   */ 
  interface TariffPlanFieldRefs {
    readonly id: FieldRef<"TariffPlan", 'String'>
    readonly branchId: FieldRef<"TariffPlan", 'String'>
    readonly code: FieldRef<"TariffPlan", 'String'>
    readonly name: FieldRef<"TariffPlan", 'String'>
    readonly status: FieldRef<"TariffPlan", 'String'>
    readonly payerType: FieldRef<"TariffPlan", 'String'>
    readonly effectiveFrom: FieldRef<"TariffPlan", 'DateTime'>
    readonly effectiveTo: FieldRef<"TariffPlan", 'DateTime'>
    readonly createdAt: FieldRef<"TariffPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"TariffPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TariffPlan findUnique
   */
  export type TariffPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan findUniqueOrThrow
   */
  export type TariffPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan findFirst
   */
  export type TariffPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffPlans.
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffPlans.
     */
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * TariffPlan findFirstOrThrow
   */
  export type TariffPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffPlans.
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffPlans.
     */
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * TariffPlan findMany
   */
  export type TariffPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlans to fetch.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TariffPlans.
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * TariffPlan create
   */
  export type TariffPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a TariffPlan.
     */
    data: XOR<TariffPlanCreateInput, TariffPlanUncheckedCreateInput>
  }

  /**
   * TariffPlan createMany
   */
  export type TariffPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TariffPlans.
     */
    data: TariffPlanCreateManyInput | TariffPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TariffPlan createManyAndReturn
   */
  export type TariffPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TariffPlans.
     */
    data: TariffPlanCreateManyInput | TariffPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TariffPlan update
   */
  export type TariffPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a TariffPlan.
     */
    data: XOR<TariffPlanUpdateInput, TariffPlanUncheckedUpdateInput>
    /**
     * Choose, which TariffPlan to update.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan updateMany
   */
  export type TariffPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TariffPlans.
     */
    data: XOR<TariffPlanUpdateManyMutationInput, TariffPlanUncheckedUpdateManyInput>
    /**
     * Filter which TariffPlans to update
     */
    where?: TariffPlanWhereInput
  }

  /**
   * TariffPlan upsert
   */
  export type TariffPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the TariffPlan to update in case it exists.
     */
    where: TariffPlanWhereUniqueInput
    /**
     * In case the TariffPlan found by the `where` argument doesn't exist, create a new TariffPlan with this data.
     */
    create: XOR<TariffPlanCreateInput, TariffPlanUncheckedCreateInput>
    /**
     * In case the TariffPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TariffPlanUpdateInput, TariffPlanUncheckedUpdateInput>
  }

  /**
   * TariffPlan delete
   */
  export type TariffPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter which TariffPlan to delete.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan deleteMany
   */
  export type TariffPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffPlans to delete
     */
    where?: TariffPlanWhereInput
  }

  /**
   * TariffPlan.rates
   */
  export type TariffPlan$ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    where?: TariffRateWhereInput
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    cursor?: TariffRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffPlan without action
   */
  export type TariffPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCatalogItem
   */

  export type AggregateServiceCatalogItem = {
    _count: ServiceCatalogItemCountAggregateOutputType | null
    _min: ServiceCatalogItemMinAggregateOutputType | null
    _max: ServiceCatalogItemMaxAggregateOutputType | null
  }

  export type ServiceCatalogItemMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: string | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCatalogItemMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: string | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCatalogItemCountAggregateOutputType = {
    id: number
    code: number
    name: number
    category: number
    unit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceCatalogItemMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCatalogItemMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCatalogItemCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceCatalogItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCatalogItem to aggregate.
     */
    where?: ServiceCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCatalogItems to fetch.
     */
    orderBy?: ServiceCatalogItemOrderByWithRelationInput | ServiceCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCatalogItems
    **/
    _count?: true | ServiceCatalogItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCatalogItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCatalogItemMaxAggregateInputType
  }

  export type GetServiceCatalogItemAggregateType<T extends ServiceCatalogItemAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCatalogItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCatalogItem[P]>
      : GetScalarType<T[P], AggregateServiceCatalogItem[P]>
  }




  export type ServiceCatalogItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCatalogItemWhereInput
    orderBy?: ServiceCatalogItemOrderByWithAggregationInput | ServiceCatalogItemOrderByWithAggregationInput[]
    by: ServiceCatalogItemScalarFieldEnum[] | ServiceCatalogItemScalarFieldEnum
    having?: ServiceCatalogItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCatalogItemCountAggregateInputType | true
    _min?: ServiceCatalogItemMinAggregateInputType
    _max?: ServiceCatalogItemMaxAggregateInputType
  }

  export type ServiceCatalogItemGroupByOutputType = {
    id: string
    code: string
    name: string
    category: string
    unit: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceCatalogItemCountAggregateOutputType | null
    _min: ServiceCatalogItemMinAggregateOutputType | null
    _max: ServiceCatalogItemMaxAggregateOutputType | null
  }

  type GetServiceCatalogItemGroupByPayload<T extends ServiceCatalogItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCatalogItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCatalogItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCatalogItemGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCatalogItemGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCatalogItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCatalogItem"]>

  export type ServiceCatalogItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCatalogItem"]>

  export type ServiceCatalogItemSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ServiceCatalogItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCatalogItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      category: string
      unit: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceCatalogItem"]>
    composites: {}
  }

  type ServiceCatalogItemGetPayload<S extends boolean | null | undefined | ServiceCatalogItemDefaultArgs> = $Result.GetResult<Prisma.$ServiceCatalogItemPayload, S>

  type ServiceCatalogItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceCatalogItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCatalogItemCountAggregateInputType | true
    }

  export interface ServiceCatalogItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCatalogItem'], meta: { name: 'ServiceCatalogItem' } }
    /**
     * Find zero or one ServiceCatalogItem that matches the filter.
     * @param {ServiceCatalogItemFindUniqueArgs} args - Arguments to find a ServiceCatalogItem
     * @example
     * // Get one ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCatalogItemFindUniqueArgs>(args: SelectSubset<T, ServiceCatalogItemFindUniqueArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceCatalogItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceCatalogItemFindUniqueOrThrowArgs} args - Arguments to find a ServiceCatalogItem
     * @example
     * // Get one ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCatalogItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCatalogItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceCatalogItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemFindFirstArgs} args - Arguments to find a ServiceCatalogItem
     * @example
     * // Get one ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCatalogItemFindFirstArgs>(args?: SelectSubset<T, ServiceCatalogItemFindFirstArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceCatalogItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemFindFirstOrThrowArgs} args - Arguments to find a ServiceCatalogItem
     * @example
     * // Get one ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCatalogItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCatalogItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceCatalogItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCatalogItems
     * const serviceCatalogItems = await prisma.serviceCatalogItem.findMany()
     * 
     * // Get first 10 ServiceCatalogItems
     * const serviceCatalogItems = await prisma.serviceCatalogItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCatalogItemWithIdOnly = await prisma.serviceCatalogItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCatalogItemFindManyArgs>(args?: SelectSubset<T, ServiceCatalogItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceCatalogItem.
     * @param {ServiceCatalogItemCreateArgs} args - Arguments to create a ServiceCatalogItem.
     * @example
     * // Create one ServiceCatalogItem
     * const ServiceCatalogItem = await prisma.serviceCatalogItem.create({
     *   data: {
     *     // ... data to create a ServiceCatalogItem
     *   }
     * })
     * 
     */
    create<T extends ServiceCatalogItemCreateArgs>(args: SelectSubset<T, ServiceCatalogItemCreateArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceCatalogItems.
     * @param {ServiceCatalogItemCreateManyArgs} args - Arguments to create many ServiceCatalogItems.
     * @example
     * // Create many ServiceCatalogItems
     * const serviceCatalogItem = await prisma.serviceCatalogItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCatalogItemCreateManyArgs>(args?: SelectSubset<T, ServiceCatalogItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCatalogItems and returns the data saved in the database.
     * @param {ServiceCatalogItemCreateManyAndReturnArgs} args - Arguments to create many ServiceCatalogItems.
     * @example
     * // Create many ServiceCatalogItems
     * const serviceCatalogItem = await prisma.serviceCatalogItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCatalogItems and only return the `id`
     * const serviceCatalogItemWithIdOnly = await prisma.serviceCatalogItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCatalogItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCatalogItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceCatalogItem.
     * @param {ServiceCatalogItemDeleteArgs} args - Arguments to delete one ServiceCatalogItem.
     * @example
     * // Delete one ServiceCatalogItem
     * const ServiceCatalogItem = await prisma.serviceCatalogItem.delete({
     *   where: {
     *     // ... filter to delete one ServiceCatalogItem
     *   }
     * })
     * 
     */
    delete<T extends ServiceCatalogItemDeleteArgs>(args: SelectSubset<T, ServiceCatalogItemDeleteArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceCatalogItem.
     * @param {ServiceCatalogItemUpdateArgs} args - Arguments to update one ServiceCatalogItem.
     * @example
     * // Update one ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCatalogItemUpdateArgs>(args: SelectSubset<T, ServiceCatalogItemUpdateArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceCatalogItems.
     * @param {ServiceCatalogItemDeleteManyArgs} args - Arguments to filter ServiceCatalogItems to delete.
     * @example
     * // Delete a few ServiceCatalogItems
     * const { count } = await prisma.serviceCatalogItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCatalogItemDeleteManyArgs>(args?: SelectSubset<T, ServiceCatalogItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCatalogItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCatalogItems
     * const serviceCatalogItem = await prisma.serviceCatalogItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCatalogItemUpdateManyArgs>(args: SelectSubset<T, ServiceCatalogItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceCatalogItem.
     * @param {ServiceCatalogItemUpsertArgs} args - Arguments to update or create a ServiceCatalogItem.
     * @example
     * // Update or create a ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.upsert({
     *   create: {
     *     // ... data to create a ServiceCatalogItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCatalogItem we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCatalogItemUpsertArgs>(args: SelectSubset<T, ServiceCatalogItemUpsertArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceCatalogItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemCountArgs} args - Arguments to filter ServiceCatalogItems to count.
     * @example
     * // Count the number of ServiceCatalogItems
     * const count = await prisma.serviceCatalogItem.count({
     *   where: {
     *     // ... the filter for the ServiceCatalogItems we want to count
     *   }
     * })
    **/
    count<T extends ServiceCatalogItemCountArgs>(
      args?: Subset<T, ServiceCatalogItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCatalogItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCatalogItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCatalogItemAggregateArgs>(args: Subset<T, ServiceCatalogItemAggregateArgs>): Prisma.PrismaPromise<GetServiceCatalogItemAggregateType<T>>

    /**
     * Group by ServiceCatalogItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCatalogItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCatalogItemGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCatalogItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCatalogItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCatalogItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCatalogItem model
   */
  readonly fields: ServiceCatalogItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCatalogItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCatalogItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCatalogItem model
   */ 
  interface ServiceCatalogItemFieldRefs {
    readonly id: FieldRef<"ServiceCatalogItem", 'String'>
    readonly code: FieldRef<"ServiceCatalogItem", 'String'>
    readonly name: FieldRef<"ServiceCatalogItem", 'String'>
    readonly category: FieldRef<"ServiceCatalogItem", 'String'>
    readonly unit: FieldRef<"ServiceCatalogItem", 'String'>
    readonly createdAt: FieldRef<"ServiceCatalogItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceCatalogItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCatalogItem findUnique
   */
  export type ServiceCatalogItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter, which ServiceCatalogItem to fetch.
     */
    where: ServiceCatalogItemWhereUniqueInput
  }

  /**
   * ServiceCatalogItem findUniqueOrThrow
   */
  export type ServiceCatalogItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter, which ServiceCatalogItem to fetch.
     */
    where: ServiceCatalogItemWhereUniqueInput
  }

  /**
   * ServiceCatalogItem findFirst
   */
  export type ServiceCatalogItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter, which ServiceCatalogItem to fetch.
     */
    where?: ServiceCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCatalogItems to fetch.
     */
    orderBy?: ServiceCatalogItemOrderByWithRelationInput | ServiceCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCatalogItems.
     */
    cursor?: ServiceCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCatalogItems.
     */
    distinct?: ServiceCatalogItemScalarFieldEnum | ServiceCatalogItemScalarFieldEnum[]
  }

  /**
   * ServiceCatalogItem findFirstOrThrow
   */
  export type ServiceCatalogItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter, which ServiceCatalogItem to fetch.
     */
    where?: ServiceCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCatalogItems to fetch.
     */
    orderBy?: ServiceCatalogItemOrderByWithRelationInput | ServiceCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCatalogItems.
     */
    cursor?: ServiceCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCatalogItems.
     */
    distinct?: ServiceCatalogItemScalarFieldEnum | ServiceCatalogItemScalarFieldEnum[]
  }

  /**
   * ServiceCatalogItem findMany
   */
  export type ServiceCatalogItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter, which ServiceCatalogItems to fetch.
     */
    where?: ServiceCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCatalogItems to fetch.
     */
    orderBy?: ServiceCatalogItemOrderByWithRelationInput | ServiceCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCatalogItems.
     */
    cursor?: ServiceCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCatalogItems.
     */
    skip?: number
    distinct?: ServiceCatalogItemScalarFieldEnum | ServiceCatalogItemScalarFieldEnum[]
  }

  /**
   * ServiceCatalogItem create
   */
  export type ServiceCatalogItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * The data needed to create a ServiceCatalogItem.
     */
    data: XOR<ServiceCatalogItemCreateInput, ServiceCatalogItemUncheckedCreateInput>
  }

  /**
   * ServiceCatalogItem createMany
   */
  export type ServiceCatalogItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCatalogItems.
     */
    data: ServiceCatalogItemCreateManyInput | ServiceCatalogItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCatalogItem createManyAndReturn
   */
  export type ServiceCatalogItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceCatalogItems.
     */
    data: ServiceCatalogItemCreateManyInput | ServiceCatalogItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCatalogItem update
   */
  export type ServiceCatalogItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * The data needed to update a ServiceCatalogItem.
     */
    data: XOR<ServiceCatalogItemUpdateInput, ServiceCatalogItemUncheckedUpdateInput>
    /**
     * Choose, which ServiceCatalogItem to update.
     */
    where: ServiceCatalogItemWhereUniqueInput
  }

  /**
   * ServiceCatalogItem updateMany
   */
  export type ServiceCatalogItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCatalogItems.
     */
    data: XOR<ServiceCatalogItemUpdateManyMutationInput, ServiceCatalogItemUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCatalogItems to update
     */
    where?: ServiceCatalogItemWhereInput
  }

  /**
   * ServiceCatalogItem upsert
   */
  export type ServiceCatalogItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * The filter to search for the ServiceCatalogItem to update in case it exists.
     */
    where: ServiceCatalogItemWhereUniqueInput
    /**
     * In case the ServiceCatalogItem found by the `where` argument doesn't exist, create a new ServiceCatalogItem with this data.
     */
    create: XOR<ServiceCatalogItemCreateInput, ServiceCatalogItemUncheckedCreateInput>
    /**
     * In case the ServiceCatalogItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCatalogItemUpdateInput, ServiceCatalogItemUncheckedUpdateInput>
  }

  /**
   * ServiceCatalogItem delete
   */
  export type ServiceCatalogItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter which ServiceCatalogItem to delete.
     */
    where: ServiceCatalogItemWhereUniqueInput
  }

  /**
   * ServiceCatalogItem deleteMany
   */
  export type ServiceCatalogItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCatalogItems to delete
     */
    where?: ServiceCatalogItemWhereInput
  }

  /**
   * ServiceCatalogItem without action
   */
  export type ServiceCatalogItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
  }


  /**
   * Model TariffRate
   */

  export type AggregateTariffRate = {
    _count: TariffRateCountAggregateOutputType | null
    _avg: TariffRateAvgAggregateOutputType | null
    _sum: TariffRateSumAggregateOutputType | null
    _min: TariffRateMinAggregateOutputType | null
    _max: TariffRateMaxAggregateOutputType | null
  }

  export type TariffRateAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TariffRateSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TariffRateMinAggregateOutputType = {
    id: string | null
    tariffPlanId: string | null
    serviceCode: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffRateMaxAggregateOutputType = {
    id: string | null
    tariffPlanId: string | null
    serviceCode: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffRateCountAggregateOutputType = {
    id: number
    tariffPlanId: number
    serviceCode: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TariffRateAvgAggregateInputType = {
    amount?: true
  }

  export type TariffRateSumAggregateInputType = {
    amount?: true
  }

  export type TariffRateMinAggregateInputType = {
    id?: true
    tariffPlanId?: true
    serviceCode?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffRateMaxAggregateInputType = {
    id?: true
    tariffPlanId?: true
    serviceCode?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffRateCountAggregateInputType = {
    id?: true
    tariffPlanId?: true
    serviceCode?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TariffRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffRate to aggregate.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TariffRates
    **/
    _count?: true | TariffRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TariffRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TariffRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TariffRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TariffRateMaxAggregateInputType
  }

  export type GetTariffRateAggregateType<T extends TariffRateAggregateArgs> = {
        [P in keyof T & keyof AggregateTariffRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTariffRate[P]>
      : GetScalarType<T[P], AggregateTariffRate[P]>
  }




  export type TariffRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffRateWhereInput
    orderBy?: TariffRateOrderByWithAggregationInput | TariffRateOrderByWithAggregationInput[]
    by: TariffRateScalarFieldEnum[] | TariffRateScalarFieldEnum
    having?: TariffRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TariffRateCountAggregateInputType | true
    _avg?: TariffRateAvgAggregateInputType
    _sum?: TariffRateSumAggregateInputType
    _min?: TariffRateMinAggregateInputType
    _max?: TariffRateMaxAggregateInputType
  }

  export type TariffRateGroupByOutputType = {
    id: string
    tariffPlanId: string
    serviceCode: string
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: TariffRateCountAggregateOutputType | null
    _avg: TariffRateAvgAggregateOutputType | null
    _sum: TariffRateSumAggregateOutputType | null
    _min: TariffRateMinAggregateOutputType | null
    _max: TariffRateMaxAggregateOutputType | null
  }

  type GetTariffRateGroupByPayload<T extends TariffRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TariffRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TariffRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TariffRateGroupByOutputType[P]>
            : GetScalarType<T[P], TariffRateGroupByOutputType[P]>
        }
      >
    >


  export type TariffRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tariffPlanId?: boolean
    serviceCode?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffRate"]>

  export type TariffRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tariffPlanId?: boolean
    serviceCode?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffRate"]>

  export type TariffRateSelectScalar = {
    id?: boolean
    tariffPlanId?: boolean
    serviceCode?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TariffRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }
  export type TariffRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }

  export type $TariffRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TariffRate"
    objects: {
      tariffPlan: Prisma.$TariffPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tariffPlanId: string
      serviceCode: string
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tariffRate"]>
    composites: {}
  }

  type TariffRateGetPayload<S extends boolean | null | undefined | TariffRateDefaultArgs> = $Result.GetResult<Prisma.$TariffRatePayload, S>

  type TariffRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TariffRateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TariffRateCountAggregateInputType | true
    }

  export interface TariffRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TariffRate'], meta: { name: 'TariffRate' } }
    /**
     * Find zero or one TariffRate that matches the filter.
     * @param {TariffRateFindUniqueArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TariffRateFindUniqueArgs>(args: SelectSubset<T, TariffRateFindUniqueArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TariffRate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TariffRateFindUniqueOrThrowArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TariffRateFindUniqueOrThrowArgs>(args: SelectSubset<T, TariffRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TariffRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateFindFirstArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TariffRateFindFirstArgs>(args?: SelectSubset<T, TariffRateFindFirstArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TariffRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateFindFirstOrThrowArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TariffRateFindFirstOrThrowArgs>(args?: SelectSubset<T, TariffRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TariffRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TariffRates
     * const tariffRates = await prisma.tariffRate.findMany()
     * 
     * // Get first 10 TariffRates
     * const tariffRates = await prisma.tariffRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tariffRateWithIdOnly = await prisma.tariffRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TariffRateFindManyArgs>(args?: SelectSubset<T, TariffRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TariffRate.
     * @param {TariffRateCreateArgs} args - Arguments to create a TariffRate.
     * @example
     * // Create one TariffRate
     * const TariffRate = await prisma.tariffRate.create({
     *   data: {
     *     // ... data to create a TariffRate
     *   }
     * })
     * 
     */
    create<T extends TariffRateCreateArgs>(args: SelectSubset<T, TariffRateCreateArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TariffRates.
     * @param {TariffRateCreateManyArgs} args - Arguments to create many TariffRates.
     * @example
     * // Create many TariffRates
     * const tariffRate = await prisma.tariffRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TariffRateCreateManyArgs>(args?: SelectSubset<T, TariffRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TariffRates and returns the data saved in the database.
     * @param {TariffRateCreateManyAndReturnArgs} args - Arguments to create many TariffRates.
     * @example
     * // Create many TariffRates
     * const tariffRate = await prisma.tariffRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TariffRates and only return the `id`
     * const tariffRateWithIdOnly = await prisma.tariffRate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TariffRateCreateManyAndReturnArgs>(args?: SelectSubset<T, TariffRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TariffRate.
     * @param {TariffRateDeleteArgs} args - Arguments to delete one TariffRate.
     * @example
     * // Delete one TariffRate
     * const TariffRate = await prisma.tariffRate.delete({
     *   where: {
     *     // ... filter to delete one TariffRate
     *   }
     * })
     * 
     */
    delete<T extends TariffRateDeleteArgs>(args: SelectSubset<T, TariffRateDeleteArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TariffRate.
     * @param {TariffRateUpdateArgs} args - Arguments to update one TariffRate.
     * @example
     * // Update one TariffRate
     * const tariffRate = await prisma.tariffRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TariffRateUpdateArgs>(args: SelectSubset<T, TariffRateUpdateArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TariffRates.
     * @param {TariffRateDeleteManyArgs} args - Arguments to filter TariffRates to delete.
     * @example
     * // Delete a few TariffRates
     * const { count } = await prisma.tariffRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TariffRateDeleteManyArgs>(args?: SelectSubset<T, TariffRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TariffRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TariffRates
     * const tariffRate = await prisma.tariffRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TariffRateUpdateManyArgs>(args: SelectSubset<T, TariffRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TariffRate.
     * @param {TariffRateUpsertArgs} args - Arguments to update or create a TariffRate.
     * @example
     * // Update or create a TariffRate
     * const tariffRate = await prisma.tariffRate.upsert({
     *   create: {
     *     // ... data to create a TariffRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TariffRate we want to update
     *   }
     * })
     */
    upsert<T extends TariffRateUpsertArgs>(args: SelectSubset<T, TariffRateUpsertArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TariffRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateCountArgs} args - Arguments to filter TariffRates to count.
     * @example
     * // Count the number of TariffRates
     * const count = await prisma.tariffRate.count({
     *   where: {
     *     // ... the filter for the TariffRates we want to count
     *   }
     * })
    **/
    count<T extends TariffRateCountArgs>(
      args?: Subset<T, TariffRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TariffRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TariffRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TariffRateAggregateArgs>(args: Subset<T, TariffRateAggregateArgs>): Prisma.PrismaPromise<GetTariffRateAggregateType<T>>

    /**
     * Group by TariffRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TariffRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TariffRateGroupByArgs['orderBy'] }
        : { orderBy?: TariffRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TariffRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTariffRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TariffRate model
   */
  readonly fields: TariffRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TariffRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TariffRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tariffPlan<T extends TariffPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TariffPlanDefaultArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TariffRate model
   */ 
  interface TariffRateFieldRefs {
    readonly id: FieldRef<"TariffRate", 'String'>
    readonly tariffPlanId: FieldRef<"TariffRate", 'String'>
    readonly serviceCode: FieldRef<"TariffRate", 'String'>
    readonly amount: FieldRef<"TariffRate", 'Decimal'>
    readonly createdAt: FieldRef<"TariffRate", 'DateTime'>
    readonly updatedAt: FieldRef<"TariffRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TariffRate findUnique
   */
  export type TariffRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate findUniqueOrThrow
   */
  export type TariffRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate findFirst
   */
  export type TariffRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffRates.
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffRates.
     */
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffRate findFirstOrThrow
   */
  export type TariffRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffRates.
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffRates.
     */
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffRate findMany
   */
  export type TariffRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRates to fetch.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TariffRates.
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffRate create
   */
  export type TariffRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * The data needed to create a TariffRate.
     */
    data: XOR<TariffRateCreateInput, TariffRateUncheckedCreateInput>
  }

  /**
   * TariffRate createMany
   */
  export type TariffRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TariffRates.
     */
    data: TariffRateCreateManyInput | TariffRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TariffRate createManyAndReturn
   */
  export type TariffRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TariffRates.
     */
    data: TariffRateCreateManyInput | TariffRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TariffRate update
   */
  export type TariffRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * The data needed to update a TariffRate.
     */
    data: XOR<TariffRateUpdateInput, TariffRateUncheckedUpdateInput>
    /**
     * Choose, which TariffRate to update.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate updateMany
   */
  export type TariffRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TariffRates.
     */
    data: XOR<TariffRateUpdateManyMutationInput, TariffRateUncheckedUpdateManyInput>
    /**
     * Filter which TariffRates to update
     */
    where?: TariffRateWhereInput
  }

  /**
   * TariffRate upsert
   */
  export type TariffRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * The filter to search for the TariffRate to update in case it exists.
     */
    where: TariffRateWhereUniqueInput
    /**
     * In case the TariffRate found by the `where` argument doesn't exist, create a new TariffRate with this data.
     */
    create: XOR<TariffRateCreateInput, TariffRateUncheckedCreateInput>
    /**
     * In case the TariffRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TariffRateUpdateInput, TariffRateUncheckedUpdateInput>
  }

  /**
   * TariffRate delete
   */
  export type TariffRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter which TariffRate to delete.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate deleteMany
   */
  export type TariffRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffRates to delete
     */
    where?: TariffRateWhereInput
  }

  /**
   * TariffRate without action
   */
  export type TariffRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
  }


  /**
   * Model ConsentRecord
   */

  export type AggregateConsentRecord = {
    _count: ConsentRecordCountAggregateOutputType | null
    _min: ConsentRecordMinAggregateOutputType | null
    _max: ConsentRecordMaxAggregateOutputType | null
  }

  export type ConsentRecordMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    scope: $Enums.ConsentScope | null
    purpose: string | null
    status: $Enums.ConsentStatus | null
    createdAt: Date | null
  }

  export type ConsentRecordMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    scope: $Enums.ConsentScope | null
    purpose: string | null
    status: $Enums.ConsentStatus | null
    createdAt: Date | null
  }

  export type ConsentRecordCountAggregateOutputType = {
    id: number
    patientId: number
    scope: number
    purpose: number
    status: number
    createdAt: number
    _all: number
  }


  export type ConsentRecordMinAggregateInputType = {
    id?: true
    patientId?: true
    scope?: true
    purpose?: true
    status?: true
    createdAt?: true
  }

  export type ConsentRecordMaxAggregateInputType = {
    id?: true
    patientId?: true
    scope?: true
    purpose?: true
    status?: true
    createdAt?: true
  }

  export type ConsentRecordCountAggregateInputType = {
    id?: true
    patientId?: true
    scope?: true
    purpose?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ConsentRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsentRecord to aggregate.
     */
    where?: ConsentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentRecords to fetch.
     */
    orderBy?: ConsentRecordOrderByWithRelationInput | ConsentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsentRecords
    **/
    _count?: true | ConsentRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsentRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsentRecordMaxAggregateInputType
  }

  export type GetConsentRecordAggregateType<T extends ConsentRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateConsentRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsentRecord[P]>
      : GetScalarType<T[P], AggregateConsentRecord[P]>
  }




  export type ConsentRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentRecordWhereInput
    orderBy?: ConsentRecordOrderByWithAggregationInput | ConsentRecordOrderByWithAggregationInput[]
    by: ConsentRecordScalarFieldEnum[] | ConsentRecordScalarFieldEnum
    having?: ConsentRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsentRecordCountAggregateInputType | true
    _min?: ConsentRecordMinAggregateInputType
    _max?: ConsentRecordMaxAggregateInputType
  }

  export type ConsentRecordGroupByOutputType = {
    id: string
    patientId: string
    scope: $Enums.ConsentScope
    purpose: string
    status: $Enums.ConsentStatus
    createdAt: Date
    _count: ConsentRecordCountAggregateOutputType | null
    _min: ConsentRecordMinAggregateOutputType | null
    _max: ConsentRecordMaxAggregateOutputType | null
  }

  type GetConsentRecordGroupByPayload<T extends ConsentRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsentRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsentRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsentRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ConsentRecordGroupByOutputType[P]>
        }
      >
    >


  export type ConsentRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    scope?: boolean
    purpose?: boolean
    status?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consentRecord"]>

  export type ConsentRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    scope?: boolean
    purpose?: boolean
    status?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consentRecord"]>

  export type ConsentRecordSelectScalar = {
    id?: boolean
    patientId?: boolean
    scope?: boolean
    purpose?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ConsentRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ConsentRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $ConsentRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsentRecord"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      scope: $Enums.ConsentScope
      purpose: string
      status: $Enums.ConsentStatus
      createdAt: Date
    }, ExtArgs["result"]["consentRecord"]>
    composites: {}
  }

  type ConsentRecordGetPayload<S extends boolean | null | undefined | ConsentRecordDefaultArgs> = $Result.GetResult<Prisma.$ConsentRecordPayload, S>

  type ConsentRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsentRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsentRecordCountAggregateInputType | true
    }

  export interface ConsentRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsentRecord'], meta: { name: 'ConsentRecord' } }
    /**
     * Find zero or one ConsentRecord that matches the filter.
     * @param {ConsentRecordFindUniqueArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsentRecordFindUniqueArgs>(args: SelectSubset<T, ConsentRecordFindUniqueArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConsentRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsentRecordFindUniqueOrThrowArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsentRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsentRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConsentRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordFindFirstArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsentRecordFindFirstArgs>(args?: SelectSubset<T, ConsentRecordFindFirstArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConsentRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordFindFirstOrThrowArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsentRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsentRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConsentRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsentRecords
     * const consentRecords = await prisma.consentRecord.findMany()
     * 
     * // Get first 10 ConsentRecords
     * const consentRecords = await prisma.consentRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consentRecordWithIdOnly = await prisma.consentRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsentRecordFindManyArgs>(args?: SelectSubset<T, ConsentRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConsentRecord.
     * @param {ConsentRecordCreateArgs} args - Arguments to create a ConsentRecord.
     * @example
     * // Create one ConsentRecord
     * const ConsentRecord = await prisma.consentRecord.create({
     *   data: {
     *     // ... data to create a ConsentRecord
     *   }
     * })
     * 
     */
    create<T extends ConsentRecordCreateArgs>(args: SelectSubset<T, ConsentRecordCreateArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConsentRecords.
     * @param {ConsentRecordCreateManyArgs} args - Arguments to create many ConsentRecords.
     * @example
     * // Create many ConsentRecords
     * const consentRecord = await prisma.consentRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsentRecordCreateManyArgs>(args?: SelectSubset<T, ConsentRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsentRecords and returns the data saved in the database.
     * @param {ConsentRecordCreateManyAndReturnArgs} args - Arguments to create many ConsentRecords.
     * @example
     * // Create many ConsentRecords
     * const consentRecord = await prisma.consentRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsentRecords and only return the `id`
     * const consentRecordWithIdOnly = await prisma.consentRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsentRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsentRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConsentRecord.
     * @param {ConsentRecordDeleteArgs} args - Arguments to delete one ConsentRecord.
     * @example
     * // Delete one ConsentRecord
     * const ConsentRecord = await prisma.consentRecord.delete({
     *   where: {
     *     // ... filter to delete one ConsentRecord
     *   }
     * })
     * 
     */
    delete<T extends ConsentRecordDeleteArgs>(args: SelectSubset<T, ConsentRecordDeleteArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConsentRecord.
     * @param {ConsentRecordUpdateArgs} args - Arguments to update one ConsentRecord.
     * @example
     * // Update one ConsentRecord
     * const consentRecord = await prisma.consentRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsentRecordUpdateArgs>(args: SelectSubset<T, ConsentRecordUpdateArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConsentRecords.
     * @param {ConsentRecordDeleteManyArgs} args - Arguments to filter ConsentRecords to delete.
     * @example
     * // Delete a few ConsentRecords
     * const { count } = await prisma.consentRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsentRecordDeleteManyArgs>(args?: SelectSubset<T, ConsentRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsentRecords
     * const consentRecord = await prisma.consentRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsentRecordUpdateManyArgs>(args: SelectSubset<T, ConsentRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsentRecord.
     * @param {ConsentRecordUpsertArgs} args - Arguments to update or create a ConsentRecord.
     * @example
     * // Update or create a ConsentRecord
     * const consentRecord = await prisma.consentRecord.upsert({
     *   create: {
     *     // ... data to create a ConsentRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsentRecord we want to update
     *   }
     * })
     */
    upsert<T extends ConsentRecordUpsertArgs>(args: SelectSubset<T, ConsentRecordUpsertArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConsentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordCountArgs} args - Arguments to filter ConsentRecords to count.
     * @example
     * // Count the number of ConsentRecords
     * const count = await prisma.consentRecord.count({
     *   where: {
     *     // ... the filter for the ConsentRecords we want to count
     *   }
     * })
    **/
    count<T extends ConsentRecordCountArgs>(
      args?: Subset<T, ConsentRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsentRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsentRecordAggregateArgs>(args: Subset<T, ConsentRecordAggregateArgs>): Prisma.PrismaPromise<GetConsentRecordAggregateType<T>>

    /**
     * Group by ConsentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsentRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsentRecordGroupByArgs['orderBy'] }
        : { orderBy?: ConsentRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsentRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsentRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsentRecord model
   */
  readonly fields: ConsentRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsentRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsentRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsentRecord model
   */ 
  interface ConsentRecordFieldRefs {
    readonly id: FieldRef<"ConsentRecord", 'String'>
    readonly patientId: FieldRef<"ConsentRecord", 'String'>
    readonly scope: FieldRef<"ConsentRecord", 'ConsentScope'>
    readonly purpose: FieldRef<"ConsentRecord", 'String'>
    readonly status: FieldRef<"ConsentRecord", 'ConsentStatus'>
    readonly createdAt: FieldRef<"ConsentRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsentRecord findUnique
   */
  export type ConsentRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter, which ConsentRecord to fetch.
     */
    where: ConsentRecordWhereUniqueInput
  }

  /**
   * ConsentRecord findUniqueOrThrow
   */
  export type ConsentRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter, which ConsentRecord to fetch.
     */
    where: ConsentRecordWhereUniqueInput
  }

  /**
   * ConsentRecord findFirst
   */
  export type ConsentRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter, which ConsentRecord to fetch.
     */
    where?: ConsentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentRecords to fetch.
     */
    orderBy?: ConsentRecordOrderByWithRelationInput | ConsentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsentRecords.
     */
    cursor?: ConsentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsentRecords.
     */
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * ConsentRecord findFirstOrThrow
   */
  export type ConsentRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter, which ConsentRecord to fetch.
     */
    where?: ConsentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentRecords to fetch.
     */
    orderBy?: ConsentRecordOrderByWithRelationInput | ConsentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsentRecords.
     */
    cursor?: ConsentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsentRecords.
     */
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * ConsentRecord findMany
   */
  export type ConsentRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter, which ConsentRecords to fetch.
     */
    where?: ConsentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentRecords to fetch.
     */
    orderBy?: ConsentRecordOrderByWithRelationInput | ConsentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsentRecords.
     */
    cursor?: ConsentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentRecords.
     */
    skip?: number
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * ConsentRecord create
   */
  export type ConsentRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a ConsentRecord.
     */
    data: XOR<ConsentRecordCreateInput, ConsentRecordUncheckedCreateInput>
  }

  /**
   * ConsentRecord createMany
   */
  export type ConsentRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsentRecords.
     */
    data: ConsentRecordCreateManyInput | ConsentRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConsentRecord createManyAndReturn
   */
  export type ConsentRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConsentRecords.
     */
    data: ConsentRecordCreateManyInput | ConsentRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConsentRecord update
   */
  export type ConsentRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a ConsentRecord.
     */
    data: XOR<ConsentRecordUpdateInput, ConsentRecordUncheckedUpdateInput>
    /**
     * Choose, which ConsentRecord to update.
     */
    where: ConsentRecordWhereUniqueInput
  }

  /**
   * ConsentRecord updateMany
   */
  export type ConsentRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsentRecords.
     */
    data: XOR<ConsentRecordUpdateManyMutationInput, ConsentRecordUncheckedUpdateManyInput>
    /**
     * Filter which ConsentRecords to update
     */
    where?: ConsentRecordWhereInput
  }

  /**
   * ConsentRecord upsert
   */
  export type ConsentRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the ConsentRecord to update in case it exists.
     */
    where: ConsentRecordWhereUniqueInput
    /**
     * In case the ConsentRecord found by the `where` argument doesn't exist, create a new ConsentRecord with this data.
     */
    create: XOR<ConsentRecordCreateInput, ConsentRecordUncheckedCreateInput>
    /**
     * In case the ConsentRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsentRecordUpdateInput, ConsentRecordUncheckedUpdateInput>
  }

  /**
   * ConsentRecord delete
   */
  export type ConsentRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter which ConsentRecord to delete.
     */
    where: ConsentRecordWhereUniqueInput
  }

  /**
   * ConsentRecord deleteMany
   */
  export type ConsentRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsentRecords to delete
     */
    where?: ConsentRecordWhereInput
  }

  /**
   * ConsentRecord without action
   */
  export type ConsentRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
  }


  /**
   * Model RtbfRequest
   */

  export type AggregateRtbfRequest = {
    _count: RtbfRequestCountAggregateOutputType | null
    _min: RtbfRequestMinAggregateOutputType | null
    _max: RtbfRequestMaxAggregateOutputType | null
  }

  export type RtbfRequestMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    reason: string | null
    status: $Enums.RtbfStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RtbfRequestMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    reason: string | null
    status: $Enums.RtbfStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RtbfRequestCountAggregateOutputType = {
    id: number
    patientId: number
    reason: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RtbfRequestMinAggregateInputType = {
    id?: true
    patientId?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RtbfRequestMaxAggregateInputType = {
    id?: true
    patientId?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RtbfRequestCountAggregateInputType = {
    id?: true
    patientId?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RtbfRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RtbfRequest to aggregate.
     */
    where?: RtbfRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RtbfRequests to fetch.
     */
    orderBy?: RtbfRequestOrderByWithRelationInput | RtbfRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RtbfRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RtbfRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RtbfRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RtbfRequests
    **/
    _count?: true | RtbfRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RtbfRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RtbfRequestMaxAggregateInputType
  }

  export type GetRtbfRequestAggregateType<T extends RtbfRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRtbfRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRtbfRequest[P]>
      : GetScalarType<T[P], AggregateRtbfRequest[P]>
  }




  export type RtbfRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RtbfRequestWhereInput
    orderBy?: RtbfRequestOrderByWithAggregationInput | RtbfRequestOrderByWithAggregationInput[]
    by: RtbfRequestScalarFieldEnum[] | RtbfRequestScalarFieldEnum
    having?: RtbfRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RtbfRequestCountAggregateInputType | true
    _min?: RtbfRequestMinAggregateInputType
    _max?: RtbfRequestMaxAggregateInputType
  }

  export type RtbfRequestGroupByOutputType = {
    id: string
    patientId: string
    reason: string
    status: $Enums.RtbfStatus
    createdAt: Date
    updatedAt: Date
    _count: RtbfRequestCountAggregateOutputType | null
    _min: RtbfRequestMinAggregateOutputType | null
    _max: RtbfRequestMaxAggregateOutputType | null
  }

  type GetRtbfRequestGroupByPayload<T extends RtbfRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RtbfRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RtbfRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RtbfRequestGroupByOutputType[P]>
            : GetScalarType<T[P], RtbfRequestGroupByOutputType[P]>
        }
      >
    >


  export type RtbfRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rtbfRequest"]>

  export type RtbfRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rtbfRequest"]>

  export type RtbfRequestSelectScalar = {
    id?: boolean
    patientId?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RtbfRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type RtbfRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $RtbfRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RtbfRequest"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      reason: string
      status: $Enums.RtbfStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rtbfRequest"]>
    composites: {}
  }

  type RtbfRequestGetPayload<S extends boolean | null | undefined | RtbfRequestDefaultArgs> = $Result.GetResult<Prisma.$RtbfRequestPayload, S>

  type RtbfRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RtbfRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RtbfRequestCountAggregateInputType | true
    }

  export interface RtbfRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RtbfRequest'], meta: { name: 'RtbfRequest' } }
    /**
     * Find zero or one RtbfRequest that matches the filter.
     * @param {RtbfRequestFindUniqueArgs} args - Arguments to find a RtbfRequest
     * @example
     * // Get one RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RtbfRequestFindUniqueArgs>(args: SelectSubset<T, RtbfRequestFindUniqueArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RtbfRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RtbfRequestFindUniqueOrThrowArgs} args - Arguments to find a RtbfRequest
     * @example
     * // Get one RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RtbfRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RtbfRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RtbfRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestFindFirstArgs} args - Arguments to find a RtbfRequest
     * @example
     * // Get one RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RtbfRequestFindFirstArgs>(args?: SelectSubset<T, RtbfRequestFindFirstArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RtbfRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestFindFirstOrThrowArgs} args - Arguments to find a RtbfRequest
     * @example
     * // Get one RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RtbfRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RtbfRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RtbfRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RtbfRequests
     * const rtbfRequests = await prisma.rtbfRequest.findMany()
     * 
     * // Get first 10 RtbfRequests
     * const rtbfRequests = await prisma.rtbfRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rtbfRequestWithIdOnly = await prisma.rtbfRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RtbfRequestFindManyArgs>(args?: SelectSubset<T, RtbfRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RtbfRequest.
     * @param {RtbfRequestCreateArgs} args - Arguments to create a RtbfRequest.
     * @example
     * // Create one RtbfRequest
     * const RtbfRequest = await prisma.rtbfRequest.create({
     *   data: {
     *     // ... data to create a RtbfRequest
     *   }
     * })
     * 
     */
    create<T extends RtbfRequestCreateArgs>(args: SelectSubset<T, RtbfRequestCreateArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RtbfRequests.
     * @param {RtbfRequestCreateManyArgs} args - Arguments to create many RtbfRequests.
     * @example
     * // Create many RtbfRequests
     * const rtbfRequest = await prisma.rtbfRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RtbfRequestCreateManyArgs>(args?: SelectSubset<T, RtbfRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RtbfRequests and returns the data saved in the database.
     * @param {RtbfRequestCreateManyAndReturnArgs} args - Arguments to create many RtbfRequests.
     * @example
     * // Create many RtbfRequests
     * const rtbfRequest = await prisma.rtbfRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RtbfRequests and only return the `id`
     * const rtbfRequestWithIdOnly = await prisma.rtbfRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RtbfRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RtbfRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RtbfRequest.
     * @param {RtbfRequestDeleteArgs} args - Arguments to delete one RtbfRequest.
     * @example
     * // Delete one RtbfRequest
     * const RtbfRequest = await prisma.rtbfRequest.delete({
     *   where: {
     *     // ... filter to delete one RtbfRequest
     *   }
     * })
     * 
     */
    delete<T extends RtbfRequestDeleteArgs>(args: SelectSubset<T, RtbfRequestDeleteArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RtbfRequest.
     * @param {RtbfRequestUpdateArgs} args - Arguments to update one RtbfRequest.
     * @example
     * // Update one RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RtbfRequestUpdateArgs>(args: SelectSubset<T, RtbfRequestUpdateArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RtbfRequests.
     * @param {RtbfRequestDeleteManyArgs} args - Arguments to filter RtbfRequests to delete.
     * @example
     * // Delete a few RtbfRequests
     * const { count } = await prisma.rtbfRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RtbfRequestDeleteManyArgs>(args?: SelectSubset<T, RtbfRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RtbfRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RtbfRequests
     * const rtbfRequest = await prisma.rtbfRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RtbfRequestUpdateManyArgs>(args: SelectSubset<T, RtbfRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RtbfRequest.
     * @param {RtbfRequestUpsertArgs} args - Arguments to update or create a RtbfRequest.
     * @example
     * // Update or create a RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.upsert({
     *   create: {
     *     // ... data to create a RtbfRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RtbfRequest we want to update
     *   }
     * })
     */
    upsert<T extends RtbfRequestUpsertArgs>(args: SelectSubset<T, RtbfRequestUpsertArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RtbfRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestCountArgs} args - Arguments to filter RtbfRequests to count.
     * @example
     * // Count the number of RtbfRequests
     * const count = await prisma.rtbfRequest.count({
     *   where: {
     *     // ... the filter for the RtbfRequests we want to count
     *   }
     * })
    **/
    count<T extends RtbfRequestCountArgs>(
      args?: Subset<T, RtbfRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RtbfRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RtbfRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RtbfRequestAggregateArgs>(args: Subset<T, RtbfRequestAggregateArgs>): Prisma.PrismaPromise<GetRtbfRequestAggregateType<T>>

    /**
     * Group by RtbfRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RtbfRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RtbfRequestGroupByArgs['orderBy'] }
        : { orderBy?: RtbfRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RtbfRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRtbfRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RtbfRequest model
   */
  readonly fields: RtbfRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RtbfRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RtbfRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RtbfRequest model
   */ 
  interface RtbfRequestFieldRefs {
    readonly id: FieldRef<"RtbfRequest", 'String'>
    readonly patientId: FieldRef<"RtbfRequest", 'String'>
    readonly reason: FieldRef<"RtbfRequest", 'String'>
    readonly status: FieldRef<"RtbfRequest", 'RtbfStatus'>
    readonly createdAt: FieldRef<"RtbfRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"RtbfRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RtbfRequest findUnique
   */
  export type RtbfRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter, which RtbfRequest to fetch.
     */
    where: RtbfRequestWhereUniqueInput
  }

  /**
   * RtbfRequest findUniqueOrThrow
   */
  export type RtbfRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter, which RtbfRequest to fetch.
     */
    where: RtbfRequestWhereUniqueInput
  }

  /**
   * RtbfRequest findFirst
   */
  export type RtbfRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter, which RtbfRequest to fetch.
     */
    where?: RtbfRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RtbfRequests to fetch.
     */
    orderBy?: RtbfRequestOrderByWithRelationInput | RtbfRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RtbfRequests.
     */
    cursor?: RtbfRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RtbfRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RtbfRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RtbfRequests.
     */
    distinct?: RtbfRequestScalarFieldEnum | RtbfRequestScalarFieldEnum[]
  }

  /**
   * RtbfRequest findFirstOrThrow
   */
  export type RtbfRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter, which RtbfRequest to fetch.
     */
    where?: RtbfRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RtbfRequests to fetch.
     */
    orderBy?: RtbfRequestOrderByWithRelationInput | RtbfRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RtbfRequests.
     */
    cursor?: RtbfRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RtbfRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RtbfRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RtbfRequests.
     */
    distinct?: RtbfRequestScalarFieldEnum | RtbfRequestScalarFieldEnum[]
  }

  /**
   * RtbfRequest findMany
   */
  export type RtbfRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter, which RtbfRequests to fetch.
     */
    where?: RtbfRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RtbfRequests to fetch.
     */
    orderBy?: RtbfRequestOrderByWithRelationInput | RtbfRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RtbfRequests.
     */
    cursor?: RtbfRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RtbfRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RtbfRequests.
     */
    skip?: number
    distinct?: RtbfRequestScalarFieldEnum | RtbfRequestScalarFieldEnum[]
  }

  /**
   * RtbfRequest create
   */
  export type RtbfRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a RtbfRequest.
     */
    data: XOR<RtbfRequestCreateInput, RtbfRequestUncheckedCreateInput>
  }

  /**
   * RtbfRequest createMany
   */
  export type RtbfRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RtbfRequests.
     */
    data: RtbfRequestCreateManyInput | RtbfRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RtbfRequest createManyAndReturn
   */
  export type RtbfRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RtbfRequests.
     */
    data: RtbfRequestCreateManyInput | RtbfRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RtbfRequest update
   */
  export type RtbfRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a RtbfRequest.
     */
    data: XOR<RtbfRequestUpdateInput, RtbfRequestUncheckedUpdateInput>
    /**
     * Choose, which RtbfRequest to update.
     */
    where: RtbfRequestWhereUniqueInput
  }

  /**
   * RtbfRequest updateMany
   */
  export type RtbfRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RtbfRequests.
     */
    data: XOR<RtbfRequestUpdateManyMutationInput, RtbfRequestUncheckedUpdateManyInput>
    /**
     * Filter which RtbfRequests to update
     */
    where?: RtbfRequestWhereInput
  }

  /**
   * RtbfRequest upsert
   */
  export type RtbfRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the RtbfRequest to update in case it exists.
     */
    where: RtbfRequestWhereUniqueInput
    /**
     * In case the RtbfRequest found by the `where` argument doesn't exist, create a new RtbfRequest with this data.
     */
    create: XOR<RtbfRequestCreateInput, RtbfRequestUncheckedCreateInput>
    /**
     * In case the RtbfRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RtbfRequestUpdateInput, RtbfRequestUncheckedUpdateInput>
  }

  /**
   * RtbfRequest delete
   */
  export type RtbfRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter which RtbfRequest to delete.
     */
    where: RtbfRequestWhereUniqueInput
  }

  /**
   * RtbfRequest deleteMany
   */
  export type RtbfRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RtbfRequests to delete
     */
    where?: RtbfRequestWhereInput
  }

  /**
   * RtbfRequest without action
   */
  export type RtbfRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
  }


  /**
   * Model StatutoryCase
   */

  export type AggregateStatutoryCase = {
    _count: StatutoryCaseCountAggregateOutputType | null
    _min: StatutoryCaseMinAggregateOutputType | null
    _max: StatutoryCaseMaxAggregateOutputType | null
  }

  export type StatutoryCaseMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    patientId: string | null
    program: string | null
    disease: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatutoryCaseMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    patientId: string | null
    program: string | null
    disease: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatutoryCaseCountAggregateOutputType = {
    id: number
    branchId: number
    patientId: number
    program: number
    disease: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatutoryCaseMinAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    program?: true
    disease?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatutoryCaseMaxAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    program?: true
    disease?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatutoryCaseCountAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    program?: true
    disease?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatutoryCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatutoryCase to aggregate.
     */
    where?: StatutoryCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatutoryCases to fetch.
     */
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatutoryCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatutoryCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatutoryCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatutoryCases
    **/
    _count?: true | StatutoryCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatutoryCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatutoryCaseMaxAggregateInputType
  }

  export type GetStatutoryCaseAggregateType<T extends StatutoryCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateStatutoryCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatutoryCase[P]>
      : GetScalarType<T[P], AggregateStatutoryCase[P]>
  }




  export type StatutoryCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatutoryCaseWhereInput
    orderBy?: StatutoryCaseOrderByWithAggregationInput | StatutoryCaseOrderByWithAggregationInput[]
    by: StatutoryCaseScalarFieldEnum[] | StatutoryCaseScalarFieldEnum
    having?: StatutoryCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatutoryCaseCountAggregateInputType | true
    _min?: StatutoryCaseMinAggregateInputType
    _max?: StatutoryCaseMaxAggregateInputType
  }

  export type StatutoryCaseGroupByOutputType = {
    id: string
    branchId: string
    patientId: string
    program: string
    disease: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: StatutoryCaseCountAggregateOutputType | null
    _min: StatutoryCaseMinAggregateOutputType | null
    _max: StatutoryCaseMaxAggregateOutputType | null
  }

  type GetStatutoryCaseGroupByPayload<T extends StatutoryCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatutoryCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatutoryCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatutoryCaseGroupByOutputType[P]>
            : GetScalarType<T[P], StatutoryCaseGroupByOutputType[P]>
        }
      >
    >


  export type StatutoryCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    program?: boolean
    disease?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statutoryCase"]>

  export type StatutoryCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    program?: boolean
    disease?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statutoryCase"]>

  export type StatutoryCaseSelectScalar = {
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    program?: boolean
    disease?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StatutoryCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type StatutoryCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $StatutoryCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatutoryCase"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      patientId: string
      program: string
      disease: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["statutoryCase"]>
    composites: {}
  }

  type StatutoryCaseGetPayload<S extends boolean | null | undefined | StatutoryCaseDefaultArgs> = $Result.GetResult<Prisma.$StatutoryCasePayload, S>

  type StatutoryCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StatutoryCaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StatutoryCaseCountAggregateInputType | true
    }

  export interface StatutoryCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatutoryCase'], meta: { name: 'StatutoryCase' } }
    /**
     * Find zero or one StatutoryCase that matches the filter.
     * @param {StatutoryCaseFindUniqueArgs} args - Arguments to find a StatutoryCase
     * @example
     * // Get one StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatutoryCaseFindUniqueArgs>(args: SelectSubset<T, StatutoryCaseFindUniqueArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StatutoryCase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StatutoryCaseFindUniqueOrThrowArgs} args - Arguments to find a StatutoryCase
     * @example
     * // Get one StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatutoryCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, StatutoryCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StatutoryCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseFindFirstArgs} args - Arguments to find a StatutoryCase
     * @example
     * // Get one StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatutoryCaseFindFirstArgs>(args?: SelectSubset<T, StatutoryCaseFindFirstArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StatutoryCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseFindFirstOrThrowArgs} args - Arguments to find a StatutoryCase
     * @example
     * // Get one StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatutoryCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, StatutoryCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StatutoryCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatutoryCases
     * const statutoryCases = await prisma.statutoryCase.findMany()
     * 
     * // Get first 10 StatutoryCases
     * const statutoryCases = await prisma.statutoryCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statutoryCaseWithIdOnly = await prisma.statutoryCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatutoryCaseFindManyArgs>(args?: SelectSubset<T, StatutoryCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StatutoryCase.
     * @param {StatutoryCaseCreateArgs} args - Arguments to create a StatutoryCase.
     * @example
     * // Create one StatutoryCase
     * const StatutoryCase = await prisma.statutoryCase.create({
     *   data: {
     *     // ... data to create a StatutoryCase
     *   }
     * })
     * 
     */
    create<T extends StatutoryCaseCreateArgs>(args: SelectSubset<T, StatutoryCaseCreateArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StatutoryCases.
     * @param {StatutoryCaseCreateManyArgs} args - Arguments to create many StatutoryCases.
     * @example
     * // Create many StatutoryCases
     * const statutoryCase = await prisma.statutoryCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatutoryCaseCreateManyArgs>(args?: SelectSubset<T, StatutoryCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatutoryCases and returns the data saved in the database.
     * @param {StatutoryCaseCreateManyAndReturnArgs} args - Arguments to create many StatutoryCases.
     * @example
     * // Create many StatutoryCases
     * const statutoryCase = await prisma.statutoryCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatutoryCases and only return the `id`
     * const statutoryCaseWithIdOnly = await prisma.statutoryCase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatutoryCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, StatutoryCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StatutoryCase.
     * @param {StatutoryCaseDeleteArgs} args - Arguments to delete one StatutoryCase.
     * @example
     * // Delete one StatutoryCase
     * const StatutoryCase = await prisma.statutoryCase.delete({
     *   where: {
     *     // ... filter to delete one StatutoryCase
     *   }
     * })
     * 
     */
    delete<T extends StatutoryCaseDeleteArgs>(args: SelectSubset<T, StatutoryCaseDeleteArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StatutoryCase.
     * @param {StatutoryCaseUpdateArgs} args - Arguments to update one StatutoryCase.
     * @example
     * // Update one StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatutoryCaseUpdateArgs>(args: SelectSubset<T, StatutoryCaseUpdateArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StatutoryCases.
     * @param {StatutoryCaseDeleteManyArgs} args - Arguments to filter StatutoryCases to delete.
     * @example
     * // Delete a few StatutoryCases
     * const { count } = await prisma.statutoryCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatutoryCaseDeleteManyArgs>(args?: SelectSubset<T, StatutoryCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatutoryCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatutoryCases
     * const statutoryCase = await prisma.statutoryCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatutoryCaseUpdateManyArgs>(args: SelectSubset<T, StatutoryCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatutoryCase.
     * @param {StatutoryCaseUpsertArgs} args - Arguments to update or create a StatutoryCase.
     * @example
     * // Update or create a StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.upsert({
     *   create: {
     *     // ... data to create a StatutoryCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatutoryCase we want to update
     *   }
     * })
     */
    upsert<T extends StatutoryCaseUpsertArgs>(args: SelectSubset<T, StatutoryCaseUpsertArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StatutoryCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseCountArgs} args - Arguments to filter StatutoryCases to count.
     * @example
     * // Count the number of StatutoryCases
     * const count = await prisma.statutoryCase.count({
     *   where: {
     *     // ... the filter for the StatutoryCases we want to count
     *   }
     * })
    **/
    count<T extends StatutoryCaseCountArgs>(
      args?: Subset<T, StatutoryCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatutoryCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatutoryCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatutoryCaseAggregateArgs>(args: Subset<T, StatutoryCaseAggregateArgs>): Prisma.PrismaPromise<GetStatutoryCaseAggregateType<T>>

    /**
     * Group by StatutoryCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatutoryCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatutoryCaseGroupByArgs['orderBy'] }
        : { orderBy?: StatutoryCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatutoryCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatutoryCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatutoryCase model
   */
  readonly fields: StatutoryCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatutoryCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatutoryCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatutoryCase model
   */ 
  interface StatutoryCaseFieldRefs {
    readonly id: FieldRef<"StatutoryCase", 'String'>
    readonly branchId: FieldRef<"StatutoryCase", 'String'>
    readonly patientId: FieldRef<"StatutoryCase", 'String'>
    readonly program: FieldRef<"StatutoryCase", 'String'>
    readonly disease: FieldRef<"StatutoryCase", 'String'>
    readonly status: FieldRef<"StatutoryCase", 'String'>
    readonly createdAt: FieldRef<"StatutoryCase", 'DateTime'>
    readonly updatedAt: FieldRef<"StatutoryCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatutoryCase findUnique
   */
  export type StatutoryCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter, which StatutoryCase to fetch.
     */
    where: StatutoryCaseWhereUniqueInput
  }

  /**
   * StatutoryCase findUniqueOrThrow
   */
  export type StatutoryCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter, which StatutoryCase to fetch.
     */
    where: StatutoryCaseWhereUniqueInput
  }

  /**
   * StatutoryCase findFirst
   */
  export type StatutoryCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter, which StatutoryCase to fetch.
     */
    where?: StatutoryCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatutoryCases to fetch.
     */
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatutoryCases.
     */
    cursor?: StatutoryCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatutoryCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatutoryCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatutoryCases.
     */
    distinct?: StatutoryCaseScalarFieldEnum | StatutoryCaseScalarFieldEnum[]
  }

  /**
   * StatutoryCase findFirstOrThrow
   */
  export type StatutoryCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter, which StatutoryCase to fetch.
     */
    where?: StatutoryCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatutoryCases to fetch.
     */
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatutoryCases.
     */
    cursor?: StatutoryCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatutoryCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatutoryCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatutoryCases.
     */
    distinct?: StatutoryCaseScalarFieldEnum | StatutoryCaseScalarFieldEnum[]
  }

  /**
   * StatutoryCase findMany
   */
  export type StatutoryCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter, which StatutoryCases to fetch.
     */
    where?: StatutoryCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatutoryCases to fetch.
     */
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatutoryCases.
     */
    cursor?: StatutoryCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatutoryCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatutoryCases.
     */
    skip?: number
    distinct?: StatutoryCaseScalarFieldEnum | StatutoryCaseScalarFieldEnum[]
  }

  /**
   * StatutoryCase create
   */
  export type StatutoryCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a StatutoryCase.
     */
    data: XOR<StatutoryCaseCreateInput, StatutoryCaseUncheckedCreateInput>
  }

  /**
   * StatutoryCase createMany
   */
  export type StatutoryCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatutoryCases.
     */
    data: StatutoryCaseCreateManyInput | StatutoryCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatutoryCase createManyAndReturn
   */
  export type StatutoryCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StatutoryCases.
     */
    data: StatutoryCaseCreateManyInput | StatutoryCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatutoryCase update
   */
  export type StatutoryCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a StatutoryCase.
     */
    data: XOR<StatutoryCaseUpdateInput, StatutoryCaseUncheckedUpdateInput>
    /**
     * Choose, which StatutoryCase to update.
     */
    where: StatutoryCaseWhereUniqueInput
  }

  /**
   * StatutoryCase updateMany
   */
  export type StatutoryCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatutoryCases.
     */
    data: XOR<StatutoryCaseUpdateManyMutationInput, StatutoryCaseUncheckedUpdateManyInput>
    /**
     * Filter which StatutoryCases to update
     */
    where?: StatutoryCaseWhereInput
  }

  /**
   * StatutoryCase upsert
   */
  export type StatutoryCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the StatutoryCase to update in case it exists.
     */
    where: StatutoryCaseWhereUniqueInput
    /**
     * In case the StatutoryCase found by the `where` argument doesn't exist, create a new StatutoryCase with this data.
     */
    create: XOR<StatutoryCaseCreateInput, StatutoryCaseUncheckedCreateInput>
    /**
     * In case the StatutoryCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatutoryCaseUpdateInput, StatutoryCaseUncheckedUpdateInput>
  }

  /**
   * StatutoryCase delete
   */
  export type StatutoryCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter which StatutoryCase to delete.
     */
    where: StatutoryCaseWhereUniqueInput
  }

  /**
   * StatutoryCase deleteMany
   */
  export type StatutoryCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatutoryCases to delete
     */
    where?: StatutoryCaseWhereInput
  }

  /**
   * StatutoryCase without action
   */
  export type StatutoryCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
  }


  /**
   * Model AuditEvent
   */

  export type AggregateAuditEvent = {
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  export type AuditEventMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    actorUserId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditEventMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    actorUserId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditEventCountAggregateOutputType = {
    id: number
    branchId: number
    actorUserId: number
    action: number
    entity: number
    entityId: number
    meta: number
    createdAt: number
    _all: number
  }


  export type AuditEventMinAggregateInputType = {
    id?: true
    branchId?: true
    actorUserId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditEventMaxAggregateInputType = {
    id?: true
    branchId?: true
    actorUserId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditEventCountAggregateInputType = {
    id?: true
    branchId?: true
    actorUserId?: true
    action?: true
    entity?: true
    entityId?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type AuditEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvent to aggregate.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditEvents
    **/
    _count?: true | AuditEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditEventMaxAggregateInputType
  }

  export type GetAuditEventAggregateType<T extends AuditEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditEvent[P]>
      : GetScalarType<T[P], AggregateAuditEvent[P]>
  }




  export type AuditEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithAggregationInput | AuditEventOrderByWithAggregationInput[]
    by: AuditEventScalarFieldEnum[] | AuditEventScalarFieldEnum
    having?: AuditEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditEventCountAggregateInputType | true
    _min?: AuditEventMinAggregateInputType
    _max?: AuditEventMaxAggregateInputType
  }

  export type AuditEventGroupByOutputType = {
    id: string
    branchId: string | null
    actorUserId: string | null
    action: string
    entity: string
    entityId: string | null
    meta: JsonValue | null
    createdAt: Date
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  type GetAuditEventGroupByPayload<T extends AuditEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
            : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
        }
      >
    >


  export type AuditEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    actorUserId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    meta?: boolean
    createdAt?: boolean
    branch?: boolean | AuditEvent$branchArgs<ExtArgs>
    actorUser?: boolean | AuditEvent$actorUserArgs<ExtArgs>
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    actorUserId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    meta?: boolean
    createdAt?: boolean
    branch?: boolean | AuditEvent$branchArgs<ExtArgs>
    actorUser?: boolean | AuditEvent$actorUserArgs<ExtArgs>
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectScalar = {
    id?: boolean
    branchId?: boolean
    actorUserId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type AuditEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | AuditEvent$branchArgs<ExtArgs>
    actorUser?: boolean | AuditEvent$actorUserArgs<ExtArgs>
  }
  export type AuditEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | AuditEvent$branchArgs<ExtArgs>
    actorUser?: boolean | AuditEvent$actorUserArgs<ExtArgs>
  }

  export type $AuditEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditEvent"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      actorUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string | null
      actorUserId: string | null
      action: string
      entity: string
      entityId: string | null
      meta: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditEvent"]>
    composites: {}
  }

  type AuditEventGetPayload<S extends boolean | null | undefined | AuditEventDefaultArgs> = $Result.GetResult<Prisma.$AuditEventPayload, S>

  type AuditEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditEventCountAggregateInputType | true
    }

  export interface AuditEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditEvent'], meta: { name: 'AuditEvent' } }
    /**
     * Find zero or one AuditEvent that matches the filter.
     * @param {AuditEventFindUniqueArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditEventFindUniqueArgs>(args: SelectSubset<T, AuditEventFindUniqueArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditEventFindUniqueOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditEventFindFirstArgs>(args?: SelectSubset<T, AuditEventFindFirstArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany()
     * 
     * // Get first 10 AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditEventFindManyArgs>(args?: SelectSubset<T, AuditEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditEvent.
     * @param {AuditEventCreateArgs} args - Arguments to create a AuditEvent.
     * @example
     * // Create one AuditEvent
     * const AuditEvent = await prisma.auditEvent.create({
     *   data: {
     *     // ... data to create a AuditEvent
     *   }
     * })
     * 
     */
    create<T extends AuditEventCreateArgs>(args: SelectSubset<T, AuditEventCreateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditEvents.
     * @param {AuditEventCreateManyArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditEventCreateManyArgs>(args?: SelectSubset<T, AuditEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditEvents and returns the data saved in the database.
     * @param {AuditEventCreateManyAndReturnArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditEvents and only return the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditEvent.
     * @param {AuditEventDeleteArgs} args - Arguments to delete one AuditEvent.
     * @example
     * // Delete one AuditEvent
     * const AuditEvent = await prisma.auditEvent.delete({
     *   where: {
     *     // ... filter to delete one AuditEvent
     *   }
     * })
     * 
     */
    delete<T extends AuditEventDeleteArgs>(args: SelectSubset<T, AuditEventDeleteArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditEvent.
     * @param {AuditEventUpdateArgs} args - Arguments to update one AuditEvent.
     * @example
     * // Update one AuditEvent
     * const auditEvent = await prisma.auditEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditEventUpdateArgs>(args: SelectSubset<T, AuditEventUpdateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditEvents.
     * @param {AuditEventDeleteManyArgs} args - Arguments to filter AuditEvents to delete.
     * @example
     * // Delete a few AuditEvents
     * const { count } = await prisma.auditEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditEventDeleteManyArgs>(args?: SelectSubset<T, AuditEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditEvents
     * const auditEvent = await prisma.auditEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditEventUpdateManyArgs>(args: SelectSubset<T, AuditEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditEvent.
     * @param {AuditEventUpsertArgs} args - Arguments to update or create a AuditEvent.
     * @example
     * // Update or create a AuditEvent
     * const auditEvent = await prisma.auditEvent.upsert({
     *   create: {
     *     // ... data to create a AuditEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditEvent we want to update
     *   }
     * })
     */
    upsert<T extends AuditEventUpsertArgs>(args: SelectSubset<T, AuditEventUpsertArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventCountArgs} args - Arguments to filter AuditEvents to count.
     * @example
     * // Count the number of AuditEvents
     * const count = await prisma.auditEvent.count({
     *   where: {
     *     // ... the filter for the AuditEvents we want to count
     *   }
     * })
    **/
    count<T extends AuditEventCountArgs>(
      args?: Subset<T, AuditEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditEventAggregateArgs>(args: Subset<T, AuditEventAggregateArgs>): Prisma.PrismaPromise<GetAuditEventAggregateType<T>>

    /**
     * Group by AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditEventGroupByArgs['orderBy'] }
        : { orderBy?: AuditEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditEvent model
   */
  readonly fields: AuditEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends AuditEvent$branchArgs<ExtArgs> = {}>(args?: Subset<T, AuditEvent$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    actorUser<T extends AuditEvent$actorUserArgs<ExtArgs> = {}>(args?: Subset<T, AuditEvent$actorUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditEvent model
   */ 
  interface AuditEventFieldRefs {
    readonly id: FieldRef<"AuditEvent", 'String'>
    readonly branchId: FieldRef<"AuditEvent", 'String'>
    readonly actorUserId: FieldRef<"AuditEvent", 'String'>
    readonly action: FieldRef<"AuditEvent", 'String'>
    readonly entity: FieldRef<"AuditEvent", 'String'>
    readonly entityId: FieldRef<"AuditEvent", 'String'>
    readonly meta: FieldRef<"AuditEvent", 'Json'>
    readonly createdAt: FieldRef<"AuditEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditEvent findUnique
   */
  export type AuditEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findUniqueOrThrow
   */
  export type AuditEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findFirst
   */
  export type AuditEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findFirstOrThrow
   */
  export type AuditEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findMany
   */
  export type AuditEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvents to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent create
   */
  export type AuditEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditEvent.
     */
    data: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
  }

  /**
   * AuditEvent createMany
   */
  export type AuditEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditEvent createManyAndReturn
   */
  export type AuditEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditEvent update
   */
  export type AuditEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditEvent.
     */
    data: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
    /**
     * Choose, which AuditEvent to update.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent updateMany
   */
  export type AuditEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditEvents.
     */
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AuditEvents to update
     */
    where?: AuditEventWhereInput
  }

  /**
   * AuditEvent upsert
   */
  export type AuditEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditEvent to update in case it exists.
     */
    where: AuditEventWhereUniqueInput
    /**
     * In case the AuditEvent found by the `where` argument doesn't exist, create a new AuditEvent with this data.
     */
    create: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
    /**
     * In case the AuditEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
  }

  /**
   * AuditEvent delete
   */
  export type AuditEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter which AuditEvent to delete.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent deleteMany
   */
  export type AuditEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvents to delete
     */
    where?: AuditEventWhereInput
  }

  /**
   * AuditEvent.branch
   */
  export type AuditEvent$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * AuditEvent.actorUser
   */
  export type AuditEvent$actorUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditEvent without action
   */
  export type AuditEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
  }


  /**
   * Model OutboxEvent
   */

  export type AggregateOutboxEvent = {
    _count: OutboxEventCountAggregateOutputType | null
    _avg: OutboxEventAvgAggregateOutputType | null
    _sum: OutboxEventSumAggregateOutputType | null
    _min: OutboxEventMinAggregateOutputType | null
    _max: OutboxEventMaxAggregateOutputType | null
  }

  export type OutboxEventAvgAggregateOutputType = {
    attempts: number | null
  }

  export type OutboxEventSumAggregateOutputType = {
    attempts: number | null
  }

  export type OutboxEventMinAggregateOutputType = {
    id: string | null
    topic: string | null
    key: string | null
    status: $Enums.OutboxStatus | null
    attempts: number | null
    availableAt: Date | null
    lockedAt: Date | null
    sentAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutboxEventMaxAggregateOutputType = {
    id: string | null
    topic: string | null
    key: string | null
    status: $Enums.OutboxStatus | null
    attempts: number | null
    availableAt: Date | null
    lockedAt: Date | null
    sentAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutboxEventCountAggregateOutputType = {
    id: number
    topic: number
    key: number
    payload: number
    status: number
    attempts: number
    availableAt: number
    lockedAt: number
    sentAt: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutboxEventAvgAggregateInputType = {
    attempts?: true
  }

  export type OutboxEventSumAggregateInputType = {
    attempts?: true
  }

  export type OutboxEventMinAggregateInputType = {
    id?: true
    topic?: true
    key?: true
    status?: true
    attempts?: true
    availableAt?: true
    lockedAt?: true
    sentAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutboxEventMaxAggregateInputType = {
    id?: true
    topic?: true
    key?: true
    status?: true
    attempts?: true
    availableAt?: true
    lockedAt?: true
    sentAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutboxEventCountAggregateInputType = {
    id?: true
    topic?: true
    key?: true
    payload?: true
    status?: true
    attempts?: true
    availableAt?: true
    lockedAt?: true
    sentAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutboxEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboxEvent to aggregate.
     */
    where?: OutboxEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboxEvents to fetch.
     */
    orderBy?: OutboxEventOrderByWithRelationInput | OutboxEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutboxEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboxEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboxEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutboxEvents
    **/
    _count?: true | OutboxEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutboxEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutboxEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutboxEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutboxEventMaxAggregateInputType
  }

  export type GetOutboxEventAggregateType<T extends OutboxEventAggregateArgs> = {
        [P in keyof T & keyof AggregateOutboxEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutboxEvent[P]>
      : GetScalarType<T[P], AggregateOutboxEvent[P]>
  }




  export type OutboxEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboxEventWhereInput
    orderBy?: OutboxEventOrderByWithAggregationInput | OutboxEventOrderByWithAggregationInput[]
    by: OutboxEventScalarFieldEnum[] | OutboxEventScalarFieldEnum
    having?: OutboxEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutboxEventCountAggregateInputType | true
    _avg?: OutboxEventAvgAggregateInputType
    _sum?: OutboxEventSumAggregateInputType
    _min?: OutboxEventMinAggregateInputType
    _max?: OutboxEventMaxAggregateInputType
  }

  export type OutboxEventGroupByOutputType = {
    id: string
    topic: string
    key: string | null
    payload: JsonValue
    status: $Enums.OutboxStatus
    attempts: number
    availableAt: Date
    lockedAt: Date | null
    sentAt: Date | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: OutboxEventCountAggregateOutputType | null
    _avg: OutboxEventAvgAggregateOutputType | null
    _sum: OutboxEventSumAggregateOutputType | null
    _min: OutboxEventMinAggregateOutputType | null
    _max: OutboxEventMaxAggregateOutputType | null
  }

  type GetOutboxEventGroupByPayload<T extends OutboxEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutboxEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutboxEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutboxEventGroupByOutputType[P]>
            : GetScalarType<T[P], OutboxEventGroupByOutputType[P]>
        }
      >
    >


  export type OutboxEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    key?: boolean
    payload?: boolean
    status?: boolean
    attempts?: boolean
    availableAt?: boolean
    lockedAt?: boolean
    sentAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["outboxEvent"]>

  export type OutboxEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    key?: boolean
    payload?: boolean
    status?: boolean
    attempts?: boolean
    availableAt?: boolean
    lockedAt?: boolean
    sentAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["outboxEvent"]>

  export type OutboxEventSelectScalar = {
    id?: boolean
    topic?: boolean
    key?: boolean
    payload?: boolean
    status?: boolean
    attempts?: boolean
    availableAt?: boolean
    lockedAt?: boolean
    sentAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $OutboxEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutboxEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topic: string
      key: string | null
      payload: Prisma.JsonValue
      status: $Enums.OutboxStatus
      attempts: number
      availableAt: Date
      lockedAt: Date | null
      sentAt: Date | null
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["outboxEvent"]>
    composites: {}
  }

  type OutboxEventGetPayload<S extends boolean | null | undefined | OutboxEventDefaultArgs> = $Result.GetResult<Prisma.$OutboxEventPayload, S>

  type OutboxEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OutboxEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OutboxEventCountAggregateInputType | true
    }

  export interface OutboxEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutboxEvent'], meta: { name: 'OutboxEvent' } }
    /**
     * Find zero or one OutboxEvent that matches the filter.
     * @param {OutboxEventFindUniqueArgs} args - Arguments to find a OutboxEvent
     * @example
     * // Get one OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutboxEventFindUniqueArgs>(args: SelectSubset<T, OutboxEventFindUniqueArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OutboxEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OutboxEventFindUniqueOrThrowArgs} args - Arguments to find a OutboxEvent
     * @example
     * // Get one OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutboxEventFindUniqueOrThrowArgs>(args: SelectSubset<T, OutboxEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OutboxEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventFindFirstArgs} args - Arguments to find a OutboxEvent
     * @example
     * // Get one OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutboxEventFindFirstArgs>(args?: SelectSubset<T, OutboxEventFindFirstArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OutboxEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventFindFirstOrThrowArgs} args - Arguments to find a OutboxEvent
     * @example
     * // Get one OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutboxEventFindFirstOrThrowArgs>(args?: SelectSubset<T, OutboxEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OutboxEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutboxEvents
     * const outboxEvents = await prisma.outboxEvent.findMany()
     * 
     * // Get first 10 OutboxEvents
     * const outboxEvents = await prisma.outboxEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outboxEventWithIdOnly = await prisma.outboxEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutboxEventFindManyArgs>(args?: SelectSubset<T, OutboxEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OutboxEvent.
     * @param {OutboxEventCreateArgs} args - Arguments to create a OutboxEvent.
     * @example
     * // Create one OutboxEvent
     * const OutboxEvent = await prisma.outboxEvent.create({
     *   data: {
     *     // ... data to create a OutboxEvent
     *   }
     * })
     * 
     */
    create<T extends OutboxEventCreateArgs>(args: SelectSubset<T, OutboxEventCreateArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OutboxEvents.
     * @param {OutboxEventCreateManyArgs} args - Arguments to create many OutboxEvents.
     * @example
     * // Create many OutboxEvents
     * const outboxEvent = await prisma.outboxEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutboxEventCreateManyArgs>(args?: SelectSubset<T, OutboxEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutboxEvents and returns the data saved in the database.
     * @param {OutboxEventCreateManyAndReturnArgs} args - Arguments to create many OutboxEvents.
     * @example
     * // Create many OutboxEvents
     * const outboxEvent = await prisma.outboxEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutboxEvents and only return the `id`
     * const outboxEventWithIdOnly = await prisma.outboxEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutboxEventCreateManyAndReturnArgs>(args?: SelectSubset<T, OutboxEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OutboxEvent.
     * @param {OutboxEventDeleteArgs} args - Arguments to delete one OutboxEvent.
     * @example
     * // Delete one OutboxEvent
     * const OutboxEvent = await prisma.outboxEvent.delete({
     *   where: {
     *     // ... filter to delete one OutboxEvent
     *   }
     * })
     * 
     */
    delete<T extends OutboxEventDeleteArgs>(args: SelectSubset<T, OutboxEventDeleteArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OutboxEvent.
     * @param {OutboxEventUpdateArgs} args - Arguments to update one OutboxEvent.
     * @example
     * // Update one OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutboxEventUpdateArgs>(args: SelectSubset<T, OutboxEventUpdateArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OutboxEvents.
     * @param {OutboxEventDeleteManyArgs} args - Arguments to filter OutboxEvents to delete.
     * @example
     * // Delete a few OutboxEvents
     * const { count } = await prisma.outboxEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutboxEventDeleteManyArgs>(args?: SelectSubset<T, OutboxEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutboxEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutboxEvents
     * const outboxEvent = await prisma.outboxEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutboxEventUpdateManyArgs>(args: SelectSubset<T, OutboxEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OutboxEvent.
     * @param {OutboxEventUpsertArgs} args - Arguments to update or create a OutboxEvent.
     * @example
     * // Update or create a OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.upsert({
     *   create: {
     *     // ... data to create a OutboxEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutboxEvent we want to update
     *   }
     * })
     */
    upsert<T extends OutboxEventUpsertArgs>(args: SelectSubset<T, OutboxEventUpsertArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OutboxEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventCountArgs} args - Arguments to filter OutboxEvents to count.
     * @example
     * // Count the number of OutboxEvents
     * const count = await prisma.outboxEvent.count({
     *   where: {
     *     // ... the filter for the OutboxEvents we want to count
     *   }
     * })
    **/
    count<T extends OutboxEventCountArgs>(
      args?: Subset<T, OutboxEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutboxEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutboxEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutboxEventAggregateArgs>(args: Subset<T, OutboxEventAggregateArgs>): Prisma.PrismaPromise<GetOutboxEventAggregateType<T>>

    /**
     * Group by OutboxEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutboxEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutboxEventGroupByArgs['orderBy'] }
        : { orderBy?: OutboxEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutboxEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutboxEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutboxEvent model
   */
  readonly fields: OutboxEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutboxEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutboxEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutboxEvent model
   */ 
  interface OutboxEventFieldRefs {
    readonly id: FieldRef<"OutboxEvent", 'String'>
    readonly topic: FieldRef<"OutboxEvent", 'String'>
    readonly key: FieldRef<"OutboxEvent", 'String'>
    readonly payload: FieldRef<"OutboxEvent", 'Json'>
    readonly status: FieldRef<"OutboxEvent", 'OutboxStatus'>
    readonly attempts: FieldRef<"OutboxEvent", 'Int'>
    readonly availableAt: FieldRef<"OutboxEvent", 'DateTime'>
    readonly lockedAt: FieldRef<"OutboxEvent", 'DateTime'>
    readonly sentAt: FieldRef<"OutboxEvent", 'DateTime'>
    readonly error: FieldRef<"OutboxEvent", 'String'>
    readonly createdAt: FieldRef<"OutboxEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"OutboxEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutboxEvent findUnique
   */
  export type OutboxEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter, which OutboxEvent to fetch.
     */
    where: OutboxEventWhereUniqueInput
  }

  /**
   * OutboxEvent findUniqueOrThrow
   */
  export type OutboxEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter, which OutboxEvent to fetch.
     */
    where: OutboxEventWhereUniqueInput
  }

  /**
   * OutboxEvent findFirst
   */
  export type OutboxEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter, which OutboxEvent to fetch.
     */
    where?: OutboxEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboxEvents to fetch.
     */
    orderBy?: OutboxEventOrderByWithRelationInput | OutboxEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboxEvents.
     */
    cursor?: OutboxEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboxEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboxEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboxEvents.
     */
    distinct?: OutboxEventScalarFieldEnum | OutboxEventScalarFieldEnum[]
  }

  /**
   * OutboxEvent findFirstOrThrow
   */
  export type OutboxEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter, which OutboxEvent to fetch.
     */
    where?: OutboxEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboxEvents to fetch.
     */
    orderBy?: OutboxEventOrderByWithRelationInput | OutboxEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboxEvents.
     */
    cursor?: OutboxEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboxEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboxEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboxEvents.
     */
    distinct?: OutboxEventScalarFieldEnum | OutboxEventScalarFieldEnum[]
  }

  /**
   * OutboxEvent findMany
   */
  export type OutboxEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter, which OutboxEvents to fetch.
     */
    where?: OutboxEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboxEvents to fetch.
     */
    orderBy?: OutboxEventOrderByWithRelationInput | OutboxEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutboxEvents.
     */
    cursor?: OutboxEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboxEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboxEvents.
     */
    skip?: number
    distinct?: OutboxEventScalarFieldEnum | OutboxEventScalarFieldEnum[]
  }

  /**
   * OutboxEvent create
   */
  export type OutboxEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * The data needed to create a OutboxEvent.
     */
    data: XOR<OutboxEventCreateInput, OutboxEventUncheckedCreateInput>
  }

  /**
   * OutboxEvent createMany
   */
  export type OutboxEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutboxEvents.
     */
    data: OutboxEventCreateManyInput | OutboxEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutboxEvent createManyAndReturn
   */
  export type OutboxEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OutboxEvents.
     */
    data: OutboxEventCreateManyInput | OutboxEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutboxEvent update
   */
  export type OutboxEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * The data needed to update a OutboxEvent.
     */
    data: XOR<OutboxEventUpdateInput, OutboxEventUncheckedUpdateInput>
    /**
     * Choose, which OutboxEvent to update.
     */
    where: OutboxEventWhereUniqueInput
  }

  /**
   * OutboxEvent updateMany
   */
  export type OutboxEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutboxEvents.
     */
    data: XOR<OutboxEventUpdateManyMutationInput, OutboxEventUncheckedUpdateManyInput>
    /**
     * Filter which OutboxEvents to update
     */
    where?: OutboxEventWhereInput
  }

  /**
   * OutboxEvent upsert
   */
  export type OutboxEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * The filter to search for the OutboxEvent to update in case it exists.
     */
    where: OutboxEventWhereUniqueInput
    /**
     * In case the OutboxEvent found by the `where` argument doesn't exist, create a new OutboxEvent with this data.
     */
    create: XOR<OutboxEventCreateInput, OutboxEventUncheckedCreateInput>
    /**
     * In case the OutboxEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutboxEventUpdateInput, OutboxEventUncheckedUpdateInput>
  }

  /**
   * OutboxEvent delete
   */
  export type OutboxEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter which OutboxEvent to delete.
     */
    where: OutboxEventWhereUniqueInput
  }

  /**
   * OutboxEvent deleteMany
   */
  export type OutboxEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboxEvents to delete
     */
    where?: OutboxEventWhereInput
  }

  /**
   * OutboxEvent without action
   */
  export type OutboxEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    code: number
    name: number
    category: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    code: string
    name: string
    category: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleGrants?: boolean | Permission$roleGrantsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleGrants?: boolean | Permission$roleGrantsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roleGrants: Prisma.$RoleTemplatePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      category: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roleGrants<T extends Permission$roleGrantsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$roleGrantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly code: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly category: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.roleGrants
   */
  export type Permission$roleGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    where?: RoleTemplatePermissionWhereInput
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    cursor?: RoleTemplatePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleTemplatePermissionScalarFieldEnum | RoleTemplatePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RoleTemplate
   */

  export type AggregateRoleTemplate = {
    _count: RoleTemplateCountAggregateOutputType | null
    _min: RoleTemplateMinAggregateOutputType | null
    _max: RoleTemplateMaxAggregateOutputType | null
  }

  export type RoleTemplateMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    scope: $Enums.RoleScope | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplateMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    scope: $Enums.RoleScope | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplateCountAggregateOutputType = {
    id: number
    code: number
    name: number
    scope: number
    description: number
    isSystem: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleTemplateMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    scope?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplateMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    scope?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplateCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    scope?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplate to aggregate.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleTemplates
    **/
    _count?: true | RoleTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleTemplateMaxAggregateInputType
  }

  export type GetRoleTemplateAggregateType<T extends RoleTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleTemplate[P]>
      : GetScalarType<T[P], AggregateRoleTemplate[P]>
  }




  export type RoleTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplateWhereInput
    orderBy?: RoleTemplateOrderByWithAggregationInput | RoleTemplateOrderByWithAggregationInput[]
    by: RoleTemplateScalarFieldEnum[] | RoleTemplateScalarFieldEnum
    having?: RoleTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleTemplateCountAggregateInputType | true
    _min?: RoleTemplateMinAggregateInputType
    _max?: RoleTemplateMaxAggregateInputType
  }

  export type RoleTemplateGroupByOutputType = {
    id: string
    code: string
    name: string
    scope: $Enums.RoleScope
    description: string | null
    isSystem: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleTemplateCountAggregateOutputType | null
    _min: RoleTemplateMinAggregateOutputType | null
    _max: RoleTemplateMaxAggregateOutputType | null
  }

  type GetRoleTemplateGroupByPayload<T extends RoleTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], RoleTemplateGroupByOutputType[P]>
        }
      >
    >


  export type RoleTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    scope?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    versions?: boolean | RoleTemplate$versionsArgs<ExtArgs>
    _count?: boolean | RoleTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleTemplate"]>

  export type RoleTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    scope?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["roleTemplate"]>

  export type RoleTemplateSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    scope?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | RoleTemplate$versionsArgs<ExtArgs>
    _count?: boolean | RoleTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoleTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleTemplate"
    objects: {
      versions: Prisma.$RoleTemplateVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      scope: $Enums.RoleScope
      description: string | null
      isSystem: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roleTemplate"]>
    composites: {}
  }

  type RoleTemplateGetPayload<S extends boolean | null | undefined | RoleTemplateDefaultArgs> = $Result.GetResult<Prisma.$RoleTemplatePayload, S>

  type RoleTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleTemplateCountAggregateInputType | true
    }

  export interface RoleTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleTemplate'], meta: { name: 'RoleTemplate' } }
    /**
     * Find zero or one RoleTemplate that matches the filter.
     * @param {RoleTemplateFindUniqueArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleTemplateFindUniqueArgs>(args: SelectSubset<T, RoleTemplateFindUniqueArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoleTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleTemplateFindUniqueOrThrowArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoleTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateFindFirstArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleTemplateFindFirstArgs>(args?: SelectSubset<T, RoleTemplateFindFirstArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoleTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateFindFirstOrThrowArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoleTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleTemplates
     * const roleTemplates = await prisma.roleTemplate.findMany()
     * 
     * // Get first 10 RoleTemplates
     * const roleTemplates = await prisma.roleTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleTemplateWithIdOnly = await prisma.roleTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleTemplateFindManyArgs>(args?: SelectSubset<T, RoleTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoleTemplate.
     * @param {RoleTemplateCreateArgs} args - Arguments to create a RoleTemplate.
     * @example
     * // Create one RoleTemplate
     * const RoleTemplate = await prisma.roleTemplate.create({
     *   data: {
     *     // ... data to create a RoleTemplate
     *   }
     * })
     * 
     */
    create<T extends RoleTemplateCreateArgs>(args: SelectSubset<T, RoleTemplateCreateArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoleTemplates.
     * @param {RoleTemplateCreateManyArgs} args - Arguments to create many RoleTemplates.
     * @example
     * // Create many RoleTemplates
     * const roleTemplate = await prisma.roleTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleTemplateCreateManyArgs>(args?: SelectSubset<T, RoleTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleTemplates and returns the data saved in the database.
     * @param {RoleTemplateCreateManyAndReturnArgs} args - Arguments to create many RoleTemplates.
     * @example
     * // Create many RoleTemplates
     * const roleTemplate = await prisma.roleTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleTemplates and only return the `id`
     * const roleTemplateWithIdOnly = await prisma.roleTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoleTemplate.
     * @param {RoleTemplateDeleteArgs} args - Arguments to delete one RoleTemplate.
     * @example
     * // Delete one RoleTemplate
     * const RoleTemplate = await prisma.roleTemplate.delete({
     *   where: {
     *     // ... filter to delete one RoleTemplate
     *   }
     * })
     * 
     */
    delete<T extends RoleTemplateDeleteArgs>(args: SelectSubset<T, RoleTemplateDeleteArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoleTemplate.
     * @param {RoleTemplateUpdateArgs} args - Arguments to update one RoleTemplate.
     * @example
     * // Update one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleTemplateUpdateArgs>(args: SelectSubset<T, RoleTemplateUpdateArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoleTemplates.
     * @param {RoleTemplateDeleteManyArgs} args - Arguments to filter RoleTemplates to delete.
     * @example
     * // Delete a few RoleTemplates
     * const { count } = await prisma.roleTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleTemplateDeleteManyArgs>(args?: SelectSubset<T, RoleTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleTemplates
     * const roleTemplate = await prisma.roleTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleTemplateUpdateManyArgs>(args: SelectSubset<T, RoleTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleTemplate.
     * @param {RoleTemplateUpsertArgs} args - Arguments to update or create a RoleTemplate.
     * @example
     * // Update or create a RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.upsert({
     *   create: {
     *     // ... data to create a RoleTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleTemplate we want to update
     *   }
     * })
     */
    upsert<T extends RoleTemplateUpsertArgs>(args: SelectSubset<T, RoleTemplateUpsertArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoleTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateCountArgs} args - Arguments to filter RoleTemplates to count.
     * @example
     * // Count the number of RoleTemplates
     * const count = await prisma.roleTemplate.count({
     *   where: {
     *     // ... the filter for the RoleTemplates we want to count
     *   }
     * })
    **/
    count<T extends RoleTemplateCountArgs>(
      args?: Subset<T, RoleTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleTemplateAggregateArgs>(args: Subset<T, RoleTemplateAggregateArgs>): Prisma.PrismaPromise<GetRoleTemplateAggregateType<T>>

    /**
     * Group by RoleTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleTemplateGroupByArgs['orderBy'] }
        : { orderBy?: RoleTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleTemplate model
   */
  readonly fields: RoleTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    versions<T extends RoleTemplate$versionsArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplate$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleTemplate model
   */ 
  interface RoleTemplateFieldRefs {
    readonly id: FieldRef<"RoleTemplate", 'String'>
    readonly code: FieldRef<"RoleTemplate", 'String'>
    readonly name: FieldRef<"RoleTemplate", 'String'>
    readonly scope: FieldRef<"RoleTemplate", 'RoleScope'>
    readonly description: FieldRef<"RoleTemplate", 'String'>
    readonly isSystem: FieldRef<"RoleTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"RoleTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleTemplate findUnique
   */
  export type RoleTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate findUniqueOrThrow
   */
  export type RoleTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate findFirst
   */
  export type RoleTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplates.
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplates.
     */
    distinct?: RoleTemplateScalarFieldEnum | RoleTemplateScalarFieldEnum[]
  }

  /**
   * RoleTemplate findFirstOrThrow
   */
  export type RoleTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplates.
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplates.
     */
    distinct?: RoleTemplateScalarFieldEnum | RoleTemplateScalarFieldEnum[]
  }

  /**
   * RoleTemplate findMany
   */
  export type RoleTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplates to fetch.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleTemplates.
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    distinct?: RoleTemplateScalarFieldEnum | RoleTemplateScalarFieldEnum[]
  }

  /**
   * RoleTemplate create
   */
  export type RoleTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleTemplate.
     */
    data: XOR<RoleTemplateCreateInput, RoleTemplateUncheckedCreateInput>
  }

  /**
   * RoleTemplate createMany
   */
  export type RoleTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleTemplates.
     */
    data: RoleTemplateCreateManyInput | RoleTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleTemplate createManyAndReturn
   */
  export type RoleTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoleTemplates.
     */
    data: RoleTemplateCreateManyInput | RoleTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleTemplate update
   */
  export type RoleTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleTemplate.
     */
    data: XOR<RoleTemplateUpdateInput, RoleTemplateUncheckedUpdateInput>
    /**
     * Choose, which RoleTemplate to update.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate updateMany
   */
  export type RoleTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleTemplates.
     */
    data: XOR<RoleTemplateUpdateManyMutationInput, RoleTemplateUncheckedUpdateManyInput>
    /**
     * Filter which RoleTemplates to update
     */
    where?: RoleTemplateWhereInput
  }

  /**
   * RoleTemplate upsert
   */
  export type RoleTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleTemplate to update in case it exists.
     */
    where: RoleTemplateWhereUniqueInput
    /**
     * In case the RoleTemplate found by the `where` argument doesn't exist, create a new RoleTemplate with this data.
     */
    create: XOR<RoleTemplateCreateInput, RoleTemplateUncheckedCreateInput>
    /**
     * In case the RoleTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleTemplateUpdateInput, RoleTemplateUncheckedUpdateInput>
  }

  /**
   * RoleTemplate delete
   */
  export type RoleTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter which RoleTemplate to delete.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate deleteMany
   */
  export type RoleTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplates to delete
     */
    where?: RoleTemplateWhereInput
  }

  /**
   * RoleTemplate.versions
   */
  export type RoleTemplate$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    where?: RoleTemplateVersionWhereInput
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    cursor?: RoleTemplateVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleTemplateVersionScalarFieldEnum | RoleTemplateVersionScalarFieldEnum[]
  }

  /**
   * RoleTemplate without action
   */
  export type RoleTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
  }


  /**
   * Model RoleTemplateVersion
   */

  export type AggregateRoleTemplateVersion = {
    _count: RoleTemplateVersionCountAggregateOutputType | null
    _avg: RoleTemplateVersionAvgAggregateOutputType | null
    _sum: RoleTemplateVersionSumAggregateOutputType | null
    _min: RoleTemplateVersionMinAggregateOutputType | null
    _max: RoleTemplateVersionMaxAggregateOutputType | null
  }

  export type RoleTemplateVersionAvgAggregateOutputType = {
    version: number | null
  }

  export type RoleTemplateVersionSumAggregateOutputType = {
    version: number | null
  }

  export type RoleTemplateVersionMinAggregateOutputType = {
    id: string | null
    roleTemplateId: string | null
    version: number | null
    status: $Enums.RoleVersionStatus | null
    notes: string | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplateVersionMaxAggregateOutputType = {
    id: string | null
    roleTemplateId: string | null
    version: number | null
    status: $Enums.RoleVersionStatus | null
    notes: string | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplateVersionCountAggregateOutputType = {
    id: number
    roleTemplateId: number
    version: number
    status: number
    notes: number
    createdByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleTemplateVersionAvgAggregateInputType = {
    version?: true
  }

  export type RoleTemplateVersionSumAggregateInputType = {
    version?: true
  }

  export type RoleTemplateVersionMinAggregateInputType = {
    id?: true
    roleTemplateId?: true
    version?: true
    status?: true
    notes?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplateVersionMaxAggregateInputType = {
    id?: true
    roleTemplateId?: true
    version?: true
    status?: true
    notes?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplateVersionCountAggregateInputType = {
    id?: true
    roleTemplateId?: true
    version?: true
    status?: true
    notes?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleTemplateVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplateVersion to aggregate.
     */
    where?: RoleTemplateVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplateVersions to fetch.
     */
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleTemplateVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplateVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplateVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleTemplateVersions
    **/
    _count?: true | RoleTemplateVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleTemplateVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleTemplateVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleTemplateVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleTemplateVersionMaxAggregateInputType
  }

  export type GetRoleTemplateVersionAggregateType<T extends RoleTemplateVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleTemplateVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleTemplateVersion[P]>
      : GetScalarType<T[P], AggregateRoleTemplateVersion[P]>
  }




  export type RoleTemplateVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplateVersionWhereInput
    orderBy?: RoleTemplateVersionOrderByWithAggregationInput | RoleTemplateVersionOrderByWithAggregationInput[]
    by: RoleTemplateVersionScalarFieldEnum[] | RoleTemplateVersionScalarFieldEnum
    having?: RoleTemplateVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleTemplateVersionCountAggregateInputType | true
    _avg?: RoleTemplateVersionAvgAggregateInputType
    _sum?: RoleTemplateVersionSumAggregateInputType
    _min?: RoleTemplateVersionMinAggregateInputType
    _max?: RoleTemplateVersionMaxAggregateInputType
  }

  export type RoleTemplateVersionGroupByOutputType = {
    id: string
    roleTemplateId: string
    version: number
    status: $Enums.RoleVersionStatus
    notes: string | null
    createdByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleTemplateVersionCountAggregateOutputType | null
    _avg: RoleTemplateVersionAvgAggregateOutputType | null
    _sum: RoleTemplateVersionSumAggregateOutputType | null
    _min: RoleTemplateVersionMinAggregateOutputType | null
    _max: RoleTemplateVersionMaxAggregateOutputType | null
  }

  type GetRoleTemplateVersionGroupByPayload<T extends RoleTemplateVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleTemplateVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleTemplateVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleTemplateVersionGroupByOutputType[P]>
            : GetScalarType<T[P], RoleTemplateVersionGroupByOutputType[P]>
        }
      >
    >


  export type RoleTemplateVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleTemplateId?: boolean
    version?: boolean
    status?: boolean
    notes?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleTemplate?: boolean | RoleTemplateDefaultArgs<ExtArgs>
    createdByUser?: boolean | RoleTemplateVersion$createdByUserArgs<ExtArgs>
    permissions?: boolean | RoleTemplateVersion$permissionsArgs<ExtArgs>
    users?: boolean | RoleTemplateVersion$usersArgs<ExtArgs>
    _count?: boolean | RoleTemplateVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleTemplateVersion"]>

  export type RoleTemplateVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleTemplateId?: boolean
    version?: boolean
    status?: boolean
    notes?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleTemplate?: boolean | RoleTemplateDefaultArgs<ExtArgs>
    createdByUser?: boolean | RoleTemplateVersion$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["roleTemplateVersion"]>

  export type RoleTemplateVersionSelectScalar = {
    id?: boolean
    roleTemplateId?: boolean
    version?: boolean
    status?: boolean
    notes?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleTemplateVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleTemplate?: boolean | RoleTemplateDefaultArgs<ExtArgs>
    createdByUser?: boolean | RoleTemplateVersion$createdByUserArgs<ExtArgs>
    permissions?: boolean | RoleTemplateVersion$permissionsArgs<ExtArgs>
    users?: boolean | RoleTemplateVersion$usersArgs<ExtArgs>
    _count?: boolean | RoleTemplateVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleTemplateVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleTemplate?: boolean | RoleTemplateDefaultArgs<ExtArgs>
    createdByUser?: boolean | RoleTemplateVersion$createdByUserArgs<ExtArgs>
  }

  export type $RoleTemplateVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleTemplateVersion"
    objects: {
      roleTemplate: Prisma.$RoleTemplatePayload<ExtArgs>
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
      permissions: Prisma.$RoleTemplatePermissionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleTemplateId: string
      version: number
      status: $Enums.RoleVersionStatus
      notes: string | null
      createdByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roleTemplateVersion"]>
    composites: {}
  }

  type RoleTemplateVersionGetPayload<S extends boolean | null | undefined | RoleTemplateVersionDefaultArgs> = $Result.GetResult<Prisma.$RoleTemplateVersionPayload, S>

  type RoleTemplateVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleTemplateVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleTemplateVersionCountAggregateInputType | true
    }

  export interface RoleTemplateVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleTemplateVersion'], meta: { name: 'RoleTemplateVersion' } }
    /**
     * Find zero or one RoleTemplateVersion that matches the filter.
     * @param {RoleTemplateVersionFindUniqueArgs} args - Arguments to find a RoleTemplateVersion
     * @example
     * // Get one RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleTemplateVersionFindUniqueArgs>(args: SelectSubset<T, RoleTemplateVersionFindUniqueArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoleTemplateVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleTemplateVersionFindUniqueOrThrowArgs} args - Arguments to find a RoleTemplateVersion
     * @example
     * // Get one RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleTemplateVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleTemplateVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoleTemplateVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionFindFirstArgs} args - Arguments to find a RoleTemplateVersion
     * @example
     * // Get one RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleTemplateVersionFindFirstArgs>(args?: SelectSubset<T, RoleTemplateVersionFindFirstArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoleTemplateVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionFindFirstOrThrowArgs} args - Arguments to find a RoleTemplateVersion
     * @example
     * // Get one RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleTemplateVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleTemplateVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoleTemplateVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleTemplateVersions
     * const roleTemplateVersions = await prisma.roleTemplateVersion.findMany()
     * 
     * // Get first 10 RoleTemplateVersions
     * const roleTemplateVersions = await prisma.roleTemplateVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleTemplateVersionWithIdOnly = await prisma.roleTemplateVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleTemplateVersionFindManyArgs>(args?: SelectSubset<T, RoleTemplateVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoleTemplateVersion.
     * @param {RoleTemplateVersionCreateArgs} args - Arguments to create a RoleTemplateVersion.
     * @example
     * // Create one RoleTemplateVersion
     * const RoleTemplateVersion = await prisma.roleTemplateVersion.create({
     *   data: {
     *     // ... data to create a RoleTemplateVersion
     *   }
     * })
     * 
     */
    create<T extends RoleTemplateVersionCreateArgs>(args: SelectSubset<T, RoleTemplateVersionCreateArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoleTemplateVersions.
     * @param {RoleTemplateVersionCreateManyArgs} args - Arguments to create many RoleTemplateVersions.
     * @example
     * // Create many RoleTemplateVersions
     * const roleTemplateVersion = await prisma.roleTemplateVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleTemplateVersionCreateManyArgs>(args?: SelectSubset<T, RoleTemplateVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleTemplateVersions and returns the data saved in the database.
     * @param {RoleTemplateVersionCreateManyAndReturnArgs} args - Arguments to create many RoleTemplateVersions.
     * @example
     * // Create many RoleTemplateVersions
     * const roleTemplateVersion = await prisma.roleTemplateVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleTemplateVersions and only return the `id`
     * const roleTemplateVersionWithIdOnly = await prisma.roleTemplateVersion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleTemplateVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleTemplateVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoleTemplateVersion.
     * @param {RoleTemplateVersionDeleteArgs} args - Arguments to delete one RoleTemplateVersion.
     * @example
     * // Delete one RoleTemplateVersion
     * const RoleTemplateVersion = await prisma.roleTemplateVersion.delete({
     *   where: {
     *     // ... filter to delete one RoleTemplateVersion
     *   }
     * })
     * 
     */
    delete<T extends RoleTemplateVersionDeleteArgs>(args: SelectSubset<T, RoleTemplateVersionDeleteArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoleTemplateVersion.
     * @param {RoleTemplateVersionUpdateArgs} args - Arguments to update one RoleTemplateVersion.
     * @example
     * // Update one RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleTemplateVersionUpdateArgs>(args: SelectSubset<T, RoleTemplateVersionUpdateArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoleTemplateVersions.
     * @param {RoleTemplateVersionDeleteManyArgs} args - Arguments to filter RoleTemplateVersions to delete.
     * @example
     * // Delete a few RoleTemplateVersions
     * const { count } = await prisma.roleTemplateVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleTemplateVersionDeleteManyArgs>(args?: SelectSubset<T, RoleTemplateVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleTemplateVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleTemplateVersions
     * const roleTemplateVersion = await prisma.roleTemplateVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleTemplateVersionUpdateManyArgs>(args: SelectSubset<T, RoleTemplateVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleTemplateVersion.
     * @param {RoleTemplateVersionUpsertArgs} args - Arguments to update or create a RoleTemplateVersion.
     * @example
     * // Update or create a RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.upsert({
     *   create: {
     *     // ... data to create a RoleTemplateVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleTemplateVersion we want to update
     *   }
     * })
     */
    upsert<T extends RoleTemplateVersionUpsertArgs>(args: SelectSubset<T, RoleTemplateVersionUpsertArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoleTemplateVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionCountArgs} args - Arguments to filter RoleTemplateVersions to count.
     * @example
     * // Count the number of RoleTemplateVersions
     * const count = await prisma.roleTemplateVersion.count({
     *   where: {
     *     // ... the filter for the RoleTemplateVersions we want to count
     *   }
     * })
    **/
    count<T extends RoleTemplateVersionCountArgs>(
      args?: Subset<T, RoleTemplateVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleTemplateVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleTemplateVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleTemplateVersionAggregateArgs>(args: Subset<T, RoleTemplateVersionAggregateArgs>): Prisma.PrismaPromise<GetRoleTemplateVersionAggregateType<T>>

    /**
     * Group by RoleTemplateVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleTemplateVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleTemplateVersionGroupByArgs['orderBy'] }
        : { orderBy?: RoleTemplateVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleTemplateVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleTemplateVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleTemplateVersion model
   */
  readonly fields: RoleTemplateVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleTemplateVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleTemplateVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roleTemplate<T extends RoleTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplateDefaultArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdByUser<T extends RoleTemplateVersion$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplateVersion$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    permissions<T extends RoleTemplateVersion$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplateVersion$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends RoleTemplateVersion$usersArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplateVersion$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleTemplateVersion model
   */ 
  interface RoleTemplateVersionFieldRefs {
    readonly id: FieldRef<"RoleTemplateVersion", 'String'>
    readonly roleTemplateId: FieldRef<"RoleTemplateVersion", 'String'>
    readonly version: FieldRef<"RoleTemplateVersion", 'Int'>
    readonly status: FieldRef<"RoleTemplateVersion", 'RoleVersionStatus'>
    readonly notes: FieldRef<"RoleTemplateVersion", 'String'>
    readonly createdByUserId: FieldRef<"RoleTemplateVersion", 'String'>
    readonly createdAt: FieldRef<"RoleTemplateVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleTemplateVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleTemplateVersion findUnique
   */
  export type RoleTemplateVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplateVersion to fetch.
     */
    where: RoleTemplateVersionWhereUniqueInput
  }

  /**
   * RoleTemplateVersion findUniqueOrThrow
   */
  export type RoleTemplateVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplateVersion to fetch.
     */
    where: RoleTemplateVersionWhereUniqueInput
  }

  /**
   * RoleTemplateVersion findFirst
   */
  export type RoleTemplateVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplateVersion to fetch.
     */
    where?: RoleTemplateVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplateVersions to fetch.
     */
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplateVersions.
     */
    cursor?: RoleTemplateVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplateVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplateVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplateVersions.
     */
    distinct?: RoleTemplateVersionScalarFieldEnum | RoleTemplateVersionScalarFieldEnum[]
  }

  /**
   * RoleTemplateVersion findFirstOrThrow
   */
  export type RoleTemplateVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplateVersion to fetch.
     */
    where?: RoleTemplateVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplateVersions to fetch.
     */
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplateVersions.
     */
    cursor?: RoleTemplateVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplateVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplateVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplateVersions.
     */
    distinct?: RoleTemplateVersionScalarFieldEnum | RoleTemplateVersionScalarFieldEnum[]
  }

  /**
   * RoleTemplateVersion findMany
   */
  export type RoleTemplateVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplateVersions to fetch.
     */
    where?: RoleTemplateVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplateVersions to fetch.
     */
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleTemplateVersions.
     */
    cursor?: RoleTemplateVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplateVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplateVersions.
     */
    skip?: number
    distinct?: RoleTemplateVersionScalarFieldEnum | RoleTemplateVersionScalarFieldEnum[]
  }

  /**
   * RoleTemplateVersion create
   */
  export type RoleTemplateVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleTemplateVersion.
     */
    data: XOR<RoleTemplateVersionCreateInput, RoleTemplateVersionUncheckedCreateInput>
  }

  /**
   * RoleTemplateVersion createMany
   */
  export type RoleTemplateVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleTemplateVersions.
     */
    data: RoleTemplateVersionCreateManyInput | RoleTemplateVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleTemplateVersion createManyAndReturn
   */
  export type RoleTemplateVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoleTemplateVersions.
     */
    data: RoleTemplateVersionCreateManyInput | RoleTemplateVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleTemplateVersion update
   */
  export type RoleTemplateVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleTemplateVersion.
     */
    data: XOR<RoleTemplateVersionUpdateInput, RoleTemplateVersionUncheckedUpdateInput>
    /**
     * Choose, which RoleTemplateVersion to update.
     */
    where: RoleTemplateVersionWhereUniqueInput
  }

  /**
   * RoleTemplateVersion updateMany
   */
  export type RoleTemplateVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleTemplateVersions.
     */
    data: XOR<RoleTemplateVersionUpdateManyMutationInput, RoleTemplateVersionUncheckedUpdateManyInput>
    /**
     * Filter which RoleTemplateVersions to update
     */
    where?: RoleTemplateVersionWhereInput
  }

  /**
   * RoleTemplateVersion upsert
   */
  export type RoleTemplateVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleTemplateVersion to update in case it exists.
     */
    where: RoleTemplateVersionWhereUniqueInput
    /**
     * In case the RoleTemplateVersion found by the `where` argument doesn't exist, create a new RoleTemplateVersion with this data.
     */
    create: XOR<RoleTemplateVersionCreateInput, RoleTemplateVersionUncheckedCreateInput>
    /**
     * In case the RoleTemplateVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleTemplateVersionUpdateInput, RoleTemplateVersionUncheckedUpdateInput>
  }

  /**
   * RoleTemplateVersion delete
   */
  export type RoleTemplateVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter which RoleTemplateVersion to delete.
     */
    where: RoleTemplateVersionWhereUniqueInput
  }

  /**
   * RoleTemplateVersion deleteMany
   */
  export type RoleTemplateVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplateVersions to delete
     */
    where?: RoleTemplateVersionWhereInput
  }

  /**
   * RoleTemplateVersion.createdByUser
   */
  export type RoleTemplateVersion$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RoleTemplateVersion.permissions
   */
  export type RoleTemplateVersion$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    where?: RoleTemplatePermissionWhereInput
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    cursor?: RoleTemplatePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleTemplatePermissionScalarFieldEnum | RoleTemplatePermissionScalarFieldEnum[]
  }

  /**
   * RoleTemplateVersion.users
   */
  export type RoleTemplateVersion$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * RoleTemplateVersion without action
   */
  export type RoleTemplateVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
  }


  /**
   * Model RoleTemplatePermission
   */

  export type AggregateRoleTemplatePermission = {
    _count: RoleTemplatePermissionCountAggregateOutputType | null
    _min: RoleTemplatePermissionMinAggregateOutputType | null
    _max: RoleTemplatePermissionMaxAggregateOutputType | null
  }

  export type RoleTemplatePermissionMinAggregateOutputType = {
    id: string | null
    roleVersionId: string | null
    permissionId: string | null
    allowed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplatePermissionMaxAggregateOutputType = {
    id: string | null
    roleVersionId: string | null
    permissionId: string | null
    allowed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplatePermissionCountAggregateOutputType = {
    id: number
    roleVersionId: number
    permissionId: number
    allowed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleTemplatePermissionMinAggregateInputType = {
    id?: true
    roleVersionId?: true
    permissionId?: true
    allowed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplatePermissionMaxAggregateInputType = {
    id?: true
    roleVersionId?: true
    permissionId?: true
    allowed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplatePermissionCountAggregateInputType = {
    id?: true
    roleVersionId?: true
    permissionId?: true
    allowed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleTemplatePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplatePermission to aggregate.
     */
    where?: RoleTemplatePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplatePermissions to fetch.
     */
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleTemplatePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplatePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplatePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleTemplatePermissions
    **/
    _count?: true | RoleTemplatePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleTemplatePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleTemplatePermissionMaxAggregateInputType
  }

  export type GetRoleTemplatePermissionAggregateType<T extends RoleTemplatePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleTemplatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleTemplatePermission[P]>
      : GetScalarType<T[P], AggregateRoleTemplatePermission[P]>
  }




  export type RoleTemplatePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplatePermissionWhereInput
    orderBy?: RoleTemplatePermissionOrderByWithAggregationInput | RoleTemplatePermissionOrderByWithAggregationInput[]
    by: RoleTemplatePermissionScalarFieldEnum[] | RoleTemplatePermissionScalarFieldEnum
    having?: RoleTemplatePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleTemplatePermissionCountAggregateInputType | true
    _min?: RoleTemplatePermissionMinAggregateInputType
    _max?: RoleTemplatePermissionMaxAggregateInputType
  }

  export type RoleTemplatePermissionGroupByOutputType = {
    id: string
    roleVersionId: string
    permissionId: string
    allowed: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleTemplatePermissionCountAggregateOutputType | null
    _min: RoleTemplatePermissionMinAggregateOutputType | null
    _max: RoleTemplatePermissionMaxAggregateOutputType | null
  }

  type GetRoleTemplatePermissionGroupByPayload<T extends RoleTemplatePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleTemplatePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleTemplatePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleTemplatePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RoleTemplatePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RoleTemplatePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleVersionId?: boolean
    permissionId?: boolean
    allowed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleVersion?: boolean | RoleTemplateVersionDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleTemplatePermission"]>

  export type RoleTemplatePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleVersionId?: boolean
    permissionId?: boolean
    allowed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleVersion?: boolean | RoleTemplateVersionDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleTemplatePermission"]>

  export type RoleTemplatePermissionSelectScalar = {
    id?: boolean
    roleVersionId?: boolean
    permissionId?: boolean
    allowed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleTemplatePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleVersion?: boolean | RoleTemplateVersionDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RoleTemplatePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleVersion?: boolean | RoleTemplateVersionDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RoleTemplatePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleTemplatePermission"
    objects: {
      roleVersion: Prisma.$RoleTemplateVersionPayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleVersionId: string
      permissionId: string
      allowed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roleTemplatePermission"]>
    composites: {}
  }

  type RoleTemplatePermissionGetPayload<S extends boolean | null | undefined | RoleTemplatePermissionDefaultArgs> = $Result.GetResult<Prisma.$RoleTemplatePermissionPayload, S>

  type RoleTemplatePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleTemplatePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleTemplatePermissionCountAggregateInputType | true
    }

  export interface RoleTemplatePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleTemplatePermission'], meta: { name: 'RoleTemplatePermission' } }
    /**
     * Find zero or one RoleTemplatePermission that matches the filter.
     * @param {RoleTemplatePermissionFindUniqueArgs} args - Arguments to find a RoleTemplatePermission
     * @example
     * // Get one RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleTemplatePermissionFindUniqueArgs>(args: SelectSubset<T, RoleTemplatePermissionFindUniqueArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoleTemplatePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleTemplatePermissionFindUniqueOrThrowArgs} args - Arguments to find a RoleTemplatePermission
     * @example
     * // Get one RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleTemplatePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleTemplatePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoleTemplatePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionFindFirstArgs} args - Arguments to find a RoleTemplatePermission
     * @example
     * // Get one RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleTemplatePermissionFindFirstArgs>(args?: SelectSubset<T, RoleTemplatePermissionFindFirstArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoleTemplatePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionFindFirstOrThrowArgs} args - Arguments to find a RoleTemplatePermission
     * @example
     * // Get one RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleTemplatePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleTemplatePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoleTemplatePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleTemplatePermissions
     * const roleTemplatePermissions = await prisma.roleTemplatePermission.findMany()
     * 
     * // Get first 10 RoleTemplatePermissions
     * const roleTemplatePermissions = await prisma.roleTemplatePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleTemplatePermissionWithIdOnly = await prisma.roleTemplatePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleTemplatePermissionFindManyArgs>(args?: SelectSubset<T, RoleTemplatePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoleTemplatePermission.
     * @param {RoleTemplatePermissionCreateArgs} args - Arguments to create a RoleTemplatePermission.
     * @example
     * // Create one RoleTemplatePermission
     * const RoleTemplatePermission = await prisma.roleTemplatePermission.create({
     *   data: {
     *     // ... data to create a RoleTemplatePermission
     *   }
     * })
     * 
     */
    create<T extends RoleTemplatePermissionCreateArgs>(args: SelectSubset<T, RoleTemplatePermissionCreateArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoleTemplatePermissions.
     * @param {RoleTemplatePermissionCreateManyArgs} args - Arguments to create many RoleTemplatePermissions.
     * @example
     * // Create many RoleTemplatePermissions
     * const roleTemplatePermission = await prisma.roleTemplatePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleTemplatePermissionCreateManyArgs>(args?: SelectSubset<T, RoleTemplatePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleTemplatePermissions and returns the data saved in the database.
     * @param {RoleTemplatePermissionCreateManyAndReturnArgs} args - Arguments to create many RoleTemplatePermissions.
     * @example
     * // Create many RoleTemplatePermissions
     * const roleTemplatePermission = await prisma.roleTemplatePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleTemplatePermissions and only return the `id`
     * const roleTemplatePermissionWithIdOnly = await prisma.roleTemplatePermission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleTemplatePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleTemplatePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoleTemplatePermission.
     * @param {RoleTemplatePermissionDeleteArgs} args - Arguments to delete one RoleTemplatePermission.
     * @example
     * // Delete one RoleTemplatePermission
     * const RoleTemplatePermission = await prisma.roleTemplatePermission.delete({
     *   where: {
     *     // ... filter to delete one RoleTemplatePermission
     *   }
     * })
     * 
     */
    delete<T extends RoleTemplatePermissionDeleteArgs>(args: SelectSubset<T, RoleTemplatePermissionDeleteArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoleTemplatePermission.
     * @param {RoleTemplatePermissionUpdateArgs} args - Arguments to update one RoleTemplatePermission.
     * @example
     * // Update one RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleTemplatePermissionUpdateArgs>(args: SelectSubset<T, RoleTemplatePermissionUpdateArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoleTemplatePermissions.
     * @param {RoleTemplatePermissionDeleteManyArgs} args - Arguments to filter RoleTemplatePermissions to delete.
     * @example
     * // Delete a few RoleTemplatePermissions
     * const { count } = await prisma.roleTemplatePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleTemplatePermissionDeleteManyArgs>(args?: SelectSubset<T, RoleTemplatePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleTemplatePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleTemplatePermissions
     * const roleTemplatePermission = await prisma.roleTemplatePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleTemplatePermissionUpdateManyArgs>(args: SelectSubset<T, RoleTemplatePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleTemplatePermission.
     * @param {RoleTemplatePermissionUpsertArgs} args - Arguments to update or create a RoleTemplatePermission.
     * @example
     * // Update or create a RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.upsert({
     *   create: {
     *     // ... data to create a RoleTemplatePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleTemplatePermission we want to update
     *   }
     * })
     */
    upsert<T extends RoleTemplatePermissionUpsertArgs>(args: SelectSubset<T, RoleTemplatePermissionUpsertArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoleTemplatePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionCountArgs} args - Arguments to filter RoleTemplatePermissions to count.
     * @example
     * // Count the number of RoleTemplatePermissions
     * const count = await prisma.roleTemplatePermission.count({
     *   where: {
     *     // ... the filter for the RoleTemplatePermissions we want to count
     *   }
     * })
    **/
    count<T extends RoleTemplatePermissionCountArgs>(
      args?: Subset<T, RoleTemplatePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleTemplatePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleTemplatePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleTemplatePermissionAggregateArgs>(args: Subset<T, RoleTemplatePermissionAggregateArgs>): Prisma.PrismaPromise<GetRoleTemplatePermissionAggregateType<T>>

    /**
     * Group by RoleTemplatePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleTemplatePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleTemplatePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RoleTemplatePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleTemplatePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleTemplatePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleTemplatePermission model
   */
  readonly fields: RoleTemplatePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleTemplatePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleTemplatePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roleVersion<T extends RoleTemplateVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplateVersionDefaultArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleTemplatePermission model
   */ 
  interface RoleTemplatePermissionFieldRefs {
    readonly id: FieldRef<"RoleTemplatePermission", 'String'>
    readonly roleVersionId: FieldRef<"RoleTemplatePermission", 'String'>
    readonly permissionId: FieldRef<"RoleTemplatePermission", 'String'>
    readonly allowed: FieldRef<"RoleTemplatePermission", 'Boolean'>
    readonly createdAt: FieldRef<"RoleTemplatePermission", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleTemplatePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleTemplatePermission findUnique
   */
  export type RoleTemplatePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplatePermission to fetch.
     */
    where: RoleTemplatePermissionWhereUniqueInput
  }

  /**
   * RoleTemplatePermission findUniqueOrThrow
   */
  export type RoleTemplatePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplatePermission to fetch.
     */
    where: RoleTemplatePermissionWhereUniqueInput
  }

  /**
   * RoleTemplatePermission findFirst
   */
  export type RoleTemplatePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplatePermission to fetch.
     */
    where?: RoleTemplatePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplatePermissions to fetch.
     */
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplatePermissions.
     */
    cursor?: RoleTemplatePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplatePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplatePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplatePermissions.
     */
    distinct?: RoleTemplatePermissionScalarFieldEnum | RoleTemplatePermissionScalarFieldEnum[]
  }

  /**
   * RoleTemplatePermission findFirstOrThrow
   */
  export type RoleTemplatePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplatePermission to fetch.
     */
    where?: RoleTemplatePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplatePermissions to fetch.
     */
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplatePermissions.
     */
    cursor?: RoleTemplatePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplatePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplatePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplatePermissions.
     */
    distinct?: RoleTemplatePermissionScalarFieldEnum | RoleTemplatePermissionScalarFieldEnum[]
  }

  /**
   * RoleTemplatePermission findMany
   */
  export type RoleTemplatePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplatePermissions to fetch.
     */
    where?: RoleTemplatePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplatePermissions to fetch.
     */
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleTemplatePermissions.
     */
    cursor?: RoleTemplatePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplatePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplatePermissions.
     */
    skip?: number
    distinct?: RoleTemplatePermissionScalarFieldEnum | RoleTemplatePermissionScalarFieldEnum[]
  }

  /**
   * RoleTemplatePermission create
   */
  export type RoleTemplatePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleTemplatePermission.
     */
    data: XOR<RoleTemplatePermissionCreateInput, RoleTemplatePermissionUncheckedCreateInput>
  }

  /**
   * RoleTemplatePermission createMany
   */
  export type RoleTemplatePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleTemplatePermissions.
     */
    data: RoleTemplatePermissionCreateManyInput | RoleTemplatePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleTemplatePermission createManyAndReturn
   */
  export type RoleTemplatePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoleTemplatePermissions.
     */
    data: RoleTemplatePermissionCreateManyInput | RoleTemplatePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleTemplatePermission update
   */
  export type RoleTemplatePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleTemplatePermission.
     */
    data: XOR<RoleTemplatePermissionUpdateInput, RoleTemplatePermissionUncheckedUpdateInput>
    /**
     * Choose, which RoleTemplatePermission to update.
     */
    where: RoleTemplatePermissionWhereUniqueInput
  }

  /**
   * RoleTemplatePermission updateMany
   */
  export type RoleTemplatePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleTemplatePermissions.
     */
    data: XOR<RoleTemplatePermissionUpdateManyMutationInput, RoleTemplatePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RoleTemplatePermissions to update
     */
    where?: RoleTemplatePermissionWhereInput
  }

  /**
   * RoleTemplatePermission upsert
   */
  export type RoleTemplatePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleTemplatePermission to update in case it exists.
     */
    where: RoleTemplatePermissionWhereUniqueInput
    /**
     * In case the RoleTemplatePermission found by the `where` argument doesn't exist, create a new RoleTemplatePermission with this data.
     */
    create: XOR<RoleTemplatePermissionCreateInput, RoleTemplatePermissionUncheckedCreateInput>
    /**
     * In case the RoleTemplatePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleTemplatePermissionUpdateInput, RoleTemplatePermissionUncheckedUpdateInput>
  }

  /**
   * RoleTemplatePermission delete
   */
  export type RoleTemplatePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter which RoleTemplatePermission to delete.
     */
    where: RoleTemplatePermissionWhereUniqueInput
  }

  /**
   * RoleTemplatePermission deleteMany
   */
  export type RoleTemplatePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplatePermissions to delete
     */
    where?: RoleTemplatePermissionWhereInput
  }

  /**
   * RoleTemplatePermission without action
   */
  export type RoleTemplatePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
  }


  /**
   * Model PolicyDefinition
   */

  export type AggregatePolicyDefinition = {
    _count: PolicyDefinitionCountAggregateOutputType | null
    _min: PolicyDefinitionMinAggregateOutputType | null
    _max: PolicyDefinitionMaxAggregateOutputType | null
  }

  export type PolicyDefinitionMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PolicyDefinitionMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PolicyDefinitionCountAggregateOutputType = {
    id: number
    code: number
    name: number
    type: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PolicyDefinitionMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PolicyDefinitionMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PolicyDefinitionCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PolicyDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolicyDefinition to aggregate.
     */
    where?: PolicyDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyDefinitions to fetch.
     */
    orderBy?: PolicyDefinitionOrderByWithRelationInput | PolicyDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PolicyDefinitions
    **/
    _count?: true | PolicyDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyDefinitionMaxAggregateInputType
  }

  export type GetPolicyDefinitionAggregateType<T extends PolicyDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicyDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicyDefinition[P]>
      : GetScalarType<T[P], AggregatePolicyDefinition[P]>
  }




  export type PolicyDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyDefinitionWhereInput
    orderBy?: PolicyDefinitionOrderByWithAggregationInput | PolicyDefinitionOrderByWithAggregationInput[]
    by: PolicyDefinitionScalarFieldEnum[] | PolicyDefinitionScalarFieldEnum
    having?: PolicyDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyDefinitionCountAggregateInputType | true
    _min?: PolicyDefinitionMinAggregateInputType
    _max?: PolicyDefinitionMaxAggregateInputType
  }

  export type PolicyDefinitionGroupByOutputType = {
    id: string
    code: string
    name: string
    type: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: PolicyDefinitionCountAggregateOutputType | null
    _min: PolicyDefinitionMinAggregateOutputType | null
    _max: PolicyDefinitionMaxAggregateOutputType | null
  }

  type GetPolicyDefinitionGroupByPayload<T extends PolicyDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type PolicyDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    versions?: boolean | PolicyDefinition$versionsArgs<ExtArgs>
    _count?: boolean | PolicyDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policyDefinition"]>

  export type PolicyDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["policyDefinition"]>

  export type PolicyDefinitionSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PolicyDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | PolicyDefinition$versionsArgs<ExtArgs>
    _count?: boolean | PolicyDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PolicyDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PolicyDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PolicyDefinition"
    objects: {
      versions: Prisma.$PolicyVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      type: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["policyDefinition"]>
    composites: {}
  }

  type PolicyDefinitionGetPayload<S extends boolean | null | undefined | PolicyDefinitionDefaultArgs> = $Result.GetResult<Prisma.$PolicyDefinitionPayload, S>

  type PolicyDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PolicyDefinitionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PolicyDefinitionCountAggregateInputType | true
    }

  export interface PolicyDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PolicyDefinition'], meta: { name: 'PolicyDefinition' } }
    /**
     * Find zero or one PolicyDefinition that matches the filter.
     * @param {PolicyDefinitionFindUniqueArgs} args - Arguments to find a PolicyDefinition
     * @example
     * // Get one PolicyDefinition
     * const policyDefinition = await prisma.policyDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyDefinitionFindUniqueArgs>(args: SelectSubset<T, PolicyDefinitionFindUniqueArgs<ExtArgs>>): Prisma__PolicyDefinitionClient<$Result.GetResult<Prisma.$PolicyDefinitionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PolicyDefinition that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PolicyDefinitionFindUniqueOrThrowArgs} args - Arguments to find a PolicyDefinition
     * @example
     * // Get one PolicyDefinition
     * const policyDefinition = await prisma.policyDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyDefinitionClient<$Result.GetResult<Prisma.$PolicyDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PolicyDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyDefinitionFindFirstArgs} args - Arguments to find a PolicyDefinition
     * @example
     * // Get one PolicyDefinition
     * const policyDefinition = await prisma.policyDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyDefinitionFindFirstArgs>(args?: SelectSubset<T, PolicyDefinitionFindFirstArgs<ExtArgs>>): Prisma__PolicyDefinitionClient<$Result.GetResult<Prisma.$PolicyDefinitionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PolicyDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyDefinitionFindFirstOrThrowArgs} args - Arguments to find a PolicyDefinition
     * @example
     * // Get one PolicyDefinition
     * const policyDefinition = await prisma.policyDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyDefinitionClient<$Result.GetResult<Prisma.$PolicyDefinitionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PolicyDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PolicyDefinitions
     * const policyDefinitions = await prisma.policyDefinition.findMany()
     * 
     * // Get first 10 PolicyDefinitions
     * const policyDefinitions = await prisma.policyDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyDefinitionWithIdOnly = await prisma.policyDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolicyDefinitionFindManyArgs>(args?: SelectSubset<T, PolicyDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyDefinitionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PolicyDefinition.
     * @param {PolicyDefinitionCreateArgs} args - Arguments to create a PolicyDefinition.
     * @example
     * // Create one PolicyDefinition
     * const PolicyDefinition = await prisma.policyDefinition.create({
     *   data: {
     *     // ... data to create a PolicyDefinition
     *   }
     * })
     * 
     */
    create<T extends PolicyDefinitionCreateArgs>(args: SelectSubset<T, PolicyDefinitionCreateArgs<ExtArgs>>): Prisma__PolicyDefinitionClient<$Result.GetResult<Prisma.$PolicyDefinitionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PolicyDefinitions.
     * @param {PolicyDefinitionCreateManyArgs} args - Arguments to create many PolicyDefinitions.
     * @example
     * // Create many PolicyDefinitions
     * const policyDefinition = await prisma.policyDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyDefinitionCreateManyArgs>(args?: SelectSubset<T, PolicyDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PolicyDefinitions and returns the data saved in the database.
     * @param {PolicyDefinitionCreateManyAndReturnArgs} args - Arguments to create many PolicyDefinitions.
     * @example
     * // Create many PolicyDefinitions
     * const policyDefinition = await prisma.policyDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PolicyDefinitions and only return the `id`
     * const policyDefinitionWithIdOnly = await prisma.policyDefinition.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyDefinitionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PolicyDefinition.
     * @param {PolicyDefinitionDeleteArgs} args - Arguments to delete one PolicyDefinition.
     * @example
     * // Delete one PolicyDefinition
     * const PolicyDefinition = await prisma.policyDefinition.delete({
     *   where: {
     *     // ... filter to delete one PolicyDefinition
     *   }
     * })
     * 
     */
    delete<T extends PolicyDefinitionDeleteArgs>(args: SelectSubset<T, PolicyDefinitionDeleteArgs<ExtArgs>>): Prisma__PolicyDefinitionClient<$Result.GetResult<Prisma.$PolicyDefinitionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PolicyDefinition.
     * @param {PolicyDefinitionUpdateArgs} args - Arguments to update one PolicyDefinition.
     * @example
     * // Update one PolicyDefinition
     * const policyDefinition = await prisma.policyDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyDefinitionUpdateArgs>(args: SelectSubset<T, PolicyDefinitionUpdateArgs<ExtArgs>>): Prisma__PolicyDefinitionClient<$Result.GetResult<Prisma.$PolicyDefinitionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PolicyDefinitions.
     * @param {PolicyDefinitionDeleteManyArgs} args - Arguments to filter PolicyDefinitions to delete.
     * @example
     * // Delete a few PolicyDefinitions
     * const { count } = await prisma.policyDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyDefinitionDeleteManyArgs>(args?: SelectSubset<T, PolicyDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolicyDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PolicyDefinitions
     * const policyDefinition = await prisma.policyDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyDefinitionUpdateManyArgs>(args: SelectSubset<T, PolicyDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PolicyDefinition.
     * @param {PolicyDefinitionUpsertArgs} args - Arguments to update or create a PolicyDefinition.
     * @example
     * // Update or create a PolicyDefinition
     * const policyDefinition = await prisma.policyDefinition.upsert({
     *   create: {
     *     // ... data to create a PolicyDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PolicyDefinition we want to update
     *   }
     * })
     */
    upsert<T extends PolicyDefinitionUpsertArgs>(args: SelectSubset<T, PolicyDefinitionUpsertArgs<ExtArgs>>): Prisma__PolicyDefinitionClient<$Result.GetResult<Prisma.$PolicyDefinitionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PolicyDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyDefinitionCountArgs} args - Arguments to filter PolicyDefinitions to count.
     * @example
     * // Count the number of PolicyDefinitions
     * const count = await prisma.policyDefinition.count({
     *   where: {
     *     // ... the filter for the PolicyDefinitions we want to count
     *   }
     * })
    **/
    count<T extends PolicyDefinitionCountArgs>(
      args?: Subset<T, PolicyDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PolicyDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyDefinitionAggregateArgs>(args: Subset<T, PolicyDefinitionAggregateArgs>): Prisma.PrismaPromise<GetPolicyDefinitionAggregateType<T>>

    /**
     * Group by PolicyDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: PolicyDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PolicyDefinition model
   */
  readonly fields: PolicyDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PolicyDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    versions<T extends PolicyDefinition$versionsArgs<ExtArgs> = {}>(args?: Subset<T, PolicyDefinition$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PolicyDefinition model
   */ 
  interface PolicyDefinitionFieldRefs {
    readonly id: FieldRef<"PolicyDefinition", 'String'>
    readonly code: FieldRef<"PolicyDefinition", 'String'>
    readonly name: FieldRef<"PolicyDefinition", 'String'>
    readonly type: FieldRef<"PolicyDefinition", 'String'>
    readonly description: FieldRef<"PolicyDefinition", 'String'>
    readonly createdAt: FieldRef<"PolicyDefinition", 'DateTime'>
    readonly updatedAt: FieldRef<"PolicyDefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PolicyDefinition findUnique
   */
  export type PolicyDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinition
     */
    select?: PolicyDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyDefinition to fetch.
     */
    where: PolicyDefinitionWhereUniqueInput
  }

  /**
   * PolicyDefinition findUniqueOrThrow
   */
  export type PolicyDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinition
     */
    select?: PolicyDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyDefinition to fetch.
     */
    where: PolicyDefinitionWhereUniqueInput
  }

  /**
   * PolicyDefinition findFirst
   */
  export type PolicyDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinition
     */
    select?: PolicyDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyDefinition to fetch.
     */
    where?: PolicyDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyDefinitions to fetch.
     */
    orderBy?: PolicyDefinitionOrderByWithRelationInput | PolicyDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyDefinitions.
     */
    cursor?: PolicyDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyDefinitions.
     */
    distinct?: PolicyDefinitionScalarFieldEnum | PolicyDefinitionScalarFieldEnum[]
  }

  /**
   * PolicyDefinition findFirstOrThrow
   */
  export type PolicyDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinition
     */
    select?: PolicyDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyDefinition to fetch.
     */
    where?: PolicyDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyDefinitions to fetch.
     */
    orderBy?: PolicyDefinitionOrderByWithRelationInput | PolicyDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyDefinitions.
     */
    cursor?: PolicyDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyDefinitions.
     */
    distinct?: PolicyDefinitionScalarFieldEnum | PolicyDefinitionScalarFieldEnum[]
  }

  /**
   * PolicyDefinition findMany
   */
  export type PolicyDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinition
     */
    select?: PolicyDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyDefinitions to fetch.
     */
    where?: PolicyDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyDefinitions to fetch.
     */
    orderBy?: PolicyDefinitionOrderByWithRelationInput | PolicyDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PolicyDefinitions.
     */
    cursor?: PolicyDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyDefinitions.
     */
    skip?: number
    distinct?: PolicyDefinitionScalarFieldEnum | PolicyDefinitionScalarFieldEnum[]
  }

  /**
   * PolicyDefinition create
   */
  export type PolicyDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinition
     */
    select?: PolicyDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a PolicyDefinition.
     */
    data: XOR<PolicyDefinitionCreateInput, PolicyDefinitionUncheckedCreateInput>
  }

  /**
   * PolicyDefinition createMany
   */
  export type PolicyDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PolicyDefinitions.
     */
    data: PolicyDefinitionCreateManyInput | PolicyDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PolicyDefinition createManyAndReturn
   */
  export type PolicyDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinition
     */
    select?: PolicyDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PolicyDefinitions.
     */
    data: PolicyDefinitionCreateManyInput | PolicyDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PolicyDefinition update
   */
  export type PolicyDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinition
     */
    select?: PolicyDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a PolicyDefinition.
     */
    data: XOR<PolicyDefinitionUpdateInput, PolicyDefinitionUncheckedUpdateInput>
    /**
     * Choose, which PolicyDefinition to update.
     */
    where: PolicyDefinitionWhereUniqueInput
  }

  /**
   * PolicyDefinition updateMany
   */
  export type PolicyDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PolicyDefinitions.
     */
    data: XOR<PolicyDefinitionUpdateManyMutationInput, PolicyDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which PolicyDefinitions to update
     */
    where?: PolicyDefinitionWhereInput
  }

  /**
   * PolicyDefinition upsert
   */
  export type PolicyDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinition
     */
    select?: PolicyDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the PolicyDefinition to update in case it exists.
     */
    where: PolicyDefinitionWhereUniqueInput
    /**
     * In case the PolicyDefinition found by the `where` argument doesn't exist, create a new PolicyDefinition with this data.
     */
    create: XOR<PolicyDefinitionCreateInput, PolicyDefinitionUncheckedCreateInput>
    /**
     * In case the PolicyDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyDefinitionUpdateInput, PolicyDefinitionUncheckedUpdateInput>
  }

  /**
   * PolicyDefinition delete
   */
  export type PolicyDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinition
     */
    select?: PolicyDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyDefinitionInclude<ExtArgs> | null
    /**
     * Filter which PolicyDefinition to delete.
     */
    where: PolicyDefinitionWhereUniqueInput
  }

  /**
   * PolicyDefinition deleteMany
   */
  export type PolicyDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolicyDefinitions to delete
     */
    where?: PolicyDefinitionWhereInput
  }

  /**
   * PolicyDefinition.versions
   */
  export type PolicyDefinition$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    where?: PolicyVersionWhereInput
    orderBy?: PolicyVersionOrderByWithRelationInput | PolicyVersionOrderByWithRelationInput[]
    cursor?: PolicyVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyVersionScalarFieldEnum | PolicyVersionScalarFieldEnum[]
  }

  /**
   * PolicyDefinition without action
   */
  export type PolicyDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyDefinition
     */
    select?: PolicyDefinitionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model PolicyVersion
   */

  export type AggregatePolicyVersion = {
    _count: PolicyVersionCountAggregateOutputType | null
    _avg: PolicyVersionAvgAggregateOutputType | null
    _sum: PolicyVersionSumAggregateOutputType | null
    _min: PolicyVersionMinAggregateOutputType | null
    _max: PolicyVersionMaxAggregateOutputType | null
  }

  export type PolicyVersionAvgAggregateOutputType = {
    version: number | null
  }

  export type PolicyVersionSumAggregateOutputType = {
    version: number | null
  }

  export type PolicyVersionMinAggregateOutputType = {
    id: string | null
    policyId: string | null
    scope: $Enums.PolicyScope | null
    branchId: string | null
    version: number | null
    status: $Enums.PolicyVersionStatus | null
    effectiveAt: Date | null
    notes: string | null
    applyToAllBranches: boolean | null
    createdByUserId: string | null
    submittedAt: Date | null
    submittedByUserId: string | null
    approvedAt: Date | null
    approvedByUserId: string | null
    approvalNote: string | null
    rejectedAt: Date | null
    rejectedByUserId: string | null
    rejectionReason: string | null
    retiredAt: Date | null
    retiredByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PolicyVersionMaxAggregateOutputType = {
    id: string | null
    policyId: string | null
    scope: $Enums.PolicyScope | null
    branchId: string | null
    version: number | null
    status: $Enums.PolicyVersionStatus | null
    effectiveAt: Date | null
    notes: string | null
    applyToAllBranches: boolean | null
    createdByUserId: string | null
    submittedAt: Date | null
    submittedByUserId: string | null
    approvedAt: Date | null
    approvedByUserId: string | null
    approvalNote: string | null
    rejectedAt: Date | null
    rejectedByUserId: string | null
    rejectionReason: string | null
    retiredAt: Date | null
    retiredByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PolicyVersionCountAggregateOutputType = {
    id: number
    policyId: number
    scope: number
    branchId: number
    version: number
    status: number
    effectiveAt: number
    notes: number
    payload: number
    applyToAllBranches: number
    createdByUserId: number
    submittedAt: number
    submittedByUserId: number
    approvedAt: number
    approvedByUserId: number
    approvalNote: number
    rejectedAt: number
    rejectedByUserId: number
    rejectionReason: number
    retiredAt: number
    retiredByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PolicyVersionAvgAggregateInputType = {
    version?: true
  }

  export type PolicyVersionSumAggregateInputType = {
    version?: true
  }

  export type PolicyVersionMinAggregateInputType = {
    id?: true
    policyId?: true
    scope?: true
    branchId?: true
    version?: true
    status?: true
    effectiveAt?: true
    notes?: true
    applyToAllBranches?: true
    createdByUserId?: true
    submittedAt?: true
    submittedByUserId?: true
    approvedAt?: true
    approvedByUserId?: true
    approvalNote?: true
    rejectedAt?: true
    rejectedByUserId?: true
    rejectionReason?: true
    retiredAt?: true
    retiredByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PolicyVersionMaxAggregateInputType = {
    id?: true
    policyId?: true
    scope?: true
    branchId?: true
    version?: true
    status?: true
    effectiveAt?: true
    notes?: true
    applyToAllBranches?: true
    createdByUserId?: true
    submittedAt?: true
    submittedByUserId?: true
    approvedAt?: true
    approvedByUserId?: true
    approvalNote?: true
    rejectedAt?: true
    rejectedByUserId?: true
    rejectionReason?: true
    retiredAt?: true
    retiredByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PolicyVersionCountAggregateInputType = {
    id?: true
    policyId?: true
    scope?: true
    branchId?: true
    version?: true
    status?: true
    effectiveAt?: true
    notes?: true
    payload?: true
    applyToAllBranches?: true
    createdByUserId?: true
    submittedAt?: true
    submittedByUserId?: true
    approvedAt?: true
    approvedByUserId?: true
    approvalNote?: true
    rejectedAt?: true
    rejectedByUserId?: true
    rejectionReason?: true
    retiredAt?: true
    retiredByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PolicyVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolicyVersion to aggregate.
     */
    where?: PolicyVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyVersions to fetch.
     */
    orderBy?: PolicyVersionOrderByWithRelationInput | PolicyVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PolicyVersions
    **/
    _count?: true | PolicyVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolicyVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolicyVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyVersionMaxAggregateInputType
  }

  export type GetPolicyVersionAggregateType<T extends PolicyVersionAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicyVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicyVersion[P]>
      : GetScalarType<T[P], AggregatePolicyVersion[P]>
  }




  export type PolicyVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyVersionWhereInput
    orderBy?: PolicyVersionOrderByWithAggregationInput | PolicyVersionOrderByWithAggregationInput[]
    by: PolicyVersionScalarFieldEnum[] | PolicyVersionScalarFieldEnum
    having?: PolicyVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyVersionCountAggregateInputType | true
    _avg?: PolicyVersionAvgAggregateInputType
    _sum?: PolicyVersionSumAggregateInputType
    _min?: PolicyVersionMinAggregateInputType
    _max?: PolicyVersionMaxAggregateInputType
  }

  export type PolicyVersionGroupByOutputType = {
    id: string
    policyId: string
    scope: $Enums.PolicyScope
    branchId: string | null
    version: number
    status: $Enums.PolicyVersionStatus
    effectiveAt: Date
    notes: string | null
    payload: JsonValue
    applyToAllBranches: boolean
    createdByUserId: string | null
    submittedAt: Date | null
    submittedByUserId: string | null
    approvedAt: Date | null
    approvedByUserId: string | null
    approvalNote: string | null
    rejectedAt: Date | null
    rejectedByUserId: string | null
    rejectionReason: string | null
    retiredAt: Date | null
    retiredByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PolicyVersionCountAggregateOutputType | null
    _avg: PolicyVersionAvgAggregateOutputType | null
    _sum: PolicyVersionSumAggregateOutputType | null
    _min: PolicyVersionMinAggregateOutputType | null
    _max: PolicyVersionMaxAggregateOutputType | null
  }

  type GetPolicyVersionGroupByPayload<T extends PolicyVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyVersionGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyVersionGroupByOutputType[P]>
        }
      >
    >


  export type PolicyVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    policyId?: boolean
    scope?: boolean
    branchId?: boolean
    version?: boolean
    status?: boolean
    effectiveAt?: boolean
    notes?: boolean
    payload?: boolean
    applyToAllBranches?: boolean
    createdByUserId?: boolean
    submittedAt?: boolean
    submittedByUserId?: boolean
    approvedAt?: boolean
    approvedByUserId?: boolean
    approvalNote?: boolean
    rejectedAt?: boolean
    rejectedByUserId?: boolean
    rejectionReason?: boolean
    retiredAt?: boolean
    retiredByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    policy?: boolean | PolicyDefinitionDefaultArgs<ExtArgs>
    branch?: boolean | PolicyVersion$branchArgs<ExtArgs>
    branches?: boolean | PolicyVersion$branchesArgs<ExtArgs>
    createdByUser?: boolean | PolicyVersion$createdByUserArgs<ExtArgs>
    submittedByUser?: boolean | PolicyVersion$submittedByUserArgs<ExtArgs>
    approvedByUser?: boolean | PolicyVersion$approvedByUserArgs<ExtArgs>
    rejectedByUser?: boolean | PolicyVersion$rejectedByUserArgs<ExtArgs>
    retiredByUser?: boolean | PolicyVersion$retiredByUserArgs<ExtArgs>
    _count?: boolean | PolicyVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policyVersion"]>

  export type PolicyVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    policyId?: boolean
    scope?: boolean
    branchId?: boolean
    version?: boolean
    status?: boolean
    effectiveAt?: boolean
    notes?: boolean
    payload?: boolean
    applyToAllBranches?: boolean
    createdByUserId?: boolean
    submittedAt?: boolean
    submittedByUserId?: boolean
    approvedAt?: boolean
    approvedByUserId?: boolean
    approvalNote?: boolean
    rejectedAt?: boolean
    rejectedByUserId?: boolean
    rejectionReason?: boolean
    retiredAt?: boolean
    retiredByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    policy?: boolean | PolicyDefinitionDefaultArgs<ExtArgs>
    branch?: boolean | PolicyVersion$branchArgs<ExtArgs>
    createdByUser?: boolean | PolicyVersion$createdByUserArgs<ExtArgs>
    submittedByUser?: boolean | PolicyVersion$submittedByUserArgs<ExtArgs>
    approvedByUser?: boolean | PolicyVersion$approvedByUserArgs<ExtArgs>
    rejectedByUser?: boolean | PolicyVersion$rejectedByUserArgs<ExtArgs>
    retiredByUser?: boolean | PolicyVersion$retiredByUserArgs<ExtArgs>
  }, ExtArgs["result"]["policyVersion"]>

  export type PolicyVersionSelectScalar = {
    id?: boolean
    policyId?: boolean
    scope?: boolean
    branchId?: boolean
    version?: boolean
    status?: boolean
    effectiveAt?: boolean
    notes?: boolean
    payload?: boolean
    applyToAllBranches?: boolean
    createdByUserId?: boolean
    submittedAt?: boolean
    submittedByUserId?: boolean
    approvedAt?: boolean
    approvedByUserId?: boolean
    approvalNote?: boolean
    rejectedAt?: boolean
    rejectedByUserId?: boolean
    rejectionReason?: boolean
    retiredAt?: boolean
    retiredByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PolicyVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policy?: boolean | PolicyDefinitionDefaultArgs<ExtArgs>
    branch?: boolean | PolicyVersion$branchArgs<ExtArgs>
    branches?: boolean | PolicyVersion$branchesArgs<ExtArgs>
    createdByUser?: boolean | PolicyVersion$createdByUserArgs<ExtArgs>
    submittedByUser?: boolean | PolicyVersion$submittedByUserArgs<ExtArgs>
    approvedByUser?: boolean | PolicyVersion$approvedByUserArgs<ExtArgs>
    rejectedByUser?: boolean | PolicyVersion$rejectedByUserArgs<ExtArgs>
    retiredByUser?: boolean | PolicyVersion$retiredByUserArgs<ExtArgs>
    _count?: boolean | PolicyVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PolicyVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policy?: boolean | PolicyDefinitionDefaultArgs<ExtArgs>
    branch?: boolean | PolicyVersion$branchArgs<ExtArgs>
    createdByUser?: boolean | PolicyVersion$createdByUserArgs<ExtArgs>
    submittedByUser?: boolean | PolicyVersion$submittedByUserArgs<ExtArgs>
    approvedByUser?: boolean | PolicyVersion$approvedByUserArgs<ExtArgs>
    rejectedByUser?: boolean | PolicyVersion$rejectedByUserArgs<ExtArgs>
    retiredByUser?: boolean | PolicyVersion$retiredByUserArgs<ExtArgs>
  }

  export type $PolicyVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PolicyVersion"
    objects: {
      policy: Prisma.$PolicyDefinitionPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
      branches: Prisma.$PolicyVersionBranchPayload<ExtArgs>[]
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
      submittedByUser: Prisma.$UserPayload<ExtArgs> | null
      approvedByUser: Prisma.$UserPayload<ExtArgs> | null
      rejectedByUser: Prisma.$UserPayload<ExtArgs> | null
      retiredByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      policyId: string
      scope: $Enums.PolicyScope
      branchId: string | null
      version: number
      status: $Enums.PolicyVersionStatus
      effectiveAt: Date
      notes: string | null
      payload: Prisma.JsonValue
      applyToAllBranches: boolean
      createdByUserId: string | null
      submittedAt: Date | null
      submittedByUserId: string | null
      approvedAt: Date | null
      approvedByUserId: string | null
      approvalNote: string | null
      rejectedAt: Date | null
      rejectedByUserId: string | null
      rejectionReason: string | null
      retiredAt: Date | null
      retiredByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["policyVersion"]>
    composites: {}
  }

  type PolicyVersionGetPayload<S extends boolean | null | undefined | PolicyVersionDefaultArgs> = $Result.GetResult<Prisma.$PolicyVersionPayload, S>

  type PolicyVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PolicyVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PolicyVersionCountAggregateInputType | true
    }

  export interface PolicyVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PolicyVersion'], meta: { name: 'PolicyVersion' } }
    /**
     * Find zero or one PolicyVersion that matches the filter.
     * @param {PolicyVersionFindUniqueArgs} args - Arguments to find a PolicyVersion
     * @example
     * // Get one PolicyVersion
     * const policyVersion = await prisma.policyVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyVersionFindUniqueArgs>(args: SelectSubset<T, PolicyVersionFindUniqueArgs<ExtArgs>>): Prisma__PolicyVersionClient<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PolicyVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PolicyVersionFindUniqueOrThrowArgs} args - Arguments to find a PolicyVersion
     * @example
     * // Get one PolicyVersion
     * const policyVersion = await prisma.policyVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyVersionClient<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PolicyVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionFindFirstArgs} args - Arguments to find a PolicyVersion
     * @example
     * // Get one PolicyVersion
     * const policyVersion = await prisma.policyVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyVersionFindFirstArgs>(args?: SelectSubset<T, PolicyVersionFindFirstArgs<ExtArgs>>): Prisma__PolicyVersionClient<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PolicyVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionFindFirstOrThrowArgs} args - Arguments to find a PolicyVersion
     * @example
     * // Get one PolicyVersion
     * const policyVersion = await prisma.policyVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyVersionClient<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PolicyVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PolicyVersions
     * const policyVersions = await prisma.policyVersion.findMany()
     * 
     * // Get first 10 PolicyVersions
     * const policyVersions = await prisma.policyVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyVersionWithIdOnly = await prisma.policyVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolicyVersionFindManyArgs>(args?: SelectSubset<T, PolicyVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PolicyVersion.
     * @param {PolicyVersionCreateArgs} args - Arguments to create a PolicyVersion.
     * @example
     * // Create one PolicyVersion
     * const PolicyVersion = await prisma.policyVersion.create({
     *   data: {
     *     // ... data to create a PolicyVersion
     *   }
     * })
     * 
     */
    create<T extends PolicyVersionCreateArgs>(args: SelectSubset<T, PolicyVersionCreateArgs<ExtArgs>>): Prisma__PolicyVersionClient<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PolicyVersions.
     * @param {PolicyVersionCreateManyArgs} args - Arguments to create many PolicyVersions.
     * @example
     * // Create many PolicyVersions
     * const policyVersion = await prisma.policyVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyVersionCreateManyArgs>(args?: SelectSubset<T, PolicyVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PolicyVersions and returns the data saved in the database.
     * @param {PolicyVersionCreateManyAndReturnArgs} args - Arguments to create many PolicyVersions.
     * @example
     * // Create many PolicyVersions
     * const policyVersion = await prisma.policyVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PolicyVersions and only return the `id`
     * const policyVersionWithIdOnly = await prisma.policyVersion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PolicyVersion.
     * @param {PolicyVersionDeleteArgs} args - Arguments to delete one PolicyVersion.
     * @example
     * // Delete one PolicyVersion
     * const PolicyVersion = await prisma.policyVersion.delete({
     *   where: {
     *     // ... filter to delete one PolicyVersion
     *   }
     * })
     * 
     */
    delete<T extends PolicyVersionDeleteArgs>(args: SelectSubset<T, PolicyVersionDeleteArgs<ExtArgs>>): Prisma__PolicyVersionClient<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PolicyVersion.
     * @param {PolicyVersionUpdateArgs} args - Arguments to update one PolicyVersion.
     * @example
     * // Update one PolicyVersion
     * const policyVersion = await prisma.policyVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyVersionUpdateArgs>(args: SelectSubset<T, PolicyVersionUpdateArgs<ExtArgs>>): Prisma__PolicyVersionClient<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PolicyVersions.
     * @param {PolicyVersionDeleteManyArgs} args - Arguments to filter PolicyVersions to delete.
     * @example
     * // Delete a few PolicyVersions
     * const { count } = await prisma.policyVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyVersionDeleteManyArgs>(args?: SelectSubset<T, PolicyVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolicyVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PolicyVersions
     * const policyVersion = await prisma.policyVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyVersionUpdateManyArgs>(args: SelectSubset<T, PolicyVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PolicyVersion.
     * @param {PolicyVersionUpsertArgs} args - Arguments to update or create a PolicyVersion.
     * @example
     * // Update or create a PolicyVersion
     * const policyVersion = await prisma.policyVersion.upsert({
     *   create: {
     *     // ... data to create a PolicyVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PolicyVersion we want to update
     *   }
     * })
     */
    upsert<T extends PolicyVersionUpsertArgs>(args: SelectSubset<T, PolicyVersionUpsertArgs<ExtArgs>>): Prisma__PolicyVersionClient<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PolicyVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionCountArgs} args - Arguments to filter PolicyVersions to count.
     * @example
     * // Count the number of PolicyVersions
     * const count = await prisma.policyVersion.count({
     *   where: {
     *     // ... the filter for the PolicyVersions we want to count
     *   }
     * })
    **/
    count<T extends PolicyVersionCountArgs>(
      args?: Subset<T, PolicyVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PolicyVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyVersionAggregateArgs>(args: Subset<T, PolicyVersionAggregateArgs>): Prisma.PrismaPromise<GetPolicyVersionAggregateType<T>>

    /**
     * Group by PolicyVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyVersionGroupByArgs['orderBy'] }
        : { orderBy?: PolicyVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PolicyVersion model
   */
  readonly fields: PolicyVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PolicyVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    policy<T extends PolicyDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PolicyDefinitionDefaultArgs<ExtArgs>>): Prisma__PolicyDefinitionClient<$Result.GetResult<Prisma.$PolicyDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends PolicyVersion$branchArgs<ExtArgs> = {}>(args?: Subset<T, PolicyVersion$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    branches<T extends PolicyVersion$branchesArgs<ExtArgs> = {}>(args?: Subset<T, PolicyVersion$branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "findMany"> | Null>
    createdByUser<T extends PolicyVersion$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, PolicyVersion$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    submittedByUser<T extends PolicyVersion$submittedByUserArgs<ExtArgs> = {}>(args?: Subset<T, PolicyVersion$submittedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    approvedByUser<T extends PolicyVersion$approvedByUserArgs<ExtArgs> = {}>(args?: Subset<T, PolicyVersion$approvedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    rejectedByUser<T extends PolicyVersion$rejectedByUserArgs<ExtArgs> = {}>(args?: Subset<T, PolicyVersion$rejectedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    retiredByUser<T extends PolicyVersion$retiredByUserArgs<ExtArgs> = {}>(args?: Subset<T, PolicyVersion$retiredByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PolicyVersion model
   */ 
  interface PolicyVersionFieldRefs {
    readonly id: FieldRef<"PolicyVersion", 'String'>
    readonly policyId: FieldRef<"PolicyVersion", 'String'>
    readonly scope: FieldRef<"PolicyVersion", 'PolicyScope'>
    readonly branchId: FieldRef<"PolicyVersion", 'String'>
    readonly version: FieldRef<"PolicyVersion", 'Int'>
    readonly status: FieldRef<"PolicyVersion", 'PolicyVersionStatus'>
    readonly effectiveAt: FieldRef<"PolicyVersion", 'DateTime'>
    readonly notes: FieldRef<"PolicyVersion", 'String'>
    readonly payload: FieldRef<"PolicyVersion", 'Json'>
    readonly applyToAllBranches: FieldRef<"PolicyVersion", 'Boolean'>
    readonly createdByUserId: FieldRef<"PolicyVersion", 'String'>
    readonly submittedAt: FieldRef<"PolicyVersion", 'DateTime'>
    readonly submittedByUserId: FieldRef<"PolicyVersion", 'String'>
    readonly approvedAt: FieldRef<"PolicyVersion", 'DateTime'>
    readonly approvedByUserId: FieldRef<"PolicyVersion", 'String'>
    readonly approvalNote: FieldRef<"PolicyVersion", 'String'>
    readonly rejectedAt: FieldRef<"PolicyVersion", 'DateTime'>
    readonly rejectedByUserId: FieldRef<"PolicyVersion", 'String'>
    readonly rejectionReason: FieldRef<"PolicyVersion", 'String'>
    readonly retiredAt: FieldRef<"PolicyVersion", 'DateTime'>
    readonly retiredByUserId: FieldRef<"PolicyVersion", 'String'>
    readonly createdAt: FieldRef<"PolicyVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"PolicyVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PolicyVersion findUnique
   */
  export type PolicyVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyVersion to fetch.
     */
    where: PolicyVersionWhereUniqueInput
  }

  /**
   * PolicyVersion findUniqueOrThrow
   */
  export type PolicyVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyVersion to fetch.
     */
    where: PolicyVersionWhereUniqueInput
  }

  /**
   * PolicyVersion findFirst
   */
  export type PolicyVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyVersion to fetch.
     */
    where?: PolicyVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyVersions to fetch.
     */
    orderBy?: PolicyVersionOrderByWithRelationInput | PolicyVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyVersions.
     */
    cursor?: PolicyVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyVersions.
     */
    distinct?: PolicyVersionScalarFieldEnum | PolicyVersionScalarFieldEnum[]
  }

  /**
   * PolicyVersion findFirstOrThrow
   */
  export type PolicyVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyVersion to fetch.
     */
    where?: PolicyVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyVersions to fetch.
     */
    orderBy?: PolicyVersionOrderByWithRelationInput | PolicyVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyVersions.
     */
    cursor?: PolicyVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyVersions.
     */
    distinct?: PolicyVersionScalarFieldEnum | PolicyVersionScalarFieldEnum[]
  }

  /**
   * PolicyVersion findMany
   */
  export type PolicyVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    /**
     * Filter, which PolicyVersions to fetch.
     */
    where?: PolicyVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyVersions to fetch.
     */
    orderBy?: PolicyVersionOrderByWithRelationInput | PolicyVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PolicyVersions.
     */
    cursor?: PolicyVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyVersions.
     */
    skip?: number
    distinct?: PolicyVersionScalarFieldEnum | PolicyVersionScalarFieldEnum[]
  }

  /**
   * PolicyVersion create
   */
  export type PolicyVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a PolicyVersion.
     */
    data: XOR<PolicyVersionCreateInput, PolicyVersionUncheckedCreateInput>
  }

  /**
   * PolicyVersion createMany
   */
  export type PolicyVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PolicyVersions.
     */
    data: PolicyVersionCreateManyInput | PolicyVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PolicyVersion createManyAndReturn
   */
  export type PolicyVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PolicyVersions.
     */
    data: PolicyVersionCreateManyInput | PolicyVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PolicyVersion update
   */
  export type PolicyVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a PolicyVersion.
     */
    data: XOR<PolicyVersionUpdateInput, PolicyVersionUncheckedUpdateInput>
    /**
     * Choose, which PolicyVersion to update.
     */
    where: PolicyVersionWhereUniqueInput
  }

  /**
   * PolicyVersion updateMany
   */
  export type PolicyVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PolicyVersions.
     */
    data: XOR<PolicyVersionUpdateManyMutationInput, PolicyVersionUncheckedUpdateManyInput>
    /**
     * Filter which PolicyVersions to update
     */
    where?: PolicyVersionWhereInput
  }

  /**
   * PolicyVersion upsert
   */
  export type PolicyVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the PolicyVersion to update in case it exists.
     */
    where: PolicyVersionWhereUniqueInput
    /**
     * In case the PolicyVersion found by the `where` argument doesn't exist, create a new PolicyVersion with this data.
     */
    create: XOR<PolicyVersionCreateInput, PolicyVersionUncheckedCreateInput>
    /**
     * In case the PolicyVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyVersionUpdateInput, PolicyVersionUncheckedUpdateInput>
  }

  /**
   * PolicyVersion delete
   */
  export type PolicyVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
    /**
     * Filter which PolicyVersion to delete.
     */
    where: PolicyVersionWhereUniqueInput
  }

  /**
   * PolicyVersion deleteMany
   */
  export type PolicyVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolicyVersions to delete
     */
    where?: PolicyVersionWhereInput
  }

  /**
   * PolicyVersion.branch
   */
  export type PolicyVersion$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * PolicyVersion.branches
   */
  export type PolicyVersion$branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
    where?: PolicyVersionBranchWhereInput
    orderBy?: PolicyVersionBranchOrderByWithRelationInput | PolicyVersionBranchOrderByWithRelationInput[]
    cursor?: PolicyVersionBranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PolicyVersionBranchScalarFieldEnum | PolicyVersionBranchScalarFieldEnum[]
  }

  /**
   * PolicyVersion.createdByUser
   */
  export type PolicyVersion$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PolicyVersion.submittedByUser
   */
  export type PolicyVersion$submittedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PolicyVersion.approvedByUser
   */
  export type PolicyVersion$approvedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PolicyVersion.rejectedByUser
   */
  export type PolicyVersion$rejectedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PolicyVersion.retiredByUser
   */
  export type PolicyVersion$retiredByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PolicyVersion without action
   */
  export type PolicyVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersion
     */
    select?: PolicyVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionInclude<ExtArgs> | null
  }


  /**
   * Model PolicyVersionBranch
   */

  export type AggregatePolicyVersionBranch = {
    _count: PolicyVersionBranchCountAggregateOutputType | null
    _min: PolicyVersionBranchMinAggregateOutputType | null
    _max: PolicyVersionBranchMaxAggregateOutputType | null
  }

  export type PolicyVersionBranchMinAggregateOutputType = {
    id: string | null
    policyVersionId: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type PolicyVersionBranchMaxAggregateOutputType = {
    id: string | null
    policyVersionId: string | null
    branchId: string | null
    createdAt: Date | null
  }

  export type PolicyVersionBranchCountAggregateOutputType = {
    id: number
    policyVersionId: number
    branchId: number
    createdAt: number
    _all: number
  }


  export type PolicyVersionBranchMinAggregateInputType = {
    id?: true
    policyVersionId?: true
    branchId?: true
    createdAt?: true
  }

  export type PolicyVersionBranchMaxAggregateInputType = {
    id?: true
    policyVersionId?: true
    branchId?: true
    createdAt?: true
  }

  export type PolicyVersionBranchCountAggregateInputType = {
    id?: true
    policyVersionId?: true
    branchId?: true
    createdAt?: true
    _all?: true
  }

  export type PolicyVersionBranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolicyVersionBranch to aggregate.
     */
    where?: PolicyVersionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyVersionBranches to fetch.
     */
    orderBy?: PolicyVersionBranchOrderByWithRelationInput | PolicyVersionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyVersionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyVersionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyVersionBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PolicyVersionBranches
    **/
    _count?: true | PolicyVersionBranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyVersionBranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyVersionBranchMaxAggregateInputType
  }

  export type GetPolicyVersionBranchAggregateType<T extends PolicyVersionBranchAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicyVersionBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicyVersionBranch[P]>
      : GetScalarType<T[P], AggregatePolicyVersionBranch[P]>
  }




  export type PolicyVersionBranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyVersionBranchWhereInput
    orderBy?: PolicyVersionBranchOrderByWithAggregationInput | PolicyVersionBranchOrderByWithAggregationInput[]
    by: PolicyVersionBranchScalarFieldEnum[] | PolicyVersionBranchScalarFieldEnum
    having?: PolicyVersionBranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyVersionBranchCountAggregateInputType | true
    _min?: PolicyVersionBranchMinAggregateInputType
    _max?: PolicyVersionBranchMaxAggregateInputType
  }

  export type PolicyVersionBranchGroupByOutputType = {
    id: string
    policyVersionId: string
    branchId: string
    createdAt: Date
    _count: PolicyVersionBranchCountAggregateOutputType | null
    _min: PolicyVersionBranchMinAggregateOutputType | null
    _max: PolicyVersionBranchMaxAggregateOutputType | null
  }

  type GetPolicyVersionBranchGroupByPayload<T extends PolicyVersionBranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyVersionBranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyVersionBranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyVersionBranchGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyVersionBranchGroupByOutputType[P]>
        }
      >
    >


  export type PolicyVersionBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    policyVersionId?: boolean
    branchId?: boolean
    createdAt?: boolean
    policyVersion?: boolean | PolicyVersionDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policyVersionBranch"]>

  export type PolicyVersionBranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    policyVersionId?: boolean
    branchId?: boolean
    createdAt?: boolean
    policyVersion?: boolean | PolicyVersionDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["policyVersionBranch"]>

  export type PolicyVersionBranchSelectScalar = {
    id?: boolean
    policyVersionId?: boolean
    branchId?: boolean
    createdAt?: boolean
  }

  export type PolicyVersionBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policyVersion?: boolean | PolicyVersionDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type PolicyVersionBranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    policyVersion?: boolean | PolicyVersionDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $PolicyVersionBranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PolicyVersionBranch"
    objects: {
      policyVersion: Prisma.$PolicyVersionPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      policyVersionId: string
      branchId: string
      createdAt: Date
    }, ExtArgs["result"]["policyVersionBranch"]>
    composites: {}
  }

  type PolicyVersionBranchGetPayload<S extends boolean | null | undefined | PolicyVersionBranchDefaultArgs> = $Result.GetResult<Prisma.$PolicyVersionBranchPayload, S>

  type PolicyVersionBranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PolicyVersionBranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PolicyVersionBranchCountAggregateInputType | true
    }

  export interface PolicyVersionBranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PolicyVersionBranch'], meta: { name: 'PolicyVersionBranch' } }
    /**
     * Find zero or one PolicyVersionBranch that matches the filter.
     * @param {PolicyVersionBranchFindUniqueArgs} args - Arguments to find a PolicyVersionBranch
     * @example
     * // Get one PolicyVersionBranch
     * const policyVersionBranch = await prisma.policyVersionBranch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyVersionBranchFindUniqueArgs>(args: SelectSubset<T, PolicyVersionBranchFindUniqueArgs<ExtArgs>>): Prisma__PolicyVersionBranchClient<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PolicyVersionBranch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PolicyVersionBranchFindUniqueOrThrowArgs} args - Arguments to find a PolicyVersionBranch
     * @example
     * // Get one PolicyVersionBranch
     * const policyVersionBranch = await prisma.policyVersionBranch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyVersionBranchFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyVersionBranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyVersionBranchClient<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PolicyVersionBranch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionBranchFindFirstArgs} args - Arguments to find a PolicyVersionBranch
     * @example
     * // Get one PolicyVersionBranch
     * const policyVersionBranch = await prisma.policyVersionBranch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyVersionBranchFindFirstArgs>(args?: SelectSubset<T, PolicyVersionBranchFindFirstArgs<ExtArgs>>): Prisma__PolicyVersionBranchClient<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PolicyVersionBranch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionBranchFindFirstOrThrowArgs} args - Arguments to find a PolicyVersionBranch
     * @example
     * // Get one PolicyVersionBranch
     * const policyVersionBranch = await prisma.policyVersionBranch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyVersionBranchFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyVersionBranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyVersionBranchClient<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PolicyVersionBranches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionBranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PolicyVersionBranches
     * const policyVersionBranches = await prisma.policyVersionBranch.findMany()
     * 
     * // Get first 10 PolicyVersionBranches
     * const policyVersionBranches = await prisma.policyVersionBranch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyVersionBranchWithIdOnly = await prisma.policyVersionBranch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolicyVersionBranchFindManyArgs>(args?: SelectSubset<T, PolicyVersionBranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PolicyVersionBranch.
     * @param {PolicyVersionBranchCreateArgs} args - Arguments to create a PolicyVersionBranch.
     * @example
     * // Create one PolicyVersionBranch
     * const PolicyVersionBranch = await prisma.policyVersionBranch.create({
     *   data: {
     *     // ... data to create a PolicyVersionBranch
     *   }
     * })
     * 
     */
    create<T extends PolicyVersionBranchCreateArgs>(args: SelectSubset<T, PolicyVersionBranchCreateArgs<ExtArgs>>): Prisma__PolicyVersionBranchClient<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PolicyVersionBranches.
     * @param {PolicyVersionBranchCreateManyArgs} args - Arguments to create many PolicyVersionBranches.
     * @example
     * // Create many PolicyVersionBranches
     * const policyVersionBranch = await prisma.policyVersionBranch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyVersionBranchCreateManyArgs>(args?: SelectSubset<T, PolicyVersionBranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PolicyVersionBranches and returns the data saved in the database.
     * @param {PolicyVersionBranchCreateManyAndReturnArgs} args - Arguments to create many PolicyVersionBranches.
     * @example
     * // Create many PolicyVersionBranches
     * const policyVersionBranch = await prisma.policyVersionBranch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PolicyVersionBranches and only return the `id`
     * const policyVersionBranchWithIdOnly = await prisma.policyVersionBranch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyVersionBranchCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyVersionBranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PolicyVersionBranch.
     * @param {PolicyVersionBranchDeleteArgs} args - Arguments to delete one PolicyVersionBranch.
     * @example
     * // Delete one PolicyVersionBranch
     * const PolicyVersionBranch = await prisma.policyVersionBranch.delete({
     *   where: {
     *     // ... filter to delete one PolicyVersionBranch
     *   }
     * })
     * 
     */
    delete<T extends PolicyVersionBranchDeleteArgs>(args: SelectSubset<T, PolicyVersionBranchDeleteArgs<ExtArgs>>): Prisma__PolicyVersionBranchClient<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PolicyVersionBranch.
     * @param {PolicyVersionBranchUpdateArgs} args - Arguments to update one PolicyVersionBranch.
     * @example
     * // Update one PolicyVersionBranch
     * const policyVersionBranch = await prisma.policyVersionBranch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyVersionBranchUpdateArgs>(args: SelectSubset<T, PolicyVersionBranchUpdateArgs<ExtArgs>>): Prisma__PolicyVersionBranchClient<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PolicyVersionBranches.
     * @param {PolicyVersionBranchDeleteManyArgs} args - Arguments to filter PolicyVersionBranches to delete.
     * @example
     * // Delete a few PolicyVersionBranches
     * const { count } = await prisma.policyVersionBranch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyVersionBranchDeleteManyArgs>(args?: SelectSubset<T, PolicyVersionBranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolicyVersionBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionBranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PolicyVersionBranches
     * const policyVersionBranch = await prisma.policyVersionBranch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyVersionBranchUpdateManyArgs>(args: SelectSubset<T, PolicyVersionBranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PolicyVersionBranch.
     * @param {PolicyVersionBranchUpsertArgs} args - Arguments to update or create a PolicyVersionBranch.
     * @example
     * // Update or create a PolicyVersionBranch
     * const policyVersionBranch = await prisma.policyVersionBranch.upsert({
     *   create: {
     *     // ... data to create a PolicyVersionBranch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PolicyVersionBranch we want to update
     *   }
     * })
     */
    upsert<T extends PolicyVersionBranchUpsertArgs>(args: SelectSubset<T, PolicyVersionBranchUpsertArgs<ExtArgs>>): Prisma__PolicyVersionBranchClient<$Result.GetResult<Prisma.$PolicyVersionBranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PolicyVersionBranches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionBranchCountArgs} args - Arguments to filter PolicyVersionBranches to count.
     * @example
     * // Count the number of PolicyVersionBranches
     * const count = await prisma.policyVersionBranch.count({
     *   where: {
     *     // ... the filter for the PolicyVersionBranches we want to count
     *   }
     * })
    **/
    count<T extends PolicyVersionBranchCountArgs>(
      args?: Subset<T, PolicyVersionBranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyVersionBranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PolicyVersionBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionBranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyVersionBranchAggregateArgs>(args: Subset<T, PolicyVersionBranchAggregateArgs>): Prisma.PrismaPromise<GetPolicyVersionBranchAggregateType<T>>

    /**
     * Group by PolicyVersionBranch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyVersionBranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyVersionBranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyVersionBranchGroupByArgs['orderBy'] }
        : { orderBy?: PolicyVersionBranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyVersionBranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyVersionBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PolicyVersionBranch model
   */
  readonly fields: PolicyVersionBranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PolicyVersionBranch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyVersionBranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    policyVersion<T extends PolicyVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PolicyVersionDefaultArgs<ExtArgs>>): Prisma__PolicyVersionClient<$Result.GetResult<Prisma.$PolicyVersionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PolicyVersionBranch model
   */ 
  interface PolicyVersionBranchFieldRefs {
    readonly id: FieldRef<"PolicyVersionBranch", 'String'>
    readonly policyVersionId: FieldRef<"PolicyVersionBranch", 'String'>
    readonly branchId: FieldRef<"PolicyVersionBranch", 'String'>
    readonly createdAt: FieldRef<"PolicyVersionBranch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PolicyVersionBranch findUnique
   */
  export type PolicyVersionBranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
    /**
     * Filter, which PolicyVersionBranch to fetch.
     */
    where: PolicyVersionBranchWhereUniqueInput
  }

  /**
   * PolicyVersionBranch findUniqueOrThrow
   */
  export type PolicyVersionBranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
    /**
     * Filter, which PolicyVersionBranch to fetch.
     */
    where: PolicyVersionBranchWhereUniqueInput
  }

  /**
   * PolicyVersionBranch findFirst
   */
  export type PolicyVersionBranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
    /**
     * Filter, which PolicyVersionBranch to fetch.
     */
    where?: PolicyVersionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyVersionBranches to fetch.
     */
    orderBy?: PolicyVersionBranchOrderByWithRelationInput | PolicyVersionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyVersionBranches.
     */
    cursor?: PolicyVersionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyVersionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyVersionBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyVersionBranches.
     */
    distinct?: PolicyVersionBranchScalarFieldEnum | PolicyVersionBranchScalarFieldEnum[]
  }

  /**
   * PolicyVersionBranch findFirstOrThrow
   */
  export type PolicyVersionBranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
    /**
     * Filter, which PolicyVersionBranch to fetch.
     */
    where?: PolicyVersionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyVersionBranches to fetch.
     */
    orderBy?: PolicyVersionBranchOrderByWithRelationInput | PolicyVersionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolicyVersionBranches.
     */
    cursor?: PolicyVersionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyVersionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyVersionBranches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolicyVersionBranches.
     */
    distinct?: PolicyVersionBranchScalarFieldEnum | PolicyVersionBranchScalarFieldEnum[]
  }

  /**
   * PolicyVersionBranch findMany
   */
  export type PolicyVersionBranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
    /**
     * Filter, which PolicyVersionBranches to fetch.
     */
    where?: PolicyVersionBranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolicyVersionBranches to fetch.
     */
    orderBy?: PolicyVersionBranchOrderByWithRelationInput | PolicyVersionBranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PolicyVersionBranches.
     */
    cursor?: PolicyVersionBranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolicyVersionBranches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolicyVersionBranches.
     */
    skip?: number
    distinct?: PolicyVersionBranchScalarFieldEnum | PolicyVersionBranchScalarFieldEnum[]
  }

  /**
   * PolicyVersionBranch create
   */
  export type PolicyVersionBranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
    /**
     * The data needed to create a PolicyVersionBranch.
     */
    data: XOR<PolicyVersionBranchCreateInput, PolicyVersionBranchUncheckedCreateInput>
  }

  /**
   * PolicyVersionBranch createMany
   */
  export type PolicyVersionBranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PolicyVersionBranches.
     */
    data: PolicyVersionBranchCreateManyInput | PolicyVersionBranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PolicyVersionBranch createManyAndReturn
   */
  export type PolicyVersionBranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PolicyVersionBranches.
     */
    data: PolicyVersionBranchCreateManyInput | PolicyVersionBranchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PolicyVersionBranch update
   */
  export type PolicyVersionBranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
    /**
     * The data needed to update a PolicyVersionBranch.
     */
    data: XOR<PolicyVersionBranchUpdateInput, PolicyVersionBranchUncheckedUpdateInput>
    /**
     * Choose, which PolicyVersionBranch to update.
     */
    where: PolicyVersionBranchWhereUniqueInput
  }

  /**
   * PolicyVersionBranch updateMany
   */
  export type PolicyVersionBranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PolicyVersionBranches.
     */
    data: XOR<PolicyVersionBranchUpdateManyMutationInput, PolicyVersionBranchUncheckedUpdateManyInput>
    /**
     * Filter which PolicyVersionBranches to update
     */
    where?: PolicyVersionBranchWhereInput
  }

  /**
   * PolicyVersionBranch upsert
   */
  export type PolicyVersionBranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
    /**
     * The filter to search for the PolicyVersionBranch to update in case it exists.
     */
    where: PolicyVersionBranchWhereUniqueInput
    /**
     * In case the PolicyVersionBranch found by the `where` argument doesn't exist, create a new PolicyVersionBranch with this data.
     */
    create: XOR<PolicyVersionBranchCreateInput, PolicyVersionBranchUncheckedCreateInput>
    /**
     * In case the PolicyVersionBranch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyVersionBranchUpdateInput, PolicyVersionBranchUncheckedUpdateInput>
  }

  /**
   * PolicyVersionBranch delete
   */
  export type PolicyVersionBranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
    /**
     * Filter which PolicyVersionBranch to delete.
     */
    where: PolicyVersionBranchWhereUniqueInput
  }

  /**
   * PolicyVersionBranch deleteMany
   */
  export type PolicyVersionBranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PolicyVersionBranches to delete
     */
    where?: PolicyVersionBranchWhereInput
  }

  /**
   * PolicyVersionBranch without action
   */
  export type PolicyVersionBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PolicyVersionBranch
     */
    select?: PolicyVersionBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PolicyVersionBranchInclude<ExtArgs> | null
  }


  /**
   * Model LocationNode
   */

  export type AggregateLocationNode = {
    _count: LocationNodeCountAggregateOutputType | null
    _min: LocationNodeMinAggregateOutputType | null
    _max: LocationNodeMaxAggregateOutputType | null
  }

  export type LocationNodeMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    kind: $Enums.LocationKind | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationNodeMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    kind: $Enums.LocationKind | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationNodeCountAggregateOutputType = {
    id: number
    branchId: number
    kind: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationNodeMinAggregateInputType = {
    id?: true
    branchId?: true
    kind?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationNodeMaxAggregateInputType = {
    id?: true
    branchId?: true
    kind?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationNodeCountAggregateInputType = {
    id?: true
    branchId?: true
    kind?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationNode to aggregate.
     */
    where?: LocationNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNodes to fetch.
     */
    orderBy?: LocationNodeOrderByWithRelationInput | LocationNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationNodes
    **/
    _count?: true | LocationNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationNodeMaxAggregateInputType
  }

  export type GetLocationNodeAggregateType<T extends LocationNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationNode[P]>
      : GetScalarType<T[P], AggregateLocationNode[P]>
  }




  export type LocationNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationNodeWhereInput
    orderBy?: LocationNodeOrderByWithAggregationInput | LocationNodeOrderByWithAggregationInput[]
    by: LocationNodeScalarFieldEnum[] | LocationNodeScalarFieldEnum
    having?: LocationNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationNodeCountAggregateInputType | true
    _min?: LocationNodeMinAggregateInputType
    _max?: LocationNodeMaxAggregateInputType
  }

  export type LocationNodeGroupByOutputType = {
    id: string
    branchId: string
    kind: $Enums.LocationKind
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LocationNodeCountAggregateOutputType | null
    _min: LocationNodeMinAggregateOutputType | null
    _max: LocationNodeMaxAggregateOutputType | null
  }

  type GetLocationNodeGroupByPayload<T extends LocationNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationNodeGroupByOutputType[P]>
            : GetScalarType<T[P], LocationNodeGroupByOutputType[P]>
        }
      >
    >


  export type LocationNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    kind?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    parent?: boolean | LocationNode$parentArgs<ExtArgs>
    children?: boolean | LocationNode$childrenArgs<ExtArgs>
    revisions?: boolean | LocationNode$revisionsArgs<ExtArgs>
    EquipmentAsset?: boolean | LocationNode$EquipmentAssetArgs<ExtArgs>
    _count?: boolean | LocationNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationNode"]>

  export type LocationNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    kind?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    parent?: boolean | LocationNode$parentArgs<ExtArgs>
  }, ExtArgs["result"]["locationNode"]>

  export type LocationNodeSelectScalar = {
    id?: boolean
    branchId?: boolean
    kind?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    parent?: boolean | LocationNode$parentArgs<ExtArgs>
    children?: boolean | LocationNode$childrenArgs<ExtArgs>
    revisions?: boolean | LocationNode$revisionsArgs<ExtArgs>
    EquipmentAsset?: boolean | LocationNode$EquipmentAssetArgs<ExtArgs>
    _count?: boolean | LocationNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    parent?: boolean | LocationNode$parentArgs<ExtArgs>
  }

  export type $LocationNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationNode"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      parent: Prisma.$LocationNodePayload<ExtArgs> | null
      children: Prisma.$LocationNodePayload<ExtArgs>[]
      revisions: Prisma.$LocationNodeRevisionPayload<ExtArgs>[]
      EquipmentAsset: Prisma.$EquipmentAssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      kind: $Enums.LocationKind
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["locationNode"]>
    composites: {}
  }

  type LocationNodeGetPayload<S extends boolean | null | undefined | LocationNodeDefaultArgs> = $Result.GetResult<Prisma.$LocationNodePayload, S>

  type LocationNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationNodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationNodeCountAggregateInputType | true
    }

  export interface LocationNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationNode'], meta: { name: 'LocationNode' } }
    /**
     * Find zero or one LocationNode that matches the filter.
     * @param {LocationNodeFindUniqueArgs} args - Arguments to find a LocationNode
     * @example
     * // Get one LocationNode
     * const locationNode = await prisma.locationNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationNodeFindUniqueArgs>(args: SelectSubset<T, LocationNodeFindUniqueArgs<ExtArgs>>): Prisma__LocationNodeClient<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LocationNode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationNodeFindUniqueOrThrowArgs} args - Arguments to find a LocationNode
     * @example
     * // Get one LocationNode
     * const locationNode = await prisma.locationNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationNodeClient<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LocationNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeFindFirstArgs} args - Arguments to find a LocationNode
     * @example
     * // Get one LocationNode
     * const locationNode = await prisma.locationNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationNodeFindFirstArgs>(args?: SelectSubset<T, LocationNodeFindFirstArgs<ExtArgs>>): Prisma__LocationNodeClient<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LocationNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeFindFirstOrThrowArgs} args - Arguments to find a LocationNode
     * @example
     * // Get one LocationNode
     * const locationNode = await prisma.locationNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationNodeClient<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LocationNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationNodes
     * const locationNodes = await prisma.locationNode.findMany()
     * 
     * // Get first 10 LocationNodes
     * const locationNodes = await prisma.locationNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationNodeWithIdOnly = await prisma.locationNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationNodeFindManyArgs>(args?: SelectSubset<T, LocationNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LocationNode.
     * @param {LocationNodeCreateArgs} args - Arguments to create a LocationNode.
     * @example
     * // Create one LocationNode
     * const LocationNode = await prisma.locationNode.create({
     *   data: {
     *     // ... data to create a LocationNode
     *   }
     * })
     * 
     */
    create<T extends LocationNodeCreateArgs>(args: SelectSubset<T, LocationNodeCreateArgs<ExtArgs>>): Prisma__LocationNodeClient<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LocationNodes.
     * @param {LocationNodeCreateManyArgs} args - Arguments to create many LocationNodes.
     * @example
     * // Create many LocationNodes
     * const locationNode = await prisma.locationNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationNodeCreateManyArgs>(args?: SelectSubset<T, LocationNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocationNodes and returns the data saved in the database.
     * @param {LocationNodeCreateManyAndReturnArgs} args - Arguments to create many LocationNodes.
     * @example
     * // Create many LocationNodes
     * const locationNode = await prisma.locationNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocationNodes and only return the `id`
     * const locationNodeWithIdOnly = await prisma.locationNode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LocationNode.
     * @param {LocationNodeDeleteArgs} args - Arguments to delete one LocationNode.
     * @example
     * // Delete one LocationNode
     * const LocationNode = await prisma.locationNode.delete({
     *   where: {
     *     // ... filter to delete one LocationNode
     *   }
     * })
     * 
     */
    delete<T extends LocationNodeDeleteArgs>(args: SelectSubset<T, LocationNodeDeleteArgs<ExtArgs>>): Prisma__LocationNodeClient<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LocationNode.
     * @param {LocationNodeUpdateArgs} args - Arguments to update one LocationNode.
     * @example
     * // Update one LocationNode
     * const locationNode = await prisma.locationNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationNodeUpdateArgs>(args: SelectSubset<T, LocationNodeUpdateArgs<ExtArgs>>): Prisma__LocationNodeClient<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LocationNodes.
     * @param {LocationNodeDeleteManyArgs} args - Arguments to filter LocationNodes to delete.
     * @example
     * // Delete a few LocationNodes
     * const { count } = await prisma.locationNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationNodeDeleteManyArgs>(args?: SelectSubset<T, LocationNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationNodes
     * const locationNode = await prisma.locationNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationNodeUpdateManyArgs>(args: SelectSubset<T, LocationNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocationNode.
     * @param {LocationNodeUpsertArgs} args - Arguments to update or create a LocationNode.
     * @example
     * // Update or create a LocationNode
     * const locationNode = await prisma.locationNode.upsert({
     *   create: {
     *     // ... data to create a LocationNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationNode we want to update
     *   }
     * })
     */
    upsert<T extends LocationNodeUpsertArgs>(args: SelectSubset<T, LocationNodeUpsertArgs<ExtArgs>>): Prisma__LocationNodeClient<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LocationNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeCountArgs} args - Arguments to filter LocationNodes to count.
     * @example
     * // Count the number of LocationNodes
     * const count = await prisma.locationNode.count({
     *   where: {
     *     // ... the filter for the LocationNodes we want to count
     *   }
     * })
    **/
    count<T extends LocationNodeCountArgs>(
      args?: Subset<T, LocationNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationNodeAggregateArgs>(args: Subset<T, LocationNodeAggregateArgs>): Prisma.PrismaPromise<GetLocationNodeAggregateType<T>>

    /**
     * Group by LocationNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationNodeGroupByArgs['orderBy'] }
        : { orderBy?: LocationNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationNode model
   */
  readonly fields: LocationNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends LocationNode$parentArgs<ExtArgs> = {}>(args?: Subset<T, LocationNode$parentArgs<ExtArgs>>): Prisma__LocationNodeClient<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends LocationNode$childrenArgs<ExtArgs> = {}>(args?: Subset<T, LocationNode$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "findMany"> | Null>
    revisions<T extends LocationNode$revisionsArgs<ExtArgs> = {}>(args?: Subset<T, LocationNode$revisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "findMany"> | Null>
    EquipmentAsset<T extends LocationNode$EquipmentAssetArgs<ExtArgs> = {}>(args?: Subset<T, LocationNode$EquipmentAssetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationNode model
   */ 
  interface LocationNodeFieldRefs {
    readonly id: FieldRef<"LocationNode", 'String'>
    readonly branchId: FieldRef<"LocationNode", 'String'>
    readonly kind: FieldRef<"LocationNode", 'LocationKind'>
    readonly parentId: FieldRef<"LocationNode", 'String'>
    readonly createdAt: FieldRef<"LocationNode", 'DateTime'>
    readonly updatedAt: FieldRef<"LocationNode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocationNode findUnique
   */
  export type LocationNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    /**
     * Filter, which LocationNode to fetch.
     */
    where: LocationNodeWhereUniqueInput
  }

  /**
   * LocationNode findUniqueOrThrow
   */
  export type LocationNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    /**
     * Filter, which LocationNode to fetch.
     */
    where: LocationNodeWhereUniqueInput
  }

  /**
   * LocationNode findFirst
   */
  export type LocationNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    /**
     * Filter, which LocationNode to fetch.
     */
    where?: LocationNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNodes to fetch.
     */
    orderBy?: LocationNodeOrderByWithRelationInput | LocationNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationNodes.
     */
    cursor?: LocationNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationNodes.
     */
    distinct?: LocationNodeScalarFieldEnum | LocationNodeScalarFieldEnum[]
  }

  /**
   * LocationNode findFirstOrThrow
   */
  export type LocationNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    /**
     * Filter, which LocationNode to fetch.
     */
    where?: LocationNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNodes to fetch.
     */
    orderBy?: LocationNodeOrderByWithRelationInput | LocationNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationNodes.
     */
    cursor?: LocationNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationNodes.
     */
    distinct?: LocationNodeScalarFieldEnum | LocationNodeScalarFieldEnum[]
  }

  /**
   * LocationNode findMany
   */
  export type LocationNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    /**
     * Filter, which LocationNodes to fetch.
     */
    where?: LocationNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNodes to fetch.
     */
    orderBy?: LocationNodeOrderByWithRelationInput | LocationNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationNodes.
     */
    cursor?: LocationNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNodes.
     */
    skip?: number
    distinct?: LocationNodeScalarFieldEnum | LocationNodeScalarFieldEnum[]
  }

  /**
   * LocationNode create
   */
  export type LocationNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationNode.
     */
    data: XOR<LocationNodeCreateInput, LocationNodeUncheckedCreateInput>
  }

  /**
   * LocationNode createMany
   */
  export type LocationNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationNodes.
     */
    data: LocationNodeCreateManyInput | LocationNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LocationNode createManyAndReturn
   */
  export type LocationNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LocationNodes.
     */
    data: LocationNodeCreateManyInput | LocationNodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationNode update
   */
  export type LocationNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationNode.
     */
    data: XOR<LocationNodeUpdateInput, LocationNodeUncheckedUpdateInput>
    /**
     * Choose, which LocationNode to update.
     */
    where: LocationNodeWhereUniqueInput
  }

  /**
   * LocationNode updateMany
   */
  export type LocationNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationNodes.
     */
    data: XOR<LocationNodeUpdateManyMutationInput, LocationNodeUncheckedUpdateManyInput>
    /**
     * Filter which LocationNodes to update
     */
    where?: LocationNodeWhereInput
  }

  /**
   * LocationNode upsert
   */
  export type LocationNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationNode to update in case it exists.
     */
    where: LocationNodeWhereUniqueInput
    /**
     * In case the LocationNode found by the `where` argument doesn't exist, create a new LocationNode with this data.
     */
    create: XOR<LocationNodeCreateInput, LocationNodeUncheckedCreateInput>
    /**
     * In case the LocationNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationNodeUpdateInput, LocationNodeUncheckedUpdateInput>
  }

  /**
   * LocationNode delete
   */
  export type LocationNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    /**
     * Filter which LocationNode to delete.
     */
    where: LocationNodeWhereUniqueInput
  }

  /**
   * LocationNode deleteMany
   */
  export type LocationNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationNodes to delete
     */
    where?: LocationNodeWhereInput
  }

  /**
   * LocationNode.parent
   */
  export type LocationNode$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    where?: LocationNodeWhereInput
  }

  /**
   * LocationNode.children
   */
  export type LocationNode$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    where?: LocationNodeWhereInput
    orderBy?: LocationNodeOrderByWithRelationInput | LocationNodeOrderByWithRelationInput[]
    cursor?: LocationNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationNodeScalarFieldEnum | LocationNodeScalarFieldEnum[]
  }

  /**
   * LocationNode.revisions
   */
  export type LocationNode$revisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
    where?: LocationNodeRevisionWhereInput
    orderBy?: LocationNodeRevisionOrderByWithRelationInput | LocationNodeRevisionOrderByWithRelationInput[]
    cursor?: LocationNodeRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationNodeRevisionScalarFieldEnum | LocationNodeRevisionScalarFieldEnum[]
  }

  /**
   * LocationNode.EquipmentAsset
   */
  export type LocationNode$EquipmentAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    where?: EquipmentAssetWhereInput
    orderBy?: EquipmentAssetOrderByWithRelationInput | EquipmentAssetOrderByWithRelationInput[]
    cursor?: EquipmentAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentAssetScalarFieldEnum | EquipmentAssetScalarFieldEnum[]
  }

  /**
   * LocationNode without action
   */
  export type LocationNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
  }


  /**
   * Model LocationNodeRevision
   */

  export type AggregateLocationNodeRevision = {
    _count: LocationNodeRevisionCountAggregateOutputType | null
    _min: LocationNodeRevisionMinAggregateOutputType | null
    _max: LocationNodeRevisionMaxAggregateOutputType | null
  }

  export type LocationNodeRevisionMinAggregateOutputType = {
    id: string | null
    nodeId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdByUserId: string | null
    createdAt: Date | null
  }

  export type LocationNodeRevisionMaxAggregateOutputType = {
    id: string | null
    nodeId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdByUserId: string | null
    createdAt: Date | null
  }

  export type LocationNodeRevisionCountAggregateOutputType = {
    id: number
    nodeId: number
    code: number
    name: number
    isActive: number
    effectiveFrom: number
    effectiveTo: number
    createdByUserId: number
    createdAt: number
    _all: number
  }


  export type LocationNodeRevisionMinAggregateInputType = {
    id?: true
    nodeId?: true
    code?: true
    name?: true
    isActive?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdByUserId?: true
    createdAt?: true
  }

  export type LocationNodeRevisionMaxAggregateInputType = {
    id?: true
    nodeId?: true
    code?: true
    name?: true
    isActive?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdByUserId?: true
    createdAt?: true
  }

  export type LocationNodeRevisionCountAggregateInputType = {
    id?: true
    nodeId?: true
    code?: true
    name?: true
    isActive?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdByUserId?: true
    createdAt?: true
    _all?: true
  }

  export type LocationNodeRevisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationNodeRevision to aggregate.
     */
    where?: LocationNodeRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNodeRevisions to fetch.
     */
    orderBy?: LocationNodeRevisionOrderByWithRelationInput | LocationNodeRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationNodeRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNodeRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNodeRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationNodeRevisions
    **/
    _count?: true | LocationNodeRevisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationNodeRevisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationNodeRevisionMaxAggregateInputType
  }

  export type GetLocationNodeRevisionAggregateType<T extends LocationNodeRevisionAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationNodeRevision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationNodeRevision[P]>
      : GetScalarType<T[P], AggregateLocationNodeRevision[P]>
  }




  export type LocationNodeRevisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationNodeRevisionWhereInput
    orderBy?: LocationNodeRevisionOrderByWithAggregationInput | LocationNodeRevisionOrderByWithAggregationInput[]
    by: LocationNodeRevisionScalarFieldEnum[] | LocationNodeRevisionScalarFieldEnum
    having?: LocationNodeRevisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationNodeRevisionCountAggregateInputType | true
    _min?: LocationNodeRevisionMinAggregateInputType
    _max?: LocationNodeRevisionMaxAggregateInputType
  }

  export type LocationNodeRevisionGroupByOutputType = {
    id: string
    nodeId: string
    code: string
    name: string
    isActive: boolean
    effectiveFrom: Date
    effectiveTo: Date | null
    createdByUserId: string | null
    createdAt: Date
    _count: LocationNodeRevisionCountAggregateOutputType | null
    _min: LocationNodeRevisionMinAggregateOutputType | null
    _max: LocationNodeRevisionMaxAggregateOutputType | null
  }

  type GetLocationNodeRevisionGroupByPayload<T extends LocationNodeRevisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationNodeRevisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationNodeRevisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationNodeRevisionGroupByOutputType[P]>
            : GetScalarType<T[P], LocationNodeRevisionGroupByOutputType[P]>
        }
      >
    >


  export type LocationNodeRevisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    node?: boolean | LocationNodeDefaultArgs<ExtArgs>
    createdByUser?: boolean | LocationNodeRevision$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["locationNodeRevision"]>

  export type LocationNodeRevisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    node?: boolean | LocationNodeDefaultArgs<ExtArgs>
    createdByUser?: boolean | LocationNodeRevision$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["locationNodeRevision"]>

  export type LocationNodeRevisionSelectScalar = {
    id?: boolean
    nodeId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
  }

  export type LocationNodeRevisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | LocationNodeDefaultArgs<ExtArgs>
    createdByUser?: boolean | LocationNodeRevision$createdByUserArgs<ExtArgs>
  }
  export type LocationNodeRevisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | LocationNodeDefaultArgs<ExtArgs>
    createdByUser?: boolean | LocationNodeRevision$createdByUserArgs<ExtArgs>
  }

  export type $LocationNodeRevisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationNodeRevision"
    objects: {
      node: Prisma.$LocationNodePayload<ExtArgs>
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nodeId: string
      code: string
      name: string
      isActive: boolean
      effectiveFrom: Date
      effectiveTo: Date | null
      createdByUserId: string | null
      createdAt: Date
    }, ExtArgs["result"]["locationNodeRevision"]>
    composites: {}
  }

  type LocationNodeRevisionGetPayload<S extends boolean | null | undefined | LocationNodeRevisionDefaultArgs> = $Result.GetResult<Prisma.$LocationNodeRevisionPayload, S>

  type LocationNodeRevisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationNodeRevisionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationNodeRevisionCountAggregateInputType | true
    }

  export interface LocationNodeRevisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationNodeRevision'], meta: { name: 'LocationNodeRevision' } }
    /**
     * Find zero or one LocationNodeRevision that matches the filter.
     * @param {LocationNodeRevisionFindUniqueArgs} args - Arguments to find a LocationNodeRevision
     * @example
     * // Get one LocationNodeRevision
     * const locationNodeRevision = await prisma.locationNodeRevision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationNodeRevisionFindUniqueArgs>(args: SelectSubset<T, LocationNodeRevisionFindUniqueArgs<ExtArgs>>): Prisma__LocationNodeRevisionClient<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LocationNodeRevision that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationNodeRevisionFindUniqueOrThrowArgs} args - Arguments to find a LocationNodeRevision
     * @example
     * // Get one LocationNodeRevision
     * const locationNodeRevision = await prisma.locationNodeRevision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationNodeRevisionFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationNodeRevisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationNodeRevisionClient<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LocationNodeRevision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeRevisionFindFirstArgs} args - Arguments to find a LocationNodeRevision
     * @example
     * // Get one LocationNodeRevision
     * const locationNodeRevision = await prisma.locationNodeRevision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationNodeRevisionFindFirstArgs>(args?: SelectSubset<T, LocationNodeRevisionFindFirstArgs<ExtArgs>>): Prisma__LocationNodeRevisionClient<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LocationNodeRevision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeRevisionFindFirstOrThrowArgs} args - Arguments to find a LocationNodeRevision
     * @example
     * // Get one LocationNodeRevision
     * const locationNodeRevision = await prisma.locationNodeRevision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationNodeRevisionFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationNodeRevisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationNodeRevisionClient<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LocationNodeRevisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeRevisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationNodeRevisions
     * const locationNodeRevisions = await prisma.locationNodeRevision.findMany()
     * 
     * // Get first 10 LocationNodeRevisions
     * const locationNodeRevisions = await prisma.locationNodeRevision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationNodeRevisionWithIdOnly = await prisma.locationNodeRevision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationNodeRevisionFindManyArgs>(args?: SelectSubset<T, LocationNodeRevisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LocationNodeRevision.
     * @param {LocationNodeRevisionCreateArgs} args - Arguments to create a LocationNodeRevision.
     * @example
     * // Create one LocationNodeRevision
     * const LocationNodeRevision = await prisma.locationNodeRevision.create({
     *   data: {
     *     // ... data to create a LocationNodeRevision
     *   }
     * })
     * 
     */
    create<T extends LocationNodeRevisionCreateArgs>(args: SelectSubset<T, LocationNodeRevisionCreateArgs<ExtArgs>>): Prisma__LocationNodeRevisionClient<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LocationNodeRevisions.
     * @param {LocationNodeRevisionCreateManyArgs} args - Arguments to create many LocationNodeRevisions.
     * @example
     * // Create many LocationNodeRevisions
     * const locationNodeRevision = await prisma.locationNodeRevision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationNodeRevisionCreateManyArgs>(args?: SelectSubset<T, LocationNodeRevisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocationNodeRevisions and returns the data saved in the database.
     * @param {LocationNodeRevisionCreateManyAndReturnArgs} args - Arguments to create many LocationNodeRevisions.
     * @example
     * // Create many LocationNodeRevisions
     * const locationNodeRevision = await prisma.locationNodeRevision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocationNodeRevisions and only return the `id`
     * const locationNodeRevisionWithIdOnly = await prisma.locationNodeRevision.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationNodeRevisionCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationNodeRevisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LocationNodeRevision.
     * @param {LocationNodeRevisionDeleteArgs} args - Arguments to delete one LocationNodeRevision.
     * @example
     * // Delete one LocationNodeRevision
     * const LocationNodeRevision = await prisma.locationNodeRevision.delete({
     *   where: {
     *     // ... filter to delete one LocationNodeRevision
     *   }
     * })
     * 
     */
    delete<T extends LocationNodeRevisionDeleteArgs>(args: SelectSubset<T, LocationNodeRevisionDeleteArgs<ExtArgs>>): Prisma__LocationNodeRevisionClient<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LocationNodeRevision.
     * @param {LocationNodeRevisionUpdateArgs} args - Arguments to update one LocationNodeRevision.
     * @example
     * // Update one LocationNodeRevision
     * const locationNodeRevision = await prisma.locationNodeRevision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationNodeRevisionUpdateArgs>(args: SelectSubset<T, LocationNodeRevisionUpdateArgs<ExtArgs>>): Prisma__LocationNodeRevisionClient<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LocationNodeRevisions.
     * @param {LocationNodeRevisionDeleteManyArgs} args - Arguments to filter LocationNodeRevisions to delete.
     * @example
     * // Delete a few LocationNodeRevisions
     * const { count } = await prisma.locationNodeRevision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationNodeRevisionDeleteManyArgs>(args?: SelectSubset<T, LocationNodeRevisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationNodeRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeRevisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationNodeRevisions
     * const locationNodeRevision = await prisma.locationNodeRevision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationNodeRevisionUpdateManyArgs>(args: SelectSubset<T, LocationNodeRevisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocationNodeRevision.
     * @param {LocationNodeRevisionUpsertArgs} args - Arguments to update or create a LocationNodeRevision.
     * @example
     * // Update or create a LocationNodeRevision
     * const locationNodeRevision = await prisma.locationNodeRevision.upsert({
     *   create: {
     *     // ... data to create a LocationNodeRevision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationNodeRevision we want to update
     *   }
     * })
     */
    upsert<T extends LocationNodeRevisionUpsertArgs>(args: SelectSubset<T, LocationNodeRevisionUpsertArgs<ExtArgs>>): Prisma__LocationNodeRevisionClient<$Result.GetResult<Prisma.$LocationNodeRevisionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LocationNodeRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeRevisionCountArgs} args - Arguments to filter LocationNodeRevisions to count.
     * @example
     * // Count the number of LocationNodeRevisions
     * const count = await prisma.locationNodeRevision.count({
     *   where: {
     *     // ... the filter for the LocationNodeRevisions we want to count
     *   }
     * })
    **/
    count<T extends LocationNodeRevisionCountArgs>(
      args?: Subset<T, LocationNodeRevisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationNodeRevisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationNodeRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeRevisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationNodeRevisionAggregateArgs>(args: Subset<T, LocationNodeRevisionAggregateArgs>): Prisma.PrismaPromise<GetLocationNodeRevisionAggregateType<T>>

    /**
     * Group by LocationNodeRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationNodeRevisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationNodeRevisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationNodeRevisionGroupByArgs['orderBy'] }
        : { orderBy?: LocationNodeRevisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationNodeRevisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationNodeRevisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationNodeRevision model
   */
  readonly fields: LocationNodeRevisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationNodeRevision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationNodeRevisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    node<T extends LocationNodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationNodeDefaultArgs<ExtArgs>>): Prisma__LocationNodeClient<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdByUser<T extends LocationNodeRevision$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, LocationNodeRevision$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationNodeRevision model
   */ 
  interface LocationNodeRevisionFieldRefs {
    readonly id: FieldRef<"LocationNodeRevision", 'String'>
    readonly nodeId: FieldRef<"LocationNodeRevision", 'String'>
    readonly code: FieldRef<"LocationNodeRevision", 'String'>
    readonly name: FieldRef<"LocationNodeRevision", 'String'>
    readonly isActive: FieldRef<"LocationNodeRevision", 'Boolean'>
    readonly effectiveFrom: FieldRef<"LocationNodeRevision", 'DateTime'>
    readonly effectiveTo: FieldRef<"LocationNodeRevision", 'DateTime'>
    readonly createdByUserId: FieldRef<"LocationNodeRevision", 'String'>
    readonly createdAt: FieldRef<"LocationNodeRevision", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocationNodeRevision findUnique
   */
  export type LocationNodeRevisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
    /**
     * Filter, which LocationNodeRevision to fetch.
     */
    where: LocationNodeRevisionWhereUniqueInput
  }

  /**
   * LocationNodeRevision findUniqueOrThrow
   */
  export type LocationNodeRevisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
    /**
     * Filter, which LocationNodeRevision to fetch.
     */
    where: LocationNodeRevisionWhereUniqueInput
  }

  /**
   * LocationNodeRevision findFirst
   */
  export type LocationNodeRevisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
    /**
     * Filter, which LocationNodeRevision to fetch.
     */
    where?: LocationNodeRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNodeRevisions to fetch.
     */
    orderBy?: LocationNodeRevisionOrderByWithRelationInput | LocationNodeRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationNodeRevisions.
     */
    cursor?: LocationNodeRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNodeRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNodeRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationNodeRevisions.
     */
    distinct?: LocationNodeRevisionScalarFieldEnum | LocationNodeRevisionScalarFieldEnum[]
  }

  /**
   * LocationNodeRevision findFirstOrThrow
   */
  export type LocationNodeRevisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
    /**
     * Filter, which LocationNodeRevision to fetch.
     */
    where?: LocationNodeRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNodeRevisions to fetch.
     */
    orderBy?: LocationNodeRevisionOrderByWithRelationInput | LocationNodeRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationNodeRevisions.
     */
    cursor?: LocationNodeRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNodeRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNodeRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationNodeRevisions.
     */
    distinct?: LocationNodeRevisionScalarFieldEnum | LocationNodeRevisionScalarFieldEnum[]
  }

  /**
   * LocationNodeRevision findMany
   */
  export type LocationNodeRevisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
    /**
     * Filter, which LocationNodeRevisions to fetch.
     */
    where?: LocationNodeRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationNodeRevisions to fetch.
     */
    orderBy?: LocationNodeRevisionOrderByWithRelationInput | LocationNodeRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationNodeRevisions.
     */
    cursor?: LocationNodeRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationNodeRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationNodeRevisions.
     */
    skip?: number
    distinct?: LocationNodeRevisionScalarFieldEnum | LocationNodeRevisionScalarFieldEnum[]
  }

  /**
   * LocationNodeRevision create
   */
  export type LocationNodeRevisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationNodeRevision.
     */
    data: XOR<LocationNodeRevisionCreateInput, LocationNodeRevisionUncheckedCreateInput>
  }

  /**
   * LocationNodeRevision createMany
   */
  export type LocationNodeRevisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationNodeRevisions.
     */
    data: LocationNodeRevisionCreateManyInput | LocationNodeRevisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LocationNodeRevision createManyAndReturn
   */
  export type LocationNodeRevisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LocationNodeRevisions.
     */
    data: LocationNodeRevisionCreateManyInput | LocationNodeRevisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationNodeRevision update
   */
  export type LocationNodeRevisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationNodeRevision.
     */
    data: XOR<LocationNodeRevisionUpdateInput, LocationNodeRevisionUncheckedUpdateInput>
    /**
     * Choose, which LocationNodeRevision to update.
     */
    where: LocationNodeRevisionWhereUniqueInput
  }

  /**
   * LocationNodeRevision updateMany
   */
  export type LocationNodeRevisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationNodeRevisions.
     */
    data: XOR<LocationNodeRevisionUpdateManyMutationInput, LocationNodeRevisionUncheckedUpdateManyInput>
    /**
     * Filter which LocationNodeRevisions to update
     */
    where?: LocationNodeRevisionWhereInput
  }

  /**
   * LocationNodeRevision upsert
   */
  export type LocationNodeRevisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationNodeRevision to update in case it exists.
     */
    where: LocationNodeRevisionWhereUniqueInput
    /**
     * In case the LocationNodeRevision found by the `where` argument doesn't exist, create a new LocationNodeRevision with this data.
     */
    create: XOR<LocationNodeRevisionCreateInput, LocationNodeRevisionUncheckedCreateInput>
    /**
     * In case the LocationNodeRevision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationNodeRevisionUpdateInput, LocationNodeRevisionUncheckedUpdateInput>
  }

  /**
   * LocationNodeRevision delete
   */
  export type LocationNodeRevisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
    /**
     * Filter which LocationNodeRevision to delete.
     */
    where: LocationNodeRevisionWhereUniqueInput
  }

  /**
   * LocationNodeRevision deleteMany
   */
  export type LocationNodeRevisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationNodeRevisions to delete
     */
    where?: LocationNodeRevisionWhereInput
  }

  /**
   * LocationNodeRevision.createdByUser
   */
  export type LocationNodeRevision$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LocationNodeRevision without action
   */
  export type LocationNodeRevisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNodeRevision
     */
    select?: LocationNodeRevisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeRevisionInclude<ExtArgs> | null
  }


  /**
   * Model UnitTypeCatalog
   */

  export type AggregateUnitTypeCatalog = {
    _count: UnitTypeCatalogCountAggregateOutputType | null
    _avg: UnitTypeCatalogAvgAggregateOutputType | null
    _sum: UnitTypeCatalogSumAggregateOutputType | null
    _min: UnitTypeCatalogMinAggregateOutputType | null
    _max: UnitTypeCatalogMaxAggregateOutputType | null
  }

  export type UnitTypeCatalogAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type UnitTypeCatalogSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type UnitTypeCatalogMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    usesRoomsDefault: boolean | null
    schedulableByDefault: boolean | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitTypeCatalogMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    usesRoomsDefault: boolean | null
    schedulableByDefault: boolean | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitTypeCatalogCountAggregateOutputType = {
    id: number
    code: number
    name: number
    usesRoomsDefault: number
    schedulableByDefault: number
    sortOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitTypeCatalogAvgAggregateInputType = {
    sortOrder?: true
  }

  export type UnitTypeCatalogSumAggregateInputType = {
    sortOrder?: true
  }

  export type UnitTypeCatalogMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    usesRoomsDefault?: true
    schedulableByDefault?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitTypeCatalogMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    usesRoomsDefault?: true
    schedulableByDefault?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitTypeCatalogCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    usesRoomsDefault?: true
    schedulableByDefault?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitTypeCatalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitTypeCatalog to aggregate.
     */
    where?: UnitTypeCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTypeCatalogs to fetch.
     */
    orderBy?: UnitTypeCatalogOrderByWithRelationInput | UnitTypeCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitTypeCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTypeCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTypeCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitTypeCatalogs
    **/
    _count?: true | UnitTypeCatalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitTypeCatalogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitTypeCatalogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitTypeCatalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitTypeCatalogMaxAggregateInputType
  }

  export type GetUnitTypeCatalogAggregateType<T extends UnitTypeCatalogAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitTypeCatalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitTypeCatalog[P]>
      : GetScalarType<T[P], AggregateUnitTypeCatalog[P]>
  }




  export type UnitTypeCatalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitTypeCatalogWhereInput
    orderBy?: UnitTypeCatalogOrderByWithAggregationInput | UnitTypeCatalogOrderByWithAggregationInput[]
    by: UnitTypeCatalogScalarFieldEnum[] | UnitTypeCatalogScalarFieldEnum
    having?: UnitTypeCatalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitTypeCatalogCountAggregateInputType | true
    _avg?: UnitTypeCatalogAvgAggregateInputType
    _sum?: UnitTypeCatalogSumAggregateInputType
    _min?: UnitTypeCatalogMinAggregateInputType
    _max?: UnitTypeCatalogMaxAggregateInputType
  }

  export type UnitTypeCatalogGroupByOutputType = {
    id: string
    code: string
    name: string
    usesRoomsDefault: boolean
    schedulableByDefault: boolean
    sortOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UnitTypeCatalogCountAggregateOutputType | null
    _avg: UnitTypeCatalogAvgAggregateOutputType | null
    _sum: UnitTypeCatalogSumAggregateOutputType | null
    _min: UnitTypeCatalogMinAggregateOutputType | null
    _max: UnitTypeCatalogMaxAggregateOutputType | null
  }

  type GetUnitTypeCatalogGroupByPayload<T extends UnitTypeCatalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitTypeCatalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitTypeCatalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitTypeCatalogGroupByOutputType[P]>
            : GetScalarType<T[P], UnitTypeCatalogGroupByOutputType[P]>
        }
      >
    >


  export type UnitTypeCatalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    usesRoomsDefault?: boolean
    schedulableByDefault?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branchLinks?: boolean | UnitTypeCatalog$branchLinksArgs<ExtArgs>
    units?: boolean | UnitTypeCatalog$unitsArgs<ExtArgs>
    _count?: boolean | UnitTypeCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitTypeCatalog"]>

  export type UnitTypeCatalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    usesRoomsDefault?: boolean
    schedulableByDefault?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unitTypeCatalog"]>

  export type UnitTypeCatalogSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    usesRoomsDefault?: boolean
    schedulableByDefault?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitTypeCatalogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branchLinks?: boolean | UnitTypeCatalog$branchLinksArgs<ExtArgs>
    units?: boolean | UnitTypeCatalog$unitsArgs<ExtArgs>
    _count?: boolean | UnitTypeCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitTypeCatalogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnitTypeCatalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitTypeCatalog"
    objects: {
      branchLinks: Prisma.$BranchUnitTypePayload<ExtArgs>[]
      units: Prisma.$UnitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      usesRoomsDefault: boolean
      schedulableByDefault: boolean
      sortOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitTypeCatalog"]>
    composites: {}
  }

  type UnitTypeCatalogGetPayload<S extends boolean | null | undefined | UnitTypeCatalogDefaultArgs> = $Result.GetResult<Prisma.$UnitTypeCatalogPayload, S>

  type UnitTypeCatalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitTypeCatalogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitTypeCatalogCountAggregateInputType | true
    }

  export interface UnitTypeCatalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitTypeCatalog'], meta: { name: 'UnitTypeCatalog' } }
    /**
     * Find zero or one UnitTypeCatalog that matches the filter.
     * @param {UnitTypeCatalogFindUniqueArgs} args - Arguments to find a UnitTypeCatalog
     * @example
     * // Get one UnitTypeCatalog
     * const unitTypeCatalog = await prisma.unitTypeCatalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitTypeCatalogFindUniqueArgs>(args: SelectSubset<T, UnitTypeCatalogFindUniqueArgs<ExtArgs>>): Prisma__UnitTypeCatalogClient<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UnitTypeCatalog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnitTypeCatalogFindUniqueOrThrowArgs} args - Arguments to find a UnitTypeCatalog
     * @example
     * // Get one UnitTypeCatalog
     * const unitTypeCatalog = await prisma.unitTypeCatalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitTypeCatalogFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitTypeCatalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitTypeCatalogClient<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UnitTypeCatalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeCatalogFindFirstArgs} args - Arguments to find a UnitTypeCatalog
     * @example
     * // Get one UnitTypeCatalog
     * const unitTypeCatalog = await prisma.unitTypeCatalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitTypeCatalogFindFirstArgs>(args?: SelectSubset<T, UnitTypeCatalogFindFirstArgs<ExtArgs>>): Prisma__UnitTypeCatalogClient<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UnitTypeCatalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeCatalogFindFirstOrThrowArgs} args - Arguments to find a UnitTypeCatalog
     * @example
     * // Get one UnitTypeCatalog
     * const unitTypeCatalog = await prisma.unitTypeCatalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitTypeCatalogFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitTypeCatalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitTypeCatalogClient<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UnitTypeCatalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeCatalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitTypeCatalogs
     * const unitTypeCatalogs = await prisma.unitTypeCatalog.findMany()
     * 
     * // Get first 10 UnitTypeCatalogs
     * const unitTypeCatalogs = await prisma.unitTypeCatalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitTypeCatalogWithIdOnly = await prisma.unitTypeCatalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitTypeCatalogFindManyArgs>(args?: SelectSubset<T, UnitTypeCatalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UnitTypeCatalog.
     * @param {UnitTypeCatalogCreateArgs} args - Arguments to create a UnitTypeCatalog.
     * @example
     * // Create one UnitTypeCatalog
     * const UnitTypeCatalog = await prisma.unitTypeCatalog.create({
     *   data: {
     *     // ... data to create a UnitTypeCatalog
     *   }
     * })
     * 
     */
    create<T extends UnitTypeCatalogCreateArgs>(args: SelectSubset<T, UnitTypeCatalogCreateArgs<ExtArgs>>): Prisma__UnitTypeCatalogClient<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UnitTypeCatalogs.
     * @param {UnitTypeCatalogCreateManyArgs} args - Arguments to create many UnitTypeCatalogs.
     * @example
     * // Create many UnitTypeCatalogs
     * const unitTypeCatalog = await prisma.unitTypeCatalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitTypeCatalogCreateManyArgs>(args?: SelectSubset<T, UnitTypeCatalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitTypeCatalogs and returns the data saved in the database.
     * @param {UnitTypeCatalogCreateManyAndReturnArgs} args - Arguments to create many UnitTypeCatalogs.
     * @example
     * // Create many UnitTypeCatalogs
     * const unitTypeCatalog = await prisma.unitTypeCatalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitTypeCatalogs and only return the `id`
     * const unitTypeCatalogWithIdOnly = await prisma.unitTypeCatalog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitTypeCatalogCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitTypeCatalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UnitTypeCatalog.
     * @param {UnitTypeCatalogDeleteArgs} args - Arguments to delete one UnitTypeCatalog.
     * @example
     * // Delete one UnitTypeCatalog
     * const UnitTypeCatalog = await prisma.unitTypeCatalog.delete({
     *   where: {
     *     // ... filter to delete one UnitTypeCatalog
     *   }
     * })
     * 
     */
    delete<T extends UnitTypeCatalogDeleteArgs>(args: SelectSubset<T, UnitTypeCatalogDeleteArgs<ExtArgs>>): Prisma__UnitTypeCatalogClient<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UnitTypeCatalog.
     * @param {UnitTypeCatalogUpdateArgs} args - Arguments to update one UnitTypeCatalog.
     * @example
     * // Update one UnitTypeCatalog
     * const unitTypeCatalog = await prisma.unitTypeCatalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitTypeCatalogUpdateArgs>(args: SelectSubset<T, UnitTypeCatalogUpdateArgs<ExtArgs>>): Prisma__UnitTypeCatalogClient<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UnitTypeCatalogs.
     * @param {UnitTypeCatalogDeleteManyArgs} args - Arguments to filter UnitTypeCatalogs to delete.
     * @example
     * // Delete a few UnitTypeCatalogs
     * const { count } = await prisma.unitTypeCatalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitTypeCatalogDeleteManyArgs>(args?: SelectSubset<T, UnitTypeCatalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitTypeCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeCatalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitTypeCatalogs
     * const unitTypeCatalog = await prisma.unitTypeCatalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitTypeCatalogUpdateManyArgs>(args: SelectSubset<T, UnitTypeCatalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitTypeCatalog.
     * @param {UnitTypeCatalogUpsertArgs} args - Arguments to update or create a UnitTypeCatalog.
     * @example
     * // Update or create a UnitTypeCatalog
     * const unitTypeCatalog = await prisma.unitTypeCatalog.upsert({
     *   create: {
     *     // ... data to create a UnitTypeCatalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitTypeCatalog we want to update
     *   }
     * })
     */
    upsert<T extends UnitTypeCatalogUpsertArgs>(args: SelectSubset<T, UnitTypeCatalogUpsertArgs<ExtArgs>>): Prisma__UnitTypeCatalogClient<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UnitTypeCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeCatalogCountArgs} args - Arguments to filter UnitTypeCatalogs to count.
     * @example
     * // Count the number of UnitTypeCatalogs
     * const count = await prisma.unitTypeCatalog.count({
     *   where: {
     *     // ... the filter for the UnitTypeCatalogs we want to count
     *   }
     * })
    **/
    count<T extends UnitTypeCatalogCountArgs>(
      args?: Subset<T, UnitTypeCatalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitTypeCatalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitTypeCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeCatalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitTypeCatalogAggregateArgs>(args: Subset<T, UnitTypeCatalogAggregateArgs>): Prisma.PrismaPromise<GetUnitTypeCatalogAggregateType<T>>

    /**
     * Group by UnitTypeCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitTypeCatalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitTypeCatalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitTypeCatalogGroupByArgs['orderBy'] }
        : { orderBy?: UnitTypeCatalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitTypeCatalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitTypeCatalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitTypeCatalog model
   */
  readonly fields: UnitTypeCatalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitTypeCatalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitTypeCatalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branchLinks<T extends UnitTypeCatalog$branchLinksArgs<ExtArgs> = {}>(args?: Subset<T, UnitTypeCatalog$branchLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "findMany"> | Null>
    units<T extends UnitTypeCatalog$unitsArgs<ExtArgs> = {}>(args?: Subset<T, UnitTypeCatalog$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitTypeCatalog model
   */ 
  interface UnitTypeCatalogFieldRefs {
    readonly id: FieldRef<"UnitTypeCatalog", 'String'>
    readonly code: FieldRef<"UnitTypeCatalog", 'String'>
    readonly name: FieldRef<"UnitTypeCatalog", 'String'>
    readonly usesRoomsDefault: FieldRef<"UnitTypeCatalog", 'Boolean'>
    readonly schedulableByDefault: FieldRef<"UnitTypeCatalog", 'Boolean'>
    readonly sortOrder: FieldRef<"UnitTypeCatalog", 'Int'>
    readonly isActive: FieldRef<"UnitTypeCatalog", 'Boolean'>
    readonly createdAt: FieldRef<"UnitTypeCatalog", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitTypeCatalog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitTypeCatalog findUnique
   */
  export type UnitTypeCatalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalog
     */
    select?: UnitTypeCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeCatalogInclude<ExtArgs> | null
    /**
     * Filter, which UnitTypeCatalog to fetch.
     */
    where: UnitTypeCatalogWhereUniqueInput
  }

  /**
   * UnitTypeCatalog findUniqueOrThrow
   */
  export type UnitTypeCatalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalog
     */
    select?: UnitTypeCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeCatalogInclude<ExtArgs> | null
    /**
     * Filter, which UnitTypeCatalog to fetch.
     */
    where: UnitTypeCatalogWhereUniqueInput
  }

  /**
   * UnitTypeCatalog findFirst
   */
  export type UnitTypeCatalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalog
     */
    select?: UnitTypeCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeCatalogInclude<ExtArgs> | null
    /**
     * Filter, which UnitTypeCatalog to fetch.
     */
    where?: UnitTypeCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTypeCatalogs to fetch.
     */
    orderBy?: UnitTypeCatalogOrderByWithRelationInput | UnitTypeCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitTypeCatalogs.
     */
    cursor?: UnitTypeCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTypeCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTypeCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitTypeCatalogs.
     */
    distinct?: UnitTypeCatalogScalarFieldEnum | UnitTypeCatalogScalarFieldEnum[]
  }

  /**
   * UnitTypeCatalog findFirstOrThrow
   */
  export type UnitTypeCatalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalog
     */
    select?: UnitTypeCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeCatalogInclude<ExtArgs> | null
    /**
     * Filter, which UnitTypeCatalog to fetch.
     */
    where?: UnitTypeCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTypeCatalogs to fetch.
     */
    orderBy?: UnitTypeCatalogOrderByWithRelationInput | UnitTypeCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitTypeCatalogs.
     */
    cursor?: UnitTypeCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTypeCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTypeCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitTypeCatalogs.
     */
    distinct?: UnitTypeCatalogScalarFieldEnum | UnitTypeCatalogScalarFieldEnum[]
  }

  /**
   * UnitTypeCatalog findMany
   */
  export type UnitTypeCatalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalog
     */
    select?: UnitTypeCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeCatalogInclude<ExtArgs> | null
    /**
     * Filter, which UnitTypeCatalogs to fetch.
     */
    where?: UnitTypeCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitTypeCatalogs to fetch.
     */
    orderBy?: UnitTypeCatalogOrderByWithRelationInput | UnitTypeCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitTypeCatalogs.
     */
    cursor?: UnitTypeCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitTypeCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitTypeCatalogs.
     */
    skip?: number
    distinct?: UnitTypeCatalogScalarFieldEnum | UnitTypeCatalogScalarFieldEnum[]
  }

  /**
   * UnitTypeCatalog create
   */
  export type UnitTypeCatalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalog
     */
    select?: UnitTypeCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeCatalogInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitTypeCatalog.
     */
    data: XOR<UnitTypeCatalogCreateInput, UnitTypeCatalogUncheckedCreateInput>
  }

  /**
   * UnitTypeCatalog createMany
   */
  export type UnitTypeCatalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitTypeCatalogs.
     */
    data: UnitTypeCatalogCreateManyInput | UnitTypeCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitTypeCatalog createManyAndReturn
   */
  export type UnitTypeCatalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalog
     */
    select?: UnitTypeCatalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UnitTypeCatalogs.
     */
    data: UnitTypeCatalogCreateManyInput | UnitTypeCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitTypeCatalog update
   */
  export type UnitTypeCatalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalog
     */
    select?: UnitTypeCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeCatalogInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitTypeCatalog.
     */
    data: XOR<UnitTypeCatalogUpdateInput, UnitTypeCatalogUncheckedUpdateInput>
    /**
     * Choose, which UnitTypeCatalog to update.
     */
    where: UnitTypeCatalogWhereUniqueInput
  }

  /**
   * UnitTypeCatalog updateMany
   */
  export type UnitTypeCatalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitTypeCatalogs.
     */
    data: XOR<UnitTypeCatalogUpdateManyMutationInput, UnitTypeCatalogUncheckedUpdateManyInput>
    /**
     * Filter which UnitTypeCatalogs to update
     */
    where?: UnitTypeCatalogWhereInput
  }

  /**
   * UnitTypeCatalog upsert
   */
  export type UnitTypeCatalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalog
     */
    select?: UnitTypeCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeCatalogInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitTypeCatalog to update in case it exists.
     */
    where: UnitTypeCatalogWhereUniqueInput
    /**
     * In case the UnitTypeCatalog found by the `where` argument doesn't exist, create a new UnitTypeCatalog with this data.
     */
    create: XOR<UnitTypeCatalogCreateInput, UnitTypeCatalogUncheckedCreateInput>
    /**
     * In case the UnitTypeCatalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitTypeCatalogUpdateInput, UnitTypeCatalogUncheckedUpdateInput>
  }

  /**
   * UnitTypeCatalog delete
   */
  export type UnitTypeCatalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalog
     */
    select?: UnitTypeCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeCatalogInclude<ExtArgs> | null
    /**
     * Filter which UnitTypeCatalog to delete.
     */
    where: UnitTypeCatalogWhereUniqueInput
  }

  /**
   * UnitTypeCatalog deleteMany
   */
  export type UnitTypeCatalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitTypeCatalogs to delete
     */
    where?: UnitTypeCatalogWhereInput
  }

  /**
   * UnitTypeCatalog.branchLinks
   */
  export type UnitTypeCatalog$branchLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
    where?: BranchUnitTypeWhereInput
    orderBy?: BranchUnitTypeOrderByWithRelationInput | BranchUnitTypeOrderByWithRelationInput[]
    cursor?: BranchUnitTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchUnitTypeScalarFieldEnum | BranchUnitTypeScalarFieldEnum[]
  }

  /**
   * UnitTypeCatalog.units
   */
  export type UnitTypeCatalog$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * UnitTypeCatalog without action
   */
  export type UnitTypeCatalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitTypeCatalog
     */
    select?: UnitTypeCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitTypeCatalogInclude<ExtArgs> | null
  }


  /**
   * Model BranchUnitType
   */

  export type AggregateBranchUnitType = {
    _count: BranchUnitTypeCountAggregateOutputType | null
    _min: BranchUnitTypeMinAggregateOutputType | null
    _max: BranchUnitTypeMaxAggregateOutputType | null
  }

  export type BranchUnitTypeMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    unitTypeId: string | null
    isEnabled: boolean | null
    enabledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchUnitTypeMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    unitTypeId: string | null
    isEnabled: boolean | null
    enabledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchUnitTypeCountAggregateOutputType = {
    id: number
    branchId: number
    unitTypeId: number
    isEnabled: number
    enabledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchUnitTypeMinAggregateInputType = {
    id?: true
    branchId?: true
    unitTypeId?: true
    isEnabled?: true
    enabledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchUnitTypeMaxAggregateInputType = {
    id?: true
    branchId?: true
    unitTypeId?: true
    isEnabled?: true
    enabledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchUnitTypeCountAggregateInputType = {
    id?: true
    branchId?: true
    unitTypeId?: true
    isEnabled?: true
    enabledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchUnitTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchUnitType to aggregate.
     */
    where?: BranchUnitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchUnitTypes to fetch.
     */
    orderBy?: BranchUnitTypeOrderByWithRelationInput | BranchUnitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchUnitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchUnitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchUnitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BranchUnitTypes
    **/
    _count?: true | BranchUnitTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchUnitTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchUnitTypeMaxAggregateInputType
  }

  export type GetBranchUnitTypeAggregateType<T extends BranchUnitTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateBranchUnitType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranchUnitType[P]>
      : GetScalarType<T[P], AggregateBranchUnitType[P]>
  }




  export type BranchUnitTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchUnitTypeWhereInput
    orderBy?: BranchUnitTypeOrderByWithAggregationInput | BranchUnitTypeOrderByWithAggregationInput[]
    by: BranchUnitTypeScalarFieldEnum[] | BranchUnitTypeScalarFieldEnum
    having?: BranchUnitTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchUnitTypeCountAggregateInputType | true
    _min?: BranchUnitTypeMinAggregateInputType
    _max?: BranchUnitTypeMaxAggregateInputType
  }

  export type BranchUnitTypeGroupByOutputType = {
    id: string
    branchId: string
    unitTypeId: string
    isEnabled: boolean
    enabledAt: Date
    createdAt: Date
    updatedAt: Date
    _count: BranchUnitTypeCountAggregateOutputType | null
    _min: BranchUnitTypeMinAggregateOutputType | null
    _max: BranchUnitTypeMaxAggregateOutputType | null
  }

  type GetBranchUnitTypeGroupByPayload<T extends BranchUnitTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchUnitTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchUnitTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchUnitTypeGroupByOutputType[P]>
            : GetScalarType<T[P], BranchUnitTypeGroupByOutputType[P]>
        }
      >
    >


  export type BranchUnitTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    unitTypeId?: boolean
    isEnabled?: boolean
    enabledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unitType?: boolean | UnitTypeCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchUnitType"]>

  export type BranchUnitTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    unitTypeId?: boolean
    isEnabled?: boolean
    enabledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unitType?: boolean | UnitTypeCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branchUnitType"]>

  export type BranchUnitTypeSelectScalar = {
    id?: boolean
    branchId?: boolean
    unitTypeId?: boolean
    isEnabled?: boolean
    enabledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchUnitTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unitType?: boolean | UnitTypeCatalogDefaultArgs<ExtArgs>
  }
  export type BranchUnitTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unitType?: boolean | UnitTypeCatalogDefaultArgs<ExtArgs>
  }

  export type $BranchUnitTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BranchUnitType"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      unitType: Prisma.$UnitTypeCatalogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      unitTypeId: string
      isEnabled: boolean
      enabledAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branchUnitType"]>
    composites: {}
  }

  type BranchUnitTypeGetPayload<S extends boolean | null | undefined | BranchUnitTypeDefaultArgs> = $Result.GetResult<Prisma.$BranchUnitTypePayload, S>

  type BranchUnitTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchUnitTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchUnitTypeCountAggregateInputType | true
    }

  export interface BranchUnitTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BranchUnitType'], meta: { name: 'BranchUnitType' } }
    /**
     * Find zero or one BranchUnitType that matches the filter.
     * @param {BranchUnitTypeFindUniqueArgs} args - Arguments to find a BranchUnitType
     * @example
     * // Get one BranchUnitType
     * const branchUnitType = await prisma.branchUnitType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchUnitTypeFindUniqueArgs>(args: SelectSubset<T, BranchUnitTypeFindUniqueArgs<ExtArgs>>): Prisma__BranchUnitTypeClient<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BranchUnitType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchUnitTypeFindUniqueOrThrowArgs} args - Arguments to find a BranchUnitType
     * @example
     * // Get one BranchUnitType
     * const branchUnitType = await prisma.branchUnitType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchUnitTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchUnitTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchUnitTypeClient<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BranchUnitType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUnitTypeFindFirstArgs} args - Arguments to find a BranchUnitType
     * @example
     * // Get one BranchUnitType
     * const branchUnitType = await prisma.branchUnitType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchUnitTypeFindFirstArgs>(args?: SelectSubset<T, BranchUnitTypeFindFirstArgs<ExtArgs>>): Prisma__BranchUnitTypeClient<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BranchUnitType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUnitTypeFindFirstOrThrowArgs} args - Arguments to find a BranchUnitType
     * @example
     * // Get one BranchUnitType
     * const branchUnitType = await prisma.branchUnitType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchUnitTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchUnitTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchUnitTypeClient<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BranchUnitTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUnitTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BranchUnitTypes
     * const branchUnitTypes = await prisma.branchUnitType.findMany()
     * 
     * // Get first 10 BranchUnitTypes
     * const branchUnitTypes = await prisma.branchUnitType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchUnitTypeWithIdOnly = await prisma.branchUnitType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchUnitTypeFindManyArgs>(args?: SelectSubset<T, BranchUnitTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BranchUnitType.
     * @param {BranchUnitTypeCreateArgs} args - Arguments to create a BranchUnitType.
     * @example
     * // Create one BranchUnitType
     * const BranchUnitType = await prisma.branchUnitType.create({
     *   data: {
     *     // ... data to create a BranchUnitType
     *   }
     * })
     * 
     */
    create<T extends BranchUnitTypeCreateArgs>(args: SelectSubset<T, BranchUnitTypeCreateArgs<ExtArgs>>): Prisma__BranchUnitTypeClient<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BranchUnitTypes.
     * @param {BranchUnitTypeCreateManyArgs} args - Arguments to create many BranchUnitTypes.
     * @example
     * // Create many BranchUnitTypes
     * const branchUnitType = await prisma.branchUnitType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchUnitTypeCreateManyArgs>(args?: SelectSubset<T, BranchUnitTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BranchUnitTypes and returns the data saved in the database.
     * @param {BranchUnitTypeCreateManyAndReturnArgs} args - Arguments to create many BranchUnitTypes.
     * @example
     * // Create many BranchUnitTypes
     * const branchUnitType = await prisma.branchUnitType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BranchUnitTypes and only return the `id`
     * const branchUnitTypeWithIdOnly = await prisma.branchUnitType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchUnitTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchUnitTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BranchUnitType.
     * @param {BranchUnitTypeDeleteArgs} args - Arguments to delete one BranchUnitType.
     * @example
     * // Delete one BranchUnitType
     * const BranchUnitType = await prisma.branchUnitType.delete({
     *   where: {
     *     // ... filter to delete one BranchUnitType
     *   }
     * })
     * 
     */
    delete<T extends BranchUnitTypeDeleteArgs>(args: SelectSubset<T, BranchUnitTypeDeleteArgs<ExtArgs>>): Prisma__BranchUnitTypeClient<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BranchUnitType.
     * @param {BranchUnitTypeUpdateArgs} args - Arguments to update one BranchUnitType.
     * @example
     * // Update one BranchUnitType
     * const branchUnitType = await prisma.branchUnitType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUnitTypeUpdateArgs>(args: SelectSubset<T, BranchUnitTypeUpdateArgs<ExtArgs>>): Prisma__BranchUnitTypeClient<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BranchUnitTypes.
     * @param {BranchUnitTypeDeleteManyArgs} args - Arguments to filter BranchUnitTypes to delete.
     * @example
     * // Delete a few BranchUnitTypes
     * const { count } = await prisma.branchUnitType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchUnitTypeDeleteManyArgs>(args?: SelectSubset<T, BranchUnitTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BranchUnitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUnitTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BranchUnitTypes
     * const branchUnitType = await prisma.branchUnitType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUnitTypeUpdateManyArgs>(args: SelectSubset<T, BranchUnitTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BranchUnitType.
     * @param {BranchUnitTypeUpsertArgs} args - Arguments to update or create a BranchUnitType.
     * @example
     * // Update or create a BranchUnitType
     * const branchUnitType = await prisma.branchUnitType.upsert({
     *   create: {
     *     // ... data to create a BranchUnitType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BranchUnitType we want to update
     *   }
     * })
     */
    upsert<T extends BranchUnitTypeUpsertArgs>(args: SelectSubset<T, BranchUnitTypeUpsertArgs<ExtArgs>>): Prisma__BranchUnitTypeClient<$Result.GetResult<Prisma.$BranchUnitTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BranchUnitTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUnitTypeCountArgs} args - Arguments to filter BranchUnitTypes to count.
     * @example
     * // Count the number of BranchUnitTypes
     * const count = await prisma.branchUnitType.count({
     *   where: {
     *     // ... the filter for the BranchUnitTypes we want to count
     *   }
     * })
    **/
    count<T extends BranchUnitTypeCountArgs>(
      args?: Subset<T, BranchUnitTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchUnitTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BranchUnitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUnitTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchUnitTypeAggregateArgs>(args: Subset<T, BranchUnitTypeAggregateArgs>): Prisma.PrismaPromise<GetBranchUnitTypeAggregateType<T>>

    /**
     * Group by BranchUnitType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUnitTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchUnitTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchUnitTypeGroupByArgs['orderBy'] }
        : { orderBy?: BranchUnitTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchUnitTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchUnitTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BranchUnitType model
   */
  readonly fields: BranchUnitTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BranchUnitType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchUnitTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    unitType<T extends UnitTypeCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitTypeCatalogDefaultArgs<ExtArgs>>): Prisma__UnitTypeCatalogClient<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BranchUnitType model
   */ 
  interface BranchUnitTypeFieldRefs {
    readonly id: FieldRef<"BranchUnitType", 'String'>
    readonly branchId: FieldRef<"BranchUnitType", 'String'>
    readonly unitTypeId: FieldRef<"BranchUnitType", 'String'>
    readonly isEnabled: FieldRef<"BranchUnitType", 'Boolean'>
    readonly enabledAt: FieldRef<"BranchUnitType", 'DateTime'>
    readonly createdAt: FieldRef<"BranchUnitType", 'DateTime'>
    readonly updatedAt: FieldRef<"BranchUnitType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BranchUnitType findUnique
   */
  export type BranchUnitTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
    /**
     * Filter, which BranchUnitType to fetch.
     */
    where: BranchUnitTypeWhereUniqueInput
  }

  /**
   * BranchUnitType findUniqueOrThrow
   */
  export type BranchUnitTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
    /**
     * Filter, which BranchUnitType to fetch.
     */
    where: BranchUnitTypeWhereUniqueInput
  }

  /**
   * BranchUnitType findFirst
   */
  export type BranchUnitTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
    /**
     * Filter, which BranchUnitType to fetch.
     */
    where?: BranchUnitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchUnitTypes to fetch.
     */
    orderBy?: BranchUnitTypeOrderByWithRelationInput | BranchUnitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchUnitTypes.
     */
    cursor?: BranchUnitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchUnitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchUnitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchUnitTypes.
     */
    distinct?: BranchUnitTypeScalarFieldEnum | BranchUnitTypeScalarFieldEnum[]
  }

  /**
   * BranchUnitType findFirstOrThrow
   */
  export type BranchUnitTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
    /**
     * Filter, which BranchUnitType to fetch.
     */
    where?: BranchUnitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchUnitTypes to fetch.
     */
    orderBy?: BranchUnitTypeOrderByWithRelationInput | BranchUnitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BranchUnitTypes.
     */
    cursor?: BranchUnitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchUnitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchUnitTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BranchUnitTypes.
     */
    distinct?: BranchUnitTypeScalarFieldEnum | BranchUnitTypeScalarFieldEnum[]
  }

  /**
   * BranchUnitType findMany
   */
  export type BranchUnitTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
    /**
     * Filter, which BranchUnitTypes to fetch.
     */
    where?: BranchUnitTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BranchUnitTypes to fetch.
     */
    orderBy?: BranchUnitTypeOrderByWithRelationInput | BranchUnitTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BranchUnitTypes.
     */
    cursor?: BranchUnitTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BranchUnitTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BranchUnitTypes.
     */
    skip?: number
    distinct?: BranchUnitTypeScalarFieldEnum | BranchUnitTypeScalarFieldEnum[]
  }

  /**
   * BranchUnitType create
   */
  export type BranchUnitTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a BranchUnitType.
     */
    data: XOR<BranchUnitTypeCreateInput, BranchUnitTypeUncheckedCreateInput>
  }

  /**
   * BranchUnitType createMany
   */
  export type BranchUnitTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BranchUnitTypes.
     */
    data: BranchUnitTypeCreateManyInput | BranchUnitTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BranchUnitType createManyAndReturn
   */
  export type BranchUnitTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BranchUnitTypes.
     */
    data: BranchUnitTypeCreateManyInput | BranchUnitTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BranchUnitType update
   */
  export type BranchUnitTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a BranchUnitType.
     */
    data: XOR<BranchUnitTypeUpdateInput, BranchUnitTypeUncheckedUpdateInput>
    /**
     * Choose, which BranchUnitType to update.
     */
    where: BranchUnitTypeWhereUniqueInput
  }

  /**
   * BranchUnitType updateMany
   */
  export type BranchUnitTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BranchUnitTypes.
     */
    data: XOR<BranchUnitTypeUpdateManyMutationInput, BranchUnitTypeUncheckedUpdateManyInput>
    /**
     * Filter which BranchUnitTypes to update
     */
    where?: BranchUnitTypeWhereInput
  }

  /**
   * BranchUnitType upsert
   */
  export type BranchUnitTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the BranchUnitType to update in case it exists.
     */
    where: BranchUnitTypeWhereUniqueInput
    /**
     * In case the BranchUnitType found by the `where` argument doesn't exist, create a new BranchUnitType with this data.
     */
    create: XOR<BranchUnitTypeCreateInput, BranchUnitTypeUncheckedCreateInput>
    /**
     * In case the BranchUnitType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUnitTypeUpdateInput, BranchUnitTypeUncheckedUpdateInput>
  }

  /**
   * BranchUnitType delete
   */
  export type BranchUnitTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
    /**
     * Filter which BranchUnitType to delete.
     */
    where: BranchUnitTypeWhereUniqueInput
  }

  /**
   * BranchUnitType deleteMany
   */
  export type BranchUnitTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BranchUnitTypes to delete
     */
    where?: BranchUnitTypeWhereInput
  }

  /**
   * BranchUnitType without action
   */
  export type BranchUnitTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchUnitType
     */
    select?: BranchUnitTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchUnitTypeInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    departmentId: string | null
    unitTypeId: string | null
    code: string | null
    name: string | null
    usesRooms: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    departmentId: string | null
    unitTypeId: string | null
    code: string | null
    name: string | null
    usesRooms: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    branchId: number
    departmentId: number
    unitTypeId: number
    code: number
    name: number
    usesRooms: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitMinAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    unitTypeId?: true
    code?: true
    name?: true
    usesRooms?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    unitTypeId?: true
    code?: true
    name?: true
    usesRooms?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    unitTypeId?: true
    code?: true
    name?: true
    usesRooms?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    branchId: string
    departmentId: string
    unitTypeId: string
    code: string
    name: string
    usesRooms: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    unitTypeId?: boolean
    code?: boolean
    name?: boolean
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    unitType?: boolean | UnitTypeCatalogDefaultArgs<ExtArgs>
    rooms?: boolean | Unit$roomsArgs<ExtArgs>
    resources?: boolean | Unit$resourcesArgs<ExtArgs>
    equipment?: boolean | Unit$equipmentArgs<ExtArgs>
    bookings?: boolean | Unit$bookingsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    unitTypeId?: boolean
    code?: boolean
    name?: boolean
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    unitType?: boolean | UnitTypeCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    unitTypeId?: boolean
    code?: boolean
    name?: boolean
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    unitType?: boolean | UnitTypeCatalogDefaultArgs<ExtArgs>
    rooms?: boolean | Unit$roomsArgs<ExtArgs>
    resources?: boolean | Unit$resourcesArgs<ExtArgs>
    equipment?: boolean | Unit$equipmentArgs<ExtArgs>
    bookings?: boolean | Unit$bookingsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    unitType?: boolean | UnitTypeCatalogDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs>
      unitType: Prisma.$UnitTypeCatalogPayload<ExtArgs>
      rooms: Prisma.$UnitRoomPayload<ExtArgs>[]
      resources: Prisma.$UnitResourcePayload<ExtArgs>[]
      equipment: Prisma.$EquipmentAssetPayload<ExtArgs>[]
      bookings: Prisma.$ProcedureBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      departmentId: string
      unitTypeId: string
      code: string
      name: string
      usesRooms: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    unitType<T extends UnitTypeCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitTypeCatalogDefaultArgs<ExtArgs>>): Prisma__UnitTypeCatalogClient<$Result.GetResult<Prisma.$UnitTypeCatalogPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rooms<T extends Unit$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "findMany"> | Null>
    resources<T extends Unit$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Unit$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "findMany"> | Null>
    equipment<T extends Unit$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, Unit$equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends Unit$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */ 
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly branchId: FieldRef<"Unit", 'String'>
    readonly departmentId: FieldRef<"Unit", 'String'>
    readonly unitTypeId: FieldRef<"Unit", 'String'>
    readonly code: FieldRef<"Unit", 'String'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly usesRooms: FieldRef<"Unit", 'Boolean'>
    readonly isActive: FieldRef<"Unit", 'Boolean'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
  }

  /**
   * Unit.rooms
   */
  export type Unit$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    where?: UnitRoomWhereInput
    orderBy?: UnitRoomOrderByWithRelationInput | UnitRoomOrderByWithRelationInput[]
    cursor?: UnitRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitRoomScalarFieldEnum | UnitRoomScalarFieldEnum[]
  }

  /**
   * Unit.resources
   */
  export type Unit$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    where?: UnitResourceWhereInput
    orderBy?: UnitResourceOrderByWithRelationInput | UnitResourceOrderByWithRelationInput[]
    cursor?: UnitResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitResourceScalarFieldEnum | UnitResourceScalarFieldEnum[]
  }

  /**
   * Unit.equipment
   */
  export type Unit$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    where?: EquipmentAssetWhereInput
    orderBy?: EquipmentAssetOrderByWithRelationInput | EquipmentAssetOrderByWithRelationInput[]
    cursor?: EquipmentAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentAssetScalarFieldEnum | EquipmentAssetScalarFieldEnum[]
  }

  /**
   * Unit.bookings
   */
  export type Unit$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    where?: ProcedureBookingWhereInput
    orderBy?: ProcedureBookingOrderByWithRelationInput | ProcedureBookingOrderByWithRelationInput[]
    cursor?: ProcedureBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedureBookingScalarFieldEnum | ProcedureBookingScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model UnitRoom
   */

  export type AggregateUnitRoom = {
    _count: UnitRoomCountAggregateOutputType | null
    _min: UnitRoomMinAggregateOutputType | null
    _max: UnitRoomMaxAggregateOutputType | null
  }

  export type UnitRoomMinAggregateOutputType = {
    id: string | null
    unitId: string | null
    branchId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitRoomMaxAggregateOutputType = {
    id: string | null
    unitId: string | null
    branchId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitRoomCountAggregateOutputType = {
    id: number
    unitId: number
    branchId: number
    code: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitRoomMinAggregateInputType = {
    id?: true
    unitId?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitRoomMaxAggregateInputType = {
    id?: true
    unitId?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitRoomCountAggregateInputType = {
    id?: true
    unitId?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitRoom to aggregate.
     */
    where?: UnitRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitRooms to fetch.
     */
    orderBy?: UnitRoomOrderByWithRelationInput | UnitRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitRooms
    **/
    _count?: true | UnitRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitRoomMaxAggregateInputType
  }

  export type GetUnitRoomAggregateType<T extends UnitRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitRoom[P]>
      : GetScalarType<T[P], AggregateUnitRoom[P]>
  }




  export type UnitRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitRoomWhereInput
    orderBy?: UnitRoomOrderByWithAggregationInput | UnitRoomOrderByWithAggregationInput[]
    by: UnitRoomScalarFieldEnum[] | UnitRoomScalarFieldEnum
    having?: UnitRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitRoomCountAggregateInputType | true
    _min?: UnitRoomMinAggregateInputType
    _max?: UnitRoomMaxAggregateInputType
  }

  export type UnitRoomGroupByOutputType = {
    id: string
    unitId: string
    branchId: string
    code: string
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UnitRoomCountAggregateOutputType | null
    _min: UnitRoomMinAggregateOutputType | null
    _max: UnitRoomMaxAggregateOutputType | null
  }

  type GetUnitRoomGroupByPayload<T extends UnitRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitRoomGroupByOutputType[P]>
            : GetScalarType<T[P], UnitRoomGroupByOutputType[P]>
        }
      >
    >


  export type UnitRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    resources?: boolean | UnitRoom$resourcesArgs<ExtArgs>
    equipment?: boolean | UnitRoom$equipmentArgs<ExtArgs>
    _count?: boolean | UnitRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitRoom"]>

  export type UnitRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unitId?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitRoom"]>

  export type UnitRoomSelectScalar = {
    id?: boolean
    unitId?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    resources?: boolean | UnitRoom$resourcesArgs<ExtArgs>
    equipment?: boolean | UnitRoom$equipmentArgs<ExtArgs>
    _count?: boolean | UnitRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $UnitRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitRoom"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>
      resources: Prisma.$UnitResourcePayload<ExtArgs>[]
      equipment: Prisma.$EquipmentAssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unitId: string
      branchId: string
      code: string
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitRoom"]>
    composites: {}
  }

  type UnitRoomGetPayload<S extends boolean | null | undefined | UnitRoomDefaultArgs> = $Result.GetResult<Prisma.$UnitRoomPayload, S>

  type UnitRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitRoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitRoomCountAggregateInputType | true
    }

  export interface UnitRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitRoom'], meta: { name: 'UnitRoom' } }
    /**
     * Find zero or one UnitRoom that matches the filter.
     * @param {UnitRoomFindUniqueArgs} args - Arguments to find a UnitRoom
     * @example
     * // Get one UnitRoom
     * const unitRoom = await prisma.unitRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitRoomFindUniqueArgs>(args: SelectSubset<T, UnitRoomFindUniqueArgs<ExtArgs>>): Prisma__UnitRoomClient<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UnitRoom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnitRoomFindUniqueOrThrowArgs} args - Arguments to find a UnitRoom
     * @example
     * // Get one UnitRoom
     * const unitRoom = await prisma.unitRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitRoomClient<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UnitRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitRoomFindFirstArgs} args - Arguments to find a UnitRoom
     * @example
     * // Get one UnitRoom
     * const unitRoom = await prisma.unitRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitRoomFindFirstArgs>(args?: SelectSubset<T, UnitRoomFindFirstArgs<ExtArgs>>): Prisma__UnitRoomClient<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UnitRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitRoomFindFirstOrThrowArgs} args - Arguments to find a UnitRoom
     * @example
     * // Get one UnitRoom
     * const unitRoom = await prisma.unitRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitRoomClient<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UnitRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitRooms
     * const unitRooms = await prisma.unitRoom.findMany()
     * 
     * // Get first 10 UnitRooms
     * const unitRooms = await prisma.unitRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitRoomWithIdOnly = await prisma.unitRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitRoomFindManyArgs>(args?: SelectSubset<T, UnitRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UnitRoom.
     * @param {UnitRoomCreateArgs} args - Arguments to create a UnitRoom.
     * @example
     * // Create one UnitRoom
     * const UnitRoom = await prisma.unitRoom.create({
     *   data: {
     *     // ... data to create a UnitRoom
     *   }
     * })
     * 
     */
    create<T extends UnitRoomCreateArgs>(args: SelectSubset<T, UnitRoomCreateArgs<ExtArgs>>): Prisma__UnitRoomClient<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UnitRooms.
     * @param {UnitRoomCreateManyArgs} args - Arguments to create many UnitRooms.
     * @example
     * // Create many UnitRooms
     * const unitRoom = await prisma.unitRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitRoomCreateManyArgs>(args?: SelectSubset<T, UnitRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitRooms and returns the data saved in the database.
     * @param {UnitRoomCreateManyAndReturnArgs} args - Arguments to create many UnitRooms.
     * @example
     * // Create many UnitRooms
     * const unitRoom = await prisma.unitRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitRooms and only return the `id`
     * const unitRoomWithIdOnly = await prisma.unitRoom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UnitRoom.
     * @param {UnitRoomDeleteArgs} args - Arguments to delete one UnitRoom.
     * @example
     * // Delete one UnitRoom
     * const UnitRoom = await prisma.unitRoom.delete({
     *   where: {
     *     // ... filter to delete one UnitRoom
     *   }
     * })
     * 
     */
    delete<T extends UnitRoomDeleteArgs>(args: SelectSubset<T, UnitRoomDeleteArgs<ExtArgs>>): Prisma__UnitRoomClient<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UnitRoom.
     * @param {UnitRoomUpdateArgs} args - Arguments to update one UnitRoom.
     * @example
     * // Update one UnitRoom
     * const unitRoom = await prisma.unitRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitRoomUpdateArgs>(args: SelectSubset<T, UnitRoomUpdateArgs<ExtArgs>>): Prisma__UnitRoomClient<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UnitRooms.
     * @param {UnitRoomDeleteManyArgs} args - Arguments to filter UnitRooms to delete.
     * @example
     * // Delete a few UnitRooms
     * const { count } = await prisma.unitRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitRoomDeleteManyArgs>(args?: SelectSubset<T, UnitRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitRooms
     * const unitRoom = await prisma.unitRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitRoomUpdateManyArgs>(args: SelectSubset<T, UnitRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitRoom.
     * @param {UnitRoomUpsertArgs} args - Arguments to update or create a UnitRoom.
     * @example
     * // Update or create a UnitRoom
     * const unitRoom = await prisma.unitRoom.upsert({
     *   create: {
     *     // ... data to create a UnitRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitRoom we want to update
     *   }
     * })
     */
    upsert<T extends UnitRoomUpsertArgs>(args: SelectSubset<T, UnitRoomUpsertArgs<ExtArgs>>): Prisma__UnitRoomClient<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UnitRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitRoomCountArgs} args - Arguments to filter UnitRooms to count.
     * @example
     * // Count the number of UnitRooms
     * const count = await prisma.unitRoom.count({
     *   where: {
     *     // ... the filter for the UnitRooms we want to count
     *   }
     * })
    **/
    count<T extends UnitRoomCountArgs>(
      args?: Subset<T, UnitRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitRoomAggregateArgs>(args: Subset<T, UnitRoomAggregateArgs>): Prisma.PrismaPromise<GetUnitRoomAggregateType<T>>

    /**
     * Group by UnitRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitRoomGroupByArgs['orderBy'] }
        : { orderBy?: UnitRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitRoom model
   */
  readonly fields: UnitRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resources<T extends UnitRoom$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, UnitRoom$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "findMany"> | Null>
    equipment<T extends UnitRoom$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, UnitRoom$equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitRoom model
   */ 
  interface UnitRoomFieldRefs {
    readonly id: FieldRef<"UnitRoom", 'String'>
    readonly unitId: FieldRef<"UnitRoom", 'String'>
    readonly branchId: FieldRef<"UnitRoom", 'String'>
    readonly code: FieldRef<"UnitRoom", 'String'>
    readonly name: FieldRef<"UnitRoom", 'String'>
    readonly isActive: FieldRef<"UnitRoom", 'Boolean'>
    readonly createdAt: FieldRef<"UnitRoom", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitRoom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitRoom findUnique
   */
  export type UnitRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    /**
     * Filter, which UnitRoom to fetch.
     */
    where: UnitRoomWhereUniqueInput
  }

  /**
   * UnitRoom findUniqueOrThrow
   */
  export type UnitRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    /**
     * Filter, which UnitRoom to fetch.
     */
    where: UnitRoomWhereUniqueInput
  }

  /**
   * UnitRoom findFirst
   */
  export type UnitRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    /**
     * Filter, which UnitRoom to fetch.
     */
    where?: UnitRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitRooms to fetch.
     */
    orderBy?: UnitRoomOrderByWithRelationInput | UnitRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitRooms.
     */
    cursor?: UnitRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitRooms.
     */
    distinct?: UnitRoomScalarFieldEnum | UnitRoomScalarFieldEnum[]
  }

  /**
   * UnitRoom findFirstOrThrow
   */
  export type UnitRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    /**
     * Filter, which UnitRoom to fetch.
     */
    where?: UnitRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitRooms to fetch.
     */
    orderBy?: UnitRoomOrderByWithRelationInput | UnitRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitRooms.
     */
    cursor?: UnitRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitRooms.
     */
    distinct?: UnitRoomScalarFieldEnum | UnitRoomScalarFieldEnum[]
  }

  /**
   * UnitRoom findMany
   */
  export type UnitRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    /**
     * Filter, which UnitRooms to fetch.
     */
    where?: UnitRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitRooms to fetch.
     */
    orderBy?: UnitRoomOrderByWithRelationInput | UnitRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitRooms.
     */
    cursor?: UnitRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitRooms.
     */
    skip?: number
    distinct?: UnitRoomScalarFieldEnum | UnitRoomScalarFieldEnum[]
  }

  /**
   * UnitRoom create
   */
  export type UnitRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitRoom.
     */
    data: XOR<UnitRoomCreateInput, UnitRoomUncheckedCreateInput>
  }

  /**
   * UnitRoom createMany
   */
  export type UnitRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitRooms.
     */
    data: UnitRoomCreateManyInput | UnitRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitRoom createManyAndReturn
   */
  export type UnitRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UnitRooms.
     */
    data: UnitRoomCreateManyInput | UnitRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitRoom update
   */
  export type UnitRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitRoom.
     */
    data: XOR<UnitRoomUpdateInput, UnitRoomUncheckedUpdateInput>
    /**
     * Choose, which UnitRoom to update.
     */
    where: UnitRoomWhereUniqueInput
  }

  /**
   * UnitRoom updateMany
   */
  export type UnitRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitRooms.
     */
    data: XOR<UnitRoomUpdateManyMutationInput, UnitRoomUncheckedUpdateManyInput>
    /**
     * Filter which UnitRooms to update
     */
    where?: UnitRoomWhereInput
  }

  /**
   * UnitRoom upsert
   */
  export type UnitRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitRoom to update in case it exists.
     */
    where: UnitRoomWhereUniqueInput
    /**
     * In case the UnitRoom found by the `where` argument doesn't exist, create a new UnitRoom with this data.
     */
    create: XOR<UnitRoomCreateInput, UnitRoomUncheckedCreateInput>
    /**
     * In case the UnitRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitRoomUpdateInput, UnitRoomUncheckedUpdateInput>
  }

  /**
   * UnitRoom delete
   */
  export type UnitRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    /**
     * Filter which UnitRoom to delete.
     */
    where: UnitRoomWhereUniqueInput
  }

  /**
   * UnitRoom deleteMany
   */
  export type UnitRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitRooms to delete
     */
    where?: UnitRoomWhereInput
  }

  /**
   * UnitRoom.resources
   */
  export type UnitRoom$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    where?: UnitResourceWhereInput
    orderBy?: UnitResourceOrderByWithRelationInput | UnitResourceOrderByWithRelationInput[]
    cursor?: UnitResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitResourceScalarFieldEnum | UnitResourceScalarFieldEnum[]
  }

  /**
   * UnitRoom.equipment
   */
  export type UnitRoom$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    where?: EquipmentAssetWhereInput
    orderBy?: EquipmentAssetOrderByWithRelationInput | EquipmentAssetOrderByWithRelationInput[]
    cursor?: EquipmentAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentAssetScalarFieldEnum | EquipmentAssetScalarFieldEnum[]
  }

  /**
   * UnitRoom without action
   */
  export type UnitRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
  }


  /**
   * Model UnitResource
   */

  export type AggregateUnitResource = {
    _count: UnitResourceCountAggregateOutputType | null
    _min: UnitResourceMinAggregateOutputType | null
    _max: UnitResourceMaxAggregateOutputType | null
  }

  export type UnitResourceMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    unitId: string | null
    roomId: string | null
    resourceType: $Enums.UnitResourceType | null
    code: string | null
    name: string | null
    state: $Enums.UnitResourceState | null
    isActive: boolean | null
    isSchedulable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitResourceMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    unitId: string | null
    roomId: string | null
    resourceType: $Enums.UnitResourceType | null
    code: string | null
    name: string | null
    state: $Enums.UnitResourceState | null
    isActive: boolean | null
    isSchedulable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitResourceCountAggregateOutputType = {
    id: number
    branchId: number
    unitId: number
    roomId: number
    resourceType: number
    code: number
    name: number
    state: number
    isActive: number
    isSchedulable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitResourceMinAggregateInputType = {
    id?: true
    branchId?: true
    unitId?: true
    roomId?: true
    resourceType?: true
    code?: true
    name?: true
    state?: true
    isActive?: true
    isSchedulable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitResourceMaxAggregateInputType = {
    id?: true
    branchId?: true
    unitId?: true
    roomId?: true
    resourceType?: true
    code?: true
    name?: true
    state?: true
    isActive?: true
    isSchedulable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitResourceCountAggregateInputType = {
    id?: true
    branchId?: true
    unitId?: true
    roomId?: true
    resourceType?: true
    code?: true
    name?: true
    state?: true
    isActive?: true
    isSchedulable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitResource to aggregate.
     */
    where?: UnitResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitResources to fetch.
     */
    orderBy?: UnitResourceOrderByWithRelationInput | UnitResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitResources
    **/
    _count?: true | UnitResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitResourceMaxAggregateInputType
  }

  export type GetUnitResourceAggregateType<T extends UnitResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitResource[P]>
      : GetScalarType<T[P], AggregateUnitResource[P]>
  }




  export type UnitResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitResourceWhereInput
    orderBy?: UnitResourceOrderByWithAggregationInput | UnitResourceOrderByWithAggregationInput[]
    by: UnitResourceScalarFieldEnum[] | UnitResourceScalarFieldEnum
    having?: UnitResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitResourceCountAggregateInputType | true
    _min?: UnitResourceMinAggregateInputType
    _max?: UnitResourceMaxAggregateInputType
  }

  export type UnitResourceGroupByOutputType = {
    id: string
    branchId: string
    unitId: string
    roomId: string | null
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state: $Enums.UnitResourceState
    isActive: boolean
    isSchedulable: boolean
    createdAt: Date
    updatedAt: Date
    _count: UnitResourceCountAggregateOutputType | null
    _min: UnitResourceMinAggregateOutputType | null
    _max: UnitResourceMaxAggregateOutputType | null
  }

  type GetUnitResourceGroupByPayload<T extends UnitResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitResourceGroupByOutputType[P]>
            : GetScalarType<T[P], UnitResourceGroupByOutputType[P]>
        }
      >
    >


  export type UnitResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    unitId?: boolean
    roomId?: boolean
    resourceType?: boolean
    code?: boolean
    name?: boolean
    state?: boolean
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    room?: boolean | UnitResource$roomArgs<ExtArgs>
    bookings?: boolean | UnitResource$bookingsArgs<ExtArgs>
    _count?: boolean | UnitResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitResource"]>

  export type UnitResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    unitId?: boolean
    roomId?: boolean
    resourceType?: boolean
    code?: boolean
    name?: boolean
    state?: boolean
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    room?: boolean | UnitResource$roomArgs<ExtArgs>
  }, ExtArgs["result"]["unitResource"]>

  export type UnitResourceSelectScalar = {
    id?: boolean
    branchId?: boolean
    unitId?: boolean
    roomId?: boolean
    resourceType?: boolean
    code?: boolean
    name?: boolean
    state?: boolean
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    room?: boolean | UnitResource$roomArgs<ExtArgs>
    bookings?: boolean | UnitResource$bookingsArgs<ExtArgs>
    _count?: boolean | UnitResourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    room?: boolean | UnitResource$roomArgs<ExtArgs>
  }

  export type $UnitResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitResource"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>
      room: Prisma.$UnitRoomPayload<ExtArgs> | null
      bookings: Prisma.$ProcedureBookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      unitId: string
      roomId: string | null
      resourceType: $Enums.UnitResourceType
      code: string
      name: string
      state: $Enums.UnitResourceState
      isActive: boolean
      isSchedulable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitResource"]>
    composites: {}
  }

  type UnitResourceGetPayload<S extends boolean | null | undefined | UnitResourceDefaultArgs> = $Result.GetResult<Prisma.$UnitResourcePayload, S>

  type UnitResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitResourceCountAggregateInputType | true
    }

  export interface UnitResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitResource'], meta: { name: 'UnitResource' } }
    /**
     * Find zero or one UnitResource that matches the filter.
     * @param {UnitResourceFindUniqueArgs} args - Arguments to find a UnitResource
     * @example
     * // Get one UnitResource
     * const unitResource = await prisma.unitResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitResourceFindUniqueArgs>(args: SelectSubset<T, UnitResourceFindUniqueArgs<ExtArgs>>): Prisma__UnitResourceClient<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UnitResource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnitResourceFindUniqueOrThrowArgs} args - Arguments to find a UnitResource
     * @example
     * // Get one UnitResource
     * const unitResource = await prisma.unitResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitResourceClient<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UnitResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitResourceFindFirstArgs} args - Arguments to find a UnitResource
     * @example
     * // Get one UnitResource
     * const unitResource = await prisma.unitResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitResourceFindFirstArgs>(args?: SelectSubset<T, UnitResourceFindFirstArgs<ExtArgs>>): Prisma__UnitResourceClient<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UnitResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitResourceFindFirstOrThrowArgs} args - Arguments to find a UnitResource
     * @example
     * // Get one UnitResource
     * const unitResource = await prisma.unitResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitResourceClient<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UnitResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitResources
     * const unitResources = await prisma.unitResource.findMany()
     * 
     * // Get first 10 UnitResources
     * const unitResources = await prisma.unitResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitResourceWithIdOnly = await prisma.unitResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitResourceFindManyArgs>(args?: SelectSubset<T, UnitResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UnitResource.
     * @param {UnitResourceCreateArgs} args - Arguments to create a UnitResource.
     * @example
     * // Create one UnitResource
     * const UnitResource = await prisma.unitResource.create({
     *   data: {
     *     // ... data to create a UnitResource
     *   }
     * })
     * 
     */
    create<T extends UnitResourceCreateArgs>(args: SelectSubset<T, UnitResourceCreateArgs<ExtArgs>>): Prisma__UnitResourceClient<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UnitResources.
     * @param {UnitResourceCreateManyArgs} args - Arguments to create many UnitResources.
     * @example
     * // Create many UnitResources
     * const unitResource = await prisma.unitResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitResourceCreateManyArgs>(args?: SelectSubset<T, UnitResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitResources and returns the data saved in the database.
     * @param {UnitResourceCreateManyAndReturnArgs} args - Arguments to create many UnitResources.
     * @example
     * // Create many UnitResources
     * const unitResource = await prisma.unitResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitResources and only return the `id`
     * const unitResourceWithIdOnly = await prisma.unitResource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UnitResource.
     * @param {UnitResourceDeleteArgs} args - Arguments to delete one UnitResource.
     * @example
     * // Delete one UnitResource
     * const UnitResource = await prisma.unitResource.delete({
     *   where: {
     *     // ... filter to delete one UnitResource
     *   }
     * })
     * 
     */
    delete<T extends UnitResourceDeleteArgs>(args: SelectSubset<T, UnitResourceDeleteArgs<ExtArgs>>): Prisma__UnitResourceClient<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UnitResource.
     * @param {UnitResourceUpdateArgs} args - Arguments to update one UnitResource.
     * @example
     * // Update one UnitResource
     * const unitResource = await prisma.unitResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitResourceUpdateArgs>(args: SelectSubset<T, UnitResourceUpdateArgs<ExtArgs>>): Prisma__UnitResourceClient<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UnitResources.
     * @param {UnitResourceDeleteManyArgs} args - Arguments to filter UnitResources to delete.
     * @example
     * // Delete a few UnitResources
     * const { count } = await prisma.unitResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitResourceDeleteManyArgs>(args?: SelectSubset<T, UnitResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitResources
     * const unitResource = await prisma.unitResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitResourceUpdateManyArgs>(args: SelectSubset<T, UnitResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitResource.
     * @param {UnitResourceUpsertArgs} args - Arguments to update or create a UnitResource.
     * @example
     * // Update or create a UnitResource
     * const unitResource = await prisma.unitResource.upsert({
     *   create: {
     *     // ... data to create a UnitResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitResource we want to update
     *   }
     * })
     */
    upsert<T extends UnitResourceUpsertArgs>(args: SelectSubset<T, UnitResourceUpsertArgs<ExtArgs>>): Prisma__UnitResourceClient<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UnitResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitResourceCountArgs} args - Arguments to filter UnitResources to count.
     * @example
     * // Count the number of UnitResources
     * const count = await prisma.unitResource.count({
     *   where: {
     *     // ... the filter for the UnitResources we want to count
     *   }
     * })
    **/
    count<T extends UnitResourceCountArgs>(
      args?: Subset<T, UnitResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitResourceAggregateArgs>(args: Subset<T, UnitResourceAggregateArgs>): Prisma.PrismaPromise<GetUnitResourceAggregateType<T>>

    /**
     * Group by UnitResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitResourceGroupByArgs['orderBy'] }
        : { orderBy?: UnitResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitResource model
   */
  readonly fields: UnitResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    room<T extends UnitResource$roomArgs<ExtArgs> = {}>(args?: Subset<T, UnitResource$roomArgs<ExtArgs>>): Prisma__UnitRoomClient<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    bookings<T extends UnitResource$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, UnitResource$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitResource model
   */ 
  interface UnitResourceFieldRefs {
    readonly id: FieldRef<"UnitResource", 'String'>
    readonly branchId: FieldRef<"UnitResource", 'String'>
    readonly unitId: FieldRef<"UnitResource", 'String'>
    readonly roomId: FieldRef<"UnitResource", 'String'>
    readonly resourceType: FieldRef<"UnitResource", 'UnitResourceType'>
    readonly code: FieldRef<"UnitResource", 'String'>
    readonly name: FieldRef<"UnitResource", 'String'>
    readonly state: FieldRef<"UnitResource", 'UnitResourceState'>
    readonly isActive: FieldRef<"UnitResource", 'Boolean'>
    readonly isSchedulable: FieldRef<"UnitResource", 'Boolean'>
    readonly createdAt: FieldRef<"UnitResource", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitResource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitResource findUnique
   */
  export type UnitResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    /**
     * Filter, which UnitResource to fetch.
     */
    where: UnitResourceWhereUniqueInput
  }

  /**
   * UnitResource findUniqueOrThrow
   */
  export type UnitResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    /**
     * Filter, which UnitResource to fetch.
     */
    where: UnitResourceWhereUniqueInput
  }

  /**
   * UnitResource findFirst
   */
  export type UnitResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    /**
     * Filter, which UnitResource to fetch.
     */
    where?: UnitResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitResources to fetch.
     */
    orderBy?: UnitResourceOrderByWithRelationInput | UnitResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitResources.
     */
    cursor?: UnitResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitResources.
     */
    distinct?: UnitResourceScalarFieldEnum | UnitResourceScalarFieldEnum[]
  }

  /**
   * UnitResource findFirstOrThrow
   */
  export type UnitResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    /**
     * Filter, which UnitResource to fetch.
     */
    where?: UnitResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitResources to fetch.
     */
    orderBy?: UnitResourceOrderByWithRelationInput | UnitResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitResources.
     */
    cursor?: UnitResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitResources.
     */
    distinct?: UnitResourceScalarFieldEnum | UnitResourceScalarFieldEnum[]
  }

  /**
   * UnitResource findMany
   */
  export type UnitResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    /**
     * Filter, which UnitResources to fetch.
     */
    where?: UnitResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitResources to fetch.
     */
    orderBy?: UnitResourceOrderByWithRelationInput | UnitResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitResources.
     */
    cursor?: UnitResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitResources.
     */
    skip?: number
    distinct?: UnitResourceScalarFieldEnum | UnitResourceScalarFieldEnum[]
  }

  /**
   * UnitResource create
   */
  export type UnitResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitResource.
     */
    data: XOR<UnitResourceCreateInput, UnitResourceUncheckedCreateInput>
  }

  /**
   * UnitResource createMany
   */
  export type UnitResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitResources.
     */
    data: UnitResourceCreateManyInput | UnitResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitResource createManyAndReturn
   */
  export type UnitResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UnitResources.
     */
    data: UnitResourceCreateManyInput | UnitResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitResource update
   */
  export type UnitResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitResource.
     */
    data: XOR<UnitResourceUpdateInput, UnitResourceUncheckedUpdateInput>
    /**
     * Choose, which UnitResource to update.
     */
    where: UnitResourceWhereUniqueInput
  }

  /**
   * UnitResource updateMany
   */
  export type UnitResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitResources.
     */
    data: XOR<UnitResourceUpdateManyMutationInput, UnitResourceUncheckedUpdateManyInput>
    /**
     * Filter which UnitResources to update
     */
    where?: UnitResourceWhereInput
  }

  /**
   * UnitResource upsert
   */
  export type UnitResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitResource to update in case it exists.
     */
    where: UnitResourceWhereUniqueInput
    /**
     * In case the UnitResource found by the `where` argument doesn't exist, create a new UnitResource with this data.
     */
    create: XOR<UnitResourceCreateInput, UnitResourceUncheckedCreateInput>
    /**
     * In case the UnitResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitResourceUpdateInput, UnitResourceUncheckedUpdateInput>
  }

  /**
   * UnitResource delete
   */
  export type UnitResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
    /**
     * Filter which UnitResource to delete.
     */
    where: UnitResourceWhereUniqueInput
  }

  /**
   * UnitResource deleteMany
   */
  export type UnitResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitResources to delete
     */
    where?: UnitResourceWhereInput
  }

  /**
   * UnitResource.room
   */
  export type UnitResource$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    where?: UnitRoomWhereInput
  }

  /**
   * UnitResource.bookings
   */
  export type UnitResource$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    where?: ProcedureBookingWhereInput
    orderBy?: ProcedureBookingOrderByWithRelationInput | ProcedureBookingOrderByWithRelationInput[]
    cursor?: ProcedureBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcedureBookingScalarFieldEnum | ProcedureBookingScalarFieldEnum[]
  }

  /**
   * UnitResource without action
   */
  export type UnitResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitResource
     */
    select?: UnitResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitResourceInclude<ExtArgs> | null
  }


  /**
   * Model EquipmentAsset
   */

  export type AggregateEquipmentAsset = {
    _count: EquipmentAssetCountAggregateOutputType | null
    _avg: EquipmentAssetAvgAggregateOutputType | null
    _sum: EquipmentAssetSumAggregateOutputType | null
    _min: EquipmentAssetMinAggregateOutputType | null
    _max: EquipmentAssetMaxAggregateOutputType | null
  }

  export type EquipmentAssetAvgAggregateOutputType = {
    pmFrequencyDays: number | null
  }

  export type EquipmentAssetSumAggregateOutputType = {
    pmFrequencyDays: number | null
  }

  export type EquipmentAssetMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    category: $Enums.EquipmentComplianceCategory | null
    make: string | null
    model: string | null
    serial: string | null
    ownerDepartmentId: string | null
    unitId: string | null
    roomId: string | null
    locationNodeId: string | null
    operationalStatus: $Enums.EquipmentOperationalStatus | null
    amcVendor: string | null
    amcValidFrom: Date | null
    amcValidTo: Date | null
    warrantyValidTo: Date | null
    pmFrequencyDays: number | null
    nextPmDueAt: Date | null
    aerbLicenseNo: string | null
    aerbValidTo: Date | null
    pcpndtRegNo: string | null
    pcpndtValidTo: Date | null
    isSchedulable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentAssetMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    category: $Enums.EquipmentComplianceCategory | null
    make: string | null
    model: string | null
    serial: string | null
    ownerDepartmentId: string | null
    unitId: string | null
    roomId: string | null
    locationNodeId: string | null
    operationalStatus: $Enums.EquipmentOperationalStatus | null
    amcVendor: string | null
    amcValidFrom: Date | null
    amcValidTo: Date | null
    warrantyValidTo: Date | null
    pmFrequencyDays: number | null
    nextPmDueAt: Date | null
    aerbLicenseNo: string | null
    aerbValidTo: Date | null
    pcpndtRegNo: string | null
    pcpndtValidTo: Date | null
    isSchedulable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentAssetCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    category: number
    make: number
    model: number
    serial: number
    ownerDepartmentId: number
    unitId: number
    roomId: number
    locationNodeId: number
    operationalStatus: number
    amcVendor: number
    amcValidFrom: number
    amcValidTo: number
    warrantyValidTo: number
    pmFrequencyDays: number
    nextPmDueAt: number
    aerbLicenseNo: number
    aerbValidTo: number
    pcpndtRegNo: number
    pcpndtValidTo: number
    isSchedulable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentAssetAvgAggregateInputType = {
    pmFrequencyDays?: true
  }

  export type EquipmentAssetSumAggregateInputType = {
    pmFrequencyDays?: true
  }

  export type EquipmentAssetMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    make?: true
    model?: true
    serial?: true
    ownerDepartmentId?: true
    unitId?: true
    roomId?: true
    locationNodeId?: true
    operationalStatus?: true
    amcVendor?: true
    amcValidFrom?: true
    amcValidTo?: true
    warrantyValidTo?: true
    pmFrequencyDays?: true
    nextPmDueAt?: true
    aerbLicenseNo?: true
    aerbValidTo?: true
    pcpndtRegNo?: true
    pcpndtValidTo?: true
    isSchedulable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentAssetMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    make?: true
    model?: true
    serial?: true
    ownerDepartmentId?: true
    unitId?: true
    roomId?: true
    locationNodeId?: true
    operationalStatus?: true
    amcVendor?: true
    amcValidFrom?: true
    amcValidTo?: true
    warrantyValidTo?: true
    pmFrequencyDays?: true
    nextPmDueAt?: true
    aerbLicenseNo?: true
    aerbValidTo?: true
    pcpndtRegNo?: true
    pcpndtValidTo?: true
    isSchedulable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentAssetCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    make?: true
    model?: true
    serial?: true
    ownerDepartmentId?: true
    unitId?: true
    roomId?: true
    locationNodeId?: true
    operationalStatus?: true
    amcVendor?: true
    amcValidFrom?: true
    amcValidTo?: true
    warrantyValidTo?: true
    pmFrequencyDays?: true
    nextPmDueAt?: true
    aerbLicenseNo?: true
    aerbValidTo?: true
    pcpndtRegNo?: true
    pcpndtValidTo?: true
    isSchedulable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentAsset to aggregate.
     */
    where?: EquipmentAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentAssets to fetch.
     */
    orderBy?: EquipmentAssetOrderByWithRelationInput | EquipmentAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentAssets
    **/
    _count?: true | EquipmentAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentAssetMaxAggregateInputType
  }

  export type GetEquipmentAssetAggregateType<T extends EquipmentAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentAsset[P]>
      : GetScalarType<T[P], AggregateEquipmentAsset[P]>
  }




  export type EquipmentAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentAssetWhereInput
    orderBy?: EquipmentAssetOrderByWithAggregationInput | EquipmentAssetOrderByWithAggregationInput[]
    by: EquipmentAssetScalarFieldEnum[] | EquipmentAssetScalarFieldEnum
    having?: EquipmentAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentAssetCountAggregateInputType | true
    _avg?: EquipmentAssetAvgAggregateInputType
    _sum?: EquipmentAssetSumAggregateInputType
    _min?: EquipmentAssetMinAggregateInputType
    _max?: EquipmentAssetMaxAggregateInputType
  }

  export type EquipmentAssetGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    category: $Enums.EquipmentComplianceCategory
    make: string | null
    model: string | null
    serial: string | null
    ownerDepartmentId: string | null
    unitId: string | null
    roomId: string | null
    locationNodeId: string | null
    operationalStatus: $Enums.EquipmentOperationalStatus
    amcVendor: string | null
    amcValidFrom: Date | null
    amcValidTo: Date | null
    warrantyValidTo: Date | null
    pmFrequencyDays: number | null
    nextPmDueAt: Date | null
    aerbLicenseNo: string | null
    aerbValidTo: Date | null
    pcpndtRegNo: string | null
    pcpndtValidTo: Date | null
    isSchedulable: boolean
    createdAt: Date
    updatedAt: Date
    _count: EquipmentAssetCountAggregateOutputType | null
    _avg: EquipmentAssetAvgAggregateOutputType | null
    _sum: EquipmentAssetSumAggregateOutputType | null
    _min: EquipmentAssetMinAggregateOutputType | null
    _max: EquipmentAssetMaxAggregateOutputType | null
  }

  type GetEquipmentAssetGroupByPayload<T extends EquipmentAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentAssetGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentAssetGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    make?: boolean
    model?: boolean
    serial?: boolean
    ownerDepartmentId?: boolean
    unitId?: boolean
    roomId?: boolean
    locationNodeId?: boolean
    operationalStatus?: boolean
    amcVendor?: boolean
    amcValidFrom?: boolean
    amcValidTo?: boolean
    warrantyValidTo?: boolean
    pmFrequencyDays?: boolean
    nextPmDueAt?: boolean
    aerbLicenseNo?: boolean
    aerbValidTo?: boolean
    pcpndtRegNo?: boolean
    pcpndtValidTo?: boolean
    isSchedulable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ownerDepartment?: boolean | EquipmentAsset$ownerDepartmentArgs<ExtArgs>
    unit?: boolean | EquipmentAsset$unitArgs<ExtArgs>
    room?: boolean | EquipmentAsset$roomArgs<ExtArgs>
    locationNode?: boolean | EquipmentAsset$locationNodeArgs<ExtArgs>
    downtimeTickets?: boolean | EquipmentAsset$downtimeTicketsArgs<ExtArgs>
    _count?: boolean | EquipmentAssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentAsset"]>

  export type EquipmentAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    make?: boolean
    model?: boolean
    serial?: boolean
    ownerDepartmentId?: boolean
    unitId?: boolean
    roomId?: boolean
    locationNodeId?: boolean
    operationalStatus?: boolean
    amcVendor?: boolean
    amcValidFrom?: boolean
    amcValidTo?: boolean
    warrantyValidTo?: boolean
    pmFrequencyDays?: boolean
    nextPmDueAt?: boolean
    aerbLicenseNo?: boolean
    aerbValidTo?: boolean
    pcpndtRegNo?: boolean
    pcpndtValidTo?: boolean
    isSchedulable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ownerDepartment?: boolean | EquipmentAsset$ownerDepartmentArgs<ExtArgs>
    unit?: boolean | EquipmentAsset$unitArgs<ExtArgs>
    room?: boolean | EquipmentAsset$roomArgs<ExtArgs>
    locationNode?: boolean | EquipmentAsset$locationNodeArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentAsset"]>

  export type EquipmentAssetSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    make?: boolean
    model?: boolean
    serial?: boolean
    ownerDepartmentId?: boolean
    unitId?: boolean
    roomId?: boolean
    locationNodeId?: boolean
    operationalStatus?: boolean
    amcVendor?: boolean
    amcValidFrom?: boolean
    amcValidTo?: boolean
    warrantyValidTo?: boolean
    pmFrequencyDays?: boolean
    nextPmDueAt?: boolean
    aerbLicenseNo?: boolean
    aerbValidTo?: boolean
    pcpndtRegNo?: boolean
    pcpndtValidTo?: boolean
    isSchedulable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ownerDepartment?: boolean | EquipmentAsset$ownerDepartmentArgs<ExtArgs>
    unit?: boolean | EquipmentAsset$unitArgs<ExtArgs>
    room?: boolean | EquipmentAsset$roomArgs<ExtArgs>
    locationNode?: boolean | EquipmentAsset$locationNodeArgs<ExtArgs>
    downtimeTickets?: boolean | EquipmentAsset$downtimeTicketsArgs<ExtArgs>
    _count?: boolean | EquipmentAssetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentAssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ownerDepartment?: boolean | EquipmentAsset$ownerDepartmentArgs<ExtArgs>
    unit?: boolean | EquipmentAsset$unitArgs<ExtArgs>
    room?: boolean | EquipmentAsset$roomArgs<ExtArgs>
    locationNode?: boolean | EquipmentAsset$locationNodeArgs<ExtArgs>
  }

  export type $EquipmentAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentAsset"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      ownerDepartment: Prisma.$DepartmentPayload<ExtArgs> | null
      unit: Prisma.$UnitPayload<ExtArgs> | null
      room: Prisma.$UnitRoomPayload<ExtArgs> | null
      locationNode: Prisma.$LocationNodePayload<ExtArgs> | null
      downtimeTickets: Prisma.$DowntimeTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      category: $Enums.EquipmentComplianceCategory
      make: string | null
      model: string | null
      serial: string | null
      ownerDepartmentId: string | null
      unitId: string | null
      roomId: string | null
      locationNodeId: string | null
      operationalStatus: $Enums.EquipmentOperationalStatus
      amcVendor: string | null
      amcValidFrom: Date | null
      amcValidTo: Date | null
      warrantyValidTo: Date | null
      pmFrequencyDays: number | null
      nextPmDueAt: Date | null
      aerbLicenseNo: string | null
      aerbValidTo: Date | null
      pcpndtRegNo: string | null
      pcpndtValidTo: Date | null
      isSchedulable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipmentAsset"]>
    composites: {}
  }

  type EquipmentAssetGetPayload<S extends boolean | null | undefined | EquipmentAssetDefaultArgs> = $Result.GetResult<Prisma.$EquipmentAssetPayload, S>

  type EquipmentAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EquipmentAssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EquipmentAssetCountAggregateInputType | true
    }

  export interface EquipmentAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentAsset'], meta: { name: 'EquipmentAsset' } }
    /**
     * Find zero or one EquipmentAsset that matches the filter.
     * @param {EquipmentAssetFindUniqueArgs} args - Arguments to find a EquipmentAsset
     * @example
     * // Get one EquipmentAsset
     * const equipmentAsset = await prisma.equipmentAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentAssetFindUniqueArgs>(args: SelectSubset<T, EquipmentAssetFindUniqueArgs<ExtArgs>>): Prisma__EquipmentAssetClient<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EquipmentAsset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EquipmentAssetFindUniqueOrThrowArgs} args - Arguments to find a EquipmentAsset
     * @example
     * // Get one EquipmentAsset
     * const equipmentAsset = await prisma.equipmentAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentAssetClient<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EquipmentAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssetFindFirstArgs} args - Arguments to find a EquipmentAsset
     * @example
     * // Get one EquipmentAsset
     * const equipmentAsset = await prisma.equipmentAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentAssetFindFirstArgs>(args?: SelectSubset<T, EquipmentAssetFindFirstArgs<ExtArgs>>): Prisma__EquipmentAssetClient<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EquipmentAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssetFindFirstOrThrowArgs} args - Arguments to find a EquipmentAsset
     * @example
     * // Get one EquipmentAsset
     * const equipmentAsset = await prisma.equipmentAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentAssetClient<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EquipmentAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentAssets
     * const equipmentAssets = await prisma.equipmentAsset.findMany()
     * 
     * // Get first 10 EquipmentAssets
     * const equipmentAssets = await prisma.equipmentAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentAssetWithIdOnly = await prisma.equipmentAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentAssetFindManyArgs>(args?: SelectSubset<T, EquipmentAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EquipmentAsset.
     * @param {EquipmentAssetCreateArgs} args - Arguments to create a EquipmentAsset.
     * @example
     * // Create one EquipmentAsset
     * const EquipmentAsset = await prisma.equipmentAsset.create({
     *   data: {
     *     // ... data to create a EquipmentAsset
     *   }
     * })
     * 
     */
    create<T extends EquipmentAssetCreateArgs>(args: SelectSubset<T, EquipmentAssetCreateArgs<ExtArgs>>): Prisma__EquipmentAssetClient<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EquipmentAssets.
     * @param {EquipmentAssetCreateManyArgs} args - Arguments to create many EquipmentAssets.
     * @example
     * // Create many EquipmentAssets
     * const equipmentAsset = await prisma.equipmentAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentAssetCreateManyArgs>(args?: SelectSubset<T, EquipmentAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipmentAssets and returns the data saved in the database.
     * @param {EquipmentAssetCreateManyAndReturnArgs} args - Arguments to create many EquipmentAssets.
     * @example
     * // Create many EquipmentAssets
     * const equipmentAsset = await prisma.equipmentAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipmentAssets and only return the `id`
     * const equipmentAssetWithIdOnly = await prisma.equipmentAsset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EquipmentAsset.
     * @param {EquipmentAssetDeleteArgs} args - Arguments to delete one EquipmentAsset.
     * @example
     * // Delete one EquipmentAsset
     * const EquipmentAsset = await prisma.equipmentAsset.delete({
     *   where: {
     *     // ... filter to delete one EquipmentAsset
     *   }
     * })
     * 
     */
    delete<T extends EquipmentAssetDeleteArgs>(args: SelectSubset<T, EquipmentAssetDeleteArgs<ExtArgs>>): Prisma__EquipmentAssetClient<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EquipmentAsset.
     * @param {EquipmentAssetUpdateArgs} args - Arguments to update one EquipmentAsset.
     * @example
     * // Update one EquipmentAsset
     * const equipmentAsset = await prisma.equipmentAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentAssetUpdateArgs>(args: SelectSubset<T, EquipmentAssetUpdateArgs<ExtArgs>>): Prisma__EquipmentAssetClient<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EquipmentAssets.
     * @param {EquipmentAssetDeleteManyArgs} args - Arguments to filter EquipmentAssets to delete.
     * @example
     * // Delete a few EquipmentAssets
     * const { count } = await prisma.equipmentAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentAssetDeleteManyArgs>(args?: SelectSubset<T, EquipmentAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentAssets
     * const equipmentAsset = await prisma.equipmentAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentAssetUpdateManyArgs>(args: SelectSubset<T, EquipmentAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EquipmentAsset.
     * @param {EquipmentAssetUpsertArgs} args - Arguments to update or create a EquipmentAsset.
     * @example
     * // Update or create a EquipmentAsset
     * const equipmentAsset = await prisma.equipmentAsset.upsert({
     *   create: {
     *     // ... data to create a EquipmentAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentAsset we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentAssetUpsertArgs>(args: SelectSubset<T, EquipmentAssetUpsertArgs<ExtArgs>>): Prisma__EquipmentAssetClient<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EquipmentAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssetCountArgs} args - Arguments to filter EquipmentAssets to count.
     * @example
     * // Count the number of EquipmentAssets
     * const count = await prisma.equipmentAsset.count({
     *   where: {
     *     // ... the filter for the EquipmentAssets we want to count
     *   }
     * })
    **/
    count<T extends EquipmentAssetCountArgs>(
      args?: Subset<T, EquipmentAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAssetAggregateArgs>(args: Subset<T, EquipmentAssetAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAssetAggregateType<T>>

    /**
     * Group by EquipmentAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentAssetGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentAsset model
   */
  readonly fields: EquipmentAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ownerDepartment<T extends EquipmentAsset$ownerDepartmentArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentAsset$ownerDepartmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    unit<T extends EquipmentAsset$unitArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentAsset$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    room<T extends EquipmentAsset$roomArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentAsset$roomArgs<ExtArgs>>): Prisma__UnitRoomClient<$Result.GetResult<Prisma.$UnitRoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    locationNode<T extends EquipmentAsset$locationNodeArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentAsset$locationNodeArgs<ExtArgs>>): Prisma__LocationNodeClient<$Result.GetResult<Prisma.$LocationNodePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    downtimeTickets<T extends EquipmentAsset$downtimeTicketsArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentAsset$downtimeTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DowntimeTicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentAsset model
   */ 
  interface EquipmentAssetFieldRefs {
    readonly id: FieldRef<"EquipmentAsset", 'String'>
    readonly branchId: FieldRef<"EquipmentAsset", 'String'>
    readonly code: FieldRef<"EquipmentAsset", 'String'>
    readonly name: FieldRef<"EquipmentAsset", 'String'>
    readonly category: FieldRef<"EquipmentAsset", 'EquipmentComplianceCategory'>
    readonly make: FieldRef<"EquipmentAsset", 'String'>
    readonly model: FieldRef<"EquipmentAsset", 'String'>
    readonly serial: FieldRef<"EquipmentAsset", 'String'>
    readonly ownerDepartmentId: FieldRef<"EquipmentAsset", 'String'>
    readonly unitId: FieldRef<"EquipmentAsset", 'String'>
    readonly roomId: FieldRef<"EquipmentAsset", 'String'>
    readonly locationNodeId: FieldRef<"EquipmentAsset", 'String'>
    readonly operationalStatus: FieldRef<"EquipmentAsset", 'EquipmentOperationalStatus'>
    readonly amcVendor: FieldRef<"EquipmentAsset", 'String'>
    readonly amcValidFrom: FieldRef<"EquipmentAsset", 'DateTime'>
    readonly amcValidTo: FieldRef<"EquipmentAsset", 'DateTime'>
    readonly warrantyValidTo: FieldRef<"EquipmentAsset", 'DateTime'>
    readonly pmFrequencyDays: FieldRef<"EquipmentAsset", 'Int'>
    readonly nextPmDueAt: FieldRef<"EquipmentAsset", 'DateTime'>
    readonly aerbLicenseNo: FieldRef<"EquipmentAsset", 'String'>
    readonly aerbValidTo: FieldRef<"EquipmentAsset", 'DateTime'>
    readonly pcpndtRegNo: FieldRef<"EquipmentAsset", 'String'>
    readonly pcpndtValidTo: FieldRef<"EquipmentAsset", 'DateTime'>
    readonly isSchedulable: FieldRef<"EquipmentAsset", 'Boolean'>
    readonly createdAt: FieldRef<"EquipmentAsset", 'DateTime'>
    readonly updatedAt: FieldRef<"EquipmentAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentAsset findUnique
   */
  export type EquipmentAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentAsset to fetch.
     */
    where: EquipmentAssetWhereUniqueInput
  }

  /**
   * EquipmentAsset findUniqueOrThrow
   */
  export type EquipmentAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentAsset to fetch.
     */
    where: EquipmentAssetWhereUniqueInput
  }

  /**
   * EquipmentAsset findFirst
   */
  export type EquipmentAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentAsset to fetch.
     */
    where?: EquipmentAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentAssets to fetch.
     */
    orderBy?: EquipmentAssetOrderByWithRelationInput | EquipmentAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentAssets.
     */
    cursor?: EquipmentAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentAssets.
     */
    distinct?: EquipmentAssetScalarFieldEnum | EquipmentAssetScalarFieldEnum[]
  }

  /**
   * EquipmentAsset findFirstOrThrow
   */
  export type EquipmentAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentAsset to fetch.
     */
    where?: EquipmentAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentAssets to fetch.
     */
    orderBy?: EquipmentAssetOrderByWithRelationInput | EquipmentAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentAssets.
     */
    cursor?: EquipmentAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentAssets.
     */
    distinct?: EquipmentAssetScalarFieldEnum | EquipmentAssetScalarFieldEnum[]
  }

  /**
   * EquipmentAsset findMany
   */
  export type EquipmentAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentAssets to fetch.
     */
    where?: EquipmentAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentAssets to fetch.
     */
    orderBy?: EquipmentAssetOrderByWithRelationInput | EquipmentAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentAssets.
     */
    cursor?: EquipmentAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentAssets.
     */
    skip?: number
    distinct?: EquipmentAssetScalarFieldEnum | EquipmentAssetScalarFieldEnum[]
  }

  /**
   * EquipmentAsset create
   */
  export type EquipmentAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentAsset.
     */
    data: XOR<EquipmentAssetCreateInput, EquipmentAssetUncheckedCreateInput>
  }

  /**
   * EquipmentAsset createMany
   */
  export type EquipmentAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentAssets.
     */
    data: EquipmentAssetCreateManyInput | EquipmentAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentAsset createManyAndReturn
   */
  export type EquipmentAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EquipmentAssets.
     */
    data: EquipmentAssetCreateManyInput | EquipmentAssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipmentAsset update
   */
  export type EquipmentAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentAsset.
     */
    data: XOR<EquipmentAssetUpdateInput, EquipmentAssetUncheckedUpdateInput>
    /**
     * Choose, which EquipmentAsset to update.
     */
    where: EquipmentAssetWhereUniqueInput
  }

  /**
   * EquipmentAsset updateMany
   */
  export type EquipmentAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentAssets.
     */
    data: XOR<EquipmentAssetUpdateManyMutationInput, EquipmentAssetUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentAssets to update
     */
    where?: EquipmentAssetWhereInput
  }

  /**
   * EquipmentAsset upsert
   */
  export type EquipmentAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentAsset to update in case it exists.
     */
    where: EquipmentAssetWhereUniqueInput
    /**
     * In case the EquipmentAsset found by the `where` argument doesn't exist, create a new EquipmentAsset with this data.
     */
    create: XOR<EquipmentAssetCreateInput, EquipmentAssetUncheckedCreateInput>
    /**
     * In case the EquipmentAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentAssetUpdateInput, EquipmentAssetUncheckedUpdateInput>
  }

  /**
   * EquipmentAsset delete
   */
  export type EquipmentAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
    /**
     * Filter which EquipmentAsset to delete.
     */
    where: EquipmentAssetWhereUniqueInput
  }

  /**
   * EquipmentAsset deleteMany
   */
  export type EquipmentAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentAssets to delete
     */
    where?: EquipmentAssetWhereInput
  }

  /**
   * EquipmentAsset.ownerDepartment
   */
  export type EquipmentAsset$ownerDepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * EquipmentAsset.unit
   */
  export type EquipmentAsset$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * EquipmentAsset.room
   */
  export type EquipmentAsset$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitRoom
     */
    select?: UnitRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitRoomInclude<ExtArgs> | null
    where?: UnitRoomWhereInput
  }

  /**
   * EquipmentAsset.locationNode
   */
  export type EquipmentAsset$locationNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationNode
     */
    select?: LocationNodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationNodeInclude<ExtArgs> | null
    where?: LocationNodeWhereInput
  }

  /**
   * EquipmentAsset.downtimeTickets
   */
  export type EquipmentAsset$downtimeTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketInclude<ExtArgs> | null
    where?: DowntimeTicketWhereInput
    orderBy?: DowntimeTicketOrderByWithRelationInput | DowntimeTicketOrderByWithRelationInput[]
    cursor?: DowntimeTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DowntimeTicketScalarFieldEnum | DowntimeTicketScalarFieldEnum[]
  }

  /**
   * EquipmentAsset without action
   */
  export type EquipmentAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentAsset
     */
    select?: EquipmentAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentAssetInclude<ExtArgs> | null
  }


  /**
   * Model DowntimeTicket
   */

  export type AggregateDowntimeTicket = {
    _count: DowntimeTicketCountAggregateOutputType | null
    _min: DowntimeTicketMinAggregateOutputType | null
    _max: DowntimeTicketMaxAggregateOutputType | null
  }

  export type DowntimeTicketMinAggregateOutputType = {
    id: string | null
    assetId: string | null
    status: $Enums.DowntimeStatus | null
    reason: string | null
    notes: string | null
    openedAt: Date | null
    closedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DowntimeTicketMaxAggregateOutputType = {
    id: string | null
    assetId: string | null
    status: $Enums.DowntimeStatus | null
    reason: string | null
    notes: string | null
    openedAt: Date | null
    closedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DowntimeTicketCountAggregateOutputType = {
    id: number
    assetId: number
    status: number
    reason: number
    notes: number
    openedAt: number
    closedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DowntimeTicketMinAggregateInputType = {
    id?: true
    assetId?: true
    status?: true
    reason?: true
    notes?: true
    openedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DowntimeTicketMaxAggregateInputType = {
    id?: true
    assetId?: true
    status?: true
    reason?: true
    notes?: true
    openedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DowntimeTicketCountAggregateInputType = {
    id?: true
    assetId?: true
    status?: true
    reason?: true
    notes?: true
    openedAt?: true
    closedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DowntimeTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DowntimeTicket to aggregate.
     */
    where?: DowntimeTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DowntimeTickets to fetch.
     */
    orderBy?: DowntimeTicketOrderByWithRelationInput | DowntimeTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DowntimeTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DowntimeTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DowntimeTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DowntimeTickets
    **/
    _count?: true | DowntimeTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DowntimeTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DowntimeTicketMaxAggregateInputType
  }

  export type GetDowntimeTicketAggregateType<T extends DowntimeTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateDowntimeTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDowntimeTicket[P]>
      : GetScalarType<T[P], AggregateDowntimeTicket[P]>
  }




  export type DowntimeTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DowntimeTicketWhereInput
    orderBy?: DowntimeTicketOrderByWithAggregationInput | DowntimeTicketOrderByWithAggregationInput[]
    by: DowntimeTicketScalarFieldEnum[] | DowntimeTicketScalarFieldEnum
    having?: DowntimeTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DowntimeTicketCountAggregateInputType | true
    _min?: DowntimeTicketMinAggregateInputType
    _max?: DowntimeTicketMaxAggregateInputType
  }

  export type DowntimeTicketGroupByOutputType = {
    id: string
    assetId: string
    status: $Enums.DowntimeStatus
    reason: string
    notes: string | null
    openedAt: Date
    closedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DowntimeTicketCountAggregateOutputType | null
    _min: DowntimeTicketMinAggregateOutputType | null
    _max: DowntimeTicketMaxAggregateOutputType | null
  }

  type GetDowntimeTicketGroupByPayload<T extends DowntimeTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DowntimeTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DowntimeTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DowntimeTicketGroupByOutputType[P]>
            : GetScalarType<T[P], DowntimeTicketGroupByOutputType[P]>
        }
      >
    >


  export type DowntimeTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    openedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    asset?: boolean | EquipmentAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["downtimeTicket"]>

  export type DowntimeTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    openedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    asset?: boolean | EquipmentAssetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["downtimeTicket"]>

  export type DowntimeTicketSelectScalar = {
    id?: boolean
    assetId?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    openedAt?: boolean
    closedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DowntimeTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | EquipmentAssetDefaultArgs<ExtArgs>
  }
  export type DowntimeTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | EquipmentAssetDefaultArgs<ExtArgs>
  }

  export type $DowntimeTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DowntimeTicket"
    objects: {
      asset: Prisma.$EquipmentAssetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assetId: string
      status: $Enums.DowntimeStatus
      reason: string
      notes: string | null
      openedAt: Date
      closedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["downtimeTicket"]>
    composites: {}
  }

  type DowntimeTicketGetPayload<S extends boolean | null | undefined | DowntimeTicketDefaultArgs> = $Result.GetResult<Prisma.$DowntimeTicketPayload, S>

  type DowntimeTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DowntimeTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DowntimeTicketCountAggregateInputType | true
    }

  export interface DowntimeTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DowntimeTicket'], meta: { name: 'DowntimeTicket' } }
    /**
     * Find zero or one DowntimeTicket that matches the filter.
     * @param {DowntimeTicketFindUniqueArgs} args - Arguments to find a DowntimeTicket
     * @example
     * // Get one DowntimeTicket
     * const downtimeTicket = await prisma.downtimeTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DowntimeTicketFindUniqueArgs>(args: SelectSubset<T, DowntimeTicketFindUniqueArgs<ExtArgs>>): Prisma__DowntimeTicketClient<$Result.GetResult<Prisma.$DowntimeTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DowntimeTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DowntimeTicketFindUniqueOrThrowArgs} args - Arguments to find a DowntimeTicket
     * @example
     * // Get one DowntimeTicket
     * const downtimeTicket = await prisma.downtimeTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DowntimeTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, DowntimeTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DowntimeTicketClient<$Result.GetResult<Prisma.$DowntimeTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DowntimeTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeTicketFindFirstArgs} args - Arguments to find a DowntimeTicket
     * @example
     * // Get one DowntimeTicket
     * const downtimeTicket = await prisma.downtimeTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DowntimeTicketFindFirstArgs>(args?: SelectSubset<T, DowntimeTicketFindFirstArgs<ExtArgs>>): Prisma__DowntimeTicketClient<$Result.GetResult<Prisma.$DowntimeTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DowntimeTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeTicketFindFirstOrThrowArgs} args - Arguments to find a DowntimeTicket
     * @example
     * // Get one DowntimeTicket
     * const downtimeTicket = await prisma.downtimeTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DowntimeTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, DowntimeTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__DowntimeTicketClient<$Result.GetResult<Prisma.$DowntimeTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DowntimeTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DowntimeTickets
     * const downtimeTickets = await prisma.downtimeTicket.findMany()
     * 
     * // Get first 10 DowntimeTickets
     * const downtimeTickets = await prisma.downtimeTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const downtimeTicketWithIdOnly = await prisma.downtimeTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DowntimeTicketFindManyArgs>(args?: SelectSubset<T, DowntimeTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DowntimeTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DowntimeTicket.
     * @param {DowntimeTicketCreateArgs} args - Arguments to create a DowntimeTicket.
     * @example
     * // Create one DowntimeTicket
     * const DowntimeTicket = await prisma.downtimeTicket.create({
     *   data: {
     *     // ... data to create a DowntimeTicket
     *   }
     * })
     * 
     */
    create<T extends DowntimeTicketCreateArgs>(args: SelectSubset<T, DowntimeTicketCreateArgs<ExtArgs>>): Prisma__DowntimeTicketClient<$Result.GetResult<Prisma.$DowntimeTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DowntimeTickets.
     * @param {DowntimeTicketCreateManyArgs} args - Arguments to create many DowntimeTickets.
     * @example
     * // Create many DowntimeTickets
     * const downtimeTicket = await prisma.downtimeTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DowntimeTicketCreateManyArgs>(args?: SelectSubset<T, DowntimeTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DowntimeTickets and returns the data saved in the database.
     * @param {DowntimeTicketCreateManyAndReturnArgs} args - Arguments to create many DowntimeTickets.
     * @example
     * // Create many DowntimeTickets
     * const downtimeTicket = await prisma.downtimeTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DowntimeTickets and only return the `id`
     * const downtimeTicketWithIdOnly = await prisma.downtimeTicket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DowntimeTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, DowntimeTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DowntimeTicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DowntimeTicket.
     * @param {DowntimeTicketDeleteArgs} args - Arguments to delete one DowntimeTicket.
     * @example
     * // Delete one DowntimeTicket
     * const DowntimeTicket = await prisma.downtimeTicket.delete({
     *   where: {
     *     // ... filter to delete one DowntimeTicket
     *   }
     * })
     * 
     */
    delete<T extends DowntimeTicketDeleteArgs>(args: SelectSubset<T, DowntimeTicketDeleteArgs<ExtArgs>>): Prisma__DowntimeTicketClient<$Result.GetResult<Prisma.$DowntimeTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DowntimeTicket.
     * @param {DowntimeTicketUpdateArgs} args - Arguments to update one DowntimeTicket.
     * @example
     * // Update one DowntimeTicket
     * const downtimeTicket = await prisma.downtimeTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DowntimeTicketUpdateArgs>(args: SelectSubset<T, DowntimeTicketUpdateArgs<ExtArgs>>): Prisma__DowntimeTicketClient<$Result.GetResult<Prisma.$DowntimeTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DowntimeTickets.
     * @param {DowntimeTicketDeleteManyArgs} args - Arguments to filter DowntimeTickets to delete.
     * @example
     * // Delete a few DowntimeTickets
     * const { count } = await prisma.downtimeTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DowntimeTicketDeleteManyArgs>(args?: SelectSubset<T, DowntimeTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DowntimeTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DowntimeTickets
     * const downtimeTicket = await prisma.downtimeTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DowntimeTicketUpdateManyArgs>(args: SelectSubset<T, DowntimeTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DowntimeTicket.
     * @param {DowntimeTicketUpsertArgs} args - Arguments to update or create a DowntimeTicket.
     * @example
     * // Update or create a DowntimeTicket
     * const downtimeTicket = await prisma.downtimeTicket.upsert({
     *   create: {
     *     // ... data to create a DowntimeTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DowntimeTicket we want to update
     *   }
     * })
     */
    upsert<T extends DowntimeTicketUpsertArgs>(args: SelectSubset<T, DowntimeTicketUpsertArgs<ExtArgs>>): Prisma__DowntimeTicketClient<$Result.GetResult<Prisma.$DowntimeTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DowntimeTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeTicketCountArgs} args - Arguments to filter DowntimeTickets to count.
     * @example
     * // Count the number of DowntimeTickets
     * const count = await prisma.downtimeTicket.count({
     *   where: {
     *     // ... the filter for the DowntimeTickets we want to count
     *   }
     * })
    **/
    count<T extends DowntimeTicketCountArgs>(
      args?: Subset<T, DowntimeTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DowntimeTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DowntimeTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DowntimeTicketAggregateArgs>(args: Subset<T, DowntimeTicketAggregateArgs>): Prisma.PrismaPromise<GetDowntimeTicketAggregateType<T>>

    /**
     * Group by DowntimeTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DowntimeTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DowntimeTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DowntimeTicketGroupByArgs['orderBy'] }
        : { orderBy?: DowntimeTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DowntimeTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDowntimeTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DowntimeTicket model
   */
  readonly fields: DowntimeTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DowntimeTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DowntimeTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends EquipmentAssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentAssetDefaultArgs<ExtArgs>>): Prisma__EquipmentAssetClient<$Result.GetResult<Prisma.$EquipmentAssetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DowntimeTicket model
   */ 
  interface DowntimeTicketFieldRefs {
    readonly id: FieldRef<"DowntimeTicket", 'String'>
    readonly assetId: FieldRef<"DowntimeTicket", 'String'>
    readonly status: FieldRef<"DowntimeTicket", 'DowntimeStatus'>
    readonly reason: FieldRef<"DowntimeTicket", 'String'>
    readonly notes: FieldRef<"DowntimeTicket", 'String'>
    readonly openedAt: FieldRef<"DowntimeTicket", 'DateTime'>
    readonly closedAt: FieldRef<"DowntimeTicket", 'DateTime'>
    readonly createdAt: FieldRef<"DowntimeTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"DowntimeTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DowntimeTicket findUnique
   */
  export type DowntimeTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketInclude<ExtArgs> | null
    /**
     * Filter, which DowntimeTicket to fetch.
     */
    where: DowntimeTicketWhereUniqueInput
  }

  /**
   * DowntimeTicket findUniqueOrThrow
   */
  export type DowntimeTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketInclude<ExtArgs> | null
    /**
     * Filter, which DowntimeTicket to fetch.
     */
    where: DowntimeTicketWhereUniqueInput
  }

  /**
   * DowntimeTicket findFirst
   */
  export type DowntimeTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketInclude<ExtArgs> | null
    /**
     * Filter, which DowntimeTicket to fetch.
     */
    where?: DowntimeTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DowntimeTickets to fetch.
     */
    orderBy?: DowntimeTicketOrderByWithRelationInput | DowntimeTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DowntimeTickets.
     */
    cursor?: DowntimeTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DowntimeTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DowntimeTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DowntimeTickets.
     */
    distinct?: DowntimeTicketScalarFieldEnum | DowntimeTicketScalarFieldEnum[]
  }

  /**
   * DowntimeTicket findFirstOrThrow
   */
  export type DowntimeTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketInclude<ExtArgs> | null
    /**
     * Filter, which DowntimeTicket to fetch.
     */
    where?: DowntimeTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DowntimeTickets to fetch.
     */
    orderBy?: DowntimeTicketOrderByWithRelationInput | DowntimeTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DowntimeTickets.
     */
    cursor?: DowntimeTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DowntimeTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DowntimeTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DowntimeTickets.
     */
    distinct?: DowntimeTicketScalarFieldEnum | DowntimeTicketScalarFieldEnum[]
  }

  /**
   * DowntimeTicket findMany
   */
  export type DowntimeTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketInclude<ExtArgs> | null
    /**
     * Filter, which DowntimeTickets to fetch.
     */
    where?: DowntimeTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DowntimeTickets to fetch.
     */
    orderBy?: DowntimeTicketOrderByWithRelationInput | DowntimeTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DowntimeTickets.
     */
    cursor?: DowntimeTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DowntimeTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DowntimeTickets.
     */
    skip?: number
    distinct?: DowntimeTicketScalarFieldEnum | DowntimeTicketScalarFieldEnum[]
  }

  /**
   * DowntimeTicket create
   */
  export type DowntimeTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a DowntimeTicket.
     */
    data: XOR<DowntimeTicketCreateInput, DowntimeTicketUncheckedCreateInput>
  }

  /**
   * DowntimeTicket createMany
   */
  export type DowntimeTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DowntimeTickets.
     */
    data: DowntimeTicketCreateManyInput | DowntimeTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DowntimeTicket createManyAndReturn
   */
  export type DowntimeTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DowntimeTickets.
     */
    data: DowntimeTicketCreateManyInput | DowntimeTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DowntimeTicket update
   */
  export type DowntimeTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a DowntimeTicket.
     */
    data: XOR<DowntimeTicketUpdateInput, DowntimeTicketUncheckedUpdateInput>
    /**
     * Choose, which DowntimeTicket to update.
     */
    where: DowntimeTicketWhereUniqueInput
  }

  /**
   * DowntimeTicket updateMany
   */
  export type DowntimeTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DowntimeTickets.
     */
    data: XOR<DowntimeTicketUpdateManyMutationInput, DowntimeTicketUncheckedUpdateManyInput>
    /**
     * Filter which DowntimeTickets to update
     */
    where?: DowntimeTicketWhereInput
  }

  /**
   * DowntimeTicket upsert
   */
  export type DowntimeTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the DowntimeTicket to update in case it exists.
     */
    where: DowntimeTicketWhereUniqueInput
    /**
     * In case the DowntimeTicket found by the `where` argument doesn't exist, create a new DowntimeTicket with this data.
     */
    create: XOR<DowntimeTicketCreateInput, DowntimeTicketUncheckedCreateInput>
    /**
     * In case the DowntimeTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DowntimeTicketUpdateInput, DowntimeTicketUncheckedUpdateInput>
  }

  /**
   * DowntimeTicket delete
   */
  export type DowntimeTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketInclude<ExtArgs> | null
    /**
     * Filter which DowntimeTicket to delete.
     */
    where: DowntimeTicketWhereUniqueInput
  }

  /**
   * DowntimeTicket deleteMany
   */
  export type DowntimeTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DowntimeTickets to delete
     */
    where?: DowntimeTicketWhereInput
  }

  /**
   * DowntimeTicket without action
   */
  export type DowntimeTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DowntimeTicket
     */
    select?: DowntimeTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DowntimeTicketInclude<ExtArgs> | null
  }


  /**
   * Model ChargeMasterItem
   */

  export type AggregateChargeMasterItem = {
    _count: ChargeMasterItemCountAggregateOutputType | null
    _min: ChargeMasterItemMinAggregateOutputType | null
    _max: ChargeMasterItemMaxAggregateOutputType | null
  }

  export type ChargeMasterItemMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    category: string | null
    unit: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChargeMasterItemMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    category: string | null
    unit: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChargeMasterItemCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    category: number
    unit: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChargeMasterItemMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChargeMasterItemMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChargeMasterItemCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChargeMasterItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChargeMasterItem to aggregate.
     */
    where?: ChargeMasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChargeMasterItems to fetch.
     */
    orderBy?: ChargeMasterItemOrderByWithRelationInput | ChargeMasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChargeMasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChargeMasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChargeMasterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChargeMasterItems
    **/
    _count?: true | ChargeMasterItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChargeMasterItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChargeMasterItemMaxAggregateInputType
  }

  export type GetChargeMasterItemAggregateType<T extends ChargeMasterItemAggregateArgs> = {
        [P in keyof T & keyof AggregateChargeMasterItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChargeMasterItem[P]>
      : GetScalarType<T[P], AggregateChargeMasterItem[P]>
  }




  export type ChargeMasterItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChargeMasterItemWhereInput
    orderBy?: ChargeMasterItemOrderByWithAggregationInput | ChargeMasterItemOrderByWithAggregationInput[]
    by: ChargeMasterItemScalarFieldEnum[] | ChargeMasterItemScalarFieldEnum
    having?: ChargeMasterItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChargeMasterItemCountAggregateInputType | true
    _min?: ChargeMasterItemMinAggregateInputType
    _max?: ChargeMasterItemMaxAggregateInputType
  }

  export type ChargeMasterItemGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    category: string | null
    unit: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ChargeMasterItemCountAggregateOutputType | null
    _min: ChargeMasterItemMinAggregateOutputType | null
    _max: ChargeMasterItemMaxAggregateOutputType | null
  }

  type GetChargeMasterItemGroupByPayload<T extends ChargeMasterItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChargeMasterItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChargeMasterItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChargeMasterItemGroupByOutputType[P]>
            : GetScalarType<T[P], ChargeMasterItemGroupByOutputType[P]>
        }
      >
    >


  export type ChargeMasterItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    mappings?: boolean | ChargeMasterItem$mappingsArgs<ExtArgs>
    _count?: boolean | ChargeMasterItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chargeMasterItem"]>

  export type ChargeMasterItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chargeMasterItem"]>

  export type ChargeMasterItemSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChargeMasterItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    mappings?: boolean | ChargeMasterItem$mappingsArgs<ExtArgs>
    _count?: boolean | ChargeMasterItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChargeMasterItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ChargeMasterItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChargeMasterItem"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      mappings: Prisma.$ServiceChargeMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      category: string | null
      unit: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chargeMasterItem"]>
    composites: {}
  }

  type ChargeMasterItemGetPayload<S extends boolean | null | undefined | ChargeMasterItemDefaultArgs> = $Result.GetResult<Prisma.$ChargeMasterItemPayload, S>

  type ChargeMasterItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChargeMasterItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChargeMasterItemCountAggregateInputType | true
    }

  export interface ChargeMasterItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChargeMasterItem'], meta: { name: 'ChargeMasterItem' } }
    /**
     * Find zero or one ChargeMasterItem that matches the filter.
     * @param {ChargeMasterItemFindUniqueArgs} args - Arguments to find a ChargeMasterItem
     * @example
     * // Get one ChargeMasterItem
     * const chargeMasterItem = await prisma.chargeMasterItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChargeMasterItemFindUniqueArgs>(args: SelectSubset<T, ChargeMasterItemFindUniqueArgs<ExtArgs>>): Prisma__ChargeMasterItemClient<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChargeMasterItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChargeMasterItemFindUniqueOrThrowArgs} args - Arguments to find a ChargeMasterItem
     * @example
     * // Get one ChargeMasterItem
     * const chargeMasterItem = await prisma.chargeMasterItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChargeMasterItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ChargeMasterItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChargeMasterItemClient<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChargeMasterItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeMasterItemFindFirstArgs} args - Arguments to find a ChargeMasterItem
     * @example
     * // Get one ChargeMasterItem
     * const chargeMasterItem = await prisma.chargeMasterItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChargeMasterItemFindFirstArgs>(args?: SelectSubset<T, ChargeMasterItemFindFirstArgs<ExtArgs>>): Prisma__ChargeMasterItemClient<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChargeMasterItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeMasterItemFindFirstOrThrowArgs} args - Arguments to find a ChargeMasterItem
     * @example
     * // Get one ChargeMasterItem
     * const chargeMasterItem = await prisma.chargeMasterItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChargeMasterItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ChargeMasterItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChargeMasterItemClient<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChargeMasterItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeMasterItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChargeMasterItems
     * const chargeMasterItems = await prisma.chargeMasterItem.findMany()
     * 
     * // Get first 10 ChargeMasterItems
     * const chargeMasterItems = await prisma.chargeMasterItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chargeMasterItemWithIdOnly = await prisma.chargeMasterItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChargeMasterItemFindManyArgs>(args?: SelectSubset<T, ChargeMasterItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChargeMasterItem.
     * @param {ChargeMasterItemCreateArgs} args - Arguments to create a ChargeMasterItem.
     * @example
     * // Create one ChargeMasterItem
     * const ChargeMasterItem = await prisma.chargeMasterItem.create({
     *   data: {
     *     // ... data to create a ChargeMasterItem
     *   }
     * })
     * 
     */
    create<T extends ChargeMasterItemCreateArgs>(args: SelectSubset<T, ChargeMasterItemCreateArgs<ExtArgs>>): Prisma__ChargeMasterItemClient<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChargeMasterItems.
     * @param {ChargeMasterItemCreateManyArgs} args - Arguments to create many ChargeMasterItems.
     * @example
     * // Create many ChargeMasterItems
     * const chargeMasterItem = await prisma.chargeMasterItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChargeMasterItemCreateManyArgs>(args?: SelectSubset<T, ChargeMasterItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChargeMasterItems and returns the data saved in the database.
     * @param {ChargeMasterItemCreateManyAndReturnArgs} args - Arguments to create many ChargeMasterItems.
     * @example
     * // Create many ChargeMasterItems
     * const chargeMasterItem = await prisma.chargeMasterItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChargeMasterItems and only return the `id`
     * const chargeMasterItemWithIdOnly = await prisma.chargeMasterItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChargeMasterItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ChargeMasterItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChargeMasterItem.
     * @param {ChargeMasterItemDeleteArgs} args - Arguments to delete one ChargeMasterItem.
     * @example
     * // Delete one ChargeMasterItem
     * const ChargeMasterItem = await prisma.chargeMasterItem.delete({
     *   where: {
     *     // ... filter to delete one ChargeMasterItem
     *   }
     * })
     * 
     */
    delete<T extends ChargeMasterItemDeleteArgs>(args: SelectSubset<T, ChargeMasterItemDeleteArgs<ExtArgs>>): Prisma__ChargeMasterItemClient<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChargeMasterItem.
     * @param {ChargeMasterItemUpdateArgs} args - Arguments to update one ChargeMasterItem.
     * @example
     * // Update one ChargeMasterItem
     * const chargeMasterItem = await prisma.chargeMasterItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChargeMasterItemUpdateArgs>(args: SelectSubset<T, ChargeMasterItemUpdateArgs<ExtArgs>>): Prisma__ChargeMasterItemClient<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChargeMasterItems.
     * @param {ChargeMasterItemDeleteManyArgs} args - Arguments to filter ChargeMasterItems to delete.
     * @example
     * // Delete a few ChargeMasterItems
     * const { count } = await prisma.chargeMasterItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChargeMasterItemDeleteManyArgs>(args?: SelectSubset<T, ChargeMasterItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChargeMasterItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeMasterItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChargeMasterItems
     * const chargeMasterItem = await prisma.chargeMasterItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChargeMasterItemUpdateManyArgs>(args: SelectSubset<T, ChargeMasterItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChargeMasterItem.
     * @param {ChargeMasterItemUpsertArgs} args - Arguments to update or create a ChargeMasterItem.
     * @example
     * // Update or create a ChargeMasterItem
     * const chargeMasterItem = await prisma.chargeMasterItem.upsert({
     *   create: {
     *     // ... data to create a ChargeMasterItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChargeMasterItem we want to update
     *   }
     * })
     */
    upsert<T extends ChargeMasterItemUpsertArgs>(args: SelectSubset<T, ChargeMasterItemUpsertArgs<ExtArgs>>): Prisma__ChargeMasterItemClient<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChargeMasterItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeMasterItemCountArgs} args - Arguments to filter ChargeMasterItems to count.
     * @example
     * // Count the number of ChargeMasterItems
     * const count = await prisma.chargeMasterItem.count({
     *   where: {
     *     // ... the filter for the ChargeMasterItems we want to count
     *   }
     * })
    **/
    count<T extends ChargeMasterItemCountArgs>(
      args?: Subset<T, ChargeMasterItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChargeMasterItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChargeMasterItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeMasterItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChargeMasterItemAggregateArgs>(args: Subset<T, ChargeMasterItemAggregateArgs>): Prisma.PrismaPromise<GetChargeMasterItemAggregateType<T>>

    /**
     * Group by ChargeMasterItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeMasterItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChargeMasterItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChargeMasterItemGroupByArgs['orderBy'] }
        : { orderBy?: ChargeMasterItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChargeMasterItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChargeMasterItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChargeMasterItem model
   */
  readonly fields: ChargeMasterItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChargeMasterItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChargeMasterItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mappings<T extends ChargeMasterItem$mappingsArgs<ExtArgs> = {}>(args?: Subset<T, ChargeMasterItem$mappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChargeMasterItem model
   */ 
  interface ChargeMasterItemFieldRefs {
    readonly id: FieldRef<"ChargeMasterItem", 'String'>
    readonly branchId: FieldRef<"ChargeMasterItem", 'String'>
    readonly code: FieldRef<"ChargeMasterItem", 'String'>
    readonly name: FieldRef<"ChargeMasterItem", 'String'>
    readonly category: FieldRef<"ChargeMasterItem", 'String'>
    readonly unit: FieldRef<"ChargeMasterItem", 'String'>
    readonly isActive: FieldRef<"ChargeMasterItem", 'Boolean'>
    readonly createdAt: FieldRef<"ChargeMasterItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ChargeMasterItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChargeMasterItem findUnique
   */
  export type ChargeMasterItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemInclude<ExtArgs> | null
    /**
     * Filter, which ChargeMasterItem to fetch.
     */
    where: ChargeMasterItemWhereUniqueInput
  }

  /**
   * ChargeMasterItem findUniqueOrThrow
   */
  export type ChargeMasterItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemInclude<ExtArgs> | null
    /**
     * Filter, which ChargeMasterItem to fetch.
     */
    where: ChargeMasterItemWhereUniqueInput
  }

  /**
   * ChargeMasterItem findFirst
   */
  export type ChargeMasterItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemInclude<ExtArgs> | null
    /**
     * Filter, which ChargeMasterItem to fetch.
     */
    where?: ChargeMasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChargeMasterItems to fetch.
     */
    orderBy?: ChargeMasterItemOrderByWithRelationInput | ChargeMasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChargeMasterItems.
     */
    cursor?: ChargeMasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChargeMasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChargeMasterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChargeMasterItems.
     */
    distinct?: ChargeMasterItemScalarFieldEnum | ChargeMasterItemScalarFieldEnum[]
  }

  /**
   * ChargeMasterItem findFirstOrThrow
   */
  export type ChargeMasterItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemInclude<ExtArgs> | null
    /**
     * Filter, which ChargeMasterItem to fetch.
     */
    where?: ChargeMasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChargeMasterItems to fetch.
     */
    orderBy?: ChargeMasterItemOrderByWithRelationInput | ChargeMasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChargeMasterItems.
     */
    cursor?: ChargeMasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChargeMasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChargeMasterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChargeMasterItems.
     */
    distinct?: ChargeMasterItemScalarFieldEnum | ChargeMasterItemScalarFieldEnum[]
  }

  /**
   * ChargeMasterItem findMany
   */
  export type ChargeMasterItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemInclude<ExtArgs> | null
    /**
     * Filter, which ChargeMasterItems to fetch.
     */
    where?: ChargeMasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChargeMasterItems to fetch.
     */
    orderBy?: ChargeMasterItemOrderByWithRelationInput | ChargeMasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChargeMasterItems.
     */
    cursor?: ChargeMasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChargeMasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChargeMasterItems.
     */
    skip?: number
    distinct?: ChargeMasterItemScalarFieldEnum | ChargeMasterItemScalarFieldEnum[]
  }

  /**
   * ChargeMasterItem create
   */
  export type ChargeMasterItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ChargeMasterItem.
     */
    data: XOR<ChargeMasterItemCreateInput, ChargeMasterItemUncheckedCreateInput>
  }

  /**
   * ChargeMasterItem createMany
   */
  export type ChargeMasterItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChargeMasterItems.
     */
    data: ChargeMasterItemCreateManyInput | ChargeMasterItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChargeMasterItem createManyAndReturn
   */
  export type ChargeMasterItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChargeMasterItems.
     */
    data: ChargeMasterItemCreateManyInput | ChargeMasterItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChargeMasterItem update
   */
  export type ChargeMasterItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ChargeMasterItem.
     */
    data: XOR<ChargeMasterItemUpdateInput, ChargeMasterItemUncheckedUpdateInput>
    /**
     * Choose, which ChargeMasterItem to update.
     */
    where: ChargeMasterItemWhereUniqueInput
  }

  /**
   * ChargeMasterItem updateMany
   */
  export type ChargeMasterItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChargeMasterItems.
     */
    data: XOR<ChargeMasterItemUpdateManyMutationInput, ChargeMasterItemUncheckedUpdateManyInput>
    /**
     * Filter which ChargeMasterItems to update
     */
    where?: ChargeMasterItemWhereInput
  }

  /**
   * ChargeMasterItem upsert
   */
  export type ChargeMasterItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ChargeMasterItem to update in case it exists.
     */
    where: ChargeMasterItemWhereUniqueInput
    /**
     * In case the ChargeMasterItem found by the `where` argument doesn't exist, create a new ChargeMasterItem with this data.
     */
    create: XOR<ChargeMasterItemCreateInput, ChargeMasterItemUncheckedCreateInput>
    /**
     * In case the ChargeMasterItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChargeMasterItemUpdateInput, ChargeMasterItemUncheckedUpdateInput>
  }

  /**
   * ChargeMasterItem delete
   */
  export type ChargeMasterItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemInclude<ExtArgs> | null
    /**
     * Filter which ChargeMasterItem to delete.
     */
    where: ChargeMasterItemWhereUniqueInput
  }

  /**
   * ChargeMasterItem deleteMany
   */
  export type ChargeMasterItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChargeMasterItems to delete
     */
    where?: ChargeMasterItemWhereInput
  }

  /**
   * ChargeMasterItem.mappings
   */
  export type ChargeMasterItem$mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    where?: ServiceChargeMappingWhereInput
    orderBy?: ServiceChargeMappingOrderByWithRelationInput | ServiceChargeMappingOrderByWithRelationInput[]
    cursor?: ServiceChargeMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceChargeMappingScalarFieldEnum | ServiceChargeMappingScalarFieldEnum[]
  }

  /**
   * ChargeMasterItem without action
   */
  export type ChargeMasterItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChargeMasterItem
     */
    select?: ChargeMasterItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeMasterItemInclude<ExtArgs> | null
  }


  /**
   * Model ServiceItem
   */

  export type AggregateServiceItem = {
    _count: ServiceItemCountAggregateOutputType | null
    _min: ServiceItemMinAggregateOutputType | null
    _max: ServiceItemMaxAggregateOutputType | null
  }

  export type ServiceItemMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    category: string | null
    unit: string | null
    isOrderable: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceItemMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    category: string | null
    unit: string | null
    isOrderable: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceItemCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    category: number
    unit: number
    isOrderable: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceItemMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    isOrderable?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceItemMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    isOrderable?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceItemCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    isOrderable?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceItem to aggregate.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceItems
    **/
    _count?: true | ServiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceItemMaxAggregateInputType
  }

  export type GetServiceItemAggregateType<T extends ServiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceItem[P]>
      : GetScalarType<T[P], AggregateServiceItem[P]>
  }




  export type ServiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceItemWhereInput
    orderBy?: ServiceItemOrderByWithAggregationInput | ServiceItemOrderByWithAggregationInput[]
    by: ServiceItemScalarFieldEnum[] | ServiceItemScalarFieldEnum
    having?: ServiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceItemCountAggregateInputType | true
    _min?: ServiceItemMinAggregateInputType
    _max?: ServiceItemMaxAggregateInputType
  }

  export type ServiceItemGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    category: string
    unit: string | null
    isOrderable: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceItemCountAggregateOutputType | null
    _min: ServiceItemMinAggregateOutputType | null
    _max: ServiceItemMaxAggregateOutputType | null
  }

  type GetServiceItemGroupByPayload<T extends ServiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceItemGroupByOutputType[P]>
        }
      >
    >


  export type ServiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    mappings?: boolean | ServiceItem$mappingsArgs<ExtArgs>
    fixIts?: boolean | ServiceItem$fixItsArgs<ExtArgs>
    _count?: boolean | ServiceItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceItem"]>

  export type ServiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceItem"]>

  export type ServiceItemSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    mappings?: boolean | ServiceItem$mappingsArgs<ExtArgs>
    fixIts?: boolean | ServiceItem$fixItsArgs<ExtArgs>
    _count?: boolean | ServiceItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $ServiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceItem"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      mappings: Prisma.$ServiceChargeMappingPayload<ExtArgs>[]
      fixIts: Prisma.$FixItTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      category: string
      unit: string | null
      isOrderable: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceItem"]>
    composites: {}
  }

  type ServiceItemGetPayload<S extends boolean | null | undefined | ServiceItemDefaultArgs> = $Result.GetResult<Prisma.$ServiceItemPayload, S>

  type ServiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceItemCountAggregateInputType | true
    }

  export interface ServiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceItem'], meta: { name: 'ServiceItem' } }
    /**
     * Find zero or one ServiceItem that matches the filter.
     * @param {ServiceItemFindUniqueArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceItemFindUniqueArgs>(args: SelectSubset<T, ServiceItemFindUniqueArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceItemFindUniqueOrThrowArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemFindFirstArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceItemFindFirstArgs>(args?: SelectSubset<T, ServiceItemFindFirstArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemFindFirstOrThrowArgs} args - Arguments to find a ServiceItem
     * @example
     * // Get one ServiceItem
     * const serviceItem = await prisma.serviceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceItems
     * const serviceItems = await prisma.serviceItem.findMany()
     * 
     * // Get first 10 ServiceItems
     * const serviceItems = await prisma.serviceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceItemWithIdOnly = await prisma.serviceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceItemFindManyArgs>(args?: SelectSubset<T, ServiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceItem.
     * @param {ServiceItemCreateArgs} args - Arguments to create a ServiceItem.
     * @example
     * // Create one ServiceItem
     * const ServiceItem = await prisma.serviceItem.create({
     *   data: {
     *     // ... data to create a ServiceItem
     *   }
     * })
     * 
     */
    create<T extends ServiceItemCreateArgs>(args: SelectSubset<T, ServiceItemCreateArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceItems.
     * @param {ServiceItemCreateManyArgs} args - Arguments to create many ServiceItems.
     * @example
     * // Create many ServiceItems
     * const serviceItem = await prisma.serviceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceItemCreateManyArgs>(args?: SelectSubset<T, ServiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceItems and returns the data saved in the database.
     * @param {ServiceItemCreateManyAndReturnArgs} args - Arguments to create many ServiceItems.
     * @example
     * // Create many ServiceItems
     * const serviceItem = await prisma.serviceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceItems and only return the `id`
     * const serviceItemWithIdOnly = await prisma.serviceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceItem.
     * @param {ServiceItemDeleteArgs} args - Arguments to delete one ServiceItem.
     * @example
     * // Delete one ServiceItem
     * const ServiceItem = await prisma.serviceItem.delete({
     *   where: {
     *     // ... filter to delete one ServiceItem
     *   }
     * })
     * 
     */
    delete<T extends ServiceItemDeleteArgs>(args: SelectSubset<T, ServiceItemDeleteArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceItem.
     * @param {ServiceItemUpdateArgs} args - Arguments to update one ServiceItem.
     * @example
     * // Update one ServiceItem
     * const serviceItem = await prisma.serviceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceItemUpdateArgs>(args: SelectSubset<T, ServiceItemUpdateArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceItems.
     * @param {ServiceItemDeleteManyArgs} args - Arguments to filter ServiceItems to delete.
     * @example
     * // Delete a few ServiceItems
     * const { count } = await prisma.serviceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceItemDeleteManyArgs>(args?: SelectSubset<T, ServiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceItems
     * const serviceItem = await prisma.serviceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceItemUpdateManyArgs>(args: SelectSubset<T, ServiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceItem.
     * @param {ServiceItemUpsertArgs} args - Arguments to update or create a ServiceItem.
     * @example
     * // Update or create a ServiceItem
     * const serviceItem = await prisma.serviceItem.upsert({
     *   create: {
     *     // ... data to create a ServiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceItem we want to update
     *   }
     * })
     */
    upsert<T extends ServiceItemUpsertArgs>(args: SelectSubset<T, ServiceItemUpsertArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemCountArgs} args - Arguments to filter ServiceItems to count.
     * @example
     * // Count the number of ServiceItems
     * const count = await prisma.serviceItem.count({
     *   where: {
     *     // ... the filter for the ServiceItems we want to count
     *   }
     * })
    **/
    count<T extends ServiceItemCountArgs>(
      args?: Subset<T, ServiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceItemAggregateArgs>(args: Subset<T, ServiceItemAggregateArgs>): Prisma.PrismaPromise<GetServiceItemAggregateType<T>>

    /**
     * Group by ServiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceItemGroupByArgs['orderBy'] }
        : { orderBy?: ServiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceItem model
   */
  readonly fields: ServiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mappings<T extends ServiceItem$mappingsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceItem$mappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "findMany"> | Null>
    fixIts<T extends ServiceItem$fixItsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceItem$fixItsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceItem model
   */ 
  interface ServiceItemFieldRefs {
    readonly id: FieldRef<"ServiceItem", 'String'>
    readonly branchId: FieldRef<"ServiceItem", 'String'>
    readonly code: FieldRef<"ServiceItem", 'String'>
    readonly name: FieldRef<"ServiceItem", 'String'>
    readonly category: FieldRef<"ServiceItem", 'String'>
    readonly unit: FieldRef<"ServiceItem", 'String'>
    readonly isOrderable: FieldRef<"ServiceItem", 'Boolean'>
    readonly isActive: FieldRef<"ServiceItem", 'Boolean'>
    readonly createdAt: FieldRef<"ServiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceItem findUnique
   */
  export type ServiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem findUniqueOrThrow
   */
  export type ServiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem findFirst
   */
  export type ServiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceItems.
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceItems.
     */
    distinct?: ServiceItemScalarFieldEnum | ServiceItemScalarFieldEnum[]
  }

  /**
   * ServiceItem findFirstOrThrow
   */
  export type ServiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItem to fetch.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceItems.
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceItems.
     */
    distinct?: ServiceItemScalarFieldEnum | ServiceItemScalarFieldEnum[]
  }

  /**
   * ServiceItem findMany
   */
  export type ServiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter, which ServiceItems to fetch.
     */
    where?: ServiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceItems to fetch.
     */
    orderBy?: ServiceItemOrderByWithRelationInput | ServiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceItems.
     */
    cursor?: ServiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceItems.
     */
    skip?: number
    distinct?: ServiceItemScalarFieldEnum | ServiceItemScalarFieldEnum[]
  }

  /**
   * ServiceItem create
   */
  export type ServiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceItem.
     */
    data: XOR<ServiceItemCreateInput, ServiceItemUncheckedCreateInput>
  }

  /**
   * ServiceItem createMany
   */
  export type ServiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceItems.
     */
    data: ServiceItemCreateManyInput | ServiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceItem createManyAndReturn
   */
  export type ServiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceItems.
     */
    data: ServiceItemCreateManyInput | ServiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceItem update
   */
  export type ServiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceItem.
     */
    data: XOR<ServiceItemUpdateInput, ServiceItemUncheckedUpdateInput>
    /**
     * Choose, which ServiceItem to update.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem updateMany
   */
  export type ServiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceItems.
     */
    data: XOR<ServiceItemUpdateManyMutationInput, ServiceItemUncheckedUpdateManyInput>
    /**
     * Filter which ServiceItems to update
     */
    where?: ServiceItemWhereInput
  }

  /**
   * ServiceItem upsert
   */
  export type ServiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceItem to update in case it exists.
     */
    where: ServiceItemWhereUniqueInput
    /**
     * In case the ServiceItem found by the `where` argument doesn't exist, create a new ServiceItem with this data.
     */
    create: XOR<ServiceItemCreateInput, ServiceItemUncheckedCreateInput>
    /**
     * In case the ServiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceItemUpdateInput, ServiceItemUncheckedUpdateInput>
  }

  /**
   * ServiceItem delete
   */
  export type ServiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    /**
     * Filter which ServiceItem to delete.
     */
    where: ServiceItemWhereUniqueInput
  }

  /**
   * ServiceItem deleteMany
   */
  export type ServiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceItems to delete
     */
    where?: ServiceItemWhereInput
  }

  /**
   * ServiceItem.mappings
   */
  export type ServiceItem$mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    where?: ServiceChargeMappingWhereInput
    orderBy?: ServiceChargeMappingOrderByWithRelationInput | ServiceChargeMappingOrderByWithRelationInput[]
    cursor?: ServiceChargeMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceChargeMappingScalarFieldEnum | ServiceChargeMappingScalarFieldEnum[]
  }

  /**
   * ServiceItem.fixIts
   */
  export type ServiceItem$fixItsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    where?: FixItTaskWhereInput
    orderBy?: FixItTaskOrderByWithRelationInput | FixItTaskOrderByWithRelationInput[]
    cursor?: FixItTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FixItTaskScalarFieldEnum | FixItTaskScalarFieldEnum[]
  }

  /**
   * ServiceItem without action
   */
  export type ServiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
  }


  /**
   * Model ServiceChargeMapping
   */

  export type AggregateServiceChargeMapping = {
    _count: ServiceChargeMappingCountAggregateOutputType | null
    _avg: ServiceChargeMappingAvgAggregateOutputType | null
    _sum: ServiceChargeMappingSumAggregateOutputType | null
    _min: ServiceChargeMappingMinAggregateOutputType | null
    _max: ServiceChargeMappingMaxAggregateOutputType | null
  }

  export type ServiceChargeMappingAvgAggregateOutputType = {
    version: number | null
  }

  export type ServiceChargeMappingSumAggregateOutputType = {
    version: number | null
  }

  export type ServiceChargeMappingMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    serviceItemId: string | null
    chargeMasterItemId: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceChargeMappingMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    serviceItemId: string | null
    chargeMasterItemId: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceChargeMappingCountAggregateOutputType = {
    id: number
    branchId: number
    serviceItemId: number
    chargeMasterItemId: number
    effectiveFrom: number
    effectiveTo: number
    version: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceChargeMappingAvgAggregateInputType = {
    version?: true
  }

  export type ServiceChargeMappingSumAggregateInputType = {
    version?: true
  }

  export type ServiceChargeMappingMinAggregateInputType = {
    id?: true
    branchId?: true
    serviceItemId?: true
    chargeMasterItemId?: true
    effectiveFrom?: true
    effectiveTo?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceChargeMappingMaxAggregateInputType = {
    id?: true
    branchId?: true
    serviceItemId?: true
    chargeMasterItemId?: true
    effectiveFrom?: true
    effectiveTo?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceChargeMappingCountAggregateInputType = {
    id?: true
    branchId?: true
    serviceItemId?: true
    chargeMasterItemId?: true
    effectiveFrom?: true
    effectiveTo?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceChargeMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceChargeMapping to aggregate.
     */
    where?: ServiceChargeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChargeMappings to fetch.
     */
    orderBy?: ServiceChargeMappingOrderByWithRelationInput | ServiceChargeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceChargeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChargeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChargeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceChargeMappings
    **/
    _count?: true | ServiceChargeMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceChargeMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceChargeMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceChargeMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceChargeMappingMaxAggregateInputType
  }

  export type GetServiceChargeMappingAggregateType<T extends ServiceChargeMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceChargeMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceChargeMapping[P]>
      : GetScalarType<T[P], AggregateServiceChargeMapping[P]>
  }




  export type ServiceChargeMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceChargeMappingWhereInput
    orderBy?: ServiceChargeMappingOrderByWithAggregationInput | ServiceChargeMappingOrderByWithAggregationInput[]
    by: ServiceChargeMappingScalarFieldEnum[] | ServiceChargeMappingScalarFieldEnum
    having?: ServiceChargeMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceChargeMappingCountAggregateInputType | true
    _avg?: ServiceChargeMappingAvgAggregateInputType
    _sum?: ServiceChargeMappingSumAggregateInputType
    _min?: ServiceChargeMappingMinAggregateInputType
    _max?: ServiceChargeMappingMaxAggregateInputType
  }

  export type ServiceChargeMappingGroupByOutputType = {
    id: string
    branchId: string
    serviceItemId: string
    chargeMasterItemId: string
    effectiveFrom: Date
    effectiveTo: Date | null
    version: number
    createdAt: Date
    updatedAt: Date
    _count: ServiceChargeMappingCountAggregateOutputType | null
    _avg: ServiceChargeMappingAvgAggregateOutputType | null
    _sum: ServiceChargeMappingSumAggregateOutputType | null
    _min: ServiceChargeMappingMinAggregateOutputType | null
    _max: ServiceChargeMappingMaxAggregateOutputType | null
  }

  type GetServiceChargeMappingGroupByPayload<T extends ServiceChargeMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceChargeMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceChargeMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceChargeMappingGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceChargeMappingGroupByOutputType[P]>
        }
      >
    >


  export type ServiceChargeMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    serviceItemId?: boolean
    chargeMasterItemId?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    serviceItem?: boolean | ServiceItemDefaultArgs<ExtArgs>
    chargeMasterItem?: boolean | ChargeMasterItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceChargeMapping"]>

  export type ServiceChargeMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    serviceItemId?: boolean
    chargeMasterItemId?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    serviceItem?: boolean | ServiceItemDefaultArgs<ExtArgs>
    chargeMasterItem?: boolean | ChargeMasterItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceChargeMapping"]>

  export type ServiceChargeMappingSelectScalar = {
    id?: boolean
    branchId?: boolean
    serviceItemId?: boolean
    chargeMasterItemId?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceChargeMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    serviceItem?: boolean | ServiceItemDefaultArgs<ExtArgs>
    chargeMasterItem?: boolean | ChargeMasterItemDefaultArgs<ExtArgs>
  }
  export type ServiceChargeMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    serviceItem?: boolean | ServiceItemDefaultArgs<ExtArgs>
    chargeMasterItem?: boolean | ChargeMasterItemDefaultArgs<ExtArgs>
  }

  export type $ServiceChargeMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceChargeMapping"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      serviceItem: Prisma.$ServiceItemPayload<ExtArgs>
      chargeMasterItem: Prisma.$ChargeMasterItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      serviceItemId: string
      chargeMasterItemId: string
      effectiveFrom: Date
      effectiveTo: Date | null
      version: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceChargeMapping"]>
    composites: {}
  }

  type ServiceChargeMappingGetPayload<S extends boolean | null | undefined | ServiceChargeMappingDefaultArgs> = $Result.GetResult<Prisma.$ServiceChargeMappingPayload, S>

  type ServiceChargeMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceChargeMappingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceChargeMappingCountAggregateInputType | true
    }

  export interface ServiceChargeMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceChargeMapping'], meta: { name: 'ServiceChargeMapping' } }
    /**
     * Find zero or one ServiceChargeMapping that matches the filter.
     * @param {ServiceChargeMappingFindUniqueArgs} args - Arguments to find a ServiceChargeMapping
     * @example
     * // Get one ServiceChargeMapping
     * const serviceChargeMapping = await prisma.serviceChargeMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceChargeMappingFindUniqueArgs>(args: SelectSubset<T, ServiceChargeMappingFindUniqueArgs<ExtArgs>>): Prisma__ServiceChargeMappingClient<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceChargeMapping that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceChargeMappingFindUniqueOrThrowArgs} args - Arguments to find a ServiceChargeMapping
     * @example
     * // Get one ServiceChargeMapping
     * const serviceChargeMapping = await prisma.serviceChargeMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceChargeMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceChargeMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceChargeMappingClient<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceChargeMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChargeMappingFindFirstArgs} args - Arguments to find a ServiceChargeMapping
     * @example
     * // Get one ServiceChargeMapping
     * const serviceChargeMapping = await prisma.serviceChargeMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceChargeMappingFindFirstArgs>(args?: SelectSubset<T, ServiceChargeMappingFindFirstArgs<ExtArgs>>): Prisma__ServiceChargeMappingClient<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceChargeMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChargeMappingFindFirstOrThrowArgs} args - Arguments to find a ServiceChargeMapping
     * @example
     * // Get one ServiceChargeMapping
     * const serviceChargeMapping = await prisma.serviceChargeMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceChargeMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceChargeMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceChargeMappingClient<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceChargeMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChargeMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceChargeMappings
     * const serviceChargeMappings = await prisma.serviceChargeMapping.findMany()
     * 
     * // Get first 10 ServiceChargeMappings
     * const serviceChargeMappings = await prisma.serviceChargeMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceChargeMappingWithIdOnly = await prisma.serviceChargeMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceChargeMappingFindManyArgs>(args?: SelectSubset<T, ServiceChargeMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceChargeMapping.
     * @param {ServiceChargeMappingCreateArgs} args - Arguments to create a ServiceChargeMapping.
     * @example
     * // Create one ServiceChargeMapping
     * const ServiceChargeMapping = await prisma.serviceChargeMapping.create({
     *   data: {
     *     // ... data to create a ServiceChargeMapping
     *   }
     * })
     * 
     */
    create<T extends ServiceChargeMappingCreateArgs>(args: SelectSubset<T, ServiceChargeMappingCreateArgs<ExtArgs>>): Prisma__ServiceChargeMappingClient<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceChargeMappings.
     * @param {ServiceChargeMappingCreateManyArgs} args - Arguments to create many ServiceChargeMappings.
     * @example
     * // Create many ServiceChargeMappings
     * const serviceChargeMapping = await prisma.serviceChargeMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceChargeMappingCreateManyArgs>(args?: SelectSubset<T, ServiceChargeMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceChargeMappings and returns the data saved in the database.
     * @param {ServiceChargeMappingCreateManyAndReturnArgs} args - Arguments to create many ServiceChargeMappings.
     * @example
     * // Create many ServiceChargeMappings
     * const serviceChargeMapping = await prisma.serviceChargeMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceChargeMappings and only return the `id`
     * const serviceChargeMappingWithIdOnly = await prisma.serviceChargeMapping.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceChargeMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceChargeMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceChargeMapping.
     * @param {ServiceChargeMappingDeleteArgs} args - Arguments to delete one ServiceChargeMapping.
     * @example
     * // Delete one ServiceChargeMapping
     * const ServiceChargeMapping = await prisma.serviceChargeMapping.delete({
     *   where: {
     *     // ... filter to delete one ServiceChargeMapping
     *   }
     * })
     * 
     */
    delete<T extends ServiceChargeMappingDeleteArgs>(args: SelectSubset<T, ServiceChargeMappingDeleteArgs<ExtArgs>>): Prisma__ServiceChargeMappingClient<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceChargeMapping.
     * @param {ServiceChargeMappingUpdateArgs} args - Arguments to update one ServiceChargeMapping.
     * @example
     * // Update one ServiceChargeMapping
     * const serviceChargeMapping = await prisma.serviceChargeMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceChargeMappingUpdateArgs>(args: SelectSubset<T, ServiceChargeMappingUpdateArgs<ExtArgs>>): Prisma__ServiceChargeMappingClient<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceChargeMappings.
     * @param {ServiceChargeMappingDeleteManyArgs} args - Arguments to filter ServiceChargeMappings to delete.
     * @example
     * // Delete a few ServiceChargeMappings
     * const { count } = await prisma.serviceChargeMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceChargeMappingDeleteManyArgs>(args?: SelectSubset<T, ServiceChargeMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceChargeMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChargeMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceChargeMappings
     * const serviceChargeMapping = await prisma.serviceChargeMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceChargeMappingUpdateManyArgs>(args: SelectSubset<T, ServiceChargeMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceChargeMapping.
     * @param {ServiceChargeMappingUpsertArgs} args - Arguments to update or create a ServiceChargeMapping.
     * @example
     * // Update or create a ServiceChargeMapping
     * const serviceChargeMapping = await prisma.serviceChargeMapping.upsert({
     *   create: {
     *     // ... data to create a ServiceChargeMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceChargeMapping we want to update
     *   }
     * })
     */
    upsert<T extends ServiceChargeMappingUpsertArgs>(args: SelectSubset<T, ServiceChargeMappingUpsertArgs<ExtArgs>>): Prisma__ServiceChargeMappingClient<$Result.GetResult<Prisma.$ServiceChargeMappingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceChargeMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChargeMappingCountArgs} args - Arguments to filter ServiceChargeMappings to count.
     * @example
     * // Count the number of ServiceChargeMappings
     * const count = await prisma.serviceChargeMapping.count({
     *   where: {
     *     // ... the filter for the ServiceChargeMappings we want to count
     *   }
     * })
    **/
    count<T extends ServiceChargeMappingCountArgs>(
      args?: Subset<T, ServiceChargeMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceChargeMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceChargeMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChargeMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceChargeMappingAggregateArgs>(args: Subset<T, ServiceChargeMappingAggregateArgs>): Prisma.PrismaPromise<GetServiceChargeMappingAggregateType<T>>

    /**
     * Group by ServiceChargeMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChargeMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceChargeMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceChargeMappingGroupByArgs['orderBy'] }
        : { orderBy?: ServiceChargeMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceChargeMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceChargeMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceChargeMapping model
   */
  readonly fields: ServiceChargeMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceChargeMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceChargeMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    serviceItem<T extends ServiceItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceItemDefaultArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    chargeMasterItem<T extends ChargeMasterItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChargeMasterItemDefaultArgs<ExtArgs>>): Prisma__ChargeMasterItemClient<$Result.GetResult<Prisma.$ChargeMasterItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceChargeMapping model
   */ 
  interface ServiceChargeMappingFieldRefs {
    readonly id: FieldRef<"ServiceChargeMapping", 'String'>
    readonly branchId: FieldRef<"ServiceChargeMapping", 'String'>
    readonly serviceItemId: FieldRef<"ServiceChargeMapping", 'String'>
    readonly chargeMasterItemId: FieldRef<"ServiceChargeMapping", 'String'>
    readonly effectiveFrom: FieldRef<"ServiceChargeMapping", 'DateTime'>
    readonly effectiveTo: FieldRef<"ServiceChargeMapping", 'DateTime'>
    readonly version: FieldRef<"ServiceChargeMapping", 'Int'>
    readonly createdAt: FieldRef<"ServiceChargeMapping", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceChargeMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceChargeMapping findUnique
   */
  export type ServiceChargeMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChargeMapping to fetch.
     */
    where: ServiceChargeMappingWhereUniqueInput
  }

  /**
   * ServiceChargeMapping findUniqueOrThrow
   */
  export type ServiceChargeMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChargeMapping to fetch.
     */
    where: ServiceChargeMappingWhereUniqueInput
  }

  /**
   * ServiceChargeMapping findFirst
   */
  export type ServiceChargeMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChargeMapping to fetch.
     */
    where?: ServiceChargeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChargeMappings to fetch.
     */
    orderBy?: ServiceChargeMappingOrderByWithRelationInput | ServiceChargeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceChargeMappings.
     */
    cursor?: ServiceChargeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChargeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChargeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceChargeMappings.
     */
    distinct?: ServiceChargeMappingScalarFieldEnum | ServiceChargeMappingScalarFieldEnum[]
  }

  /**
   * ServiceChargeMapping findFirstOrThrow
   */
  export type ServiceChargeMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChargeMapping to fetch.
     */
    where?: ServiceChargeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChargeMappings to fetch.
     */
    orderBy?: ServiceChargeMappingOrderByWithRelationInput | ServiceChargeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceChargeMappings.
     */
    cursor?: ServiceChargeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChargeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChargeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceChargeMappings.
     */
    distinct?: ServiceChargeMappingScalarFieldEnum | ServiceChargeMappingScalarFieldEnum[]
  }

  /**
   * ServiceChargeMapping findMany
   */
  export type ServiceChargeMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChargeMappings to fetch.
     */
    where?: ServiceChargeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChargeMappings to fetch.
     */
    orderBy?: ServiceChargeMappingOrderByWithRelationInput | ServiceChargeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceChargeMappings.
     */
    cursor?: ServiceChargeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChargeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChargeMappings.
     */
    skip?: number
    distinct?: ServiceChargeMappingScalarFieldEnum | ServiceChargeMappingScalarFieldEnum[]
  }

  /**
   * ServiceChargeMapping create
   */
  export type ServiceChargeMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceChargeMapping.
     */
    data: XOR<ServiceChargeMappingCreateInput, ServiceChargeMappingUncheckedCreateInput>
  }

  /**
   * ServiceChargeMapping createMany
   */
  export type ServiceChargeMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceChargeMappings.
     */
    data: ServiceChargeMappingCreateManyInput | ServiceChargeMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceChargeMapping createManyAndReturn
   */
  export type ServiceChargeMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceChargeMappings.
     */
    data: ServiceChargeMappingCreateManyInput | ServiceChargeMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceChargeMapping update
   */
  export type ServiceChargeMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceChargeMapping.
     */
    data: XOR<ServiceChargeMappingUpdateInput, ServiceChargeMappingUncheckedUpdateInput>
    /**
     * Choose, which ServiceChargeMapping to update.
     */
    where: ServiceChargeMappingWhereUniqueInput
  }

  /**
   * ServiceChargeMapping updateMany
   */
  export type ServiceChargeMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceChargeMappings.
     */
    data: XOR<ServiceChargeMappingUpdateManyMutationInput, ServiceChargeMappingUncheckedUpdateManyInput>
    /**
     * Filter which ServiceChargeMappings to update
     */
    where?: ServiceChargeMappingWhereInput
  }

  /**
   * ServiceChargeMapping upsert
   */
  export type ServiceChargeMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceChargeMapping to update in case it exists.
     */
    where: ServiceChargeMappingWhereUniqueInput
    /**
     * In case the ServiceChargeMapping found by the `where` argument doesn't exist, create a new ServiceChargeMapping with this data.
     */
    create: XOR<ServiceChargeMappingCreateInput, ServiceChargeMappingUncheckedCreateInput>
    /**
     * In case the ServiceChargeMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceChargeMappingUpdateInput, ServiceChargeMappingUncheckedUpdateInput>
  }

  /**
   * ServiceChargeMapping delete
   */
  export type ServiceChargeMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
    /**
     * Filter which ServiceChargeMapping to delete.
     */
    where: ServiceChargeMappingWhereUniqueInput
  }

  /**
   * ServiceChargeMapping deleteMany
   */
  export type ServiceChargeMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceChargeMappings to delete
     */
    where?: ServiceChargeMappingWhereInput
  }

  /**
   * ServiceChargeMapping without action
   */
  export type ServiceChargeMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChargeMapping
     */
    select?: ServiceChargeMappingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChargeMappingInclude<ExtArgs> | null
  }


  /**
   * Model FixItTask
   */

  export type AggregateFixItTask = {
    _count: FixItTaskCountAggregateOutputType | null
    _min: FixItTaskMinAggregateOutputType | null
    _max: FixItTaskMaxAggregateOutputType | null
  }

  export type FixItTaskMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    type: $Enums.FixItType | null
    status: $Enums.FixItStatus | null
    title: string | null
    serviceItemId: string | null
    assignedToUserId: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FixItTaskMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    type: $Enums.FixItType | null
    status: $Enums.FixItStatus | null
    title: string | null
    serviceItemId: string | null
    assignedToUserId: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FixItTaskCountAggregateOutputType = {
    id: number
    branchId: number
    type: number
    status: number
    title: number
    details: number
    serviceItemId: number
    assignedToUserId: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FixItTaskMinAggregateInputType = {
    id?: true
    branchId?: true
    type?: true
    status?: true
    title?: true
    serviceItemId?: true
    assignedToUserId?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FixItTaskMaxAggregateInputType = {
    id?: true
    branchId?: true
    type?: true
    status?: true
    title?: true
    serviceItemId?: true
    assignedToUserId?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FixItTaskCountAggregateInputType = {
    id?: true
    branchId?: true
    type?: true
    status?: true
    title?: true
    details?: true
    serviceItemId?: true
    assignedToUserId?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FixItTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FixItTask to aggregate.
     */
    where?: FixItTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixItTasks to fetch.
     */
    orderBy?: FixItTaskOrderByWithRelationInput | FixItTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FixItTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixItTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixItTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FixItTasks
    **/
    _count?: true | FixItTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FixItTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FixItTaskMaxAggregateInputType
  }

  export type GetFixItTaskAggregateType<T extends FixItTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateFixItTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFixItTask[P]>
      : GetScalarType<T[P], AggregateFixItTask[P]>
  }




  export type FixItTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixItTaskWhereInput
    orderBy?: FixItTaskOrderByWithAggregationInput | FixItTaskOrderByWithAggregationInput[]
    by: FixItTaskScalarFieldEnum[] | FixItTaskScalarFieldEnum
    having?: FixItTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FixItTaskCountAggregateInputType | true
    _min?: FixItTaskMinAggregateInputType
    _max?: FixItTaskMaxAggregateInputType
  }

  export type FixItTaskGroupByOutputType = {
    id: string
    branchId: string
    type: $Enums.FixItType
    status: $Enums.FixItStatus
    title: string
    details: JsonValue | null
    serviceItemId: string | null
    assignedToUserId: string | null
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FixItTaskCountAggregateOutputType | null
    _min: FixItTaskMinAggregateOutputType | null
    _max: FixItTaskMaxAggregateOutputType | null
  }

  type GetFixItTaskGroupByPayload<T extends FixItTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FixItTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FixItTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FixItTaskGroupByOutputType[P]>
            : GetScalarType<T[P], FixItTaskGroupByOutputType[P]>
        }
      >
    >


  export type FixItTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    type?: boolean
    status?: boolean
    title?: boolean
    details?: boolean
    serviceItemId?: boolean
    assignedToUserId?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    serviceItem?: boolean | FixItTask$serviceItemArgs<ExtArgs>
    assignedToUser?: boolean | FixItTask$assignedToUserArgs<ExtArgs>
  }, ExtArgs["result"]["fixItTask"]>

  export type FixItTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    type?: boolean
    status?: boolean
    title?: boolean
    details?: boolean
    serviceItemId?: boolean
    assignedToUserId?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    serviceItem?: boolean | FixItTask$serviceItemArgs<ExtArgs>
    assignedToUser?: boolean | FixItTask$assignedToUserArgs<ExtArgs>
  }, ExtArgs["result"]["fixItTask"]>

  export type FixItTaskSelectScalar = {
    id?: boolean
    branchId?: boolean
    type?: boolean
    status?: boolean
    title?: boolean
    details?: boolean
    serviceItemId?: boolean
    assignedToUserId?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FixItTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    serviceItem?: boolean | FixItTask$serviceItemArgs<ExtArgs>
    assignedToUser?: boolean | FixItTask$assignedToUserArgs<ExtArgs>
  }
  export type FixItTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    serviceItem?: boolean | FixItTask$serviceItemArgs<ExtArgs>
    assignedToUser?: boolean | FixItTask$assignedToUserArgs<ExtArgs>
  }

  export type $FixItTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FixItTask"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      serviceItem: Prisma.$ServiceItemPayload<ExtArgs> | null
      assignedToUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      type: $Enums.FixItType
      status: $Enums.FixItStatus
      title: string
      details: Prisma.JsonValue | null
      serviceItemId: string | null
      assignedToUserId: string | null
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fixItTask"]>
    composites: {}
  }

  type FixItTaskGetPayload<S extends boolean | null | undefined | FixItTaskDefaultArgs> = $Result.GetResult<Prisma.$FixItTaskPayload, S>

  type FixItTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FixItTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FixItTaskCountAggregateInputType | true
    }

  export interface FixItTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FixItTask'], meta: { name: 'FixItTask' } }
    /**
     * Find zero or one FixItTask that matches the filter.
     * @param {FixItTaskFindUniqueArgs} args - Arguments to find a FixItTask
     * @example
     * // Get one FixItTask
     * const fixItTask = await prisma.fixItTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FixItTaskFindUniqueArgs>(args: SelectSubset<T, FixItTaskFindUniqueArgs<ExtArgs>>): Prisma__FixItTaskClient<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FixItTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FixItTaskFindUniqueOrThrowArgs} args - Arguments to find a FixItTask
     * @example
     * // Get one FixItTask
     * const fixItTask = await prisma.fixItTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FixItTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, FixItTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FixItTaskClient<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FixItTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixItTaskFindFirstArgs} args - Arguments to find a FixItTask
     * @example
     * // Get one FixItTask
     * const fixItTask = await prisma.fixItTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FixItTaskFindFirstArgs>(args?: SelectSubset<T, FixItTaskFindFirstArgs<ExtArgs>>): Prisma__FixItTaskClient<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FixItTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixItTaskFindFirstOrThrowArgs} args - Arguments to find a FixItTask
     * @example
     * // Get one FixItTask
     * const fixItTask = await prisma.fixItTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FixItTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, FixItTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__FixItTaskClient<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FixItTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixItTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FixItTasks
     * const fixItTasks = await prisma.fixItTask.findMany()
     * 
     * // Get first 10 FixItTasks
     * const fixItTasks = await prisma.fixItTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fixItTaskWithIdOnly = await prisma.fixItTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FixItTaskFindManyArgs>(args?: SelectSubset<T, FixItTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FixItTask.
     * @param {FixItTaskCreateArgs} args - Arguments to create a FixItTask.
     * @example
     * // Create one FixItTask
     * const FixItTask = await prisma.fixItTask.create({
     *   data: {
     *     // ... data to create a FixItTask
     *   }
     * })
     * 
     */
    create<T extends FixItTaskCreateArgs>(args: SelectSubset<T, FixItTaskCreateArgs<ExtArgs>>): Prisma__FixItTaskClient<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FixItTasks.
     * @param {FixItTaskCreateManyArgs} args - Arguments to create many FixItTasks.
     * @example
     * // Create many FixItTasks
     * const fixItTask = await prisma.fixItTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FixItTaskCreateManyArgs>(args?: SelectSubset<T, FixItTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FixItTasks and returns the data saved in the database.
     * @param {FixItTaskCreateManyAndReturnArgs} args - Arguments to create many FixItTasks.
     * @example
     * // Create many FixItTasks
     * const fixItTask = await prisma.fixItTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FixItTasks and only return the `id`
     * const fixItTaskWithIdOnly = await prisma.fixItTask.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FixItTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, FixItTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FixItTask.
     * @param {FixItTaskDeleteArgs} args - Arguments to delete one FixItTask.
     * @example
     * // Delete one FixItTask
     * const FixItTask = await prisma.fixItTask.delete({
     *   where: {
     *     // ... filter to delete one FixItTask
     *   }
     * })
     * 
     */
    delete<T extends FixItTaskDeleteArgs>(args: SelectSubset<T, FixItTaskDeleteArgs<ExtArgs>>): Prisma__FixItTaskClient<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FixItTask.
     * @param {FixItTaskUpdateArgs} args - Arguments to update one FixItTask.
     * @example
     * // Update one FixItTask
     * const fixItTask = await prisma.fixItTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FixItTaskUpdateArgs>(args: SelectSubset<T, FixItTaskUpdateArgs<ExtArgs>>): Prisma__FixItTaskClient<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FixItTasks.
     * @param {FixItTaskDeleteManyArgs} args - Arguments to filter FixItTasks to delete.
     * @example
     * // Delete a few FixItTasks
     * const { count } = await prisma.fixItTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FixItTaskDeleteManyArgs>(args?: SelectSubset<T, FixItTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FixItTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixItTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FixItTasks
     * const fixItTask = await prisma.fixItTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FixItTaskUpdateManyArgs>(args: SelectSubset<T, FixItTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FixItTask.
     * @param {FixItTaskUpsertArgs} args - Arguments to update or create a FixItTask.
     * @example
     * // Update or create a FixItTask
     * const fixItTask = await prisma.fixItTask.upsert({
     *   create: {
     *     // ... data to create a FixItTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FixItTask we want to update
     *   }
     * })
     */
    upsert<T extends FixItTaskUpsertArgs>(args: SelectSubset<T, FixItTaskUpsertArgs<ExtArgs>>): Prisma__FixItTaskClient<$Result.GetResult<Prisma.$FixItTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FixItTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixItTaskCountArgs} args - Arguments to filter FixItTasks to count.
     * @example
     * // Count the number of FixItTasks
     * const count = await prisma.fixItTask.count({
     *   where: {
     *     // ... the filter for the FixItTasks we want to count
     *   }
     * })
    **/
    count<T extends FixItTaskCountArgs>(
      args?: Subset<T, FixItTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FixItTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FixItTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixItTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FixItTaskAggregateArgs>(args: Subset<T, FixItTaskAggregateArgs>): Prisma.PrismaPromise<GetFixItTaskAggregateType<T>>

    /**
     * Group by FixItTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixItTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FixItTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FixItTaskGroupByArgs['orderBy'] }
        : { orderBy?: FixItTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FixItTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFixItTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FixItTask model
   */
  readonly fields: FixItTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FixItTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FixItTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    serviceItem<T extends FixItTask$serviceItemArgs<ExtArgs> = {}>(args?: Subset<T, FixItTask$serviceItemArgs<ExtArgs>>): Prisma__ServiceItemClient<$Result.GetResult<Prisma.$ServiceItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    assignedToUser<T extends FixItTask$assignedToUserArgs<ExtArgs> = {}>(args?: Subset<T, FixItTask$assignedToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FixItTask model
   */ 
  interface FixItTaskFieldRefs {
    readonly id: FieldRef<"FixItTask", 'String'>
    readonly branchId: FieldRef<"FixItTask", 'String'>
    readonly type: FieldRef<"FixItTask", 'FixItType'>
    readonly status: FieldRef<"FixItTask", 'FixItStatus'>
    readonly title: FieldRef<"FixItTask", 'String'>
    readonly details: FieldRef<"FixItTask", 'Json'>
    readonly serviceItemId: FieldRef<"FixItTask", 'String'>
    readonly assignedToUserId: FieldRef<"FixItTask", 'String'>
    readonly resolvedAt: FieldRef<"FixItTask", 'DateTime'>
    readonly createdAt: FieldRef<"FixItTask", 'DateTime'>
    readonly updatedAt: FieldRef<"FixItTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FixItTask findUnique
   */
  export type FixItTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    /**
     * Filter, which FixItTask to fetch.
     */
    where: FixItTaskWhereUniqueInput
  }

  /**
   * FixItTask findUniqueOrThrow
   */
  export type FixItTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    /**
     * Filter, which FixItTask to fetch.
     */
    where: FixItTaskWhereUniqueInput
  }

  /**
   * FixItTask findFirst
   */
  export type FixItTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    /**
     * Filter, which FixItTask to fetch.
     */
    where?: FixItTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixItTasks to fetch.
     */
    orderBy?: FixItTaskOrderByWithRelationInput | FixItTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FixItTasks.
     */
    cursor?: FixItTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixItTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixItTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FixItTasks.
     */
    distinct?: FixItTaskScalarFieldEnum | FixItTaskScalarFieldEnum[]
  }

  /**
   * FixItTask findFirstOrThrow
   */
  export type FixItTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    /**
     * Filter, which FixItTask to fetch.
     */
    where?: FixItTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixItTasks to fetch.
     */
    orderBy?: FixItTaskOrderByWithRelationInput | FixItTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FixItTasks.
     */
    cursor?: FixItTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixItTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixItTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FixItTasks.
     */
    distinct?: FixItTaskScalarFieldEnum | FixItTaskScalarFieldEnum[]
  }

  /**
   * FixItTask findMany
   */
  export type FixItTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    /**
     * Filter, which FixItTasks to fetch.
     */
    where?: FixItTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FixItTasks to fetch.
     */
    orderBy?: FixItTaskOrderByWithRelationInput | FixItTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FixItTasks.
     */
    cursor?: FixItTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FixItTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FixItTasks.
     */
    skip?: number
    distinct?: FixItTaskScalarFieldEnum | FixItTaskScalarFieldEnum[]
  }

  /**
   * FixItTask create
   */
  export type FixItTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a FixItTask.
     */
    data: XOR<FixItTaskCreateInput, FixItTaskUncheckedCreateInput>
  }

  /**
   * FixItTask createMany
   */
  export type FixItTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FixItTasks.
     */
    data: FixItTaskCreateManyInput | FixItTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FixItTask createManyAndReturn
   */
  export type FixItTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FixItTasks.
     */
    data: FixItTaskCreateManyInput | FixItTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FixItTask update
   */
  export type FixItTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a FixItTask.
     */
    data: XOR<FixItTaskUpdateInput, FixItTaskUncheckedUpdateInput>
    /**
     * Choose, which FixItTask to update.
     */
    where: FixItTaskWhereUniqueInput
  }

  /**
   * FixItTask updateMany
   */
  export type FixItTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FixItTasks.
     */
    data: XOR<FixItTaskUpdateManyMutationInput, FixItTaskUncheckedUpdateManyInput>
    /**
     * Filter which FixItTasks to update
     */
    where?: FixItTaskWhereInput
  }

  /**
   * FixItTask upsert
   */
  export type FixItTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the FixItTask to update in case it exists.
     */
    where: FixItTaskWhereUniqueInput
    /**
     * In case the FixItTask found by the `where` argument doesn't exist, create a new FixItTask with this data.
     */
    create: XOR<FixItTaskCreateInput, FixItTaskUncheckedCreateInput>
    /**
     * In case the FixItTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FixItTaskUpdateInput, FixItTaskUncheckedUpdateInput>
  }

  /**
   * FixItTask delete
   */
  export type FixItTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
    /**
     * Filter which FixItTask to delete.
     */
    where: FixItTaskWhereUniqueInput
  }

  /**
   * FixItTask deleteMany
   */
  export type FixItTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FixItTasks to delete
     */
    where?: FixItTaskWhereInput
  }

  /**
   * FixItTask.serviceItem
   */
  export type FixItTask$serviceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceItem
     */
    select?: ServiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceItemInclude<ExtArgs> | null
    where?: ServiceItemWhereInput
  }

  /**
   * FixItTask.assignedToUser
   */
  export type FixItTask$assignedToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FixItTask without action
   */
  export type FixItTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FixItTask
     */
    select?: FixItTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixItTaskInclude<ExtArgs> | null
  }


  /**
   * Model BulkImportJob
   */

  export type AggregateBulkImportJob = {
    _count: BulkImportJobCountAggregateOutputType | null
    _avg: BulkImportJobAvgAggregateOutputType | null
    _sum: BulkImportJobSumAggregateOutputType | null
    _min: BulkImportJobMinAggregateOutputType | null
    _max: BulkImportJobMaxAggregateOutputType | null
  }

  export type BulkImportJobAvgAggregateOutputType = {
    totalRows: number | null
    validRows: number | null
    invalidRows: number | null
  }

  export type BulkImportJobSumAggregateOutputType = {
    totalRows: number | null
    validRows: number | null
    invalidRows: number | null
  }

  export type BulkImportJobMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    entityType: $Enums.ImportEntityType | null
    status: $Enums.ImportJobStatus | null
    fileName: string | null
    totalRows: number | null
    validRows: number | null
    invalidRows: number | null
    createdByUserId: string | null
    committedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BulkImportJobMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    entityType: $Enums.ImportEntityType | null
    status: $Enums.ImportJobStatus | null
    fileName: string | null
    totalRows: number | null
    validRows: number | null
    invalidRows: number | null
    createdByUserId: string | null
    committedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BulkImportJobCountAggregateOutputType = {
    id: number
    branchId: number
    entityType: number
    status: number
    fileName: number
    payload: number
    errors: number
    totalRows: number
    validRows: number
    invalidRows: number
    createdByUserId: number
    committedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BulkImportJobAvgAggregateInputType = {
    totalRows?: true
    validRows?: true
    invalidRows?: true
  }

  export type BulkImportJobSumAggregateInputType = {
    totalRows?: true
    validRows?: true
    invalidRows?: true
  }

  export type BulkImportJobMinAggregateInputType = {
    id?: true
    branchId?: true
    entityType?: true
    status?: true
    fileName?: true
    totalRows?: true
    validRows?: true
    invalidRows?: true
    createdByUserId?: true
    committedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BulkImportJobMaxAggregateInputType = {
    id?: true
    branchId?: true
    entityType?: true
    status?: true
    fileName?: true
    totalRows?: true
    validRows?: true
    invalidRows?: true
    createdByUserId?: true
    committedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BulkImportJobCountAggregateInputType = {
    id?: true
    branchId?: true
    entityType?: true
    status?: true
    fileName?: true
    payload?: true
    errors?: true
    totalRows?: true
    validRows?: true
    invalidRows?: true
    createdByUserId?: true
    committedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BulkImportJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulkImportJob to aggregate.
     */
    where?: BulkImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkImportJobs to fetch.
     */
    orderBy?: BulkImportJobOrderByWithRelationInput | BulkImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BulkImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BulkImportJobs
    **/
    _count?: true | BulkImportJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BulkImportJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BulkImportJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BulkImportJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BulkImportJobMaxAggregateInputType
  }

  export type GetBulkImportJobAggregateType<T extends BulkImportJobAggregateArgs> = {
        [P in keyof T & keyof AggregateBulkImportJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBulkImportJob[P]>
      : GetScalarType<T[P], AggregateBulkImportJob[P]>
  }




  export type BulkImportJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulkImportJobWhereInput
    orderBy?: BulkImportJobOrderByWithAggregationInput | BulkImportJobOrderByWithAggregationInput[]
    by: BulkImportJobScalarFieldEnum[] | BulkImportJobScalarFieldEnum
    having?: BulkImportJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BulkImportJobCountAggregateInputType | true
    _avg?: BulkImportJobAvgAggregateInputType
    _sum?: BulkImportJobSumAggregateInputType
    _min?: BulkImportJobMinAggregateInputType
    _max?: BulkImportJobMaxAggregateInputType
  }

  export type BulkImportJobGroupByOutputType = {
    id: string
    branchId: string
    entityType: $Enums.ImportEntityType
    status: $Enums.ImportJobStatus
    fileName: string | null
    payload: JsonValue | null
    errors: JsonValue | null
    totalRows: number
    validRows: number
    invalidRows: number
    createdByUserId: string | null
    committedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BulkImportJobCountAggregateOutputType | null
    _avg: BulkImportJobAvgAggregateOutputType | null
    _sum: BulkImportJobSumAggregateOutputType | null
    _min: BulkImportJobMinAggregateOutputType | null
    _max: BulkImportJobMaxAggregateOutputType | null
  }

  type GetBulkImportJobGroupByPayload<T extends BulkImportJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BulkImportJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BulkImportJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BulkImportJobGroupByOutputType[P]>
            : GetScalarType<T[P], BulkImportJobGroupByOutputType[P]>
        }
      >
    >


  export type BulkImportJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    entityType?: boolean
    status?: boolean
    fileName?: boolean
    payload?: boolean
    errors?: boolean
    totalRows?: boolean
    validRows?: boolean
    invalidRows?: boolean
    createdByUserId?: boolean
    committedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    createdByUser?: boolean | BulkImportJob$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["bulkImportJob"]>

  export type BulkImportJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    entityType?: boolean
    status?: boolean
    fileName?: boolean
    payload?: boolean
    errors?: boolean
    totalRows?: boolean
    validRows?: boolean
    invalidRows?: boolean
    createdByUserId?: boolean
    committedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    createdByUser?: boolean | BulkImportJob$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["bulkImportJob"]>

  export type BulkImportJobSelectScalar = {
    id?: boolean
    branchId?: boolean
    entityType?: boolean
    status?: boolean
    fileName?: boolean
    payload?: boolean
    errors?: boolean
    totalRows?: boolean
    validRows?: boolean
    invalidRows?: boolean
    createdByUserId?: boolean
    committedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BulkImportJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    createdByUser?: boolean | BulkImportJob$createdByUserArgs<ExtArgs>
  }
  export type BulkImportJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    createdByUser?: boolean | BulkImportJob$createdByUserArgs<ExtArgs>
  }

  export type $BulkImportJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BulkImportJob"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      entityType: $Enums.ImportEntityType
      status: $Enums.ImportJobStatus
      fileName: string | null
      payload: Prisma.JsonValue | null
      errors: Prisma.JsonValue | null
      totalRows: number
      validRows: number
      invalidRows: number
      createdByUserId: string | null
      committedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bulkImportJob"]>
    composites: {}
  }

  type BulkImportJobGetPayload<S extends boolean | null | undefined | BulkImportJobDefaultArgs> = $Result.GetResult<Prisma.$BulkImportJobPayload, S>

  type BulkImportJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BulkImportJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BulkImportJobCountAggregateInputType | true
    }

  export interface BulkImportJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BulkImportJob'], meta: { name: 'BulkImportJob' } }
    /**
     * Find zero or one BulkImportJob that matches the filter.
     * @param {BulkImportJobFindUniqueArgs} args - Arguments to find a BulkImportJob
     * @example
     * // Get one BulkImportJob
     * const bulkImportJob = await prisma.bulkImportJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BulkImportJobFindUniqueArgs>(args: SelectSubset<T, BulkImportJobFindUniqueArgs<ExtArgs>>): Prisma__BulkImportJobClient<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BulkImportJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BulkImportJobFindUniqueOrThrowArgs} args - Arguments to find a BulkImportJob
     * @example
     * // Get one BulkImportJob
     * const bulkImportJob = await prisma.bulkImportJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BulkImportJobFindUniqueOrThrowArgs>(args: SelectSubset<T, BulkImportJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BulkImportJobClient<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BulkImportJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportJobFindFirstArgs} args - Arguments to find a BulkImportJob
     * @example
     * // Get one BulkImportJob
     * const bulkImportJob = await prisma.bulkImportJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BulkImportJobFindFirstArgs>(args?: SelectSubset<T, BulkImportJobFindFirstArgs<ExtArgs>>): Prisma__BulkImportJobClient<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BulkImportJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportJobFindFirstOrThrowArgs} args - Arguments to find a BulkImportJob
     * @example
     * // Get one BulkImportJob
     * const bulkImportJob = await prisma.bulkImportJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BulkImportJobFindFirstOrThrowArgs>(args?: SelectSubset<T, BulkImportJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__BulkImportJobClient<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BulkImportJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BulkImportJobs
     * const bulkImportJobs = await prisma.bulkImportJob.findMany()
     * 
     * // Get first 10 BulkImportJobs
     * const bulkImportJobs = await prisma.bulkImportJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bulkImportJobWithIdOnly = await prisma.bulkImportJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BulkImportJobFindManyArgs>(args?: SelectSubset<T, BulkImportJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BulkImportJob.
     * @param {BulkImportJobCreateArgs} args - Arguments to create a BulkImportJob.
     * @example
     * // Create one BulkImportJob
     * const BulkImportJob = await prisma.bulkImportJob.create({
     *   data: {
     *     // ... data to create a BulkImportJob
     *   }
     * })
     * 
     */
    create<T extends BulkImportJobCreateArgs>(args: SelectSubset<T, BulkImportJobCreateArgs<ExtArgs>>): Prisma__BulkImportJobClient<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BulkImportJobs.
     * @param {BulkImportJobCreateManyArgs} args - Arguments to create many BulkImportJobs.
     * @example
     * // Create many BulkImportJobs
     * const bulkImportJob = await prisma.bulkImportJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BulkImportJobCreateManyArgs>(args?: SelectSubset<T, BulkImportJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BulkImportJobs and returns the data saved in the database.
     * @param {BulkImportJobCreateManyAndReturnArgs} args - Arguments to create many BulkImportJobs.
     * @example
     * // Create many BulkImportJobs
     * const bulkImportJob = await prisma.bulkImportJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BulkImportJobs and only return the `id`
     * const bulkImportJobWithIdOnly = await prisma.bulkImportJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BulkImportJobCreateManyAndReturnArgs>(args?: SelectSubset<T, BulkImportJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BulkImportJob.
     * @param {BulkImportJobDeleteArgs} args - Arguments to delete one BulkImportJob.
     * @example
     * // Delete one BulkImportJob
     * const BulkImportJob = await prisma.bulkImportJob.delete({
     *   where: {
     *     // ... filter to delete one BulkImportJob
     *   }
     * })
     * 
     */
    delete<T extends BulkImportJobDeleteArgs>(args: SelectSubset<T, BulkImportJobDeleteArgs<ExtArgs>>): Prisma__BulkImportJobClient<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BulkImportJob.
     * @param {BulkImportJobUpdateArgs} args - Arguments to update one BulkImportJob.
     * @example
     * // Update one BulkImportJob
     * const bulkImportJob = await prisma.bulkImportJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BulkImportJobUpdateArgs>(args: SelectSubset<T, BulkImportJobUpdateArgs<ExtArgs>>): Prisma__BulkImportJobClient<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BulkImportJobs.
     * @param {BulkImportJobDeleteManyArgs} args - Arguments to filter BulkImportJobs to delete.
     * @example
     * // Delete a few BulkImportJobs
     * const { count } = await prisma.bulkImportJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BulkImportJobDeleteManyArgs>(args?: SelectSubset<T, BulkImportJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BulkImportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BulkImportJobs
     * const bulkImportJob = await prisma.bulkImportJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BulkImportJobUpdateManyArgs>(args: SelectSubset<T, BulkImportJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BulkImportJob.
     * @param {BulkImportJobUpsertArgs} args - Arguments to update or create a BulkImportJob.
     * @example
     * // Update or create a BulkImportJob
     * const bulkImportJob = await prisma.bulkImportJob.upsert({
     *   create: {
     *     // ... data to create a BulkImportJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BulkImportJob we want to update
     *   }
     * })
     */
    upsert<T extends BulkImportJobUpsertArgs>(args: SelectSubset<T, BulkImportJobUpsertArgs<ExtArgs>>): Prisma__BulkImportJobClient<$Result.GetResult<Prisma.$BulkImportJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BulkImportJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportJobCountArgs} args - Arguments to filter BulkImportJobs to count.
     * @example
     * // Count the number of BulkImportJobs
     * const count = await prisma.bulkImportJob.count({
     *   where: {
     *     // ... the filter for the BulkImportJobs we want to count
     *   }
     * })
    **/
    count<T extends BulkImportJobCountArgs>(
      args?: Subset<T, BulkImportJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BulkImportJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BulkImportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BulkImportJobAggregateArgs>(args: Subset<T, BulkImportJobAggregateArgs>): Prisma.PrismaPromise<GetBulkImportJobAggregateType<T>>

    /**
     * Group by BulkImportJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulkImportJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BulkImportJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BulkImportJobGroupByArgs['orderBy'] }
        : { orderBy?: BulkImportJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BulkImportJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBulkImportJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BulkImportJob model
   */
  readonly fields: BulkImportJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BulkImportJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BulkImportJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdByUser<T extends BulkImportJob$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, BulkImportJob$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BulkImportJob model
   */ 
  interface BulkImportJobFieldRefs {
    readonly id: FieldRef<"BulkImportJob", 'String'>
    readonly branchId: FieldRef<"BulkImportJob", 'String'>
    readonly entityType: FieldRef<"BulkImportJob", 'ImportEntityType'>
    readonly status: FieldRef<"BulkImportJob", 'ImportJobStatus'>
    readonly fileName: FieldRef<"BulkImportJob", 'String'>
    readonly payload: FieldRef<"BulkImportJob", 'Json'>
    readonly errors: FieldRef<"BulkImportJob", 'Json'>
    readonly totalRows: FieldRef<"BulkImportJob", 'Int'>
    readonly validRows: FieldRef<"BulkImportJob", 'Int'>
    readonly invalidRows: FieldRef<"BulkImportJob", 'Int'>
    readonly createdByUserId: FieldRef<"BulkImportJob", 'String'>
    readonly committedAt: FieldRef<"BulkImportJob", 'DateTime'>
    readonly createdAt: FieldRef<"BulkImportJob", 'DateTime'>
    readonly updatedAt: FieldRef<"BulkImportJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BulkImportJob findUnique
   */
  export type BulkImportJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
    /**
     * Filter, which BulkImportJob to fetch.
     */
    where: BulkImportJobWhereUniqueInput
  }

  /**
   * BulkImportJob findUniqueOrThrow
   */
  export type BulkImportJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
    /**
     * Filter, which BulkImportJob to fetch.
     */
    where: BulkImportJobWhereUniqueInput
  }

  /**
   * BulkImportJob findFirst
   */
  export type BulkImportJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
    /**
     * Filter, which BulkImportJob to fetch.
     */
    where?: BulkImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkImportJobs to fetch.
     */
    orderBy?: BulkImportJobOrderByWithRelationInput | BulkImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulkImportJobs.
     */
    cursor?: BulkImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulkImportJobs.
     */
    distinct?: BulkImportJobScalarFieldEnum | BulkImportJobScalarFieldEnum[]
  }

  /**
   * BulkImportJob findFirstOrThrow
   */
  export type BulkImportJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
    /**
     * Filter, which BulkImportJob to fetch.
     */
    where?: BulkImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkImportJobs to fetch.
     */
    orderBy?: BulkImportJobOrderByWithRelationInput | BulkImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulkImportJobs.
     */
    cursor?: BulkImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkImportJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulkImportJobs.
     */
    distinct?: BulkImportJobScalarFieldEnum | BulkImportJobScalarFieldEnum[]
  }

  /**
   * BulkImportJob findMany
   */
  export type BulkImportJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
    /**
     * Filter, which BulkImportJobs to fetch.
     */
    where?: BulkImportJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulkImportJobs to fetch.
     */
    orderBy?: BulkImportJobOrderByWithRelationInput | BulkImportJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BulkImportJobs.
     */
    cursor?: BulkImportJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulkImportJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulkImportJobs.
     */
    skip?: number
    distinct?: BulkImportJobScalarFieldEnum | BulkImportJobScalarFieldEnum[]
  }

  /**
   * BulkImportJob create
   */
  export type BulkImportJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
    /**
     * The data needed to create a BulkImportJob.
     */
    data: XOR<BulkImportJobCreateInput, BulkImportJobUncheckedCreateInput>
  }

  /**
   * BulkImportJob createMany
   */
  export type BulkImportJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BulkImportJobs.
     */
    data: BulkImportJobCreateManyInput | BulkImportJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BulkImportJob createManyAndReturn
   */
  export type BulkImportJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BulkImportJobs.
     */
    data: BulkImportJobCreateManyInput | BulkImportJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BulkImportJob update
   */
  export type BulkImportJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
    /**
     * The data needed to update a BulkImportJob.
     */
    data: XOR<BulkImportJobUpdateInput, BulkImportJobUncheckedUpdateInput>
    /**
     * Choose, which BulkImportJob to update.
     */
    where: BulkImportJobWhereUniqueInput
  }

  /**
   * BulkImportJob updateMany
   */
  export type BulkImportJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BulkImportJobs.
     */
    data: XOR<BulkImportJobUpdateManyMutationInput, BulkImportJobUncheckedUpdateManyInput>
    /**
     * Filter which BulkImportJobs to update
     */
    where?: BulkImportJobWhereInput
  }

  /**
   * BulkImportJob upsert
   */
  export type BulkImportJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
    /**
     * The filter to search for the BulkImportJob to update in case it exists.
     */
    where: BulkImportJobWhereUniqueInput
    /**
     * In case the BulkImportJob found by the `where` argument doesn't exist, create a new BulkImportJob with this data.
     */
    create: XOR<BulkImportJobCreateInput, BulkImportJobUncheckedCreateInput>
    /**
     * In case the BulkImportJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BulkImportJobUpdateInput, BulkImportJobUncheckedUpdateInput>
  }

  /**
   * BulkImportJob delete
   */
  export type BulkImportJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
    /**
     * Filter which BulkImportJob to delete.
     */
    where: BulkImportJobWhereUniqueInput
  }

  /**
   * BulkImportJob deleteMany
   */
  export type BulkImportJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulkImportJobs to delete
     */
    where?: BulkImportJobWhereInput
  }

  /**
   * BulkImportJob.createdByUser
   */
  export type BulkImportJob$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BulkImportJob without action
   */
  export type BulkImportJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulkImportJob
     */
    select?: BulkImportJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulkImportJobInclude<ExtArgs> | null
  }


  /**
   * Model ProcedureBooking
   */

  export type AggregateProcedureBooking = {
    _count: ProcedureBookingCountAggregateOutputType | null
    _min: ProcedureBookingMinAggregateOutputType | null
    _max: ProcedureBookingMaxAggregateOutputType | null
  }

  export type ProcedureBookingMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    unitId: string | null
    resourceId: string | null
    patientId: string | null
    departmentId: string | null
    startAt: Date | null
    endAt: Date | null
    status: $Enums.BookingStatus | null
    consentOk: boolean | null
    anesthesiaOk: boolean | null
    checklistOk: boolean | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcedureBookingMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    unitId: string | null
    resourceId: string | null
    patientId: string | null
    departmentId: string | null
    startAt: Date | null
    endAt: Date | null
    status: $Enums.BookingStatus | null
    consentOk: boolean | null
    anesthesiaOk: boolean | null
    checklistOk: boolean | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProcedureBookingCountAggregateOutputType = {
    id: number
    branchId: number
    unitId: number
    resourceId: number
    patientId: number
    departmentId: number
    startAt: number
    endAt: number
    status: number
    consentOk: number
    anesthesiaOk: number
    checklistOk: number
    createdByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProcedureBookingMinAggregateInputType = {
    id?: true
    branchId?: true
    unitId?: true
    resourceId?: true
    patientId?: true
    departmentId?: true
    startAt?: true
    endAt?: true
    status?: true
    consentOk?: true
    anesthesiaOk?: true
    checklistOk?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcedureBookingMaxAggregateInputType = {
    id?: true
    branchId?: true
    unitId?: true
    resourceId?: true
    patientId?: true
    departmentId?: true
    startAt?: true
    endAt?: true
    status?: true
    consentOk?: true
    anesthesiaOk?: true
    checklistOk?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProcedureBookingCountAggregateInputType = {
    id?: true
    branchId?: true
    unitId?: true
    resourceId?: true
    patientId?: true
    departmentId?: true
    startAt?: true
    endAt?: true
    status?: true
    consentOk?: true
    anesthesiaOk?: true
    checklistOk?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProcedureBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcedureBooking to aggregate.
     */
    where?: ProcedureBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcedureBookings to fetch.
     */
    orderBy?: ProcedureBookingOrderByWithRelationInput | ProcedureBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcedureBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcedureBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcedureBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProcedureBookings
    **/
    _count?: true | ProcedureBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcedureBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcedureBookingMaxAggregateInputType
  }

  export type GetProcedureBookingAggregateType<T extends ProcedureBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateProcedureBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcedureBooking[P]>
      : GetScalarType<T[P], AggregateProcedureBooking[P]>
  }




  export type ProcedureBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcedureBookingWhereInput
    orderBy?: ProcedureBookingOrderByWithAggregationInput | ProcedureBookingOrderByWithAggregationInput[]
    by: ProcedureBookingScalarFieldEnum[] | ProcedureBookingScalarFieldEnum
    having?: ProcedureBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcedureBookingCountAggregateInputType | true
    _min?: ProcedureBookingMinAggregateInputType
    _max?: ProcedureBookingMaxAggregateInputType
  }

  export type ProcedureBookingGroupByOutputType = {
    id: string
    branchId: string
    unitId: string
    resourceId: string
    patientId: string | null
    departmentId: string | null
    startAt: Date
    endAt: Date
    status: $Enums.BookingStatus
    consentOk: boolean
    anesthesiaOk: boolean
    checklistOk: boolean
    createdByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProcedureBookingCountAggregateOutputType | null
    _min: ProcedureBookingMinAggregateOutputType | null
    _max: ProcedureBookingMaxAggregateOutputType | null
  }

  type GetProcedureBookingGroupByPayload<T extends ProcedureBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcedureBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcedureBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcedureBookingGroupByOutputType[P]>
            : GetScalarType<T[P], ProcedureBookingGroupByOutputType[P]>
        }
      >
    >


  export type ProcedureBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    unitId?: boolean
    resourceId?: boolean
    patientId?: boolean
    departmentId?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    resource?: boolean | UnitResourceDefaultArgs<ExtArgs>
    createdByUser?: boolean | ProcedureBooking$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["procedureBooking"]>

  export type ProcedureBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    unitId?: boolean
    resourceId?: boolean
    patientId?: boolean
    departmentId?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    resource?: boolean | UnitResourceDefaultArgs<ExtArgs>
    createdByUser?: boolean | ProcedureBooking$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["procedureBooking"]>

  export type ProcedureBookingSelectScalar = {
    id?: boolean
    branchId?: boolean
    unitId?: boolean
    resourceId?: boolean
    patientId?: boolean
    departmentId?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProcedureBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    resource?: boolean | UnitResourceDefaultArgs<ExtArgs>
    createdByUser?: boolean | ProcedureBooking$createdByUserArgs<ExtArgs>
  }
  export type ProcedureBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    resource?: boolean | UnitResourceDefaultArgs<ExtArgs>
    createdByUser?: boolean | ProcedureBooking$createdByUserArgs<ExtArgs>
  }

  export type $ProcedureBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProcedureBooking"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>
      resource: Prisma.$UnitResourcePayload<ExtArgs>
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      unitId: string
      resourceId: string
      patientId: string | null
      departmentId: string | null
      startAt: Date
      endAt: Date
      status: $Enums.BookingStatus
      consentOk: boolean
      anesthesiaOk: boolean
      checklistOk: boolean
      createdByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["procedureBooking"]>
    composites: {}
  }

  type ProcedureBookingGetPayload<S extends boolean | null | undefined | ProcedureBookingDefaultArgs> = $Result.GetResult<Prisma.$ProcedureBookingPayload, S>

  type ProcedureBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcedureBookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcedureBookingCountAggregateInputType | true
    }

  export interface ProcedureBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProcedureBooking'], meta: { name: 'ProcedureBooking' } }
    /**
     * Find zero or one ProcedureBooking that matches the filter.
     * @param {ProcedureBookingFindUniqueArgs} args - Arguments to find a ProcedureBooking
     * @example
     * // Get one ProcedureBooking
     * const procedureBooking = await prisma.procedureBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcedureBookingFindUniqueArgs>(args: SelectSubset<T, ProcedureBookingFindUniqueArgs<ExtArgs>>): Prisma__ProcedureBookingClient<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProcedureBooking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcedureBookingFindUniqueOrThrowArgs} args - Arguments to find a ProcedureBooking
     * @example
     * // Get one ProcedureBooking
     * const procedureBooking = await prisma.procedureBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcedureBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcedureBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcedureBookingClient<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProcedureBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureBookingFindFirstArgs} args - Arguments to find a ProcedureBooking
     * @example
     * // Get one ProcedureBooking
     * const procedureBooking = await prisma.procedureBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcedureBookingFindFirstArgs>(args?: SelectSubset<T, ProcedureBookingFindFirstArgs<ExtArgs>>): Prisma__ProcedureBookingClient<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProcedureBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureBookingFindFirstOrThrowArgs} args - Arguments to find a ProcedureBooking
     * @example
     * // Get one ProcedureBooking
     * const procedureBooking = await prisma.procedureBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcedureBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcedureBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcedureBookingClient<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProcedureBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcedureBookings
     * const procedureBookings = await prisma.procedureBooking.findMany()
     * 
     * // Get first 10 ProcedureBookings
     * const procedureBookings = await prisma.procedureBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const procedureBookingWithIdOnly = await prisma.procedureBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcedureBookingFindManyArgs>(args?: SelectSubset<T, ProcedureBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProcedureBooking.
     * @param {ProcedureBookingCreateArgs} args - Arguments to create a ProcedureBooking.
     * @example
     * // Create one ProcedureBooking
     * const ProcedureBooking = await prisma.procedureBooking.create({
     *   data: {
     *     // ... data to create a ProcedureBooking
     *   }
     * })
     * 
     */
    create<T extends ProcedureBookingCreateArgs>(args: SelectSubset<T, ProcedureBookingCreateArgs<ExtArgs>>): Prisma__ProcedureBookingClient<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProcedureBookings.
     * @param {ProcedureBookingCreateManyArgs} args - Arguments to create many ProcedureBookings.
     * @example
     * // Create many ProcedureBookings
     * const procedureBooking = await prisma.procedureBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcedureBookingCreateManyArgs>(args?: SelectSubset<T, ProcedureBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProcedureBookings and returns the data saved in the database.
     * @param {ProcedureBookingCreateManyAndReturnArgs} args - Arguments to create many ProcedureBookings.
     * @example
     * // Create many ProcedureBookings
     * const procedureBooking = await prisma.procedureBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProcedureBookings and only return the `id`
     * const procedureBookingWithIdOnly = await prisma.procedureBooking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcedureBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcedureBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProcedureBooking.
     * @param {ProcedureBookingDeleteArgs} args - Arguments to delete one ProcedureBooking.
     * @example
     * // Delete one ProcedureBooking
     * const ProcedureBooking = await prisma.procedureBooking.delete({
     *   where: {
     *     // ... filter to delete one ProcedureBooking
     *   }
     * })
     * 
     */
    delete<T extends ProcedureBookingDeleteArgs>(args: SelectSubset<T, ProcedureBookingDeleteArgs<ExtArgs>>): Prisma__ProcedureBookingClient<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProcedureBooking.
     * @param {ProcedureBookingUpdateArgs} args - Arguments to update one ProcedureBooking.
     * @example
     * // Update one ProcedureBooking
     * const procedureBooking = await prisma.procedureBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcedureBookingUpdateArgs>(args: SelectSubset<T, ProcedureBookingUpdateArgs<ExtArgs>>): Prisma__ProcedureBookingClient<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProcedureBookings.
     * @param {ProcedureBookingDeleteManyArgs} args - Arguments to filter ProcedureBookings to delete.
     * @example
     * // Delete a few ProcedureBookings
     * const { count } = await prisma.procedureBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcedureBookingDeleteManyArgs>(args?: SelectSubset<T, ProcedureBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProcedureBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcedureBookings
     * const procedureBooking = await prisma.procedureBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcedureBookingUpdateManyArgs>(args: SelectSubset<T, ProcedureBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProcedureBooking.
     * @param {ProcedureBookingUpsertArgs} args - Arguments to update or create a ProcedureBooking.
     * @example
     * // Update or create a ProcedureBooking
     * const procedureBooking = await prisma.procedureBooking.upsert({
     *   create: {
     *     // ... data to create a ProcedureBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcedureBooking we want to update
     *   }
     * })
     */
    upsert<T extends ProcedureBookingUpsertArgs>(args: SelectSubset<T, ProcedureBookingUpsertArgs<ExtArgs>>): Prisma__ProcedureBookingClient<$Result.GetResult<Prisma.$ProcedureBookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProcedureBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureBookingCountArgs} args - Arguments to filter ProcedureBookings to count.
     * @example
     * // Count the number of ProcedureBookings
     * const count = await prisma.procedureBooking.count({
     *   where: {
     *     // ... the filter for the ProcedureBookings we want to count
     *   }
     * })
    **/
    count<T extends ProcedureBookingCountArgs>(
      args?: Subset<T, ProcedureBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcedureBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProcedureBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcedureBookingAggregateArgs>(args: Subset<T, ProcedureBookingAggregateArgs>): Prisma.PrismaPromise<GetProcedureBookingAggregateType<T>>

    /**
     * Group by ProcedureBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcedureBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcedureBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcedureBookingGroupByArgs['orderBy'] }
        : { orderBy?: ProcedureBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcedureBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcedureBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProcedureBooking model
   */
  readonly fields: ProcedureBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcedureBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcedureBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resource<T extends UnitResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitResourceDefaultArgs<ExtArgs>>): Prisma__UnitResourceClient<$Result.GetResult<Prisma.$UnitResourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdByUser<T extends ProcedureBooking$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, ProcedureBooking$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProcedureBooking model
   */ 
  interface ProcedureBookingFieldRefs {
    readonly id: FieldRef<"ProcedureBooking", 'String'>
    readonly branchId: FieldRef<"ProcedureBooking", 'String'>
    readonly unitId: FieldRef<"ProcedureBooking", 'String'>
    readonly resourceId: FieldRef<"ProcedureBooking", 'String'>
    readonly patientId: FieldRef<"ProcedureBooking", 'String'>
    readonly departmentId: FieldRef<"ProcedureBooking", 'String'>
    readonly startAt: FieldRef<"ProcedureBooking", 'DateTime'>
    readonly endAt: FieldRef<"ProcedureBooking", 'DateTime'>
    readonly status: FieldRef<"ProcedureBooking", 'BookingStatus'>
    readonly consentOk: FieldRef<"ProcedureBooking", 'Boolean'>
    readonly anesthesiaOk: FieldRef<"ProcedureBooking", 'Boolean'>
    readonly checklistOk: FieldRef<"ProcedureBooking", 'Boolean'>
    readonly createdByUserId: FieldRef<"ProcedureBooking", 'String'>
    readonly createdAt: FieldRef<"ProcedureBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"ProcedureBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProcedureBooking findUnique
   */
  export type ProcedureBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    /**
     * Filter, which ProcedureBooking to fetch.
     */
    where: ProcedureBookingWhereUniqueInput
  }

  /**
   * ProcedureBooking findUniqueOrThrow
   */
  export type ProcedureBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    /**
     * Filter, which ProcedureBooking to fetch.
     */
    where: ProcedureBookingWhereUniqueInput
  }

  /**
   * ProcedureBooking findFirst
   */
  export type ProcedureBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    /**
     * Filter, which ProcedureBooking to fetch.
     */
    where?: ProcedureBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcedureBookings to fetch.
     */
    orderBy?: ProcedureBookingOrderByWithRelationInput | ProcedureBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcedureBookings.
     */
    cursor?: ProcedureBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcedureBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcedureBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcedureBookings.
     */
    distinct?: ProcedureBookingScalarFieldEnum | ProcedureBookingScalarFieldEnum[]
  }

  /**
   * ProcedureBooking findFirstOrThrow
   */
  export type ProcedureBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    /**
     * Filter, which ProcedureBooking to fetch.
     */
    where?: ProcedureBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcedureBookings to fetch.
     */
    orderBy?: ProcedureBookingOrderByWithRelationInput | ProcedureBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProcedureBookings.
     */
    cursor?: ProcedureBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcedureBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcedureBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProcedureBookings.
     */
    distinct?: ProcedureBookingScalarFieldEnum | ProcedureBookingScalarFieldEnum[]
  }

  /**
   * ProcedureBooking findMany
   */
  export type ProcedureBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    /**
     * Filter, which ProcedureBookings to fetch.
     */
    where?: ProcedureBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProcedureBookings to fetch.
     */
    orderBy?: ProcedureBookingOrderByWithRelationInput | ProcedureBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProcedureBookings.
     */
    cursor?: ProcedureBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProcedureBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProcedureBookings.
     */
    skip?: number
    distinct?: ProcedureBookingScalarFieldEnum | ProcedureBookingScalarFieldEnum[]
  }

  /**
   * ProcedureBooking create
   */
  export type ProcedureBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a ProcedureBooking.
     */
    data: XOR<ProcedureBookingCreateInput, ProcedureBookingUncheckedCreateInput>
  }

  /**
   * ProcedureBooking createMany
   */
  export type ProcedureBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProcedureBookings.
     */
    data: ProcedureBookingCreateManyInput | ProcedureBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProcedureBooking createManyAndReturn
   */
  export type ProcedureBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProcedureBookings.
     */
    data: ProcedureBookingCreateManyInput | ProcedureBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProcedureBooking update
   */
  export type ProcedureBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a ProcedureBooking.
     */
    data: XOR<ProcedureBookingUpdateInput, ProcedureBookingUncheckedUpdateInput>
    /**
     * Choose, which ProcedureBooking to update.
     */
    where: ProcedureBookingWhereUniqueInput
  }

  /**
   * ProcedureBooking updateMany
   */
  export type ProcedureBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProcedureBookings.
     */
    data: XOR<ProcedureBookingUpdateManyMutationInput, ProcedureBookingUncheckedUpdateManyInput>
    /**
     * Filter which ProcedureBookings to update
     */
    where?: ProcedureBookingWhereInput
  }

  /**
   * ProcedureBooking upsert
   */
  export type ProcedureBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the ProcedureBooking to update in case it exists.
     */
    where: ProcedureBookingWhereUniqueInput
    /**
     * In case the ProcedureBooking found by the `where` argument doesn't exist, create a new ProcedureBooking with this data.
     */
    create: XOR<ProcedureBookingCreateInput, ProcedureBookingUncheckedCreateInput>
    /**
     * In case the ProcedureBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcedureBookingUpdateInput, ProcedureBookingUncheckedUpdateInput>
  }

  /**
   * ProcedureBooking delete
   */
  export type ProcedureBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
    /**
     * Filter which ProcedureBooking to delete.
     */
    where: ProcedureBookingWhereUniqueInput
  }

  /**
   * ProcedureBooking deleteMany
   */
  export type ProcedureBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProcedureBookings to delete
     */
    where?: ProcedureBookingWhereInput
  }

  /**
   * ProcedureBooking.createdByUser
   */
  export type ProcedureBooking$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ProcedureBooking without action
   */
  export type ProcedureBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcedureBooking
     */
    select?: ProcedureBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcedureBookingInclude<ExtArgs> | null
  }


  /**
   * Model GoLiveReport
   */

  export type AggregateGoLiveReport = {
    _count: GoLiveReportCountAggregateOutputType | null
    _avg: GoLiveReportAvgAggregateOutputType | null
    _sum: GoLiveReportSumAggregateOutputType | null
    _min: GoLiveReportMinAggregateOutputType | null
    _max: GoLiveReportMaxAggregateOutputType | null
  }

  export type GoLiveReportAvgAggregateOutputType = {
    score: number | null
  }

  export type GoLiveReportSumAggregateOutputType = {
    score: number | null
  }

  export type GoLiveReportMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    score: number | null
    createdByUserId: string | null
    createdAt: Date | null
  }

  export type GoLiveReportMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    score: number | null
    createdByUserId: string | null
    createdAt: Date | null
  }

  export type GoLiveReportCountAggregateOutputType = {
    id: number
    branchId: number
    score: number
    blockers: number
    warnings: number
    snapshot: number
    createdByUserId: number
    createdAt: number
    _all: number
  }


  export type GoLiveReportAvgAggregateInputType = {
    score?: true
  }

  export type GoLiveReportSumAggregateInputType = {
    score?: true
  }

  export type GoLiveReportMinAggregateInputType = {
    id?: true
    branchId?: true
    score?: true
    createdByUserId?: true
    createdAt?: true
  }

  export type GoLiveReportMaxAggregateInputType = {
    id?: true
    branchId?: true
    score?: true
    createdByUserId?: true
    createdAt?: true
  }

  export type GoLiveReportCountAggregateInputType = {
    id?: true
    branchId?: true
    score?: true
    blockers?: true
    warnings?: true
    snapshot?: true
    createdByUserId?: true
    createdAt?: true
    _all?: true
  }

  export type GoLiveReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoLiveReport to aggregate.
     */
    where?: GoLiveReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoLiveReports to fetch.
     */
    orderBy?: GoLiveReportOrderByWithRelationInput | GoLiveReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoLiveReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoLiveReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoLiveReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoLiveReports
    **/
    _count?: true | GoLiveReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoLiveReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoLiveReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoLiveReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoLiveReportMaxAggregateInputType
  }

  export type GetGoLiveReportAggregateType<T extends GoLiveReportAggregateArgs> = {
        [P in keyof T & keyof AggregateGoLiveReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoLiveReport[P]>
      : GetScalarType<T[P], AggregateGoLiveReport[P]>
  }




  export type GoLiveReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoLiveReportWhereInput
    orderBy?: GoLiveReportOrderByWithAggregationInput | GoLiveReportOrderByWithAggregationInput[]
    by: GoLiveReportScalarFieldEnum[] | GoLiveReportScalarFieldEnum
    having?: GoLiveReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoLiveReportCountAggregateInputType | true
    _avg?: GoLiveReportAvgAggregateInputType
    _sum?: GoLiveReportSumAggregateInputType
    _min?: GoLiveReportMinAggregateInputType
    _max?: GoLiveReportMaxAggregateInputType
  }

  export type GoLiveReportGroupByOutputType = {
    id: string
    branchId: string
    score: number
    blockers: JsonValue
    warnings: JsonValue
    snapshot: JsonValue
    createdByUserId: string | null
    createdAt: Date
    _count: GoLiveReportCountAggregateOutputType | null
    _avg: GoLiveReportAvgAggregateOutputType | null
    _sum: GoLiveReportSumAggregateOutputType | null
    _min: GoLiveReportMinAggregateOutputType | null
    _max: GoLiveReportMaxAggregateOutputType | null
  }

  type GetGoLiveReportGroupByPayload<T extends GoLiveReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoLiveReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoLiveReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoLiveReportGroupByOutputType[P]>
            : GetScalarType<T[P], GoLiveReportGroupByOutputType[P]>
        }
      >
    >


  export type GoLiveReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    score?: boolean
    blockers?: boolean
    warnings?: boolean
    snapshot?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    createdByUser?: boolean | GoLiveReport$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["goLiveReport"]>

  export type GoLiveReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    score?: boolean
    blockers?: boolean
    warnings?: boolean
    snapshot?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    createdByUser?: boolean | GoLiveReport$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["goLiveReport"]>

  export type GoLiveReportSelectScalar = {
    id?: boolean
    branchId?: boolean
    score?: boolean
    blockers?: boolean
    warnings?: boolean
    snapshot?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
  }

  export type GoLiveReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    createdByUser?: boolean | GoLiveReport$createdByUserArgs<ExtArgs>
  }
  export type GoLiveReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    createdByUser?: boolean | GoLiveReport$createdByUserArgs<ExtArgs>
  }

  export type $GoLiveReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoLiveReport"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      score: number
      blockers: Prisma.JsonValue
      warnings: Prisma.JsonValue
      snapshot: Prisma.JsonValue
      createdByUserId: string | null
      createdAt: Date
    }, ExtArgs["result"]["goLiveReport"]>
    composites: {}
  }

  type GoLiveReportGetPayload<S extends boolean | null | undefined | GoLiveReportDefaultArgs> = $Result.GetResult<Prisma.$GoLiveReportPayload, S>

  type GoLiveReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GoLiveReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GoLiveReportCountAggregateInputType | true
    }

  export interface GoLiveReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoLiveReport'], meta: { name: 'GoLiveReport' } }
    /**
     * Find zero or one GoLiveReport that matches the filter.
     * @param {GoLiveReportFindUniqueArgs} args - Arguments to find a GoLiveReport
     * @example
     * // Get one GoLiveReport
     * const goLiveReport = await prisma.goLiveReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoLiveReportFindUniqueArgs>(args: SelectSubset<T, GoLiveReportFindUniqueArgs<ExtArgs>>): Prisma__GoLiveReportClient<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GoLiveReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GoLiveReportFindUniqueOrThrowArgs} args - Arguments to find a GoLiveReport
     * @example
     * // Get one GoLiveReport
     * const goLiveReport = await prisma.goLiveReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoLiveReportFindUniqueOrThrowArgs>(args: SelectSubset<T, GoLiveReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoLiveReportClient<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GoLiveReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoLiveReportFindFirstArgs} args - Arguments to find a GoLiveReport
     * @example
     * // Get one GoLiveReport
     * const goLiveReport = await prisma.goLiveReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoLiveReportFindFirstArgs>(args?: SelectSubset<T, GoLiveReportFindFirstArgs<ExtArgs>>): Prisma__GoLiveReportClient<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GoLiveReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoLiveReportFindFirstOrThrowArgs} args - Arguments to find a GoLiveReport
     * @example
     * // Get one GoLiveReport
     * const goLiveReport = await prisma.goLiveReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoLiveReportFindFirstOrThrowArgs>(args?: SelectSubset<T, GoLiveReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoLiveReportClient<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GoLiveReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoLiveReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoLiveReports
     * const goLiveReports = await prisma.goLiveReport.findMany()
     * 
     * // Get first 10 GoLiveReports
     * const goLiveReports = await prisma.goLiveReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goLiveReportWithIdOnly = await prisma.goLiveReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoLiveReportFindManyArgs>(args?: SelectSubset<T, GoLiveReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GoLiveReport.
     * @param {GoLiveReportCreateArgs} args - Arguments to create a GoLiveReport.
     * @example
     * // Create one GoLiveReport
     * const GoLiveReport = await prisma.goLiveReport.create({
     *   data: {
     *     // ... data to create a GoLiveReport
     *   }
     * })
     * 
     */
    create<T extends GoLiveReportCreateArgs>(args: SelectSubset<T, GoLiveReportCreateArgs<ExtArgs>>): Prisma__GoLiveReportClient<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GoLiveReports.
     * @param {GoLiveReportCreateManyArgs} args - Arguments to create many GoLiveReports.
     * @example
     * // Create many GoLiveReports
     * const goLiveReport = await prisma.goLiveReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoLiveReportCreateManyArgs>(args?: SelectSubset<T, GoLiveReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoLiveReports and returns the data saved in the database.
     * @param {GoLiveReportCreateManyAndReturnArgs} args - Arguments to create many GoLiveReports.
     * @example
     * // Create many GoLiveReports
     * const goLiveReport = await prisma.goLiveReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoLiveReports and only return the `id`
     * const goLiveReportWithIdOnly = await prisma.goLiveReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoLiveReportCreateManyAndReturnArgs>(args?: SelectSubset<T, GoLiveReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GoLiveReport.
     * @param {GoLiveReportDeleteArgs} args - Arguments to delete one GoLiveReport.
     * @example
     * // Delete one GoLiveReport
     * const GoLiveReport = await prisma.goLiveReport.delete({
     *   where: {
     *     // ... filter to delete one GoLiveReport
     *   }
     * })
     * 
     */
    delete<T extends GoLiveReportDeleteArgs>(args: SelectSubset<T, GoLiveReportDeleteArgs<ExtArgs>>): Prisma__GoLiveReportClient<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GoLiveReport.
     * @param {GoLiveReportUpdateArgs} args - Arguments to update one GoLiveReport.
     * @example
     * // Update one GoLiveReport
     * const goLiveReport = await prisma.goLiveReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoLiveReportUpdateArgs>(args: SelectSubset<T, GoLiveReportUpdateArgs<ExtArgs>>): Prisma__GoLiveReportClient<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GoLiveReports.
     * @param {GoLiveReportDeleteManyArgs} args - Arguments to filter GoLiveReports to delete.
     * @example
     * // Delete a few GoLiveReports
     * const { count } = await prisma.goLiveReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoLiveReportDeleteManyArgs>(args?: SelectSubset<T, GoLiveReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoLiveReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoLiveReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoLiveReports
     * const goLiveReport = await prisma.goLiveReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoLiveReportUpdateManyArgs>(args: SelectSubset<T, GoLiveReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GoLiveReport.
     * @param {GoLiveReportUpsertArgs} args - Arguments to update or create a GoLiveReport.
     * @example
     * // Update or create a GoLiveReport
     * const goLiveReport = await prisma.goLiveReport.upsert({
     *   create: {
     *     // ... data to create a GoLiveReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoLiveReport we want to update
     *   }
     * })
     */
    upsert<T extends GoLiveReportUpsertArgs>(args: SelectSubset<T, GoLiveReportUpsertArgs<ExtArgs>>): Prisma__GoLiveReportClient<$Result.GetResult<Prisma.$GoLiveReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GoLiveReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoLiveReportCountArgs} args - Arguments to filter GoLiveReports to count.
     * @example
     * // Count the number of GoLiveReports
     * const count = await prisma.goLiveReport.count({
     *   where: {
     *     // ... the filter for the GoLiveReports we want to count
     *   }
     * })
    **/
    count<T extends GoLiveReportCountArgs>(
      args?: Subset<T, GoLiveReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoLiveReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoLiveReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoLiveReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoLiveReportAggregateArgs>(args: Subset<T, GoLiveReportAggregateArgs>): Prisma.PrismaPromise<GetGoLiveReportAggregateType<T>>

    /**
     * Group by GoLiveReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoLiveReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoLiveReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoLiveReportGroupByArgs['orderBy'] }
        : { orderBy?: GoLiveReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoLiveReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoLiveReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoLiveReport model
   */
  readonly fields: GoLiveReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoLiveReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoLiveReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdByUser<T extends GoLiveReport$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, GoLiveReport$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoLiveReport model
   */ 
  interface GoLiveReportFieldRefs {
    readonly id: FieldRef<"GoLiveReport", 'String'>
    readonly branchId: FieldRef<"GoLiveReport", 'String'>
    readonly score: FieldRef<"GoLiveReport", 'Int'>
    readonly blockers: FieldRef<"GoLiveReport", 'Json'>
    readonly warnings: FieldRef<"GoLiveReport", 'Json'>
    readonly snapshot: FieldRef<"GoLiveReport", 'Json'>
    readonly createdByUserId: FieldRef<"GoLiveReport", 'String'>
    readonly createdAt: FieldRef<"GoLiveReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GoLiveReport findUnique
   */
  export type GoLiveReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
    /**
     * Filter, which GoLiveReport to fetch.
     */
    where: GoLiveReportWhereUniqueInput
  }

  /**
   * GoLiveReport findUniqueOrThrow
   */
  export type GoLiveReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
    /**
     * Filter, which GoLiveReport to fetch.
     */
    where: GoLiveReportWhereUniqueInput
  }

  /**
   * GoLiveReport findFirst
   */
  export type GoLiveReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
    /**
     * Filter, which GoLiveReport to fetch.
     */
    where?: GoLiveReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoLiveReports to fetch.
     */
    orderBy?: GoLiveReportOrderByWithRelationInput | GoLiveReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoLiveReports.
     */
    cursor?: GoLiveReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoLiveReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoLiveReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoLiveReports.
     */
    distinct?: GoLiveReportScalarFieldEnum | GoLiveReportScalarFieldEnum[]
  }

  /**
   * GoLiveReport findFirstOrThrow
   */
  export type GoLiveReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
    /**
     * Filter, which GoLiveReport to fetch.
     */
    where?: GoLiveReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoLiveReports to fetch.
     */
    orderBy?: GoLiveReportOrderByWithRelationInput | GoLiveReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoLiveReports.
     */
    cursor?: GoLiveReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoLiveReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoLiveReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoLiveReports.
     */
    distinct?: GoLiveReportScalarFieldEnum | GoLiveReportScalarFieldEnum[]
  }

  /**
   * GoLiveReport findMany
   */
  export type GoLiveReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
    /**
     * Filter, which GoLiveReports to fetch.
     */
    where?: GoLiveReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoLiveReports to fetch.
     */
    orderBy?: GoLiveReportOrderByWithRelationInput | GoLiveReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoLiveReports.
     */
    cursor?: GoLiveReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoLiveReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoLiveReports.
     */
    skip?: number
    distinct?: GoLiveReportScalarFieldEnum | GoLiveReportScalarFieldEnum[]
  }

  /**
   * GoLiveReport create
   */
  export type GoLiveReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
    /**
     * The data needed to create a GoLiveReport.
     */
    data: XOR<GoLiveReportCreateInput, GoLiveReportUncheckedCreateInput>
  }

  /**
   * GoLiveReport createMany
   */
  export type GoLiveReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoLiveReports.
     */
    data: GoLiveReportCreateManyInput | GoLiveReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoLiveReport createManyAndReturn
   */
  export type GoLiveReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GoLiveReports.
     */
    data: GoLiveReportCreateManyInput | GoLiveReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoLiveReport update
   */
  export type GoLiveReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
    /**
     * The data needed to update a GoLiveReport.
     */
    data: XOR<GoLiveReportUpdateInput, GoLiveReportUncheckedUpdateInput>
    /**
     * Choose, which GoLiveReport to update.
     */
    where: GoLiveReportWhereUniqueInput
  }

  /**
   * GoLiveReport updateMany
   */
  export type GoLiveReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoLiveReports.
     */
    data: XOR<GoLiveReportUpdateManyMutationInput, GoLiveReportUncheckedUpdateManyInput>
    /**
     * Filter which GoLiveReports to update
     */
    where?: GoLiveReportWhereInput
  }

  /**
   * GoLiveReport upsert
   */
  export type GoLiveReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
    /**
     * The filter to search for the GoLiveReport to update in case it exists.
     */
    where: GoLiveReportWhereUniqueInput
    /**
     * In case the GoLiveReport found by the `where` argument doesn't exist, create a new GoLiveReport with this data.
     */
    create: XOR<GoLiveReportCreateInput, GoLiveReportUncheckedCreateInput>
    /**
     * In case the GoLiveReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoLiveReportUpdateInput, GoLiveReportUncheckedUpdateInput>
  }

  /**
   * GoLiveReport delete
   */
  export type GoLiveReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
    /**
     * Filter which GoLiveReport to delete.
     */
    where: GoLiveReportWhereUniqueInput
  }

  /**
   * GoLiveReport deleteMany
   */
  export type GoLiveReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoLiveReports to delete
     */
    where?: GoLiveReportWhereInput
  }

  /**
   * GoLiveReport.createdByUser
   */
  export type GoLiveReport$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GoLiveReport without action
   */
  export type GoLiveReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoLiveReport
     */
    select?: GoLiveReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoLiveReportInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BranchScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    city: 'city',
    gstNumber: 'gstNumber',
    address: 'address',
    contactPhone1: 'contactPhone1',
    contactPhone2: 'contactPhone2',
    contactEmail: 'contactEmail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const FacilityCatalogScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    category: 'category',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacilityCatalogScalarFieldEnum = (typeof FacilityCatalogScalarFieldEnum)[keyof typeof FacilityCatalogScalarFieldEnum]


  export const BranchFacilityScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    facilityId: 'facilityId',
    isEnabled: 'isEnabled',
    enabledAt: 'enabledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchFacilityScalarFieldEnum = (typeof BranchFacilityScalarFieldEnum)[keyof typeof BranchFacilityScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    facilityId: 'facilityId',
    code: 'code',
    name: 'name',
    headStaffId: 'headStaffId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const DepartmentDoctorScalarFieldEnum: {
    id: 'id',
    departmentId: 'departmentId',
    staffId: 'staffId',
    isPrimary: 'isPrimary',
    assignedAt: 'assignedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentDoctorScalarFieldEnum = (typeof DepartmentDoctorScalarFieldEnum)[keyof typeof DepartmentDoctorScalarFieldEnum]


  export const SpecialtyScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpecialtyScalarFieldEnum = (typeof SpecialtyScalarFieldEnum)[keyof typeof SpecialtyScalarFieldEnum]


  export const DepartmentSpecialtyScalarFieldEnum: {
    id: 'id',
    departmentId: 'departmentId',
    specialtyId: 'specialtyId',
    isPrimary: 'isPrimary',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentSpecialtyScalarFieldEnum = (typeof DepartmentSpecialtyScalarFieldEnum)[keyof typeof DepartmentSpecialtyScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    departmentId: 'departmentId',
    specialtyId: 'specialtyId',
    empCode: 'empCode',
    name: 'name',
    designation: 'designation',
    phone: 'phone',
    email: 'email',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    phone: 'phone',
    branchId: 'branchId',
    staffId: 'staffId',
    isActive: 'isActive',
    passwordHash: 'passwordHash',
    mustChangePassword: 'mustChangePassword',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpires: 'passwordResetExpires',
    roleVersionId: 'roleVersionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    uhid: 'uhid',
    name: 'name',
    gender: 'gender',
    dob: 'dob',
    phone: 'phone',
    email: 'email',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const EncounterScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    patientId: 'patientId',
    type: 'type',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EncounterScalarFieldEnum = (typeof EncounterScalarFieldEnum)[keyof typeof EncounterScalarFieldEnum]


  export const WardScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    specialty: 'specialty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WardScalarFieldEnum = (typeof WardScalarFieldEnum)[keyof typeof WardScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    wardId: 'wardId',
    code: 'code',
    name: 'name',
    floor: 'floor',
    type: 'type',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const BedScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    roomId: 'roomId',
    code: 'code',
    state: 'state',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BedScalarFieldEnum = (typeof BedScalarFieldEnum)[keyof typeof BedScalarFieldEnum]


  export const AdmissionScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    encounterId: 'encounterId',
    patientId: 'patientId',
    bedId: 'bedId',
    admittedAt: 'admittedAt',
    dischargedAt: 'dischargedAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdmissionScalarFieldEnum = (typeof AdmissionScalarFieldEnum)[keyof typeof AdmissionScalarFieldEnum]


  export const OTScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OTScalarFieldEnum = (typeof OTScalarFieldEnum)[keyof typeof OTScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    category: 'category',
    location: 'location',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const TariffPlanScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    status: 'status',
    payerType: 'payerType',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TariffPlanScalarFieldEnum = (typeof TariffPlanScalarFieldEnum)[keyof typeof TariffPlanScalarFieldEnum]


  export const ServiceCatalogItemScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    category: 'category',
    unit: 'unit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceCatalogItemScalarFieldEnum = (typeof ServiceCatalogItemScalarFieldEnum)[keyof typeof ServiceCatalogItemScalarFieldEnum]


  export const TariffRateScalarFieldEnum: {
    id: 'id',
    tariffPlanId: 'tariffPlanId',
    serviceCode: 'serviceCode',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TariffRateScalarFieldEnum = (typeof TariffRateScalarFieldEnum)[keyof typeof TariffRateScalarFieldEnum]


  export const ConsentRecordScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    scope: 'scope',
    purpose: 'purpose',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ConsentRecordScalarFieldEnum = (typeof ConsentRecordScalarFieldEnum)[keyof typeof ConsentRecordScalarFieldEnum]


  export const RtbfRequestScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    reason: 'reason',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RtbfRequestScalarFieldEnum = (typeof RtbfRequestScalarFieldEnum)[keyof typeof RtbfRequestScalarFieldEnum]


  export const StatutoryCaseScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    patientId: 'patientId',
    program: 'program',
    disease: 'disease',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatutoryCaseScalarFieldEnum = (typeof StatutoryCaseScalarFieldEnum)[keyof typeof StatutoryCaseScalarFieldEnum]


  export const AuditEventScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    actorUserId: 'actorUserId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type AuditEventScalarFieldEnum = (typeof AuditEventScalarFieldEnum)[keyof typeof AuditEventScalarFieldEnum]


  export const OutboxEventScalarFieldEnum: {
    id: 'id',
    topic: 'topic',
    key: 'key',
    payload: 'payload',
    status: 'status',
    attempts: 'attempts',
    availableAt: 'availableAt',
    lockedAt: 'lockedAt',
    sentAt: 'sentAt',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutboxEventScalarFieldEnum = (typeof OutboxEventScalarFieldEnum)[keyof typeof OutboxEventScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    category: 'category',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RoleTemplateScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    scope: 'scope',
    description: 'description',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleTemplateScalarFieldEnum = (typeof RoleTemplateScalarFieldEnum)[keyof typeof RoleTemplateScalarFieldEnum]


  export const RoleTemplateVersionScalarFieldEnum: {
    id: 'id',
    roleTemplateId: 'roleTemplateId',
    version: 'version',
    status: 'status',
    notes: 'notes',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleTemplateVersionScalarFieldEnum = (typeof RoleTemplateVersionScalarFieldEnum)[keyof typeof RoleTemplateVersionScalarFieldEnum]


  export const RoleTemplatePermissionScalarFieldEnum: {
    id: 'id',
    roleVersionId: 'roleVersionId',
    permissionId: 'permissionId',
    allowed: 'allowed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleTemplatePermissionScalarFieldEnum = (typeof RoleTemplatePermissionScalarFieldEnum)[keyof typeof RoleTemplatePermissionScalarFieldEnum]


  export const PolicyDefinitionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    type: 'type',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PolicyDefinitionScalarFieldEnum = (typeof PolicyDefinitionScalarFieldEnum)[keyof typeof PolicyDefinitionScalarFieldEnum]


  export const PolicyVersionScalarFieldEnum: {
    id: 'id',
    policyId: 'policyId',
    scope: 'scope',
    branchId: 'branchId',
    version: 'version',
    status: 'status',
    effectiveAt: 'effectiveAt',
    notes: 'notes',
    payload: 'payload',
    applyToAllBranches: 'applyToAllBranches',
    createdByUserId: 'createdByUserId',
    submittedAt: 'submittedAt',
    submittedByUserId: 'submittedByUserId',
    approvedAt: 'approvedAt',
    approvedByUserId: 'approvedByUserId',
    approvalNote: 'approvalNote',
    rejectedAt: 'rejectedAt',
    rejectedByUserId: 'rejectedByUserId',
    rejectionReason: 'rejectionReason',
    retiredAt: 'retiredAt',
    retiredByUserId: 'retiredByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PolicyVersionScalarFieldEnum = (typeof PolicyVersionScalarFieldEnum)[keyof typeof PolicyVersionScalarFieldEnum]


  export const PolicyVersionBranchScalarFieldEnum: {
    id: 'id',
    policyVersionId: 'policyVersionId',
    branchId: 'branchId',
    createdAt: 'createdAt'
  };

  export type PolicyVersionBranchScalarFieldEnum = (typeof PolicyVersionBranchScalarFieldEnum)[keyof typeof PolicyVersionBranchScalarFieldEnum]


  export const LocationNodeScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    kind: 'kind',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationNodeScalarFieldEnum = (typeof LocationNodeScalarFieldEnum)[keyof typeof LocationNodeScalarFieldEnum]


  export const LocationNodeRevisionScalarFieldEnum: {
    id: 'id',
    nodeId: 'nodeId',
    code: 'code',
    name: 'name',
    isActive: 'isActive',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt'
  };

  export type LocationNodeRevisionScalarFieldEnum = (typeof LocationNodeRevisionScalarFieldEnum)[keyof typeof LocationNodeRevisionScalarFieldEnum]


  export const UnitTypeCatalogScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    usesRoomsDefault: 'usesRoomsDefault',
    schedulableByDefault: 'schedulableByDefault',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitTypeCatalogScalarFieldEnum = (typeof UnitTypeCatalogScalarFieldEnum)[keyof typeof UnitTypeCatalogScalarFieldEnum]


  export const BranchUnitTypeScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    unitTypeId: 'unitTypeId',
    isEnabled: 'isEnabled',
    enabledAt: 'enabledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchUnitTypeScalarFieldEnum = (typeof BranchUnitTypeScalarFieldEnum)[keyof typeof BranchUnitTypeScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    departmentId: 'departmentId',
    unitTypeId: 'unitTypeId',
    code: 'code',
    name: 'name',
    usesRooms: 'usesRooms',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const UnitRoomScalarFieldEnum: {
    id: 'id',
    unitId: 'unitId',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitRoomScalarFieldEnum = (typeof UnitRoomScalarFieldEnum)[keyof typeof UnitRoomScalarFieldEnum]


  export const UnitResourceScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    unitId: 'unitId',
    roomId: 'roomId',
    resourceType: 'resourceType',
    code: 'code',
    name: 'name',
    state: 'state',
    isActive: 'isActive',
    isSchedulable: 'isSchedulable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitResourceScalarFieldEnum = (typeof UnitResourceScalarFieldEnum)[keyof typeof UnitResourceScalarFieldEnum]


  export const EquipmentAssetScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    category: 'category',
    make: 'make',
    model: 'model',
    serial: 'serial',
    ownerDepartmentId: 'ownerDepartmentId',
    unitId: 'unitId',
    roomId: 'roomId',
    locationNodeId: 'locationNodeId',
    operationalStatus: 'operationalStatus',
    amcVendor: 'amcVendor',
    amcValidFrom: 'amcValidFrom',
    amcValidTo: 'amcValidTo',
    warrantyValidTo: 'warrantyValidTo',
    pmFrequencyDays: 'pmFrequencyDays',
    nextPmDueAt: 'nextPmDueAt',
    aerbLicenseNo: 'aerbLicenseNo',
    aerbValidTo: 'aerbValidTo',
    pcpndtRegNo: 'pcpndtRegNo',
    pcpndtValidTo: 'pcpndtValidTo',
    isSchedulable: 'isSchedulable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentAssetScalarFieldEnum = (typeof EquipmentAssetScalarFieldEnum)[keyof typeof EquipmentAssetScalarFieldEnum]


  export const DowntimeTicketScalarFieldEnum: {
    id: 'id',
    assetId: 'assetId',
    status: 'status',
    reason: 'reason',
    notes: 'notes',
    openedAt: 'openedAt',
    closedAt: 'closedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DowntimeTicketScalarFieldEnum = (typeof DowntimeTicketScalarFieldEnum)[keyof typeof DowntimeTicketScalarFieldEnum]


  export const ChargeMasterItemScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    category: 'category',
    unit: 'unit',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChargeMasterItemScalarFieldEnum = (typeof ChargeMasterItemScalarFieldEnum)[keyof typeof ChargeMasterItemScalarFieldEnum]


  export const ServiceItemScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    category: 'category',
    unit: 'unit',
    isOrderable: 'isOrderable',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceItemScalarFieldEnum = (typeof ServiceItemScalarFieldEnum)[keyof typeof ServiceItemScalarFieldEnum]


  export const ServiceChargeMappingScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    serviceItemId: 'serviceItemId',
    chargeMasterItemId: 'chargeMasterItemId',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceChargeMappingScalarFieldEnum = (typeof ServiceChargeMappingScalarFieldEnum)[keyof typeof ServiceChargeMappingScalarFieldEnum]


  export const FixItTaskScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    type: 'type',
    status: 'status',
    title: 'title',
    details: 'details',
    serviceItemId: 'serviceItemId',
    assignedToUserId: 'assignedToUserId',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FixItTaskScalarFieldEnum = (typeof FixItTaskScalarFieldEnum)[keyof typeof FixItTaskScalarFieldEnum]


  export const BulkImportJobScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    entityType: 'entityType',
    status: 'status',
    fileName: 'fileName',
    payload: 'payload',
    errors: 'errors',
    totalRows: 'totalRows',
    validRows: 'validRows',
    invalidRows: 'invalidRows',
    createdByUserId: 'createdByUserId',
    committedAt: 'committedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BulkImportJobScalarFieldEnum = (typeof BulkImportJobScalarFieldEnum)[keyof typeof BulkImportJobScalarFieldEnum]


  export const ProcedureBookingScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    unitId: 'unitId',
    resourceId: 'resourceId',
    patientId: 'patientId',
    departmentId: 'departmentId',
    startAt: 'startAt',
    endAt: 'endAt',
    status: 'status',
    consentOk: 'consentOk',
    anesthesiaOk: 'anesthesiaOk',
    checklistOk: 'checklistOk',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProcedureBookingScalarFieldEnum = (typeof ProcedureBookingScalarFieldEnum)[keyof typeof ProcedureBookingScalarFieldEnum]


  export const GoLiveReportScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    score: 'score',
    blockers: 'blockers',
    warnings: 'warnings',
    snapshot: 'snapshot',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt'
  };

  export type GoLiveReportScalarFieldEnum = (typeof GoLiveReportScalarFieldEnum)[keyof typeof GoLiveReportScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'FacilityCategory'
   */
  export type EnumFacilityCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityCategory'>
    


  /**
   * Reference to a field of type 'FacilityCategory[]'
   */
  export type ListEnumFacilityCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FacilityCategory[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'EncounterType'
   */
  export type EnumEncounterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EncounterType'>
    


  /**
   * Reference to a field of type 'EncounterType[]'
   */
  export type ListEnumEncounterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EncounterType[]'>
    


  /**
   * Reference to a field of type 'BedState'
   */
  export type EnumBedStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BedState'>
    


  /**
   * Reference to a field of type 'BedState[]'
   */
  export type ListEnumBedStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BedState[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ConsentScope'
   */
  export type EnumConsentScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentScope'>
    


  /**
   * Reference to a field of type 'ConsentScope[]'
   */
  export type ListEnumConsentScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentScope[]'>
    


  /**
   * Reference to a field of type 'ConsentStatus'
   */
  export type EnumConsentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentStatus'>
    


  /**
   * Reference to a field of type 'ConsentStatus[]'
   */
  export type ListEnumConsentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentStatus[]'>
    


  /**
   * Reference to a field of type 'RtbfStatus'
   */
  export type EnumRtbfStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RtbfStatus'>
    


  /**
   * Reference to a field of type 'RtbfStatus[]'
   */
  export type ListEnumRtbfStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RtbfStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'OutboxStatus'
   */
  export type EnumOutboxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OutboxStatus'>
    


  /**
   * Reference to a field of type 'OutboxStatus[]'
   */
  export type ListEnumOutboxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OutboxStatus[]'>
    


  /**
   * Reference to a field of type 'RoleScope'
   */
  export type EnumRoleScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleScope'>
    


  /**
   * Reference to a field of type 'RoleScope[]'
   */
  export type ListEnumRoleScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleScope[]'>
    


  /**
   * Reference to a field of type 'RoleVersionStatus'
   */
  export type EnumRoleVersionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleVersionStatus'>
    


  /**
   * Reference to a field of type 'RoleVersionStatus[]'
   */
  export type ListEnumRoleVersionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleVersionStatus[]'>
    


  /**
   * Reference to a field of type 'PolicyScope'
   */
  export type EnumPolicyScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PolicyScope'>
    


  /**
   * Reference to a field of type 'PolicyScope[]'
   */
  export type ListEnumPolicyScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PolicyScope[]'>
    


  /**
   * Reference to a field of type 'PolicyVersionStatus'
   */
  export type EnumPolicyVersionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PolicyVersionStatus'>
    


  /**
   * Reference to a field of type 'PolicyVersionStatus[]'
   */
  export type ListEnumPolicyVersionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PolicyVersionStatus[]'>
    


  /**
   * Reference to a field of type 'LocationKind'
   */
  export type EnumLocationKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationKind'>
    


  /**
   * Reference to a field of type 'LocationKind[]'
   */
  export type ListEnumLocationKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationKind[]'>
    


  /**
   * Reference to a field of type 'UnitResourceType'
   */
  export type EnumUnitResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitResourceType'>
    


  /**
   * Reference to a field of type 'UnitResourceType[]'
   */
  export type ListEnumUnitResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitResourceType[]'>
    


  /**
   * Reference to a field of type 'UnitResourceState'
   */
  export type EnumUnitResourceStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitResourceState'>
    


  /**
   * Reference to a field of type 'UnitResourceState[]'
   */
  export type ListEnumUnitResourceStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitResourceState[]'>
    


  /**
   * Reference to a field of type 'EquipmentComplianceCategory'
   */
  export type EnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentComplianceCategory'>
    


  /**
   * Reference to a field of type 'EquipmentComplianceCategory[]'
   */
  export type ListEnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentComplianceCategory[]'>
    


  /**
   * Reference to a field of type 'EquipmentOperationalStatus'
   */
  export type EnumEquipmentOperationalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentOperationalStatus'>
    


  /**
   * Reference to a field of type 'EquipmentOperationalStatus[]'
   */
  export type ListEnumEquipmentOperationalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentOperationalStatus[]'>
    


  /**
   * Reference to a field of type 'DowntimeStatus'
   */
  export type EnumDowntimeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DowntimeStatus'>
    


  /**
   * Reference to a field of type 'DowntimeStatus[]'
   */
  export type ListEnumDowntimeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DowntimeStatus[]'>
    


  /**
   * Reference to a field of type 'FixItType'
   */
  export type EnumFixItTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FixItType'>
    


  /**
   * Reference to a field of type 'FixItType[]'
   */
  export type ListEnumFixItTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FixItType[]'>
    


  /**
   * Reference to a field of type 'FixItStatus'
   */
  export type EnumFixItStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FixItStatus'>
    


  /**
   * Reference to a field of type 'FixItStatus[]'
   */
  export type ListEnumFixItStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FixItStatus[]'>
    


  /**
   * Reference to a field of type 'ImportEntityType'
   */
  export type EnumImportEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportEntityType'>
    


  /**
   * Reference to a field of type 'ImportEntityType[]'
   */
  export type ListEnumImportEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportEntityType[]'>
    


  /**
   * Reference to a field of type 'ImportJobStatus'
   */
  export type EnumImportJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportJobStatus'>
    


  /**
   * Reference to a field of type 'ImportJobStatus[]'
   */
  export type ListEnumImportJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportJobStatus[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: StringFilter<"Branch"> | string
    code?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    city?: StringFilter<"Branch"> | string
    gstNumber?: StringNullableFilter<"Branch"> | string | null
    address?: StringNullableFilter<"Branch"> | string | null
    contactPhone1?: StringNullableFilter<"Branch"> | string | null
    contactPhone2?: StringNullableFilter<"Branch"> | string | null
    contactEmail?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    departments?: DepartmentListRelationFilter
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    wards?: WardListRelationFilter
    oTs?: OTListRelationFilter
    tariffPlans?: TariffPlanListRelationFilter
    assets?: AssetListRelationFilter
    Specialty?: SpecialtyListRelationFilter
    Staff?: StaffListRelationFilter
    Encounter?: EncounterListRelationFilter
    Bed?: BedListRelationFilter
    Admission?: AdmissionListRelationFilter
    branchFacilities?: BranchFacilityListRelationFilter
    rooms?: RoomListRelationFilter
    statutoryCases?: StatutoryCaseListRelationFilter
    auditEvents?: AuditEventListRelationFilter
    policyVersions?: PolicyVersionListRelationFilter
    policyVersionBranches?: PolicyVersionBranchListRelationFilter
    locationNodes?: LocationNodeListRelationFilter
    unitTypesEnabled?: BranchUnitTypeListRelationFilter
    units?: UnitListRelationFilter
    unitRooms?: UnitRoomListRelationFilter
    unitResources?: UnitResourceListRelationFilter
    equipmentAssets?: EquipmentAssetListRelationFilter
    serviceItems?: ServiceItemListRelationFilter
    chargeMasterItems?: ChargeMasterItemListRelationFilter
    serviceMappings?: ServiceChargeMappingListRelationFilter
    fixItTasks?: FixItTaskListRelationFilter
    importJobs?: BulkImportJobListRelationFilter
    procedureBookings?: ProcedureBookingListRelationFilter
    goLiveReports?: GoLiveReportListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    gstNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contactPhone1?: SortOrderInput | SortOrder
    contactPhone2?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departments?: DepartmentOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    patients?: PatientOrderByRelationAggregateInput
    wards?: WardOrderByRelationAggregateInput
    oTs?: OTOrderByRelationAggregateInput
    tariffPlans?: TariffPlanOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
    Specialty?: SpecialtyOrderByRelationAggregateInput
    Staff?: StaffOrderByRelationAggregateInput
    Encounter?: EncounterOrderByRelationAggregateInput
    Bed?: BedOrderByRelationAggregateInput
    Admission?: AdmissionOrderByRelationAggregateInput
    branchFacilities?: BranchFacilityOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    statutoryCases?: StatutoryCaseOrderByRelationAggregateInput
    auditEvents?: AuditEventOrderByRelationAggregateInput
    policyVersions?: PolicyVersionOrderByRelationAggregateInput
    policyVersionBranches?: PolicyVersionBranchOrderByRelationAggregateInput
    locationNodes?: LocationNodeOrderByRelationAggregateInput
    unitTypesEnabled?: BranchUnitTypeOrderByRelationAggregateInput
    units?: UnitOrderByRelationAggregateInput
    unitRooms?: UnitRoomOrderByRelationAggregateInput
    unitResources?: UnitResourceOrderByRelationAggregateInput
    equipmentAssets?: EquipmentAssetOrderByRelationAggregateInput
    serviceItems?: ServiceItemOrderByRelationAggregateInput
    chargeMasterItems?: ChargeMasterItemOrderByRelationAggregateInput
    serviceMappings?: ServiceChargeMappingOrderByRelationAggregateInput
    fixItTasks?: FixItTaskOrderByRelationAggregateInput
    importJobs?: BulkImportJobOrderByRelationAggregateInput
    procedureBookings?: ProcedureBookingOrderByRelationAggregateInput
    goLiveReports?: GoLiveReportOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    city?: StringFilter<"Branch"> | string
    gstNumber?: StringNullableFilter<"Branch"> | string | null
    address?: StringNullableFilter<"Branch"> | string | null
    contactPhone1?: StringNullableFilter<"Branch"> | string | null
    contactPhone2?: StringNullableFilter<"Branch"> | string | null
    contactEmail?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    departments?: DepartmentListRelationFilter
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    wards?: WardListRelationFilter
    oTs?: OTListRelationFilter
    tariffPlans?: TariffPlanListRelationFilter
    assets?: AssetListRelationFilter
    Specialty?: SpecialtyListRelationFilter
    Staff?: StaffListRelationFilter
    Encounter?: EncounterListRelationFilter
    Bed?: BedListRelationFilter
    Admission?: AdmissionListRelationFilter
    branchFacilities?: BranchFacilityListRelationFilter
    rooms?: RoomListRelationFilter
    statutoryCases?: StatutoryCaseListRelationFilter
    auditEvents?: AuditEventListRelationFilter
    policyVersions?: PolicyVersionListRelationFilter
    policyVersionBranches?: PolicyVersionBranchListRelationFilter
    locationNodes?: LocationNodeListRelationFilter
    unitTypesEnabled?: BranchUnitTypeListRelationFilter
    units?: UnitListRelationFilter
    unitRooms?: UnitRoomListRelationFilter
    unitResources?: UnitResourceListRelationFilter
    equipmentAssets?: EquipmentAssetListRelationFilter
    serviceItems?: ServiceItemListRelationFilter
    chargeMasterItems?: ChargeMasterItemListRelationFilter
    serviceMappings?: ServiceChargeMappingListRelationFilter
    fixItTasks?: FixItTaskListRelationFilter
    importJobs?: BulkImportJobListRelationFilter
    procedureBookings?: ProcedureBookingListRelationFilter
    goLiveReports?: GoLiveReportListRelationFilter
  }, "id" | "code">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    gstNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contactPhone1?: SortOrderInput | SortOrder
    contactPhone2?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Branch"> | string
    code?: StringWithAggregatesFilter<"Branch"> | string
    name?: StringWithAggregatesFilter<"Branch"> | string
    city?: StringWithAggregatesFilter<"Branch"> | string
    gstNumber?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    address?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    contactPhone1?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    contactPhone2?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type FacilityCatalogWhereInput = {
    AND?: FacilityCatalogWhereInput | FacilityCatalogWhereInput[]
    OR?: FacilityCatalogWhereInput[]
    NOT?: FacilityCatalogWhereInput | FacilityCatalogWhereInput[]
    id?: StringFilter<"FacilityCatalog"> | string
    code?: StringFilter<"FacilityCatalog"> | string
    name?: StringFilter<"FacilityCatalog"> | string
    category?: EnumFacilityCategoryFilter<"FacilityCatalog"> | $Enums.FacilityCategory
    isActive?: BoolFilter<"FacilityCatalog"> | boolean
    sortOrder?: IntFilter<"FacilityCatalog"> | number
    createdAt?: DateTimeFilter<"FacilityCatalog"> | Date | string
    updatedAt?: DateTimeFilter<"FacilityCatalog"> | Date | string
    branchLinks?: BranchFacilityListRelationFilter
    departments?: DepartmentListRelationFilter
  }

  export type FacilityCatalogOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchLinks?: BranchFacilityOrderByRelationAggregateInput
    departments?: DepartmentOrderByRelationAggregateInput
  }

  export type FacilityCatalogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: FacilityCatalogWhereInput | FacilityCatalogWhereInput[]
    OR?: FacilityCatalogWhereInput[]
    NOT?: FacilityCatalogWhereInput | FacilityCatalogWhereInput[]
    name?: StringFilter<"FacilityCatalog"> | string
    category?: EnumFacilityCategoryFilter<"FacilityCatalog"> | $Enums.FacilityCategory
    isActive?: BoolFilter<"FacilityCatalog"> | boolean
    sortOrder?: IntFilter<"FacilityCatalog"> | number
    createdAt?: DateTimeFilter<"FacilityCatalog"> | Date | string
    updatedAt?: DateTimeFilter<"FacilityCatalog"> | Date | string
    branchLinks?: BranchFacilityListRelationFilter
    departments?: DepartmentListRelationFilter
  }, "id" | "code">

  export type FacilityCatalogOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacilityCatalogCountOrderByAggregateInput
    _avg?: FacilityCatalogAvgOrderByAggregateInput
    _max?: FacilityCatalogMaxOrderByAggregateInput
    _min?: FacilityCatalogMinOrderByAggregateInput
    _sum?: FacilityCatalogSumOrderByAggregateInput
  }

  export type FacilityCatalogScalarWhereWithAggregatesInput = {
    AND?: FacilityCatalogScalarWhereWithAggregatesInput | FacilityCatalogScalarWhereWithAggregatesInput[]
    OR?: FacilityCatalogScalarWhereWithAggregatesInput[]
    NOT?: FacilityCatalogScalarWhereWithAggregatesInput | FacilityCatalogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FacilityCatalog"> | string
    code?: StringWithAggregatesFilter<"FacilityCatalog"> | string
    name?: StringWithAggregatesFilter<"FacilityCatalog"> | string
    category?: EnumFacilityCategoryWithAggregatesFilter<"FacilityCatalog"> | $Enums.FacilityCategory
    isActive?: BoolWithAggregatesFilter<"FacilityCatalog"> | boolean
    sortOrder?: IntWithAggregatesFilter<"FacilityCatalog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FacilityCatalog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FacilityCatalog"> | Date | string
  }

  export type BranchFacilityWhereInput = {
    AND?: BranchFacilityWhereInput | BranchFacilityWhereInput[]
    OR?: BranchFacilityWhereInput[]
    NOT?: BranchFacilityWhereInput | BranchFacilityWhereInput[]
    id?: StringFilter<"BranchFacility"> | string
    branchId?: StringFilter<"BranchFacility"> | string
    facilityId?: StringFilter<"BranchFacility"> | string
    isEnabled?: BoolFilter<"BranchFacility"> | boolean
    enabledAt?: DateTimeFilter<"BranchFacility"> | Date | string
    createdAt?: DateTimeFilter<"BranchFacility"> | Date | string
    updatedAt?: DateTimeFilter<"BranchFacility"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    facility?: XOR<FacilityCatalogRelationFilter, FacilityCatalogWhereInput>
  }

  export type BranchFacilityOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    facilityId?: SortOrder
    isEnabled?: SortOrder
    enabledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    facility?: FacilityCatalogOrderByWithRelationInput
  }

  export type BranchFacilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_facilityId?: BranchFacilityBranchIdFacilityIdCompoundUniqueInput
    AND?: BranchFacilityWhereInput | BranchFacilityWhereInput[]
    OR?: BranchFacilityWhereInput[]
    NOT?: BranchFacilityWhereInput | BranchFacilityWhereInput[]
    branchId?: StringFilter<"BranchFacility"> | string
    facilityId?: StringFilter<"BranchFacility"> | string
    isEnabled?: BoolFilter<"BranchFacility"> | boolean
    enabledAt?: DateTimeFilter<"BranchFacility"> | Date | string
    createdAt?: DateTimeFilter<"BranchFacility"> | Date | string
    updatedAt?: DateTimeFilter<"BranchFacility"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    facility?: XOR<FacilityCatalogRelationFilter, FacilityCatalogWhereInput>
  }, "id" | "branchId_facilityId">

  export type BranchFacilityOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    facilityId?: SortOrder
    isEnabled?: SortOrder
    enabledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchFacilityCountOrderByAggregateInput
    _max?: BranchFacilityMaxOrderByAggregateInput
    _min?: BranchFacilityMinOrderByAggregateInput
  }

  export type BranchFacilityScalarWhereWithAggregatesInput = {
    AND?: BranchFacilityScalarWhereWithAggregatesInput | BranchFacilityScalarWhereWithAggregatesInput[]
    OR?: BranchFacilityScalarWhereWithAggregatesInput[]
    NOT?: BranchFacilityScalarWhereWithAggregatesInput | BranchFacilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BranchFacility"> | string
    branchId?: StringWithAggregatesFilter<"BranchFacility"> | string
    facilityId?: StringWithAggregatesFilter<"BranchFacility"> | string
    isEnabled?: BoolWithAggregatesFilter<"BranchFacility"> | boolean
    enabledAt?: DateTimeWithAggregatesFilter<"BranchFacility"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"BranchFacility"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BranchFacility"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    branchId?: StringFilter<"Department"> | string
    facilityId?: StringFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    headStaffId?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    facility?: XOR<FacilityCatalogRelationFilter, FacilityCatalogWhereInput>
    headStaff?: XOR<StaffNullableRelationFilter, StaffWhereInput> | null
    staff?: StaffListRelationFilter
    departmentSpecialties?: DepartmentSpecialtyListRelationFilter
    doctorAssignments?: DepartmentDoctorListRelationFilter
    units?: UnitListRelationFilter
    equipmentOwned?: EquipmentAssetListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    facilityId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    headStaffId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    facility?: FacilityCatalogOrderByWithRelationInput
    headStaff?: StaffOrderByWithRelationInput
    staff?: StaffOrderByRelationAggregateInput
    departmentSpecialties?: DepartmentSpecialtyOrderByRelationAggregateInput
    doctorAssignments?: DepartmentDoctorOrderByRelationAggregateInput
    units?: UnitOrderByRelationAggregateInput
    equipmentOwned?: EquipmentAssetOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_facilityId_code?: DepartmentBranchIdFacilityIdCodeCompoundUniqueInput
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    branchId?: StringFilter<"Department"> | string
    facilityId?: StringFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    headStaffId?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    facility?: XOR<FacilityCatalogRelationFilter, FacilityCatalogWhereInput>
    headStaff?: XOR<StaffNullableRelationFilter, StaffWhereInput> | null
    staff?: StaffListRelationFilter
    departmentSpecialties?: DepartmentSpecialtyListRelationFilter
    doctorAssignments?: DepartmentDoctorListRelationFilter
    units?: UnitListRelationFilter
    equipmentOwned?: EquipmentAssetListRelationFilter
  }, "id" | "branchId_facilityId_code">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    facilityId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    headStaffId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    branchId?: StringWithAggregatesFilter<"Department"> | string
    facilityId?: StringWithAggregatesFilter<"Department"> | string
    code?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    headStaffId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    isActive?: BoolWithAggregatesFilter<"Department"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type DepartmentDoctorWhereInput = {
    AND?: DepartmentDoctorWhereInput | DepartmentDoctorWhereInput[]
    OR?: DepartmentDoctorWhereInput[]
    NOT?: DepartmentDoctorWhereInput | DepartmentDoctorWhereInput[]
    id?: StringFilter<"DepartmentDoctor"> | string
    departmentId?: StringFilter<"DepartmentDoctor"> | string
    staffId?: StringFilter<"DepartmentDoctor"> | string
    isPrimary?: BoolFilter<"DepartmentDoctor"> | boolean
    assignedAt?: DateTimeFilter<"DepartmentDoctor"> | Date | string
    createdAt?: DateTimeFilter<"DepartmentDoctor"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentDoctor"> | Date | string
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    staff?: XOR<StaffRelationFilter, StaffWhereInput>
  }

  export type DepartmentDoctorOrderByWithRelationInput = {
    id?: SortOrder
    departmentId?: SortOrder
    staffId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
  }

  export type DepartmentDoctorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    departmentId_staffId?: DepartmentDoctorDepartmentIdStaffIdCompoundUniqueInput
    AND?: DepartmentDoctorWhereInput | DepartmentDoctorWhereInput[]
    OR?: DepartmentDoctorWhereInput[]
    NOT?: DepartmentDoctorWhereInput | DepartmentDoctorWhereInput[]
    departmentId?: StringFilter<"DepartmentDoctor"> | string
    staffId?: StringFilter<"DepartmentDoctor"> | string
    isPrimary?: BoolFilter<"DepartmentDoctor"> | boolean
    assignedAt?: DateTimeFilter<"DepartmentDoctor"> | Date | string
    createdAt?: DateTimeFilter<"DepartmentDoctor"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentDoctor"> | Date | string
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    staff?: XOR<StaffRelationFilter, StaffWhereInput>
  }, "id" | "departmentId_staffId">

  export type DepartmentDoctorOrderByWithAggregationInput = {
    id?: SortOrder
    departmentId?: SortOrder
    staffId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentDoctorCountOrderByAggregateInput
    _max?: DepartmentDoctorMaxOrderByAggregateInput
    _min?: DepartmentDoctorMinOrderByAggregateInput
  }

  export type DepartmentDoctorScalarWhereWithAggregatesInput = {
    AND?: DepartmentDoctorScalarWhereWithAggregatesInput | DepartmentDoctorScalarWhereWithAggregatesInput[]
    OR?: DepartmentDoctorScalarWhereWithAggregatesInput[]
    NOT?: DepartmentDoctorScalarWhereWithAggregatesInput | DepartmentDoctorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepartmentDoctor"> | string
    departmentId?: StringWithAggregatesFilter<"DepartmentDoctor"> | string
    staffId?: StringWithAggregatesFilter<"DepartmentDoctor"> | string
    isPrimary?: BoolWithAggregatesFilter<"DepartmentDoctor"> | boolean
    assignedAt?: DateTimeWithAggregatesFilter<"DepartmentDoctor"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"DepartmentDoctor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DepartmentDoctor"> | Date | string
  }

  export type SpecialtyWhereInput = {
    AND?: SpecialtyWhereInput | SpecialtyWhereInput[]
    OR?: SpecialtyWhereInput[]
    NOT?: SpecialtyWhereInput | SpecialtyWhereInput[]
    id?: StringFilter<"Specialty"> | string
    branchId?: StringFilter<"Specialty"> | string
    code?: StringFilter<"Specialty"> | string
    name?: StringFilter<"Specialty"> | string
    isActive?: BoolFilter<"Specialty"> | boolean
    createdAt?: DateTimeFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeFilter<"Specialty"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    staff?: StaffListRelationFilter
    departmentLinks?: DepartmentSpecialtyListRelationFilter
  }

  export type SpecialtyOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    staff?: StaffOrderByRelationAggregateInput
    departmentLinks?: DepartmentSpecialtyOrderByRelationAggregateInput
  }

  export type SpecialtyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: SpecialtyBranchIdCodeCompoundUniqueInput
    AND?: SpecialtyWhereInput | SpecialtyWhereInput[]
    OR?: SpecialtyWhereInput[]
    NOT?: SpecialtyWhereInput | SpecialtyWhereInput[]
    branchId?: StringFilter<"Specialty"> | string
    code?: StringFilter<"Specialty"> | string
    name?: StringFilter<"Specialty"> | string
    isActive?: BoolFilter<"Specialty"> | boolean
    createdAt?: DateTimeFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeFilter<"Specialty"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    staff?: StaffListRelationFilter
    departmentLinks?: DepartmentSpecialtyListRelationFilter
  }, "id" | "branchId_code">

  export type SpecialtyOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpecialtyCountOrderByAggregateInput
    _max?: SpecialtyMaxOrderByAggregateInput
    _min?: SpecialtyMinOrderByAggregateInput
  }

  export type SpecialtyScalarWhereWithAggregatesInput = {
    AND?: SpecialtyScalarWhereWithAggregatesInput | SpecialtyScalarWhereWithAggregatesInput[]
    OR?: SpecialtyScalarWhereWithAggregatesInput[]
    NOT?: SpecialtyScalarWhereWithAggregatesInput | SpecialtyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Specialty"> | string
    branchId?: StringWithAggregatesFilter<"Specialty"> | string
    code?: StringWithAggregatesFilter<"Specialty"> | string
    name?: StringWithAggregatesFilter<"Specialty"> | string
    isActive?: BoolWithAggregatesFilter<"Specialty"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Specialty"> | Date | string
  }

  export type DepartmentSpecialtyWhereInput = {
    AND?: DepartmentSpecialtyWhereInput | DepartmentSpecialtyWhereInput[]
    OR?: DepartmentSpecialtyWhereInput[]
    NOT?: DepartmentSpecialtyWhereInput | DepartmentSpecialtyWhereInput[]
    id?: StringFilter<"DepartmentSpecialty"> | string
    departmentId?: StringFilter<"DepartmentSpecialty"> | string
    specialtyId?: StringFilter<"DepartmentSpecialty"> | string
    isPrimary?: BoolFilter<"DepartmentSpecialty"> | boolean
    isActive?: BoolFilter<"DepartmentSpecialty"> | boolean
    createdAt?: DateTimeFilter<"DepartmentSpecialty"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentSpecialty"> | Date | string
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    specialty?: XOR<SpecialtyRelationFilter, SpecialtyWhereInput>
  }

  export type DepartmentSpecialtyOrderByWithRelationInput = {
    id?: SortOrder
    departmentId?: SortOrder
    specialtyId?: SortOrder
    isPrimary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
  }

  export type DepartmentSpecialtyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    departmentId_specialtyId?: DepartmentSpecialtyDepartmentIdSpecialtyIdCompoundUniqueInput
    AND?: DepartmentSpecialtyWhereInput | DepartmentSpecialtyWhereInput[]
    OR?: DepartmentSpecialtyWhereInput[]
    NOT?: DepartmentSpecialtyWhereInput | DepartmentSpecialtyWhereInput[]
    departmentId?: StringFilter<"DepartmentSpecialty"> | string
    specialtyId?: StringFilter<"DepartmentSpecialty"> | string
    isPrimary?: BoolFilter<"DepartmentSpecialty"> | boolean
    isActive?: BoolFilter<"DepartmentSpecialty"> | boolean
    createdAt?: DateTimeFilter<"DepartmentSpecialty"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentSpecialty"> | Date | string
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    specialty?: XOR<SpecialtyRelationFilter, SpecialtyWhereInput>
  }, "id" | "departmentId_specialtyId">

  export type DepartmentSpecialtyOrderByWithAggregationInput = {
    id?: SortOrder
    departmentId?: SortOrder
    specialtyId?: SortOrder
    isPrimary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentSpecialtyCountOrderByAggregateInput
    _max?: DepartmentSpecialtyMaxOrderByAggregateInput
    _min?: DepartmentSpecialtyMinOrderByAggregateInput
  }

  export type DepartmentSpecialtyScalarWhereWithAggregatesInput = {
    AND?: DepartmentSpecialtyScalarWhereWithAggregatesInput | DepartmentSpecialtyScalarWhereWithAggregatesInput[]
    OR?: DepartmentSpecialtyScalarWhereWithAggregatesInput[]
    NOT?: DepartmentSpecialtyScalarWhereWithAggregatesInput | DepartmentSpecialtyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepartmentSpecialty"> | string
    departmentId?: StringWithAggregatesFilter<"DepartmentSpecialty"> | string
    specialtyId?: StringWithAggregatesFilter<"DepartmentSpecialty"> | string
    isPrimary?: BoolWithAggregatesFilter<"DepartmentSpecialty"> | boolean
    isActive?: BoolWithAggregatesFilter<"DepartmentSpecialty"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DepartmentSpecialty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DepartmentSpecialty"> | Date | string
  }

  export type StaffWhereInput = {
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    id?: StringFilter<"Staff"> | string
    branchId?: StringFilter<"Staff"> | string
    departmentId?: StringNullableFilter<"Staff"> | string | null
    specialtyId?: StringNullableFilter<"Staff"> | string | null
    empCode?: StringFilter<"Staff"> | string
    name?: StringFilter<"Staff"> | string
    designation?: StringFilter<"Staff"> | string
    phone?: StringNullableFilter<"Staff"> | string | null
    email?: StringNullableFilter<"Staff"> | string | null
    isActive?: BoolFilter<"Staff"> | boolean
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    specialty?: XOR<SpecialtyNullableRelationFilter, SpecialtyWhereInput> | null
    doctorAssignments?: DepartmentDoctorListRelationFilter
    headedDepartments?: DepartmentListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    specialtyId?: SortOrderInput | SortOrder
    empCode?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
    doctorAssignments?: DepartmentDoctorOrderByRelationAggregateInput
    headedDepartments?: DepartmentOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type StaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_empCode?: StaffBranchIdEmpCodeCompoundUniqueInput
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    branchId?: StringFilter<"Staff"> | string
    departmentId?: StringNullableFilter<"Staff"> | string | null
    specialtyId?: StringNullableFilter<"Staff"> | string | null
    empCode?: StringFilter<"Staff"> | string
    name?: StringFilter<"Staff"> | string
    designation?: StringFilter<"Staff"> | string
    phone?: StringNullableFilter<"Staff"> | string | null
    email?: StringNullableFilter<"Staff"> | string | null
    isActive?: BoolFilter<"Staff"> | boolean
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    specialty?: XOR<SpecialtyNullableRelationFilter, SpecialtyWhereInput> | null
    doctorAssignments?: DepartmentDoctorListRelationFilter
    headedDepartments?: DepartmentListRelationFilter
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "branchId_empCode">

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    specialtyId?: SortOrderInput | SortOrder
    empCode?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    OR?: StaffScalarWhereWithAggregatesInput[]
    NOT?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Staff"> | string
    branchId?: StringWithAggregatesFilter<"Staff"> | string
    departmentId?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    specialtyId?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    empCode?: StringWithAggregatesFilter<"Staff"> | string
    name?: StringWithAggregatesFilter<"Staff"> | string
    designation?: StringWithAggregatesFilter<"Staff"> | string
    phone?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    email?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    isActive?: BoolWithAggregatesFilter<"Staff"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    branchId?: StringNullableFilter<"User"> | string | null
    staffId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    passwordHash?: StringNullableFilter<"User"> | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    roleVersionId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    staff?: XOR<StaffNullableRelationFilter, StaffWhereInput> | null
    roleVersion?: XOR<RoleTemplateVersionNullableRelationFilter, RoleTemplateVersionWhereInput> | null
    createdRoleVersions?: RoleTemplateVersionListRelationFilter
    auditEventsAsActor?: AuditEventListRelationFilter
    policyVersionsCreatedBy?: PolicyVersionListRelationFilter
    policyVersionsSubmittedBy?: PolicyVersionListRelationFilter
    policyVersionsApprovedBy?: PolicyVersionListRelationFilter
    policyVersionsRejectedBy?: PolicyVersionListRelationFilter
    policyVersionsRetiredBy?: PolicyVersionListRelationFilter
    createdLocationRevisions?: LocationNodeRevisionListRelationFilter
    createdImportJobs?: BulkImportJobListRelationFilter
    assignedFixIts?: FixItTaskListRelationFilter
    createdBookings?: ProcedureBookingListRelationFilter
    createdGoLiveReports?: GoLiveReportListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    mustChangePassword?: SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    roleVersionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
    roleVersion?: RoleTemplateVersionOrderByWithRelationInput
    createdRoleVersions?: RoleTemplateVersionOrderByRelationAggregateInput
    auditEventsAsActor?: AuditEventOrderByRelationAggregateInput
    policyVersionsCreatedBy?: PolicyVersionOrderByRelationAggregateInput
    policyVersionsSubmittedBy?: PolicyVersionOrderByRelationAggregateInput
    policyVersionsApprovedBy?: PolicyVersionOrderByRelationAggregateInput
    policyVersionsRejectedBy?: PolicyVersionOrderByRelationAggregateInput
    policyVersionsRetiredBy?: PolicyVersionOrderByRelationAggregateInput
    createdLocationRevisions?: LocationNodeRevisionOrderByRelationAggregateInput
    createdImportJobs?: BulkImportJobOrderByRelationAggregateInput
    assignedFixIts?: FixItTaskOrderByRelationAggregateInput
    createdBookings?: ProcedureBookingOrderByRelationAggregateInput
    createdGoLiveReports?: GoLiveReportOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    staffId?: string
    passwordResetToken?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    branchId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    passwordHash?: StringNullableFilter<"User"> | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    roleVersionId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    staff?: XOR<StaffNullableRelationFilter, StaffWhereInput> | null
    roleVersion?: XOR<RoleTemplateVersionNullableRelationFilter, RoleTemplateVersionWhereInput> | null
    createdRoleVersions?: RoleTemplateVersionListRelationFilter
    auditEventsAsActor?: AuditEventListRelationFilter
    policyVersionsCreatedBy?: PolicyVersionListRelationFilter
    policyVersionsSubmittedBy?: PolicyVersionListRelationFilter
    policyVersionsApprovedBy?: PolicyVersionListRelationFilter
    policyVersionsRejectedBy?: PolicyVersionListRelationFilter
    policyVersionsRetiredBy?: PolicyVersionListRelationFilter
    createdLocationRevisions?: LocationNodeRevisionListRelationFilter
    createdImportJobs?: BulkImportJobListRelationFilter
    assignedFixIts?: FixItTaskListRelationFilter
    createdBookings?: ProcedureBookingListRelationFilter
    createdGoLiveReports?: GoLiveReportListRelationFilter
  }, "id" | "email" | "staffId" | "passwordResetToken">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    mustChangePassword?: SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    roleVersionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"User"> | string | null
    staffId?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    mustChangePassword?: BoolWithAggregatesFilter<"User"> | boolean
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    roleVersionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    branchId?: StringFilter<"Patient"> | string
    uhid?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    dob?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounters?: EncounterListRelationFilter
    Admission?: AdmissionListRelationFilter
    consentRecords?: ConsentRecordListRelationFilter
    rtbfRequests?: RtbfRequestListRelationFilter
    statutoryCases?: StatutoryCaseListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    uhid?: SortOrder
    name?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
    Admission?: AdmissionOrderByRelationAggregateInput
    consentRecords?: ConsentRecordOrderByRelationAggregateInput
    rtbfRequests?: RtbfRequestOrderByRelationAggregateInput
    statutoryCases?: StatutoryCaseOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_uhid?: PatientBranchIdUhidCompoundUniqueInput
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    branchId?: StringFilter<"Patient"> | string
    uhid?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    dob?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounters?: EncounterListRelationFilter
    Admission?: AdmissionListRelationFilter
    consentRecords?: ConsentRecordListRelationFilter
    rtbfRequests?: RtbfRequestListRelationFilter
    statutoryCases?: StatutoryCaseListRelationFilter
  }, "id" | "branchId_uhid">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    uhid?: SortOrder
    name?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    branchId?: StringWithAggregatesFilter<"Patient"> | string
    uhid?: StringWithAggregatesFilter<"Patient"> | string
    name?: StringWithAggregatesFilter<"Patient"> | string
    gender?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    email?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    address?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type EncounterWhereInput = {
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    id?: StringFilter<"Encounter"> | string
    branchId?: StringFilter<"Encounter"> | string
    patientId?: StringFilter<"Encounter"> | string
    type?: EnumEncounterTypeFilter<"Encounter"> | $Enums.EncounterType
    startedAt?: DateTimeFilter<"Encounter"> | Date | string
    endedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    status?: StringFilter<"Encounter"> | string
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    admissions?: AdmissionListRelationFilter
  }

  export type EncounterOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    admissions?: AdmissionOrderByRelationAggregateInput
  }

  export type EncounterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    branchId?: StringFilter<"Encounter"> | string
    patientId?: StringFilter<"Encounter"> | string
    type?: EnumEncounterTypeFilter<"Encounter"> | $Enums.EncounterType
    startedAt?: DateTimeFilter<"Encounter"> | Date | string
    endedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    status?: StringFilter<"Encounter"> | string
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    admissions?: AdmissionListRelationFilter
  }, "id">

  export type EncounterOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EncounterCountOrderByAggregateInput
    _max?: EncounterMaxOrderByAggregateInput
    _min?: EncounterMinOrderByAggregateInput
  }

  export type EncounterScalarWhereWithAggregatesInput = {
    AND?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    OR?: EncounterScalarWhereWithAggregatesInput[]
    NOT?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Encounter"> | string
    branchId?: StringWithAggregatesFilter<"Encounter"> | string
    patientId?: StringWithAggregatesFilter<"Encounter"> | string
    type?: EnumEncounterTypeWithAggregatesFilter<"Encounter"> | $Enums.EncounterType
    startedAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
    status?: StringWithAggregatesFilter<"Encounter"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
  }

  export type WardWhereInput = {
    AND?: WardWhereInput | WardWhereInput[]
    OR?: WardWhereInput[]
    NOT?: WardWhereInput | WardWhereInput[]
    id?: StringFilter<"Ward"> | string
    branchId?: StringFilter<"Ward"> | string
    code?: StringFilter<"Ward"> | string
    name?: StringFilter<"Ward"> | string
    specialty?: StringNullableFilter<"Ward"> | string | null
    isActive?: BoolFilter<"Ward"> | boolean
    createdAt?: DateTimeFilter<"Ward"> | Date | string
    updatedAt?: DateTimeFilter<"Ward"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    rooms?: RoomListRelationFilter
  }

  export type WardOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    specialty?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    rooms?: RoomOrderByRelationAggregateInput
  }

  export type WardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: WardBranchIdCodeCompoundUniqueInput
    AND?: WardWhereInput | WardWhereInput[]
    OR?: WardWhereInput[]
    NOT?: WardWhereInput | WardWhereInput[]
    branchId?: StringFilter<"Ward"> | string
    code?: StringFilter<"Ward"> | string
    name?: StringFilter<"Ward"> | string
    specialty?: StringNullableFilter<"Ward"> | string | null
    isActive?: BoolFilter<"Ward"> | boolean
    createdAt?: DateTimeFilter<"Ward"> | Date | string
    updatedAt?: DateTimeFilter<"Ward"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    rooms?: RoomListRelationFilter
  }, "id" | "branchId_code">

  export type WardOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    specialty?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WardCountOrderByAggregateInput
    _max?: WardMaxOrderByAggregateInput
    _min?: WardMinOrderByAggregateInput
  }

  export type WardScalarWhereWithAggregatesInput = {
    AND?: WardScalarWhereWithAggregatesInput | WardScalarWhereWithAggregatesInput[]
    OR?: WardScalarWhereWithAggregatesInput[]
    NOT?: WardScalarWhereWithAggregatesInput | WardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ward"> | string
    branchId?: StringWithAggregatesFilter<"Ward"> | string
    code?: StringWithAggregatesFilter<"Ward"> | string
    name?: StringWithAggregatesFilter<"Ward"> | string
    specialty?: StringNullableWithAggregatesFilter<"Ward"> | string | null
    isActive?: BoolWithAggregatesFilter<"Ward"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Ward"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ward"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    branchId?: StringFilter<"Room"> | string
    wardId?: StringFilter<"Room"> | string
    code?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    floor?: StringNullableFilter<"Room"> | string | null
    type?: StringNullableFilter<"Room"> | string | null
    isActive?: BoolFilter<"Room"> | boolean
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    ward?: XOR<WardRelationFilter, WardWhereInput>
    beds?: BedListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    wardId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    floor?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    ward?: WardOrderByWithRelationInput
    beds?: BedOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    wardId_code?: RoomWardIdCodeCompoundUniqueInput
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    branchId?: StringFilter<"Room"> | string
    wardId?: StringFilter<"Room"> | string
    code?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    floor?: StringNullableFilter<"Room"> | string | null
    type?: StringNullableFilter<"Room"> | string | null
    isActive?: BoolFilter<"Room"> | boolean
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    ward?: XOR<WardRelationFilter, WardWhereInput>
    beds?: BedListRelationFilter
  }, "id" | "wardId_code">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    wardId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    floor?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    branchId?: StringWithAggregatesFilter<"Room"> | string
    wardId?: StringWithAggregatesFilter<"Room"> | string
    code?: StringWithAggregatesFilter<"Room"> | string
    name?: StringWithAggregatesFilter<"Room"> | string
    floor?: StringNullableWithAggregatesFilter<"Room"> | string | null
    type?: StringNullableWithAggregatesFilter<"Room"> | string | null
    isActive?: BoolWithAggregatesFilter<"Room"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type BedWhereInput = {
    AND?: BedWhereInput | BedWhereInput[]
    OR?: BedWhereInput[]
    NOT?: BedWhereInput | BedWhereInput[]
    id?: StringFilter<"Bed"> | string
    branchId?: StringFilter<"Bed"> | string
    roomId?: StringFilter<"Bed"> | string
    code?: StringFilter<"Bed"> | string
    state?: EnumBedStateFilter<"Bed"> | $Enums.BedState
    isActive?: BoolFilter<"Bed"> | boolean
    createdAt?: DateTimeFilter<"Bed"> | Date | string
    updatedAt?: DateTimeFilter<"Bed"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    admissions?: AdmissionListRelationFilter
  }

  export type BedOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    roomId?: SortOrder
    code?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    admissions?: AdmissionOrderByRelationAggregateInput
  }

  export type BedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roomId_code?: BedRoomIdCodeCompoundUniqueInput
    AND?: BedWhereInput | BedWhereInput[]
    OR?: BedWhereInput[]
    NOT?: BedWhereInput | BedWhereInput[]
    branchId?: StringFilter<"Bed"> | string
    roomId?: StringFilter<"Bed"> | string
    code?: StringFilter<"Bed"> | string
    state?: EnumBedStateFilter<"Bed"> | $Enums.BedState
    isActive?: BoolFilter<"Bed"> | boolean
    createdAt?: DateTimeFilter<"Bed"> | Date | string
    updatedAt?: DateTimeFilter<"Bed"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    admissions?: AdmissionListRelationFilter
  }, "id" | "roomId_code">

  export type BedOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    roomId?: SortOrder
    code?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BedCountOrderByAggregateInput
    _max?: BedMaxOrderByAggregateInput
    _min?: BedMinOrderByAggregateInput
  }

  export type BedScalarWhereWithAggregatesInput = {
    AND?: BedScalarWhereWithAggregatesInput | BedScalarWhereWithAggregatesInput[]
    OR?: BedScalarWhereWithAggregatesInput[]
    NOT?: BedScalarWhereWithAggregatesInput | BedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bed"> | string
    branchId?: StringWithAggregatesFilter<"Bed"> | string
    roomId?: StringWithAggregatesFilter<"Bed"> | string
    code?: StringWithAggregatesFilter<"Bed"> | string
    state?: EnumBedStateWithAggregatesFilter<"Bed"> | $Enums.BedState
    isActive?: BoolWithAggregatesFilter<"Bed"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Bed"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bed"> | Date | string
  }

  export type AdmissionWhereInput = {
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    id?: StringFilter<"Admission"> | string
    branchId?: StringFilter<"Admission"> | string
    encounterId?: StringNullableFilter<"Admission"> | string | null
    patientId?: StringFilter<"Admission"> | string
    bedId?: StringNullableFilter<"Admission"> | string | null
    admittedAt?: DateTimeFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"Admission"> | Date | string | null
    status?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounter?: XOR<EncounterNullableRelationFilter, EncounterWhereInput> | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    bed?: XOR<BedNullableRelationFilter, BedWhereInput> | null
  }

  export type AdmissionOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    bedId?: SortOrderInput | SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    bed?: BedOrderByWithRelationInput
  }

  export type AdmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    branchId?: StringFilter<"Admission"> | string
    encounterId?: StringNullableFilter<"Admission"> | string | null
    patientId?: StringFilter<"Admission"> | string
    bedId?: StringNullableFilter<"Admission"> | string | null
    admittedAt?: DateTimeFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"Admission"> | Date | string | null
    status?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounter?: XOR<EncounterNullableRelationFilter, EncounterWhereInput> | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    bed?: XOR<BedNullableRelationFilter, BedWhereInput> | null
  }, "id">

  export type AdmissionOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    bedId?: SortOrderInput | SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdmissionCountOrderByAggregateInput
    _max?: AdmissionMaxOrderByAggregateInput
    _min?: AdmissionMinOrderByAggregateInput
  }

  export type AdmissionScalarWhereWithAggregatesInput = {
    AND?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    OR?: AdmissionScalarWhereWithAggregatesInput[]
    NOT?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admission"> | string
    branchId?: StringWithAggregatesFilter<"Admission"> | string
    encounterId?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    patientId?: StringWithAggregatesFilter<"Admission"> | string
    bedId?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    admittedAt?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableWithAggregatesFilter<"Admission"> | Date | string | null
    status?: StringWithAggregatesFilter<"Admission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
  }

  export type OTWhereInput = {
    AND?: OTWhereInput | OTWhereInput[]
    OR?: OTWhereInput[]
    NOT?: OTWhereInput | OTWhereInput[]
    id?: StringFilter<"OT"> | string
    branchId?: StringFilter<"OT"> | string
    code?: StringFilter<"OT"> | string
    name?: StringFilter<"OT"> | string
    isActive?: BoolFilter<"OT"> | boolean
    createdAt?: DateTimeFilter<"OT"> | Date | string
    updatedAt?: DateTimeFilter<"OT"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type OTOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type OTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: OTBranchIdCodeCompoundUniqueInput
    AND?: OTWhereInput | OTWhereInput[]
    OR?: OTWhereInput[]
    NOT?: OTWhereInput | OTWhereInput[]
    branchId?: StringFilter<"OT"> | string
    code?: StringFilter<"OT"> | string
    name?: StringFilter<"OT"> | string
    isActive?: BoolFilter<"OT"> | boolean
    createdAt?: DateTimeFilter<"OT"> | Date | string
    updatedAt?: DateTimeFilter<"OT"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "branchId_code">

  export type OTOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OTCountOrderByAggregateInput
    _max?: OTMaxOrderByAggregateInput
    _min?: OTMinOrderByAggregateInput
  }

  export type OTScalarWhereWithAggregatesInput = {
    AND?: OTScalarWhereWithAggregatesInput | OTScalarWhereWithAggregatesInput[]
    OR?: OTScalarWhereWithAggregatesInput[]
    NOT?: OTScalarWhereWithAggregatesInput | OTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OT"> | string
    branchId?: StringWithAggregatesFilter<"OT"> | string
    code?: StringWithAggregatesFilter<"OT"> | string
    name?: StringWithAggregatesFilter<"OT"> | string
    isActive?: BoolWithAggregatesFilter<"OT"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OT"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OT"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: StringFilter<"Asset"> | string
    branchId?: StringFilter<"Asset"> | string
    code?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    category?: StringFilter<"Asset"> | string
    location?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: AssetBranchIdCodeCompoundUniqueInput
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    branchId?: StringFilter<"Asset"> | string
    code?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    category?: StringFilter<"Asset"> | string
    location?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "branchId_code">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asset"> | string
    branchId?: StringWithAggregatesFilter<"Asset"> | string
    code?: StringWithAggregatesFilter<"Asset"> | string
    name?: StringWithAggregatesFilter<"Asset"> | string
    category?: StringWithAggregatesFilter<"Asset"> | string
    location?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    status?: StringWithAggregatesFilter<"Asset"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
  }

  export type TariffPlanWhereInput = {
    AND?: TariffPlanWhereInput | TariffPlanWhereInput[]
    OR?: TariffPlanWhereInput[]
    NOT?: TariffPlanWhereInput | TariffPlanWhereInput[]
    id?: StringFilter<"TariffPlan"> | string
    branchId?: StringFilter<"TariffPlan"> | string
    code?: StringFilter<"TariffPlan"> | string
    name?: StringFilter<"TariffPlan"> | string
    status?: StringFilter<"TariffPlan"> | string
    payerType?: StringFilter<"TariffPlan"> | string
    effectiveFrom?: DateTimeFilter<"TariffPlan"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TariffPlan"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    rates?: TariffRateListRelationFilter
  }

  export type TariffPlanOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    payerType?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    rates?: TariffRateOrderByRelationAggregateInput
  }

  export type TariffPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: TariffPlanBranchIdCodeCompoundUniqueInput
    AND?: TariffPlanWhereInput | TariffPlanWhereInput[]
    OR?: TariffPlanWhereInput[]
    NOT?: TariffPlanWhereInput | TariffPlanWhereInput[]
    branchId?: StringFilter<"TariffPlan"> | string
    code?: StringFilter<"TariffPlan"> | string
    name?: StringFilter<"TariffPlan"> | string
    status?: StringFilter<"TariffPlan"> | string
    payerType?: StringFilter<"TariffPlan"> | string
    effectiveFrom?: DateTimeFilter<"TariffPlan"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TariffPlan"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    rates?: TariffRateListRelationFilter
  }, "id" | "branchId_code">

  export type TariffPlanOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    payerType?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TariffPlanCountOrderByAggregateInput
    _max?: TariffPlanMaxOrderByAggregateInput
    _min?: TariffPlanMinOrderByAggregateInput
  }

  export type TariffPlanScalarWhereWithAggregatesInput = {
    AND?: TariffPlanScalarWhereWithAggregatesInput | TariffPlanScalarWhereWithAggregatesInput[]
    OR?: TariffPlanScalarWhereWithAggregatesInput[]
    NOT?: TariffPlanScalarWhereWithAggregatesInput | TariffPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TariffPlan"> | string
    branchId?: StringWithAggregatesFilter<"TariffPlan"> | string
    code?: StringWithAggregatesFilter<"TariffPlan"> | string
    name?: StringWithAggregatesFilter<"TariffPlan"> | string
    status?: StringWithAggregatesFilter<"TariffPlan"> | string
    payerType?: StringWithAggregatesFilter<"TariffPlan"> | string
    effectiveFrom?: DateTimeWithAggregatesFilter<"TariffPlan"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"TariffPlan"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TariffPlan"> | Date | string
  }

  export type ServiceCatalogItemWhereInput = {
    AND?: ServiceCatalogItemWhereInput | ServiceCatalogItemWhereInput[]
    OR?: ServiceCatalogItemWhereInput[]
    NOT?: ServiceCatalogItemWhereInput | ServiceCatalogItemWhereInput[]
    id?: StringFilter<"ServiceCatalogItem"> | string
    code?: StringFilter<"ServiceCatalogItem"> | string
    name?: StringFilter<"ServiceCatalogItem"> | string
    category?: StringFilter<"ServiceCatalogItem"> | string
    unit?: StringNullableFilter<"ServiceCatalogItem"> | string | null
    createdAt?: DateTimeFilter<"ServiceCatalogItem"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCatalogItem"> | Date | string
  }

  export type ServiceCatalogItemOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCatalogItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ServiceCatalogItemWhereInput | ServiceCatalogItemWhereInput[]
    OR?: ServiceCatalogItemWhereInput[]
    NOT?: ServiceCatalogItemWhereInput | ServiceCatalogItemWhereInput[]
    name?: StringFilter<"ServiceCatalogItem"> | string
    category?: StringFilter<"ServiceCatalogItem"> | string
    unit?: StringNullableFilter<"ServiceCatalogItem"> | string | null
    createdAt?: DateTimeFilter<"ServiceCatalogItem"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCatalogItem"> | Date | string
  }, "id" | "code">

  export type ServiceCatalogItemOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCatalogItemCountOrderByAggregateInput
    _max?: ServiceCatalogItemMaxOrderByAggregateInput
    _min?: ServiceCatalogItemMinOrderByAggregateInput
  }

  export type ServiceCatalogItemScalarWhereWithAggregatesInput = {
    AND?: ServiceCatalogItemScalarWhereWithAggregatesInput | ServiceCatalogItemScalarWhereWithAggregatesInput[]
    OR?: ServiceCatalogItemScalarWhereWithAggregatesInput[]
    NOT?: ServiceCatalogItemScalarWhereWithAggregatesInput | ServiceCatalogItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceCatalogItem"> | string
    code?: StringWithAggregatesFilter<"ServiceCatalogItem"> | string
    name?: StringWithAggregatesFilter<"ServiceCatalogItem"> | string
    category?: StringWithAggregatesFilter<"ServiceCatalogItem"> | string
    unit?: StringNullableWithAggregatesFilter<"ServiceCatalogItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceCatalogItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceCatalogItem"> | Date | string
  }

  export type TariffRateWhereInput = {
    AND?: TariffRateWhereInput | TariffRateWhereInput[]
    OR?: TariffRateWhereInput[]
    NOT?: TariffRateWhereInput | TariffRateWhereInput[]
    id?: StringFilter<"TariffRate"> | string
    tariffPlanId?: StringFilter<"TariffRate"> | string
    serviceCode?: StringFilter<"TariffRate"> | string
    amount?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeFilter<"TariffRate"> | Date | string
    tariffPlan?: XOR<TariffPlanRelationFilter, TariffPlanWhereInput>
  }

  export type TariffRateOrderByWithRelationInput = {
    id?: SortOrder
    tariffPlanId?: SortOrder
    serviceCode?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tariffPlan?: TariffPlanOrderByWithRelationInput
  }

  export type TariffRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tariffPlanId_serviceCode?: TariffRateTariffPlanIdServiceCodeCompoundUniqueInput
    AND?: TariffRateWhereInput | TariffRateWhereInput[]
    OR?: TariffRateWhereInput[]
    NOT?: TariffRateWhereInput | TariffRateWhereInput[]
    tariffPlanId?: StringFilter<"TariffRate"> | string
    serviceCode?: StringFilter<"TariffRate"> | string
    amount?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeFilter<"TariffRate"> | Date | string
    tariffPlan?: XOR<TariffPlanRelationFilter, TariffPlanWhereInput>
  }, "id" | "tariffPlanId_serviceCode">

  export type TariffRateOrderByWithAggregationInput = {
    id?: SortOrder
    tariffPlanId?: SortOrder
    serviceCode?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TariffRateCountOrderByAggregateInput
    _avg?: TariffRateAvgOrderByAggregateInput
    _max?: TariffRateMaxOrderByAggregateInput
    _min?: TariffRateMinOrderByAggregateInput
    _sum?: TariffRateSumOrderByAggregateInput
  }

  export type TariffRateScalarWhereWithAggregatesInput = {
    AND?: TariffRateScalarWhereWithAggregatesInput | TariffRateScalarWhereWithAggregatesInput[]
    OR?: TariffRateScalarWhereWithAggregatesInput[]
    NOT?: TariffRateScalarWhereWithAggregatesInput | TariffRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TariffRate"> | string
    tariffPlanId?: StringWithAggregatesFilter<"TariffRate"> | string
    serviceCode?: StringWithAggregatesFilter<"TariffRate"> | string
    amount?: DecimalWithAggregatesFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TariffRate"> | Date | string
  }

  export type ConsentRecordWhereInput = {
    AND?: ConsentRecordWhereInput | ConsentRecordWhereInput[]
    OR?: ConsentRecordWhereInput[]
    NOT?: ConsentRecordWhereInput | ConsentRecordWhereInput[]
    id?: StringFilter<"ConsentRecord"> | string
    patientId?: StringFilter<"ConsentRecord"> | string
    scope?: EnumConsentScopeFilter<"ConsentRecord"> | $Enums.ConsentScope
    purpose?: StringFilter<"ConsentRecord"> | string
    status?: EnumConsentStatusFilter<"ConsentRecord"> | $Enums.ConsentStatus
    createdAt?: DateTimeFilter<"ConsentRecord"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type ConsentRecordOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    scope?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type ConsentRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsentRecordWhereInput | ConsentRecordWhereInput[]
    OR?: ConsentRecordWhereInput[]
    NOT?: ConsentRecordWhereInput | ConsentRecordWhereInput[]
    patientId?: StringFilter<"ConsentRecord"> | string
    scope?: EnumConsentScopeFilter<"ConsentRecord"> | $Enums.ConsentScope
    purpose?: StringFilter<"ConsentRecord"> | string
    status?: EnumConsentStatusFilter<"ConsentRecord"> | $Enums.ConsentStatus
    createdAt?: DateTimeFilter<"ConsentRecord"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type ConsentRecordOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    scope?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ConsentRecordCountOrderByAggregateInput
    _max?: ConsentRecordMaxOrderByAggregateInput
    _min?: ConsentRecordMinOrderByAggregateInput
  }

  export type ConsentRecordScalarWhereWithAggregatesInput = {
    AND?: ConsentRecordScalarWhereWithAggregatesInput | ConsentRecordScalarWhereWithAggregatesInput[]
    OR?: ConsentRecordScalarWhereWithAggregatesInput[]
    NOT?: ConsentRecordScalarWhereWithAggregatesInput | ConsentRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConsentRecord"> | string
    patientId?: StringWithAggregatesFilter<"ConsentRecord"> | string
    scope?: EnumConsentScopeWithAggregatesFilter<"ConsentRecord"> | $Enums.ConsentScope
    purpose?: StringWithAggregatesFilter<"ConsentRecord"> | string
    status?: EnumConsentStatusWithAggregatesFilter<"ConsentRecord"> | $Enums.ConsentStatus
    createdAt?: DateTimeWithAggregatesFilter<"ConsentRecord"> | Date | string
  }

  export type RtbfRequestWhereInput = {
    AND?: RtbfRequestWhereInput | RtbfRequestWhereInput[]
    OR?: RtbfRequestWhereInput[]
    NOT?: RtbfRequestWhereInput | RtbfRequestWhereInput[]
    id?: StringFilter<"RtbfRequest"> | string
    patientId?: StringFilter<"RtbfRequest"> | string
    reason?: StringFilter<"RtbfRequest"> | string
    status?: EnumRtbfStatusFilter<"RtbfRequest"> | $Enums.RtbfStatus
    createdAt?: DateTimeFilter<"RtbfRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RtbfRequest"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type RtbfRequestOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type RtbfRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RtbfRequestWhereInput | RtbfRequestWhereInput[]
    OR?: RtbfRequestWhereInput[]
    NOT?: RtbfRequestWhereInput | RtbfRequestWhereInput[]
    patientId?: StringFilter<"RtbfRequest"> | string
    reason?: StringFilter<"RtbfRequest"> | string
    status?: EnumRtbfStatusFilter<"RtbfRequest"> | $Enums.RtbfStatus
    createdAt?: DateTimeFilter<"RtbfRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RtbfRequest"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type RtbfRequestOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RtbfRequestCountOrderByAggregateInput
    _max?: RtbfRequestMaxOrderByAggregateInput
    _min?: RtbfRequestMinOrderByAggregateInput
  }

  export type RtbfRequestScalarWhereWithAggregatesInput = {
    AND?: RtbfRequestScalarWhereWithAggregatesInput | RtbfRequestScalarWhereWithAggregatesInput[]
    OR?: RtbfRequestScalarWhereWithAggregatesInput[]
    NOT?: RtbfRequestScalarWhereWithAggregatesInput | RtbfRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RtbfRequest"> | string
    patientId?: StringWithAggregatesFilter<"RtbfRequest"> | string
    reason?: StringWithAggregatesFilter<"RtbfRequest"> | string
    status?: EnumRtbfStatusWithAggregatesFilter<"RtbfRequest"> | $Enums.RtbfStatus
    createdAt?: DateTimeWithAggregatesFilter<"RtbfRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RtbfRequest"> | Date | string
  }

  export type StatutoryCaseWhereInput = {
    AND?: StatutoryCaseWhereInput | StatutoryCaseWhereInput[]
    OR?: StatutoryCaseWhereInput[]
    NOT?: StatutoryCaseWhereInput | StatutoryCaseWhereInput[]
    id?: StringFilter<"StatutoryCase"> | string
    branchId?: StringFilter<"StatutoryCase"> | string
    patientId?: StringFilter<"StatutoryCase"> | string
    program?: StringFilter<"StatutoryCase"> | string
    disease?: StringFilter<"StatutoryCase"> | string
    status?: StringFilter<"StatutoryCase"> | string
    createdAt?: DateTimeFilter<"StatutoryCase"> | Date | string
    updatedAt?: DateTimeFilter<"StatutoryCase"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type StatutoryCaseOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    program?: SortOrder
    disease?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type StatutoryCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StatutoryCaseWhereInput | StatutoryCaseWhereInput[]
    OR?: StatutoryCaseWhereInput[]
    NOT?: StatutoryCaseWhereInput | StatutoryCaseWhereInput[]
    branchId?: StringFilter<"StatutoryCase"> | string
    patientId?: StringFilter<"StatutoryCase"> | string
    program?: StringFilter<"StatutoryCase"> | string
    disease?: StringFilter<"StatutoryCase"> | string
    status?: StringFilter<"StatutoryCase"> | string
    createdAt?: DateTimeFilter<"StatutoryCase"> | Date | string
    updatedAt?: DateTimeFilter<"StatutoryCase"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type StatutoryCaseOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    program?: SortOrder
    disease?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StatutoryCaseCountOrderByAggregateInput
    _max?: StatutoryCaseMaxOrderByAggregateInput
    _min?: StatutoryCaseMinOrderByAggregateInput
  }

  export type StatutoryCaseScalarWhereWithAggregatesInput = {
    AND?: StatutoryCaseScalarWhereWithAggregatesInput | StatutoryCaseScalarWhereWithAggregatesInput[]
    OR?: StatutoryCaseScalarWhereWithAggregatesInput[]
    NOT?: StatutoryCaseScalarWhereWithAggregatesInput | StatutoryCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StatutoryCase"> | string
    branchId?: StringWithAggregatesFilter<"StatutoryCase"> | string
    patientId?: StringWithAggregatesFilter<"StatutoryCase"> | string
    program?: StringWithAggregatesFilter<"StatutoryCase"> | string
    disease?: StringWithAggregatesFilter<"StatutoryCase"> | string
    status?: StringWithAggregatesFilter<"StatutoryCase"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StatutoryCase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StatutoryCase"> | Date | string
  }

  export type AuditEventWhereInput = {
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    id?: StringFilter<"AuditEvent"> | string
    branchId?: StringNullableFilter<"AuditEvent"> | string | null
    actorUserId?: StringNullableFilter<"AuditEvent"> | string | null
    action?: StringFilter<"AuditEvent"> | string
    entity?: StringFilter<"AuditEvent"> | string
    entityId?: StringNullableFilter<"AuditEvent"> | string | null
    meta?: JsonNullableFilter<"AuditEvent">
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    actorUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditEventOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrderInput | SortOrder
    actorUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    actorUser?: UserOrderByWithRelationInput
  }

  export type AuditEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    branchId?: StringNullableFilter<"AuditEvent"> | string | null
    actorUserId?: StringNullableFilter<"AuditEvent"> | string | null
    action?: StringFilter<"AuditEvent"> | string
    entity?: StringFilter<"AuditEvent"> | string
    entityId?: StringNullableFilter<"AuditEvent"> | string | null
    meta?: JsonNullableFilter<"AuditEvent">
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    actorUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditEventOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrderInput | SortOrder
    actorUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditEventCountOrderByAggregateInput
    _max?: AuditEventMaxOrderByAggregateInput
    _min?: AuditEventMinOrderByAggregateInput
  }

  export type AuditEventScalarWhereWithAggregatesInput = {
    AND?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    OR?: AuditEventScalarWhereWithAggregatesInput[]
    NOT?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditEvent"> | string
    branchId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    actorUserId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    action?: StringWithAggregatesFilter<"AuditEvent"> | string
    entity?: StringWithAggregatesFilter<"AuditEvent"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"AuditEvent">
    createdAt?: DateTimeWithAggregatesFilter<"AuditEvent"> | Date | string
  }

  export type OutboxEventWhereInput = {
    AND?: OutboxEventWhereInput | OutboxEventWhereInput[]
    OR?: OutboxEventWhereInput[]
    NOT?: OutboxEventWhereInput | OutboxEventWhereInput[]
    id?: StringFilter<"OutboxEvent"> | string
    topic?: StringFilter<"OutboxEvent"> | string
    key?: StringNullableFilter<"OutboxEvent"> | string | null
    payload?: JsonFilter<"OutboxEvent">
    status?: EnumOutboxStatusFilter<"OutboxEvent"> | $Enums.OutboxStatus
    attempts?: IntFilter<"OutboxEvent"> | number
    availableAt?: DateTimeFilter<"OutboxEvent"> | Date | string
    lockedAt?: DateTimeNullableFilter<"OutboxEvent"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"OutboxEvent"> | Date | string | null
    error?: StringNullableFilter<"OutboxEvent"> | string | null
    createdAt?: DateTimeFilter<"OutboxEvent"> | Date | string
    updatedAt?: DateTimeFilter<"OutboxEvent"> | Date | string
  }

  export type OutboxEventOrderByWithRelationInput = {
    id?: SortOrder
    topic?: SortOrder
    key?: SortOrderInput | SortOrder
    payload?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    availableAt?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboxEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutboxEventWhereInput | OutboxEventWhereInput[]
    OR?: OutboxEventWhereInput[]
    NOT?: OutboxEventWhereInput | OutboxEventWhereInput[]
    topic?: StringFilter<"OutboxEvent"> | string
    key?: StringNullableFilter<"OutboxEvent"> | string | null
    payload?: JsonFilter<"OutboxEvent">
    status?: EnumOutboxStatusFilter<"OutboxEvent"> | $Enums.OutboxStatus
    attempts?: IntFilter<"OutboxEvent"> | number
    availableAt?: DateTimeFilter<"OutboxEvent"> | Date | string
    lockedAt?: DateTimeNullableFilter<"OutboxEvent"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"OutboxEvent"> | Date | string | null
    error?: StringNullableFilter<"OutboxEvent"> | string | null
    createdAt?: DateTimeFilter<"OutboxEvent"> | Date | string
    updatedAt?: DateTimeFilter<"OutboxEvent"> | Date | string
  }, "id">

  export type OutboxEventOrderByWithAggregationInput = {
    id?: SortOrder
    topic?: SortOrder
    key?: SortOrderInput | SortOrder
    payload?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    availableAt?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutboxEventCountOrderByAggregateInput
    _avg?: OutboxEventAvgOrderByAggregateInput
    _max?: OutboxEventMaxOrderByAggregateInput
    _min?: OutboxEventMinOrderByAggregateInput
    _sum?: OutboxEventSumOrderByAggregateInput
  }

  export type OutboxEventScalarWhereWithAggregatesInput = {
    AND?: OutboxEventScalarWhereWithAggregatesInput | OutboxEventScalarWhereWithAggregatesInput[]
    OR?: OutboxEventScalarWhereWithAggregatesInput[]
    NOT?: OutboxEventScalarWhereWithAggregatesInput | OutboxEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutboxEvent"> | string
    topic?: StringWithAggregatesFilter<"OutboxEvent"> | string
    key?: StringNullableWithAggregatesFilter<"OutboxEvent"> | string | null
    payload?: JsonWithAggregatesFilter<"OutboxEvent">
    status?: EnumOutboxStatusWithAggregatesFilter<"OutboxEvent"> | $Enums.OutboxStatus
    attempts?: IntWithAggregatesFilter<"OutboxEvent"> | number
    availableAt?: DateTimeWithAggregatesFilter<"OutboxEvent"> | Date | string
    lockedAt?: DateTimeNullableWithAggregatesFilter<"OutboxEvent"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"OutboxEvent"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"OutboxEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OutboxEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OutboxEvent"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    code?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    category?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roleGrants?: RoleTemplatePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleGrants?: RoleTemplatePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    name?: StringFilter<"Permission"> | string
    category?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roleGrants?: RoleTemplatePermissionListRelationFilter
  }, "id" | "code">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    code?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    category?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RoleTemplateWhereInput = {
    AND?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    OR?: RoleTemplateWhereInput[]
    NOT?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    id?: StringFilter<"RoleTemplate"> | string
    code?: StringFilter<"RoleTemplate"> | string
    name?: StringFilter<"RoleTemplate"> | string
    scope?: EnumRoleScopeFilter<"RoleTemplate"> | $Enums.RoleScope
    description?: StringNullableFilter<"RoleTemplate"> | string | null
    isSystem?: BoolFilter<"RoleTemplate"> | boolean
    createdAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    versions?: RoleTemplateVersionListRelationFilter
  }

  export type RoleTemplateOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    versions?: RoleTemplateVersionOrderByRelationAggregateInput
  }

  export type RoleTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    OR?: RoleTemplateWhereInput[]
    NOT?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    name?: StringFilter<"RoleTemplate"> | string
    scope?: EnumRoleScopeFilter<"RoleTemplate"> | $Enums.RoleScope
    description?: StringNullableFilter<"RoleTemplate"> | string | null
    isSystem?: BoolFilter<"RoleTemplate"> | boolean
    createdAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    versions?: RoleTemplateVersionListRelationFilter
  }, "id" | "code">

  export type RoleTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleTemplateCountOrderByAggregateInput
    _max?: RoleTemplateMaxOrderByAggregateInput
    _min?: RoleTemplateMinOrderByAggregateInput
  }

  export type RoleTemplateScalarWhereWithAggregatesInput = {
    AND?: RoleTemplateScalarWhereWithAggregatesInput | RoleTemplateScalarWhereWithAggregatesInput[]
    OR?: RoleTemplateScalarWhereWithAggregatesInput[]
    NOT?: RoleTemplateScalarWhereWithAggregatesInput | RoleTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleTemplate"> | string
    code?: StringWithAggregatesFilter<"RoleTemplate"> | string
    name?: StringWithAggregatesFilter<"RoleTemplate"> | string
    scope?: EnumRoleScopeWithAggregatesFilter<"RoleTemplate"> | $Enums.RoleScope
    description?: StringNullableWithAggregatesFilter<"RoleTemplate"> | string | null
    isSystem?: BoolWithAggregatesFilter<"RoleTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RoleTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoleTemplate"> | Date | string
  }

  export type RoleTemplateVersionWhereInput = {
    AND?: RoleTemplateVersionWhereInput | RoleTemplateVersionWhereInput[]
    OR?: RoleTemplateVersionWhereInput[]
    NOT?: RoleTemplateVersionWhereInput | RoleTemplateVersionWhereInput[]
    id?: StringFilter<"RoleTemplateVersion"> | string
    roleTemplateId?: StringFilter<"RoleTemplateVersion"> | string
    version?: IntFilter<"RoleTemplateVersion"> | number
    status?: EnumRoleVersionStatusFilter<"RoleTemplateVersion"> | $Enums.RoleVersionStatus
    notes?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdByUserId?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
    roleTemplate?: XOR<RoleTemplateRelationFilter, RoleTemplateWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    permissions?: RoleTemplatePermissionListRelationFilter
    users?: UserListRelationFilter
  }

  export type RoleTemplateVersionOrderByWithRelationInput = {
    id?: SortOrder
    roleTemplateId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleTemplate?: RoleTemplateOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
    permissions?: RoleTemplatePermissionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleTemplateVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleTemplateId_version?: RoleTemplateVersionRoleTemplateIdVersionCompoundUniqueInput
    AND?: RoleTemplateVersionWhereInput | RoleTemplateVersionWhereInput[]
    OR?: RoleTemplateVersionWhereInput[]
    NOT?: RoleTemplateVersionWhereInput | RoleTemplateVersionWhereInput[]
    roleTemplateId?: StringFilter<"RoleTemplateVersion"> | string
    version?: IntFilter<"RoleTemplateVersion"> | number
    status?: EnumRoleVersionStatusFilter<"RoleTemplateVersion"> | $Enums.RoleVersionStatus
    notes?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdByUserId?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
    roleTemplate?: XOR<RoleTemplateRelationFilter, RoleTemplateWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    permissions?: RoleTemplatePermissionListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "roleTemplateId_version">

  export type RoleTemplateVersionOrderByWithAggregationInput = {
    id?: SortOrder
    roleTemplateId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleTemplateVersionCountOrderByAggregateInput
    _avg?: RoleTemplateVersionAvgOrderByAggregateInput
    _max?: RoleTemplateVersionMaxOrderByAggregateInput
    _min?: RoleTemplateVersionMinOrderByAggregateInput
    _sum?: RoleTemplateVersionSumOrderByAggregateInput
  }

  export type RoleTemplateVersionScalarWhereWithAggregatesInput = {
    AND?: RoleTemplateVersionScalarWhereWithAggregatesInput | RoleTemplateVersionScalarWhereWithAggregatesInput[]
    OR?: RoleTemplateVersionScalarWhereWithAggregatesInput[]
    NOT?: RoleTemplateVersionScalarWhereWithAggregatesInput | RoleTemplateVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleTemplateVersion"> | string
    roleTemplateId?: StringWithAggregatesFilter<"RoleTemplateVersion"> | string
    version?: IntWithAggregatesFilter<"RoleTemplateVersion"> | number
    status?: EnumRoleVersionStatusWithAggregatesFilter<"RoleTemplateVersion"> | $Enums.RoleVersionStatus
    notes?: StringNullableWithAggregatesFilter<"RoleTemplateVersion"> | string | null
    createdByUserId?: StringNullableWithAggregatesFilter<"RoleTemplateVersion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoleTemplateVersion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoleTemplateVersion"> | Date | string
  }

  export type RoleTemplatePermissionWhereInput = {
    AND?: RoleTemplatePermissionWhereInput | RoleTemplatePermissionWhereInput[]
    OR?: RoleTemplatePermissionWhereInput[]
    NOT?: RoleTemplatePermissionWhereInput | RoleTemplatePermissionWhereInput[]
    id?: StringFilter<"RoleTemplatePermission"> | string
    roleVersionId?: StringFilter<"RoleTemplatePermission"> | string
    permissionId?: StringFilter<"RoleTemplatePermission"> | string
    allowed?: BoolFilter<"RoleTemplatePermission"> | boolean
    createdAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
    roleVersion?: XOR<RoleTemplateVersionRelationFilter, RoleTemplateVersionWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }

  export type RoleTemplatePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleVersionId?: SortOrder
    permissionId?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleVersion?: RoleTemplateVersionOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RoleTemplatePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleVersionId_permissionId?: RoleTemplatePermissionRoleVersionIdPermissionIdCompoundUniqueInput
    AND?: RoleTemplatePermissionWhereInput | RoleTemplatePermissionWhereInput[]
    OR?: RoleTemplatePermissionWhereInput[]
    NOT?: RoleTemplatePermissionWhereInput | RoleTemplatePermissionWhereInput[]
    roleVersionId?: StringFilter<"RoleTemplatePermission"> | string
    permissionId?: StringFilter<"RoleTemplatePermission"> | string
    allowed?: BoolFilter<"RoleTemplatePermission"> | boolean
    createdAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
    roleVersion?: XOR<RoleTemplateVersionRelationFilter, RoleTemplateVersionWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }, "id" | "roleVersionId_permissionId">

  export type RoleTemplatePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleVersionId?: SortOrder
    permissionId?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleTemplatePermissionCountOrderByAggregateInput
    _max?: RoleTemplatePermissionMaxOrderByAggregateInput
    _min?: RoleTemplatePermissionMinOrderByAggregateInput
  }

  export type RoleTemplatePermissionScalarWhereWithAggregatesInput = {
    AND?: RoleTemplatePermissionScalarWhereWithAggregatesInput | RoleTemplatePermissionScalarWhereWithAggregatesInput[]
    OR?: RoleTemplatePermissionScalarWhereWithAggregatesInput[]
    NOT?: RoleTemplatePermissionScalarWhereWithAggregatesInput | RoleTemplatePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleTemplatePermission"> | string
    roleVersionId?: StringWithAggregatesFilter<"RoleTemplatePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RoleTemplatePermission"> | string
    allowed?: BoolWithAggregatesFilter<"RoleTemplatePermission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RoleTemplatePermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoleTemplatePermission"> | Date | string
  }

  export type PolicyDefinitionWhereInput = {
    AND?: PolicyDefinitionWhereInput | PolicyDefinitionWhereInput[]
    OR?: PolicyDefinitionWhereInput[]
    NOT?: PolicyDefinitionWhereInput | PolicyDefinitionWhereInput[]
    id?: StringFilter<"PolicyDefinition"> | string
    code?: StringFilter<"PolicyDefinition"> | string
    name?: StringFilter<"PolicyDefinition"> | string
    type?: StringFilter<"PolicyDefinition"> | string
    description?: StringNullableFilter<"PolicyDefinition"> | string | null
    createdAt?: DateTimeFilter<"PolicyDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"PolicyDefinition"> | Date | string
    versions?: PolicyVersionListRelationFilter
  }

  export type PolicyDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    versions?: PolicyVersionOrderByRelationAggregateInput
  }

  export type PolicyDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PolicyDefinitionWhereInput | PolicyDefinitionWhereInput[]
    OR?: PolicyDefinitionWhereInput[]
    NOT?: PolicyDefinitionWhereInput | PolicyDefinitionWhereInput[]
    name?: StringFilter<"PolicyDefinition"> | string
    type?: StringFilter<"PolicyDefinition"> | string
    description?: StringNullableFilter<"PolicyDefinition"> | string | null
    createdAt?: DateTimeFilter<"PolicyDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"PolicyDefinition"> | Date | string
    versions?: PolicyVersionListRelationFilter
  }, "id" | "code">

  export type PolicyDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PolicyDefinitionCountOrderByAggregateInput
    _max?: PolicyDefinitionMaxOrderByAggregateInput
    _min?: PolicyDefinitionMinOrderByAggregateInput
  }

  export type PolicyDefinitionScalarWhereWithAggregatesInput = {
    AND?: PolicyDefinitionScalarWhereWithAggregatesInput | PolicyDefinitionScalarWhereWithAggregatesInput[]
    OR?: PolicyDefinitionScalarWhereWithAggregatesInput[]
    NOT?: PolicyDefinitionScalarWhereWithAggregatesInput | PolicyDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PolicyDefinition"> | string
    code?: StringWithAggregatesFilter<"PolicyDefinition"> | string
    name?: StringWithAggregatesFilter<"PolicyDefinition"> | string
    type?: StringWithAggregatesFilter<"PolicyDefinition"> | string
    description?: StringNullableWithAggregatesFilter<"PolicyDefinition"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PolicyDefinition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PolicyDefinition"> | Date | string
  }

  export type PolicyVersionWhereInput = {
    AND?: PolicyVersionWhereInput | PolicyVersionWhereInput[]
    OR?: PolicyVersionWhereInput[]
    NOT?: PolicyVersionWhereInput | PolicyVersionWhereInput[]
    id?: StringFilter<"PolicyVersion"> | string
    policyId?: StringFilter<"PolicyVersion"> | string
    scope?: EnumPolicyScopeFilter<"PolicyVersion"> | $Enums.PolicyScope
    branchId?: StringNullableFilter<"PolicyVersion"> | string | null
    version?: IntFilter<"PolicyVersion"> | number
    status?: EnumPolicyVersionStatusFilter<"PolicyVersion"> | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFilter<"PolicyVersion"> | Date | string
    notes?: StringNullableFilter<"PolicyVersion"> | string | null
    payload?: JsonFilter<"PolicyVersion">
    applyToAllBranches?: BoolFilter<"PolicyVersion"> | boolean
    createdByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    submittedAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    submittedByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    approvedAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    approvedByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    approvalNote?: StringNullableFilter<"PolicyVersion"> | string | null
    rejectedAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    rejectedByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    rejectionReason?: StringNullableFilter<"PolicyVersion"> | string | null
    retiredAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    retiredByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    createdAt?: DateTimeFilter<"PolicyVersion"> | Date | string
    updatedAt?: DateTimeFilter<"PolicyVersion"> | Date | string
    policy?: XOR<PolicyDefinitionRelationFilter, PolicyDefinitionWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    branches?: PolicyVersionBranchListRelationFilter
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    submittedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    approvedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    rejectedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    retiredByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type PolicyVersionOrderByWithRelationInput = {
    id?: SortOrder
    policyId?: SortOrder
    scope?: SortOrder
    branchId?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    effectiveAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    payload?: SortOrder
    applyToAllBranches?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    submittedByUserId?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedByUserId?: SortOrderInput | SortOrder
    approvalNote?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectedByUserId?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    retiredAt?: SortOrderInput | SortOrder
    retiredByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    policy?: PolicyDefinitionOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    branches?: PolicyVersionBranchOrderByRelationAggregateInput
    createdByUser?: UserOrderByWithRelationInput
    submittedByUser?: UserOrderByWithRelationInput
    approvedByUser?: UserOrderByWithRelationInput
    rejectedByUser?: UserOrderByWithRelationInput
    retiredByUser?: UserOrderByWithRelationInput
  }

  export type PolicyVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PolicyVersionWhereInput | PolicyVersionWhereInput[]
    OR?: PolicyVersionWhereInput[]
    NOT?: PolicyVersionWhereInput | PolicyVersionWhereInput[]
    policyId?: StringFilter<"PolicyVersion"> | string
    scope?: EnumPolicyScopeFilter<"PolicyVersion"> | $Enums.PolicyScope
    branchId?: StringNullableFilter<"PolicyVersion"> | string | null
    version?: IntFilter<"PolicyVersion"> | number
    status?: EnumPolicyVersionStatusFilter<"PolicyVersion"> | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFilter<"PolicyVersion"> | Date | string
    notes?: StringNullableFilter<"PolicyVersion"> | string | null
    payload?: JsonFilter<"PolicyVersion">
    applyToAllBranches?: BoolFilter<"PolicyVersion"> | boolean
    createdByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    submittedAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    submittedByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    approvedAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    approvedByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    approvalNote?: StringNullableFilter<"PolicyVersion"> | string | null
    rejectedAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    rejectedByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    rejectionReason?: StringNullableFilter<"PolicyVersion"> | string | null
    retiredAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    retiredByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    createdAt?: DateTimeFilter<"PolicyVersion"> | Date | string
    updatedAt?: DateTimeFilter<"PolicyVersion"> | Date | string
    policy?: XOR<PolicyDefinitionRelationFilter, PolicyDefinitionWhereInput>
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    branches?: PolicyVersionBranchListRelationFilter
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    submittedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    approvedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    rejectedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    retiredByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type PolicyVersionOrderByWithAggregationInput = {
    id?: SortOrder
    policyId?: SortOrder
    scope?: SortOrder
    branchId?: SortOrderInput | SortOrder
    version?: SortOrder
    status?: SortOrder
    effectiveAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    payload?: SortOrder
    applyToAllBranches?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    submittedByUserId?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    approvedByUserId?: SortOrderInput | SortOrder
    approvalNote?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    rejectedByUserId?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    retiredAt?: SortOrderInput | SortOrder
    retiredByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PolicyVersionCountOrderByAggregateInput
    _avg?: PolicyVersionAvgOrderByAggregateInput
    _max?: PolicyVersionMaxOrderByAggregateInput
    _min?: PolicyVersionMinOrderByAggregateInput
    _sum?: PolicyVersionSumOrderByAggregateInput
  }

  export type PolicyVersionScalarWhereWithAggregatesInput = {
    AND?: PolicyVersionScalarWhereWithAggregatesInput | PolicyVersionScalarWhereWithAggregatesInput[]
    OR?: PolicyVersionScalarWhereWithAggregatesInput[]
    NOT?: PolicyVersionScalarWhereWithAggregatesInput | PolicyVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PolicyVersion"> | string
    policyId?: StringWithAggregatesFilter<"PolicyVersion"> | string
    scope?: EnumPolicyScopeWithAggregatesFilter<"PolicyVersion"> | $Enums.PolicyScope
    branchId?: StringNullableWithAggregatesFilter<"PolicyVersion"> | string | null
    version?: IntWithAggregatesFilter<"PolicyVersion"> | number
    status?: EnumPolicyVersionStatusWithAggregatesFilter<"PolicyVersion"> | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeWithAggregatesFilter<"PolicyVersion"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"PolicyVersion"> | string | null
    payload?: JsonWithAggregatesFilter<"PolicyVersion">
    applyToAllBranches?: BoolWithAggregatesFilter<"PolicyVersion"> | boolean
    createdByUserId?: StringNullableWithAggregatesFilter<"PolicyVersion"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"PolicyVersion"> | Date | string | null
    submittedByUserId?: StringNullableWithAggregatesFilter<"PolicyVersion"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"PolicyVersion"> | Date | string | null
    approvedByUserId?: StringNullableWithAggregatesFilter<"PolicyVersion"> | string | null
    approvalNote?: StringNullableWithAggregatesFilter<"PolicyVersion"> | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"PolicyVersion"> | Date | string | null
    rejectedByUserId?: StringNullableWithAggregatesFilter<"PolicyVersion"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"PolicyVersion"> | string | null
    retiredAt?: DateTimeNullableWithAggregatesFilter<"PolicyVersion"> | Date | string | null
    retiredByUserId?: StringNullableWithAggregatesFilter<"PolicyVersion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PolicyVersion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PolicyVersion"> | Date | string
  }

  export type PolicyVersionBranchWhereInput = {
    AND?: PolicyVersionBranchWhereInput | PolicyVersionBranchWhereInput[]
    OR?: PolicyVersionBranchWhereInput[]
    NOT?: PolicyVersionBranchWhereInput | PolicyVersionBranchWhereInput[]
    id?: StringFilter<"PolicyVersionBranch"> | string
    policyVersionId?: StringFilter<"PolicyVersionBranch"> | string
    branchId?: StringFilter<"PolicyVersionBranch"> | string
    createdAt?: DateTimeFilter<"PolicyVersionBranch"> | Date | string
    policyVersion?: XOR<PolicyVersionRelationFilter, PolicyVersionWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type PolicyVersionBranchOrderByWithRelationInput = {
    id?: SortOrder
    policyVersionId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    policyVersion?: PolicyVersionOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
  }

  export type PolicyVersionBranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    policyVersionId_branchId?: PolicyVersionBranchPolicyVersionIdBranchIdCompoundUniqueInput
    AND?: PolicyVersionBranchWhereInput | PolicyVersionBranchWhereInput[]
    OR?: PolicyVersionBranchWhereInput[]
    NOT?: PolicyVersionBranchWhereInput | PolicyVersionBranchWhereInput[]
    policyVersionId?: StringFilter<"PolicyVersionBranch"> | string
    branchId?: StringFilter<"PolicyVersionBranch"> | string
    createdAt?: DateTimeFilter<"PolicyVersionBranch"> | Date | string
    policyVersion?: XOR<PolicyVersionRelationFilter, PolicyVersionWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "policyVersionId_branchId">

  export type PolicyVersionBranchOrderByWithAggregationInput = {
    id?: SortOrder
    policyVersionId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
    _count?: PolicyVersionBranchCountOrderByAggregateInput
    _max?: PolicyVersionBranchMaxOrderByAggregateInput
    _min?: PolicyVersionBranchMinOrderByAggregateInput
  }

  export type PolicyVersionBranchScalarWhereWithAggregatesInput = {
    AND?: PolicyVersionBranchScalarWhereWithAggregatesInput | PolicyVersionBranchScalarWhereWithAggregatesInput[]
    OR?: PolicyVersionBranchScalarWhereWithAggregatesInput[]
    NOT?: PolicyVersionBranchScalarWhereWithAggregatesInput | PolicyVersionBranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PolicyVersionBranch"> | string
    policyVersionId?: StringWithAggregatesFilter<"PolicyVersionBranch"> | string
    branchId?: StringWithAggregatesFilter<"PolicyVersionBranch"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PolicyVersionBranch"> | Date | string
  }

  export type LocationNodeWhereInput = {
    AND?: LocationNodeWhereInput | LocationNodeWhereInput[]
    OR?: LocationNodeWhereInput[]
    NOT?: LocationNodeWhereInput | LocationNodeWhereInput[]
    id?: StringFilter<"LocationNode"> | string
    branchId?: StringFilter<"LocationNode"> | string
    kind?: EnumLocationKindFilter<"LocationNode"> | $Enums.LocationKind
    parentId?: StringNullableFilter<"LocationNode"> | string | null
    createdAt?: DateTimeFilter<"LocationNode"> | Date | string
    updatedAt?: DateTimeFilter<"LocationNode"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    parent?: XOR<LocationNodeNullableRelationFilter, LocationNodeWhereInput> | null
    children?: LocationNodeListRelationFilter
    revisions?: LocationNodeRevisionListRelationFilter
    EquipmentAsset?: EquipmentAssetListRelationFilter
  }

  export type LocationNodeOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    kind?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    parent?: LocationNodeOrderByWithRelationInput
    children?: LocationNodeOrderByRelationAggregateInput
    revisions?: LocationNodeRevisionOrderByRelationAggregateInput
    EquipmentAsset?: EquipmentAssetOrderByRelationAggregateInput
  }

  export type LocationNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationNodeWhereInput | LocationNodeWhereInput[]
    OR?: LocationNodeWhereInput[]
    NOT?: LocationNodeWhereInput | LocationNodeWhereInput[]
    branchId?: StringFilter<"LocationNode"> | string
    kind?: EnumLocationKindFilter<"LocationNode"> | $Enums.LocationKind
    parentId?: StringNullableFilter<"LocationNode"> | string | null
    createdAt?: DateTimeFilter<"LocationNode"> | Date | string
    updatedAt?: DateTimeFilter<"LocationNode"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    parent?: XOR<LocationNodeNullableRelationFilter, LocationNodeWhereInput> | null
    children?: LocationNodeListRelationFilter
    revisions?: LocationNodeRevisionListRelationFilter
    EquipmentAsset?: EquipmentAssetListRelationFilter
  }, "id">

  export type LocationNodeOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    kind?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationNodeCountOrderByAggregateInput
    _max?: LocationNodeMaxOrderByAggregateInput
    _min?: LocationNodeMinOrderByAggregateInput
  }

  export type LocationNodeScalarWhereWithAggregatesInput = {
    AND?: LocationNodeScalarWhereWithAggregatesInput | LocationNodeScalarWhereWithAggregatesInput[]
    OR?: LocationNodeScalarWhereWithAggregatesInput[]
    NOT?: LocationNodeScalarWhereWithAggregatesInput | LocationNodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocationNode"> | string
    branchId?: StringWithAggregatesFilter<"LocationNode"> | string
    kind?: EnumLocationKindWithAggregatesFilter<"LocationNode"> | $Enums.LocationKind
    parentId?: StringNullableWithAggregatesFilter<"LocationNode"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LocationNode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LocationNode"> | Date | string
  }

  export type LocationNodeRevisionWhereInput = {
    AND?: LocationNodeRevisionWhereInput | LocationNodeRevisionWhereInput[]
    OR?: LocationNodeRevisionWhereInput[]
    NOT?: LocationNodeRevisionWhereInput | LocationNodeRevisionWhereInput[]
    id?: StringFilter<"LocationNodeRevision"> | string
    nodeId?: StringFilter<"LocationNodeRevision"> | string
    code?: StringFilter<"LocationNodeRevision"> | string
    name?: StringFilter<"LocationNodeRevision"> | string
    isActive?: BoolFilter<"LocationNodeRevision"> | boolean
    effectiveFrom?: DateTimeFilter<"LocationNodeRevision"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"LocationNodeRevision"> | Date | string | null
    createdByUserId?: StringNullableFilter<"LocationNodeRevision"> | string | null
    createdAt?: DateTimeFilter<"LocationNodeRevision"> | Date | string
    node?: XOR<LocationNodeRelationFilter, LocationNodeWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type LocationNodeRevisionOrderByWithRelationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    node?: LocationNodeOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
  }

  export type LocationNodeRevisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationNodeRevisionWhereInput | LocationNodeRevisionWhereInput[]
    OR?: LocationNodeRevisionWhereInput[]
    NOT?: LocationNodeRevisionWhereInput | LocationNodeRevisionWhereInput[]
    nodeId?: StringFilter<"LocationNodeRevision"> | string
    code?: StringFilter<"LocationNodeRevision"> | string
    name?: StringFilter<"LocationNodeRevision"> | string
    isActive?: BoolFilter<"LocationNodeRevision"> | boolean
    effectiveFrom?: DateTimeFilter<"LocationNodeRevision"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"LocationNodeRevision"> | Date | string | null
    createdByUserId?: StringNullableFilter<"LocationNodeRevision"> | string | null
    createdAt?: DateTimeFilter<"LocationNodeRevision"> | Date | string
    node?: XOR<LocationNodeRelationFilter, LocationNodeWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type LocationNodeRevisionOrderByWithAggregationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LocationNodeRevisionCountOrderByAggregateInput
    _max?: LocationNodeRevisionMaxOrderByAggregateInput
    _min?: LocationNodeRevisionMinOrderByAggregateInput
  }

  export type LocationNodeRevisionScalarWhereWithAggregatesInput = {
    AND?: LocationNodeRevisionScalarWhereWithAggregatesInput | LocationNodeRevisionScalarWhereWithAggregatesInput[]
    OR?: LocationNodeRevisionScalarWhereWithAggregatesInput[]
    NOT?: LocationNodeRevisionScalarWhereWithAggregatesInput | LocationNodeRevisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocationNodeRevision"> | string
    nodeId?: StringWithAggregatesFilter<"LocationNodeRevision"> | string
    code?: StringWithAggregatesFilter<"LocationNodeRevision"> | string
    name?: StringWithAggregatesFilter<"LocationNodeRevision"> | string
    isActive?: BoolWithAggregatesFilter<"LocationNodeRevision"> | boolean
    effectiveFrom?: DateTimeWithAggregatesFilter<"LocationNodeRevision"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"LocationNodeRevision"> | Date | string | null
    createdByUserId?: StringNullableWithAggregatesFilter<"LocationNodeRevision"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LocationNodeRevision"> | Date | string
  }

  export type UnitTypeCatalogWhereInput = {
    AND?: UnitTypeCatalogWhereInput | UnitTypeCatalogWhereInput[]
    OR?: UnitTypeCatalogWhereInput[]
    NOT?: UnitTypeCatalogWhereInput | UnitTypeCatalogWhereInput[]
    id?: StringFilter<"UnitTypeCatalog"> | string
    code?: StringFilter<"UnitTypeCatalog"> | string
    name?: StringFilter<"UnitTypeCatalog"> | string
    usesRoomsDefault?: BoolFilter<"UnitTypeCatalog"> | boolean
    schedulableByDefault?: BoolFilter<"UnitTypeCatalog"> | boolean
    sortOrder?: IntFilter<"UnitTypeCatalog"> | number
    isActive?: BoolFilter<"UnitTypeCatalog"> | boolean
    createdAt?: DateTimeFilter<"UnitTypeCatalog"> | Date | string
    updatedAt?: DateTimeFilter<"UnitTypeCatalog"> | Date | string
    branchLinks?: BranchUnitTypeListRelationFilter
    units?: UnitListRelationFilter
  }

  export type UnitTypeCatalogOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    usesRoomsDefault?: SortOrder
    schedulableByDefault?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branchLinks?: BranchUnitTypeOrderByRelationAggregateInput
    units?: UnitOrderByRelationAggregateInput
  }

  export type UnitTypeCatalogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: UnitTypeCatalogWhereInput | UnitTypeCatalogWhereInput[]
    OR?: UnitTypeCatalogWhereInput[]
    NOT?: UnitTypeCatalogWhereInput | UnitTypeCatalogWhereInput[]
    name?: StringFilter<"UnitTypeCatalog"> | string
    usesRoomsDefault?: BoolFilter<"UnitTypeCatalog"> | boolean
    schedulableByDefault?: BoolFilter<"UnitTypeCatalog"> | boolean
    sortOrder?: IntFilter<"UnitTypeCatalog"> | number
    isActive?: BoolFilter<"UnitTypeCatalog"> | boolean
    createdAt?: DateTimeFilter<"UnitTypeCatalog"> | Date | string
    updatedAt?: DateTimeFilter<"UnitTypeCatalog"> | Date | string
    branchLinks?: BranchUnitTypeListRelationFilter
    units?: UnitListRelationFilter
  }, "id" | "code">

  export type UnitTypeCatalogOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    usesRoomsDefault?: SortOrder
    schedulableByDefault?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitTypeCatalogCountOrderByAggregateInput
    _avg?: UnitTypeCatalogAvgOrderByAggregateInput
    _max?: UnitTypeCatalogMaxOrderByAggregateInput
    _min?: UnitTypeCatalogMinOrderByAggregateInput
    _sum?: UnitTypeCatalogSumOrderByAggregateInput
  }

  export type UnitTypeCatalogScalarWhereWithAggregatesInput = {
    AND?: UnitTypeCatalogScalarWhereWithAggregatesInput | UnitTypeCatalogScalarWhereWithAggregatesInput[]
    OR?: UnitTypeCatalogScalarWhereWithAggregatesInput[]
    NOT?: UnitTypeCatalogScalarWhereWithAggregatesInput | UnitTypeCatalogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitTypeCatalog"> | string
    code?: StringWithAggregatesFilter<"UnitTypeCatalog"> | string
    name?: StringWithAggregatesFilter<"UnitTypeCatalog"> | string
    usesRoomsDefault?: BoolWithAggregatesFilter<"UnitTypeCatalog"> | boolean
    schedulableByDefault?: BoolWithAggregatesFilter<"UnitTypeCatalog"> | boolean
    sortOrder?: IntWithAggregatesFilter<"UnitTypeCatalog"> | number
    isActive?: BoolWithAggregatesFilter<"UnitTypeCatalog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UnitTypeCatalog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitTypeCatalog"> | Date | string
  }

  export type BranchUnitTypeWhereInput = {
    AND?: BranchUnitTypeWhereInput | BranchUnitTypeWhereInput[]
    OR?: BranchUnitTypeWhereInput[]
    NOT?: BranchUnitTypeWhereInput | BranchUnitTypeWhereInput[]
    id?: StringFilter<"BranchUnitType"> | string
    branchId?: StringFilter<"BranchUnitType"> | string
    unitTypeId?: StringFilter<"BranchUnitType"> | string
    isEnabled?: BoolFilter<"BranchUnitType"> | boolean
    enabledAt?: DateTimeFilter<"BranchUnitType"> | Date | string
    createdAt?: DateTimeFilter<"BranchUnitType"> | Date | string
    updatedAt?: DateTimeFilter<"BranchUnitType"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    unitType?: XOR<UnitTypeCatalogRelationFilter, UnitTypeCatalogWhereInput>
  }

  export type BranchUnitTypeOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitTypeId?: SortOrder
    isEnabled?: SortOrder
    enabledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    unitType?: UnitTypeCatalogOrderByWithRelationInput
  }

  export type BranchUnitTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_unitTypeId?: BranchUnitTypeBranchIdUnitTypeIdCompoundUniqueInput
    AND?: BranchUnitTypeWhereInput | BranchUnitTypeWhereInput[]
    OR?: BranchUnitTypeWhereInput[]
    NOT?: BranchUnitTypeWhereInput | BranchUnitTypeWhereInput[]
    branchId?: StringFilter<"BranchUnitType"> | string
    unitTypeId?: StringFilter<"BranchUnitType"> | string
    isEnabled?: BoolFilter<"BranchUnitType"> | boolean
    enabledAt?: DateTimeFilter<"BranchUnitType"> | Date | string
    createdAt?: DateTimeFilter<"BranchUnitType"> | Date | string
    updatedAt?: DateTimeFilter<"BranchUnitType"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    unitType?: XOR<UnitTypeCatalogRelationFilter, UnitTypeCatalogWhereInput>
  }, "id" | "branchId_unitTypeId">

  export type BranchUnitTypeOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitTypeId?: SortOrder
    isEnabled?: SortOrder
    enabledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchUnitTypeCountOrderByAggregateInput
    _max?: BranchUnitTypeMaxOrderByAggregateInput
    _min?: BranchUnitTypeMinOrderByAggregateInput
  }

  export type BranchUnitTypeScalarWhereWithAggregatesInput = {
    AND?: BranchUnitTypeScalarWhereWithAggregatesInput | BranchUnitTypeScalarWhereWithAggregatesInput[]
    OR?: BranchUnitTypeScalarWhereWithAggregatesInput[]
    NOT?: BranchUnitTypeScalarWhereWithAggregatesInput | BranchUnitTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BranchUnitType"> | string
    branchId?: StringWithAggregatesFilter<"BranchUnitType"> | string
    unitTypeId?: StringWithAggregatesFilter<"BranchUnitType"> | string
    isEnabled?: BoolWithAggregatesFilter<"BranchUnitType"> | boolean
    enabledAt?: DateTimeWithAggregatesFilter<"BranchUnitType"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"BranchUnitType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BranchUnitType"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    branchId?: StringFilter<"Unit"> | string
    departmentId?: StringFilter<"Unit"> | string
    unitTypeId?: StringFilter<"Unit"> | string
    code?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    usesRooms?: BoolFilter<"Unit"> | boolean
    isActive?: BoolFilter<"Unit"> | boolean
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    unitType?: XOR<UnitTypeCatalogRelationFilter, UnitTypeCatalogWhereInput>
    rooms?: UnitRoomListRelationFilter
    resources?: UnitResourceListRelationFilter
    equipment?: EquipmentAssetListRelationFilter
    bookings?: ProcedureBookingListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    unitTypeId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    usesRooms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    unitType?: UnitTypeCatalogOrderByWithRelationInput
    rooms?: UnitRoomOrderByRelationAggregateInput
    resources?: UnitResourceOrderByRelationAggregateInput
    equipment?: EquipmentAssetOrderByRelationAggregateInput
    bookings?: ProcedureBookingOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: UnitBranchIdCodeCompoundUniqueInput
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    branchId?: StringFilter<"Unit"> | string
    departmentId?: StringFilter<"Unit"> | string
    unitTypeId?: StringFilter<"Unit"> | string
    code?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    usesRooms?: BoolFilter<"Unit"> | boolean
    isActive?: BoolFilter<"Unit"> | boolean
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    unitType?: XOR<UnitTypeCatalogRelationFilter, UnitTypeCatalogWhereInput>
    rooms?: UnitRoomListRelationFilter
    resources?: UnitResourceListRelationFilter
    equipment?: EquipmentAssetListRelationFilter
    bookings?: ProcedureBookingListRelationFilter
  }, "id" | "branchId_code">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    unitTypeId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    usesRooms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    branchId?: StringWithAggregatesFilter<"Unit"> | string
    departmentId?: StringWithAggregatesFilter<"Unit"> | string
    unitTypeId?: StringWithAggregatesFilter<"Unit"> | string
    code?: StringWithAggregatesFilter<"Unit"> | string
    name?: StringWithAggregatesFilter<"Unit"> | string
    usesRooms?: BoolWithAggregatesFilter<"Unit"> | boolean
    isActive?: BoolWithAggregatesFilter<"Unit"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type UnitRoomWhereInput = {
    AND?: UnitRoomWhereInput | UnitRoomWhereInput[]
    OR?: UnitRoomWhereInput[]
    NOT?: UnitRoomWhereInput | UnitRoomWhereInput[]
    id?: StringFilter<"UnitRoom"> | string
    unitId?: StringFilter<"UnitRoom"> | string
    branchId?: StringFilter<"UnitRoom"> | string
    code?: StringFilter<"UnitRoom"> | string
    name?: StringFilter<"UnitRoom"> | string
    isActive?: BoolFilter<"UnitRoom"> | boolean
    createdAt?: DateTimeFilter<"UnitRoom"> | Date | string
    updatedAt?: DateTimeFilter<"UnitRoom"> | Date | string
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    resources?: UnitResourceListRelationFilter
    equipment?: EquipmentAssetListRelationFilter
  }

  export type UnitRoomOrderByWithRelationInput = {
    id?: SortOrder
    unitId?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    unit?: UnitOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    resources?: UnitResourceOrderByRelationAggregateInput
    equipment?: EquipmentAssetOrderByRelationAggregateInput
  }

  export type UnitRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unitId_code?: UnitRoomUnitIdCodeCompoundUniqueInput
    AND?: UnitRoomWhereInput | UnitRoomWhereInput[]
    OR?: UnitRoomWhereInput[]
    NOT?: UnitRoomWhereInput | UnitRoomWhereInput[]
    unitId?: StringFilter<"UnitRoom"> | string
    branchId?: StringFilter<"UnitRoom"> | string
    code?: StringFilter<"UnitRoom"> | string
    name?: StringFilter<"UnitRoom"> | string
    isActive?: BoolFilter<"UnitRoom"> | boolean
    createdAt?: DateTimeFilter<"UnitRoom"> | Date | string
    updatedAt?: DateTimeFilter<"UnitRoom"> | Date | string
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    resources?: UnitResourceListRelationFilter
    equipment?: EquipmentAssetListRelationFilter
  }, "id" | "unitId_code">

  export type UnitRoomOrderByWithAggregationInput = {
    id?: SortOrder
    unitId?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitRoomCountOrderByAggregateInput
    _max?: UnitRoomMaxOrderByAggregateInput
    _min?: UnitRoomMinOrderByAggregateInput
  }

  export type UnitRoomScalarWhereWithAggregatesInput = {
    AND?: UnitRoomScalarWhereWithAggregatesInput | UnitRoomScalarWhereWithAggregatesInput[]
    OR?: UnitRoomScalarWhereWithAggregatesInput[]
    NOT?: UnitRoomScalarWhereWithAggregatesInput | UnitRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitRoom"> | string
    unitId?: StringWithAggregatesFilter<"UnitRoom"> | string
    branchId?: StringWithAggregatesFilter<"UnitRoom"> | string
    code?: StringWithAggregatesFilter<"UnitRoom"> | string
    name?: StringWithAggregatesFilter<"UnitRoom"> | string
    isActive?: BoolWithAggregatesFilter<"UnitRoom"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UnitRoom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitRoom"> | Date | string
  }

  export type UnitResourceWhereInput = {
    AND?: UnitResourceWhereInput | UnitResourceWhereInput[]
    OR?: UnitResourceWhereInput[]
    NOT?: UnitResourceWhereInput | UnitResourceWhereInput[]
    id?: StringFilter<"UnitResource"> | string
    branchId?: StringFilter<"UnitResource"> | string
    unitId?: StringFilter<"UnitResource"> | string
    roomId?: StringNullableFilter<"UnitResource"> | string | null
    resourceType?: EnumUnitResourceTypeFilter<"UnitResource"> | $Enums.UnitResourceType
    code?: StringFilter<"UnitResource"> | string
    name?: StringFilter<"UnitResource"> | string
    state?: EnumUnitResourceStateFilter<"UnitResource"> | $Enums.UnitResourceState
    isActive?: BoolFilter<"UnitResource"> | boolean
    isSchedulable?: BoolFilter<"UnitResource"> | boolean
    createdAt?: DateTimeFilter<"UnitResource"> | Date | string
    updatedAt?: DateTimeFilter<"UnitResource"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    room?: XOR<UnitRoomNullableRelationFilter, UnitRoomWhereInput> | null
    bookings?: ProcedureBookingListRelationFilter
  }

  export type UnitResourceOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    resourceType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    isSchedulable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    room?: UnitRoomOrderByWithRelationInput
    bookings?: ProcedureBookingOrderByRelationAggregateInput
  }

  export type UnitResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unitId_code?: UnitResourceUnitIdCodeCompoundUniqueInput
    AND?: UnitResourceWhereInput | UnitResourceWhereInput[]
    OR?: UnitResourceWhereInput[]
    NOT?: UnitResourceWhereInput | UnitResourceWhereInput[]
    branchId?: StringFilter<"UnitResource"> | string
    unitId?: StringFilter<"UnitResource"> | string
    roomId?: StringNullableFilter<"UnitResource"> | string | null
    resourceType?: EnumUnitResourceTypeFilter<"UnitResource"> | $Enums.UnitResourceType
    code?: StringFilter<"UnitResource"> | string
    name?: StringFilter<"UnitResource"> | string
    state?: EnumUnitResourceStateFilter<"UnitResource"> | $Enums.UnitResourceState
    isActive?: BoolFilter<"UnitResource"> | boolean
    isSchedulable?: BoolFilter<"UnitResource"> | boolean
    createdAt?: DateTimeFilter<"UnitResource"> | Date | string
    updatedAt?: DateTimeFilter<"UnitResource"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    room?: XOR<UnitRoomNullableRelationFilter, UnitRoomWhereInput> | null
    bookings?: ProcedureBookingListRelationFilter
  }, "id" | "unitId_code">

  export type UnitResourceOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    resourceType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    isSchedulable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitResourceCountOrderByAggregateInput
    _max?: UnitResourceMaxOrderByAggregateInput
    _min?: UnitResourceMinOrderByAggregateInput
  }

  export type UnitResourceScalarWhereWithAggregatesInput = {
    AND?: UnitResourceScalarWhereWithAggregatesInput | UnitResourceScalarWhereWithAggregatesInput[]
    OR?: UnitResourceScalarWhereWithAggregatesInput[]
    NOT?: UnitResourceScalarWhereWithAggregatesInput | UnitResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitResource"> | string
    branchId?: StringWithAggregatesFilter<"UnitResource"> | string
    unitId?: StringWithAggregatesFilter<"UnitResource"> | string
    roomId?: StringNullableWithAggregatesFilter<"UnitResource"> | string | null
    resourceType?: EnumUnitResourceTypeWithAggregatesFilter<"UnitResource"> | $Enums.UnitResourceType
    code?: StringWithAggregatesFilter<"UnitResource"> | string
    name?: StringWithAggregatesFilter<"UnitResource"> | string
    state?: EnumUnitResourceStateWithAggregatesFilter<"UnitResource"> | $Enums.UnitResourceState
    isActive?: BoolWithAggregatesFilter<"UnitResource"> | boolean
    isSchedulable?: BoolWithAggregatesFilter<"UnitResource"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UnitResource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitResource"> | Date | string
  }

  export type EquipmentAssetWhereInput = {
    AND?: EquipmentAssetWhereInput | EquipmentAssetWhereInput[]
    OR?: EquipmentAssetWhereInput[]
    NOT?: EquipmentAssetWhereInput | EquipmentAssetWhereInput[]
    id?: StringFilter<"EquipmentAsset"> | string
    branchId?: StringFilter<"EquipmentAsset"> | string
    code?: StringFilter<"EquipmentAsset"> | string
    name?: StringFilter<"EquipmentAsset"> | string
    category?: EnumEquipmentComplianceCategoryFilter<"EquipmentAsset"> | $Enums.EquipmentComplianceCategory
    make?: StringNullableFilter<"EquipmentAsset"> | string | null
    model?: StringNullableFilter<"EquipmentAsset"> | string | null
    serial?: StringNullableFilter<"EquipmentAsset"> | string | null
    ownerDepartmentId?: StringNullableFilter<"EquipmentAsset"> | string | null
    unitId?: StringNullableFilter<"EquipmentAsset"> | string | null
    roomId?: StringNullableFilter<"EquipmentAsset"> | string | null
    locationNodeId?: StringNullableFilter<"EquipmentAsset"> | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFilter<"EquipmentAsset"> | $Enums.EquipmentOperationalStatus
    amcVendor?: StringNullableFilter<"EquipmentAsset"> | string | null
    amcValidFrom?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    amcValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    warrantyValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    pmFrequencyDays?: IntNullableFilter<"EquipmentAsset"> | number | null
    nextPmDueAt?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    aerbLicenseNo?: StringNullableFilter<"EquipmentAsset"> | string | null
    aerbValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    pcpndtRegNo?: StringNullableFilter<"EquipmentAsset"> | string | null
    pcpndtValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    isSchedulable?: BoolFilter<"EquipmentAsset"> | boolean
    createdAt?: DateTimeFilter<"EquipmentAsset"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentAsset"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    ownerDepartment?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    unit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    room?: XOR<UnitRoomNullableRelationFilter, UnitRoomWhereInput> | null
    locationNode?: XOR<LocationNodeNullableRelationFilter, LocationNodeWhereInput> | null
    downtimeTickets?: DowntimeTicketListRelationFilter
  }

  export type EquipmentAssetOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    make?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serial?: SortOrderInput | SortOrder
    ownerDepartmentId?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    locationNodeId?: SortOrderInput | SortOrder
    operationalStatus?: SortOrder
    amcVendor?: SortOrderInput | SortOrder
    amcValidFrom?: SortOrderInput | SortOrder
    amcValidTo?: SortOrderInput | SortOrder
    warrantyValidTo?: SortOrderInput | SortOrder
    pmFrequencyDays?: SortOrderInput | SortOrder
    nextPmDueAt?: SortOrderInput | SortOrder
    aerbLicenseNo?: SortOrderInput | SortOrder
    aerbValidTo?: SortOrderInput | SortOrder
    pcpndtRegNo?: SortOrderInput | SortOrder
    pcpndtValidTo?: SortOrderInput | SortOrder
    isSchedulable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    ownerDepartment?: DepartmentOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    room?: UnitRoomOrderByWithRelationInput
    locationNode?: LocationNodeOrderByWithRelationInput
    downtimeTickets?: DowntimeTicketOrderByRelationAggregateInput
  }

  export type EquipmentAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: EquipmentAssetBranchIdCodeCompoundUniqueInput
    AND?: EquipmentAssetWhereInput | EquipmentAssetWhereInput[]
    OR?: EquipmentAssetWhereInput[]
    NOT?: EquipmentAssetWhereInput | EquipmentAssetWhereInput[]
    branchId?: StringFilter<"EquipmentAsset"> | string
    code?: StringFilter<"EquipmentAsset"> | string
    name?: StringFilter<"EquipmentAsset"> | string
    category?: EnumEquipmentComplianceCategoryFilter<"EquipmentAsset"> | $Enums.EquipmentComplianceCategory
    make?: StringNullableFilter<"EquipmentAsset"> | string | null
    model?: StringNullableFilter<"EquipmentAsset"> | string | null
    serial?: StringNullableFilter<"EquipmentAsset"> | string | null
    ownerDepartmentId?: StringNullableFilter<"EquipmentAsset"> | string | null
    unitId?: StringNullableFilter<"EquipmentAsset"> | string | null
    roomId?: StringNullableFilter<"EquipmentAsset"> | string | null
    locationNodeId?: StringNullableFilter<"EquipmentAsset"> | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFilter<"EquipmentAsset"> | $Enums.EquipmentOperationalStatus
    amcVendor?: StringNullableFilter<"EquipmentAsset"> | string | null
    amcValidFrom?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    amcValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    warrantyValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    pmFrequencyDays?: IntNullableFilter<"EquipmentAsset"> | number | null
    nextPmDueAt?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    aerbLicenseNo?: StringNullableFilter<"EquipmentAsset"> | string | null
    aerbValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    pcpndtRegNo?: StringNullableFilter<"EquipmentAsset"> | string | null
    pcpndtValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    isSchedulable?: BoolFilter<"EquipmentAsset"> | boolean
    createdAt?: DateTimeFilter<"EquipmentAsset"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentAsset"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    ownerDepartment?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    unit?: XOR<UnitNullableRelationFilter, UnitWhereInput> | null
    room?: XOR<UnitRoomNullableRelationFilter, UnitRoomWhereInput> | null
    locationNode?: XOR<LocationNodeNullableRelationFilter, LocationNodeWhereInput> | null
    downtimeTickets?: DowntimeTicketListRelationFilter
  }, "id" | "branchId_code">

  export type EquipmentAssetOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    make?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    serial?: SortOrderInput | SortOrder
    ownerDepartmentId?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    locationNodeId?: SortOrderInput | SortOrder
    operationalStatus?: SortOrder
    amcVendor?: SortOrderInput | SortOrder
    amcValidFrom?: SortOrderInput | SortOrder
    amcValidTo?: SortOrderInput | SortOrder
    warrantyValidTo?: SortOrderInput | SortOrder
    pmFrequencyDays?: SortOrderInput | SortOrder
    nextPmDueAt?: SortOrderInput | SortOrder
    aerbLicenseNo?: SortOrderInput | SortOrder
    aerbValidTo?: SortOrderInput | SortOrder
    pcpndtRegNo?: SortOrderInput | SortOrder
    pcpndtValidTo?: SortOrderInput | SortOrder
    isSchedulable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentAssetCountOrderByAggregateInput
    _avg?: EquipmentAssetAvgOrderByAggregateInput
    _max?: EquipmentAssetMaxOrderByAggregateInput
    _min?: EquipmentAssetMinOrderByAggregateInput
    _sum?: EquipmentAssetSumOrderByAggregateInput
  }

  export type EquipmentAssetScalarWhereWithAggregatesInput = {
    AND?: EquipmentAssetScalarWhereWithAggregatesInput | EquipmentAssetScalarWhereWithAggregatesInput[]
    OR?: EquipmentAssetScalarWhereWithAggregatesInput[]
    NOT?: EquipmentAssetScalarWhereWithAggregatesInput | EquipmentAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentAsset"> | string
    branchId?: StringWithAggregatesFilter<"EquipmentAsset"> | string
    code?: StringWithAggregatesFilter<"EquipmentAsset"> | string
    name?: StringWithAggregatesFilter<"EquipmentAsset"> | string
    category?: EnumEquipmentComplianceCategoryWithAggregatesFilter<"EquipmentAsset"> | $Enums.EquipmentComplianceCategory
    make?: StringNullableWithAggregatesFilter<"EquipmentAsset"> | string | null
    model?: StringNullableWithAggregatesFilter<"EquipmentAsset"> | string | null
    serial?: StringNullableWithAggregatesFilter<"EquipmentAsset"> | string | null
    ownerDepartmentId?: StringNullableWithAggregatesFilter<"EquipmentAsset"> | string | null
    unitId?: StringNullableWithAggregatesFilter<"EquipmentAsset"> | string | null
    roomId?: StringNullableWithAggregatesFilter<"EquipmentAsset"> | string | null
    locationNodeId?: StringNullableWithAggregatesFilter<"EquipmentAsset"> | string | null
    operationalStatus?: EnumEquipmentOperationalStatusWithAggregatesFilter<"EquipmentAsset"> | $Enums.EquipmentOperationalStatus
    amcVendor?: StringNullableWithAggregatesFilter<"EquipmentAsset"> | string | null
    amcValidFrom?: DateTimeNullableWithAggregatesFilter<"EquipmentAsset"> | Date | string | null
    amcValidTo?: DateTimeNullableWithAggregatesFilter<"EquipmentAsset"> | Date | string | null
    warrantyValidTo?: DateTimeNullableWithAggregatesFilter<"EquipmentAsset"> | Date | string | null
    pmFrequencyDays?: IntNullableWithAggregatesFilter<"EquipmentAsset"> | number | null
    nextPmDueAt?: DateTimeNullableWithAggregatesFilter<"EquipmentAsset"> | Date | string | null
    aerbLicenseNo?: StringNullableWithAggregatesFilter<"EquipmentAsset"> | string | null
    aerbValidTo?: DateTimeNullableWithAggregatesFilter<"EquipmentAsset"> | Date | string | null
    pcpndtRegNo?: StringNullableWithAggregatesFilter<"EquipmentAsset"> | string | null
    pcpndtValidTo?: DateTimeNullableWithAggregatesFilter<"EquipmentAsset"> | Date | string | null
    isSchedulable?: BoolWithAggregatesFilter<"EquipmentAsset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentAsset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EquipmentAsset"> | Date | string
  }

  export type DowntimeTicketWhereInput = {
    AND?: DowntimeTicketWhereInput | DowntimeTicketWhereInput[]
    OR?: DowntimeTicketWhereInput[]
    NOT?: DowntimeTicketWhereInput | DowntimeTicketWhereInput[]
    id?: StringFilter<"DowntimeTicket"> | string
    assetId?: StringFilter<"DowntimeTicket"> | string
    status?: EnumDowntimeStatusFilter<"DowntimeTicket"> | $Enums.DowntimeStatus
    reason?: StringFilter<"DowntimeTicket"> | string
    notes?: StringNullableFilter<"DowntimeTicket"> | string | null
    openedAt?: DateTimeFilter<"DowntimeTicket"> | Date | string
    closedAt?: DateTimeNullableFilter<"DowntimeTicket"> | Date | string | null
    createdAt?: DateTimeFilter<"DowntimeTicket"> | Date | string
    updatedAt?: DateTimeFilter<"DowntimeTicket"> | Date | string
    asset?: XOR<EquipmentAssetRelationFilter, EquipmentAssetWhereInput>
  }

  export type DowntimeTicketOrderByWithRelationInput = {
    id?: SortOrder
    assetId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    asset?: EquipmentAssetOrderByWithRelationInput
  }

  export type DowntimeTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DowntimeTicketWhereInput | DowntimeTicketWhereInput[]
    OR?: DowntimeTicketWhereInput[]
    NOT?: DowntimeTicketWhereInput | DowntimeTicketWhereInput[]
    assetId?: StringFilter<"DowntimeTicket"> | string
    status?: EnumDowntimeStatusFilter<"DowntimeTicket"> | $Enums.DowntimeStatus
    reason?: StringFilter<"DowntimeTicket"> | string
    notes?: StringNullableFilter<"DowntimeTicket"> | string | null
    openedAt?: DateTimeFilter<"DowntimeTicket"> | Date | string
    closedAt?: DateTimeNullableFilter<"DowntimeTicket"> | Date | string | null
    createdAt?: DateTimeFilter<"DowntimeTicket"> | Date | string
    updatedAt?: DateTimeFilter<"DowntimeTicket"> | Date | string
    asset?: XOR<EquipmentAssetRelationFilter, EquipmentAssetWhereInput>
  }, "id">

  export type DowntimeTicketOrderByWithAggregationInput = {
    id?: SortOrder
    assetId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DowntimeTicketCountOrderByAggregateInput
    _max?: DowntimeTicketMaxOrderByAggregateInput
    _min?: DowntimeTicketMinOrderByAggregateInput
  }

  export type DowntimeTicketScalarWhereWithAggregatesInput = {
    AND?: DowntimeTicketScalarWhereWithAggregatesInput | DowntimeTicketScalarWhereWithAggregatesInput[]
    OR?: DowntimeTicketScalarWhereWithAggregatesInput[]
    NOT?: DowntimeTicketScalarWhereWithAggregatesInput | DowntimeTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DowntimeTicket"> | string
    assetId?: StringWithAggregatesFilter<"DowntimeTicket"> | string
    status?: EnumDowntimeStatusWithAggregatesFilter<"DowntimeTicket"> | $Enums.DowntimeStatus
    reason?: StringWithAggregatesFilter<"DowntimeTicket"> | string
    notes?: StringNullableWithAggregatesFilter<"DowntimeTicket"> | string | null
    openedAt?: DateTimeWithAggregatesFilter<"DowntimeTicket"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"DowntimeTicket"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DowntimeTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DowntimeTicket"> | Date | string
  }

  export type ChargeMasterItemWhereInput = {
    AND?: ChargeMasterItemWhereInput | ChargeMasterItemWhereInput[]
    OR?: ChargeMasterItemWhereInput[]
    NOT?: ChargeMasterItemWhereInput | ChargeMasterItemWhereInput[]
    id?: StringFilter<"ChargeMasterItem"> | string
    branchId?: StringFilter<"ChargeMasterItem"> | string
    code?: StringFilter<"ChargeMasterItem"> | string
    name?: StringFilter<"ChargeMasterItem"> | string
    category?: StringNullableFilter<"ChargeMasterItem"> | string | null
    unit?: StringNullableFilter<"ChargeMasterItem"> | string | null
    isActive?: BoolFilter<"ChargeMasterItem"> | boolean
    createdAt?: DateTimeFilter<"ChargeMasterItem"> | Date | string
    updatedAt?: DateTimeFilter<"ChargeMasterItem"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    mappings?: ServiceChargeMappingListRelationFilter
  }

  export type ChargeMasterItemOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    mappings?: ServiceChargeMappingOrderByRelationAggregateInput
  }

  export type ChargeMasterItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: ChargeMasterItemBranchIdCodeCompoundUniqueInput
    AND?: ChargeMasterItemWhereInput | ChargeMasterItemWhereInput[]
    OR?: ChargeMasterItemWhereInput[]
    NOT?: ChargeMasterItemWhereInput | ChargeMasterItemWhereInput[]
    branchId?: StringFilter<"ChargeMasterItem"> | string
    code?: StringFilter<"ChargeMasterItem"> | string
    name?: StringFilter<"ChargeMasterItem"> | string
    category?: StringNullableFilter<"ChargeMasterItem"> | string | null
    unit?: StringNullableFilter<"ChargeMasterItem"> | string | null
    isActive?: BoolFilter<"ChargeMasterItem"> | boolean
    createdAt?: DateTimeFilter<"ChargeMasterItem"> | Date | string
    updatedAt?: DateTimeFilter<"ChargeMasterItem"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    mappings?: ServiceChargeMappingListRelationFilter
  }, "id" | "branchId_code">

  export type ChargeMasterItemOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChargeMasterItemCountOrderByAggregateInput
    _max?: ChargeMasterItemMaxOrderByAggregateInput
    _min?: ChargeMasterItemMinOrderByAggregateInput
  }

  export type ChargeMasterItemScalarWhereWithAggregatesInput = {
    AND?: ChargeMasterItemScalarWhereWithAggregatesInput | ChargeMasterItemScalarWhereWithAggregatesInput[]
    OR?: ChargeMasterItemScalarWhereWithAggregatesInput[]
    NOT?: ChargeMasterItemScalarWhereWithAggregatesInput | ChargeMasterItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChargeMasterItem"> | string
    branchId?: StringWithAggregatesFilter<"ChargeMasterItem"> | string
    code?: StringWithAggregatesFilter<"ChargeMasterItem"> | string
    name?: StringWithAggregatesFilter<"ChargeMasterItem"> | string
    category?: StringNullableWithAggregatesFilter<"ChargeMasterItem"> | string | null
    unit?: StringNullableWithAggregatesFilter<"ChargeMasterItem"> | string | null
    isActive?: BoolWithAggregatesFilter<"ChargeMasterItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChargeMasterItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChargeMasterItem"> | Date | string
  }

  export type ServiceItemWhereInput = {
    AND?: ServiceItemWhereInput | ServiceItemWhereInput[]
    OR?: ServiceItemWhereInput[]
    NOT?: ServiceItemWhereInput | ServiceItemWhereInput[]
    id?: StringFilter<"ServiceItem"> | string
    branchId?: StringFilter<"ServiceItem"> | string
    code?: StringFilter<"ServiceItem"> | string
    name?: StringFilter<"ServiceItem"> | string
    category?: StringFilter<"ServiceItem"> | string
    unit?: StringNullableFilter<"ServiceItem"> | string | null
    isOrderable?: BoolFilter<"ServiceItem"> | boolean
    isActive?: BoolFilter<"ServiceItem"> | boolean
    createdAt?: DateTimeFilter<"ServiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceItem"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    mappings?: ServiceChargeMappingListRelationFilter
    fixIts?: FixItTaskListRelationFilter
  }

  export type ServiceItemOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrderInput | SortOrder
    isOrderable?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    mappings?: ServiceChargeMappingOrderByRelationAggregateInput
    fixIts?: FixItTaskOrderByRelationAggregateInput
  }

  export type ServiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: ServiceItemBranchIdCodeCompoundUniqueInput
    AND?: ServiceItemWhereInput | ServiceItemWhereInput[]
    OR?: ServiceItemWhereInput[]
    NOT?: ServiceItemWhereInput | ServiceItemWhereInput[]
    branchId?: StringFilter<"ServiceItem"> | string
    code?: StringFilter<"ServiceItem"> | string
    name?: StringFilter<"ServiceItem"> | string
    category?: StringFilter<"ServiceItem"> | string
    unit?: StringNullableFilter<"ServiceItem"> | string | null
    isOrderable?: BoolFilter<"ServiceItem"> | boolean
    isActive?: BoolFilter<"ServiceItem"> | boolean
    createdAt?: DateTimeFilter<"ServiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceItem"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    mappings?: ServiceChargeMappingListRelationFilter
    fixIts?: FixItTaskListRelationFilter
  }, "id" | "branchId_code">

  export type ServiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrderInput | SortOrder
    isOrderable?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceItemCountOrderByAggregateInput
    _max?: ServiceItemMaxOrderByAggregateInput
    _min?: ServiceItemMinOrderByAggregateInput
  }

  export type ServiceItemScalarWhereWithAggregatesInput = {
    AND?: ServiceItemScalarWhereWithAggregatesInput | ServiceItemScalarWhereWithAggregatesInput[]
    OR?: ServiceItemScalarWhereWithAggregatesInput[]
    NOT?: ServiceItemScalarWhereWithAggregatesInput | ServiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceItem"> | string
    branchId?: StringWithAggregatesFilter<"ServiceItem"> | string
    code?: StringWithAggregatesFilter<"ServiceItem"> | string
    name?: StringWithAggregatesFilter<"ServiceItem"> | string
    category?: StringWithAggregatesFilter<"ServiceItem"> | string
    unit?: StringNullableWithAggregatesFilter<"ServiceItem"> | string | null
    isOrderable?: BoolWithAggregatesFilter<"ServiceItem"> | boolean
    isActive?: BoolWithAggregatesFilter<"ServiceItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ServiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceItem"> | Date | string
  }

  export type ServiceChargeMappingWhereInput = {
    AND?: ServiceChargeMappingWhereInput | ServiceChargeMappingWhereInput[]
    OR?: ServiceChargeMappingWhereInput[]
    NOT?: ServiceChargeMappingWhereInput | ServiceChargeMappingWhereInput[]
    id?: StringFilter<"ServiceChargeMapping"> | string
    branchId?: StringFilter<"ServiceChargeMapping"> | string
    serviceItemId?: StringFilter<"ServiceChargeMapping"> | string
    chargeMasterItemId?: StringFilter<"ServiceChargeMapping"> | string
    effectiveFrom?: DateTimeFilter<"ServiceChargeMapping"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"ServiceChargeMapping"> | Date | string | null
    version?: IntFilter<"ServiceChargeMapping"> | number
    createdAt?: DateTimeFilter<"ServiceChargeMapping"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceChargeMapping"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    serviceItem?: XOR<ServiceItemRelationFilter, ServiceItemWhereInput>
    chargeMasterItem?: XOR<ChargeMasterItemRelationFilter, ChargeMasterItemWhereInput>
  }

  export type ServiceChargeMappingOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    serviceItemId?: SortOrder
    chargeMasterItemId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    serviceItem?: ServiceItemOrderByWithRelationInput
    chargeMasterItem?: ChargeMasterItemOrderByWithRelationInput
  }

  export type ServiceChargeMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceChargeMappingWhereInput | ServiceChargeMappingWhereInput[]
    OR?: ServiceChargeMappingWhereInput[]
    NOT?: ServiceChargeMappingWhereInput | ServiceChargeMappingWhereInput[]
    branchId?: StringFilter<"ServiceChargeMapping"> | string
    serviceItemId?: StringFilter<"ServiceChargeMapping"> | string
    chargeMasterItemId?: StringFilter<"ServiceChargeMapping"> | string
    effectiveFrom?: DateTimeFilter<"ServiceChargeMapping"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"ServiceChargeMapping"> | Date | string | null
    version?: IntFilter<"ServiceChargeMapping"> | number
    createdAt?: DateTimeFilter<"ServiceChargeMapping"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceChargeMapping"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    serviceItem?: XOR<ServiceItemRelationFilter, ServiceItemWhereInput>
    chargeMasterItem?: XOR<ChargeMasterItemRelationFilter, ChargeMasterItemWhereInput>
  }, "id">

  export type ServiceChargeMappingOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    serviceItemId?: SortOrder
    chargeMasterItemId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceChargeMappingCountOrderByAggregateInput
    _avg?: ServiceChargeMappingAvgOrderByAggregateInput
    _max?: ServiceChargeMappingMaxOrderByAggregateInput
    _min?: ServiceChargeMappingMinOrderByAggregateInput
    _sum?: ServiceChargeMappingSumOrderByAggregateInput
  }

  export type ServiceChargeMappingScalarWhereWithAggregatesInput = {
    AND?: ServiceChargeMappingScalarWhereWithAggregatesInput | ServiceChargeMappingScalarWhereWithAggregatesInput[]
    OR?: ServiceChargeMappingScalarWhereWithAggregatesInput[]
    NOT?: ServiceChargeMappingScalarWhereWithAggregatesInput | ServiceChargeMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceChargeMapping"> | string
    branchId?: StringWithAggregatesFilter<"ServiceChargeMapping"> | string
    serviceItemId?: StringWithAggregatesFilter<"ServiceChargeMapping"> | string
    chargeMasterItemId?: StringWithAggregatesFilter<"ServiceChargeMapping"> | string
    effectiveFrom?: DateTimeWithAggregatesFilter<"ServiceChargeMapping"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"ServiceChargeMapping"> | Date | string | null
    version?: IntWithAggregatesFilter<"ServiceChargeMapping"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ServiceChargeMapping"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceChargeMapping"> | Date | string
  }

  export type FixItTaskWhereInput = {
    AND?: FixItTaskWhereInput | FixItTaskWhereInput[]
    OR?: FixItTaskWhereInput[]
    NOT?: FixItTaskWhereInput | FixItTaskWhereInput[]
    id?: StringFilter<"FixItTask"> | string
    branchId?: StringFilter<"FixItTask"> | string
    type?: EnumFixItTypeFilter<"FixItTask"> | $Enums.FixItType
    status?: EnumFixItStatusFilter<"FixItTask"> | $Enums.FixItStatus
    title?: StringFilter<"FixItTask"> | string
    details?: JsonNullableFilter<"FixItTask">
    serviceItemId?: StringNullableFilter<"FixItTask"> | string | null
    assignedToUserId?: StringNullableFilter<"FixItTask"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FixItTask"> | Date | string | null
    createdAt?: DateTimeFilter<"FixItTask"> | Date | string
    updatedAt?: DateTimeFilter<"FixItTask"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    serviceItem?: XOR<ServiceItemNullableRelationFilter, ServiceItemWhereInput> | null
    assignedToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type FixItTaskOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    details?: SortOrderInput | SortOrder
    serviceItemId?: SortOrderInput | SortOrder
    assignedToUserId?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    serviceItem?: ServiceItemOrderByWithRelationInput
    assignedToUser?: UserOrderByWithRelationInput
  }

  export type FixItTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FixItTaskWhereInput | FixItTaskWhereInput[]
    OR?: FixItTaskWhereInput[]
    NOT?: FixItTaskWhereInput | FixItTaskWhereInput[]
    branchId?: StringFilter<"FixItTask"> | string
    type?: EnumFixItTypeFilter<"FixItTask"> | $Enums.FixItType
    status?: EnumFixItStatusFilter<"FixItTask"> | $Enums.FixItStatus
    title?: StringFilter<"FixItTask"> | string
    details?: JsonNullableFilter<"FixItTask">
    serviceItemId?: StringNullableFilter<"FixItTask"> | string | null
    assignedToUserId?: StringNullableFilter<"FixItTask"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FixItTask"> | Date | string | null
    createdAt?: DateTimeFilter<"FixItTask"> | Date | string
    updatedAt?: DateTimeFilter<"FixItTask"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    serviceItem?: XOR<ServiceItemNullableRelationFilter, ServiceItemWhereInput> | null
    assignedToUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type FixItTaskOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    details?: SortOrderInput | SortOrder
    serviceItemId?: SortOrderInput | SortOrder
    assignedToUserId?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FixItTaskCountOrderByAggregateInput
    _max?: FixItTaskMaxOrderByAggregateInput
    _min?: FixItTaskMinOrderByAggregateInput
  }

  export type FixItTaskScalarWhereWithAggregatesInput = {
    AND?: FixItTaskScalarWhereWithAggregatesInput | FixItTaskScalarWhereWithAggregatesInput[]
    OR?: FixItTaskScalarWhereWithAggregatesInput[]
    NOT?: FixItTaskScalarWhereWithAggregatesInput | FixItTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FixItTask"> | string
    branchId?: StringWithAggregatesFilter<"FixItTask"> | string
    type?: EnumFixItTypeWithAggregatesFilter<"FixItTask"> | $Enums.FixItType
    status?: EnumFixItStatusWithAggregatesFilter<"FixItTask"> | $Enums.FixItStatus
    title?: StringWithAggregatesFilter<"FixItTask"> | string
    details?: JsonNullableWithAggregatesFilter<"FixItTask">
    serviceItemId?: StringNullableWithAggregatesFilter<"FixItTask"> | string | null
    assignedToUserId?: StringNullableWithAggregatesFilter<"FixItTask"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"FixItTask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FixItTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FixItTask"> | Date | string
  }

  export type BulkImportJobWhereInput = {
    AND?: BulkImportJobWhereInput | BulkImportJobWhereInput[]
    OR?: BulkImportJobWhereInput[]
    NOT?: BulkImportJobWhereInput | BulkImportJobWhereInput[]
    id?: StringFilter<"BulkImportJob"> | string
    branchId?: StringFilter<"BulkImportJob"> | string
    entityType?: EnumImportEntityTypeFilter<"BulkImportJob"> | $Enums.ImportEntityType
    status?: EnumImportJobStatusFilter<"BulkImportJob"> | $Enums.ImportJobStatus
    fileName?: StringNullableFilter<"BulkImportJob"> | string | null
    payload?: JsonNullableFilter<"BulkImportJob">
    errors?: JsonNullableFilter<"BulkImportJob">
    totalRows?: IntFilter<"BulkImportJob"> | number
    validRows?: IntFilter<"BulkImportJob"> | number
    invalidRows?: IntFilter<"BulkImportJob"> | number
    createdByUserId?: StringNullableFilter<"BulkImportJob"> | string | null
    committedAt?: DateTimeNullableFilter<"BulkImportJob"> | Date | string | null
    createdAt?: DateTimeFilter<"BulkImportJob"> | Date | string
    updatedAt?: DateTimeFilter<"BulkImportJob"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type BulkImportJobOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    fileName?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    errors?: SortOrderInput | SortOrder
    totalRows?: SortOrder
    validRows?: SortOrder
    invalidRows?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    committedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
  }

  export type BulkImportJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BulkImportJobWhereInput | BulkImportJobWhereInput[]
    OR?: BulkImportJobWhereInput[]
    NOT?: BulkImportJobWhereInput | BulkImportJobWhereInput[]
    branchId?: StringFilter<"BulkImportJob"> | string
    entityType?: EnumImportEntityTypeFilter<"BulkImportJob"> | $Enums.ImportEntityType
    status?: EnumImportJobStatusFilter<"BulkImportJob"> | $Enums.ImportJobStatus
    fileName?: StringNullableFilter<"BulkImportJob"> | string | null
    payload?: JsonNullableFilter<"BulkImportJob">
    errors?: JsonNullableFilter<"BulkImportJob">
    totalRows?: IntFilter<"BulkImportJob"> | number
    validRows?: IntFilter<"BulkImportJob"> | number
    invalidRows?: IntFilter<"BulkImportJob"> | number
    createdByUserId?: StringNullableFilter<"BulkImportJob"> | string | null
    committedAt?: DateTimeNullableFilter<"BulkImportJob"> | Date | string | null
    createdAt?: DateTimeFilter<"BulkImportJob"> | Date | string
    updatedAt?: DateTimeFilter<"BulkImportJob"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type BulkImportJobOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    fileName?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    errors?: SortOrderInput | SortOrder
    totalRows?: SortOrder
    validRows?: SortOrder
    invalidRows?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    committedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BulkImportJobCountOrderByAggregateInput
    _avg?: BulkImportJobAvgOrderByAggregateInput
    _max?: BulkImportJobMaxOrderByAggregateInput
    _min?: BulkImportJobMinOrderByAggregateInput
    _sum?: BulkImportJobSumOrderByAggregateInput
  }

  export type BulkImportJobScalarWhereWithAggregatesInput = {
    AND?: BulkImportJobScalarWhereWithAggregatesInput | BulkImportJobScalarWhereWithAggregatesInput[]
    OR?: BulkImportJobScalarWhereWithAggregatesInput[]
    NOT?: BulkImportJobScalarWhereWithAggregatesInput | BulkImportJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BulkImportJob"> | string
    branchId?: StringWithAggregatesFilter<"BulkImportJob"> | string
    entityType?: EnumImportEntityTypeWithAggregatesFilter<"BulkImportJob"> | $Enums.ImportEntityType
    status?: EnumImportJobStatusWithAggregatesFilter<"BulkImportJob"> | $Enums.ImportJobStatus
    fileName?: StringNullableWithAggregatesFilter<"BulkImportJob"> | string | null
    payload?: JsonNullableWithAggregatesFilter<"BulkImportJob">
    errors?: JsonNullableWithAggregatesFilter<"BulkImportJob">
    totalRows?: IntWithAggregatesFilter<"BulkImportJob"> | number
    validRows?: IntWithAggregatesFilter<"BulkImportJob"> | number
    invalidRows?: IntWithAggregatesFilter<"BulkImportJob"> | number
    createdByUserId?: StringNullableWithAggregatesFilter<"BulkImportJob"> | string | null
    committedAt?: DateTimeNullableWithAggregatesFilter<"BulkImportJob"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BulkImportJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BulkImportJob"> | Date | string
  }

  export type ProcedureBookingWhereInput = {
    AND?: ProcedureBookingWhereInput | ProcedureBookingWhereInput[]
    OR?: ProcedureBookingWhereInput[]
    NOT?: ProcedureBookingWhereInput | ProcedureBookingWhereInput[]
    id?: StringFilter<"ProcedureBooking"> | string
    branchId?: StringFilter<"ProcedureBooking"> | string
    unitId?: StringFilter<"ProcedureBooking"> | string
    resourceId?: StringFilter<"ProcedureBooking"> | string
    patientId?: StringNullableFilter<"ProcedureBooking"> | string | null
    departmentId?: StringNullableFilter<"ProcedureBooking"> | string | null
    startAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
    endAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
    status?: EnumBookingStatusFilter<"ProcedureBooking"> | $Enums.BookingStatus
    consentOk?: BoolFilter<"ProcedureBooking"> | boolean
    anesthesiaOk?: BoolFilter<"ProcedureBooking"> | boolean
    checklistOk?: BoolFilter<"ProcedureBooking"> | boolean
    createdByUserId?: StringNullableFilter<"ProcedureBooking"> | string | null
    createdAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    resource?: XOR<UnitResourceRelationFilter, UnitResourceWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ProcedureBookingOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitId?: SortOrder
    resourceId?: SortOrder
    patientId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    consentOk?: SortOrder
    anesthesiaOk?: SortOrder
    checklistOk?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    resource?: UnitResourceOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
  }

  export type ProcedureBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProcedureBookingWhereInput | ProcedureBookingWhereInput[]
    OR?: ProcedureBookingWhereInput[]
    NOT?: ProcedureBookingWhereInput | ProcedureBookingWhereInput[]
    branchId?: StringFilter<"ProcedureBooking"> | string
    unitId?: StringFilter<"ProcedureBooking"> | string
    resourceId?: StringFilter<"ProcedureBooking"> | string
    patientId?: StringNullableFilter<"ProcedureBooking"> | string | null
    departmentId?: StringNullableFilter<"ProcedureBooking"> | string | null
    startAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
    endAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
    status?: EnumBookingStatusFilter<"ProcedureBooking"> | $Enums.BookingStatus
    consentOk?: BoolFilter<"ProcedureBooking"> | boolean
    anesthesiaOk?: BoolFilter<"ProcedureBooking"> | boolean
    checklistOk?: BoolFilter<"ProcedureBooking"> | boolean
    createdByUserId?: StringNullableFilter<"ProcedureBooking"> | string | null
    createdAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    resource?: XOR<UnitResourceRelationFilter, UnitResourceWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ProcedureBookingOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitId?: SortOrder
    resourceId?: SortOrder
    patientId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    consentOk?: SortOrder
    anesthesiaOk?: SortOrder
    checklistOk?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProcedureBookingCountOrderByAggregateInput
    _max?: ProcedureBookingMaxOrderByAggregateInput
    _min?: ProcedureBookingMinOrderByAggregateInput
  }

  export type ProcedureBookingScalarWhereWithAggregatesInput = {
    AND?: ProcedureBookingScalarWhereWithAggregatesInput | ProcedureBookingScalarWhereWithAggregatesInput[]
    OR?: ProcedureBookingScalarWhereWithAggregatesInput[]
    NOT?: ProcedureBookingScalarWhereWithAggregatesInput | ProcedureBookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProcedureBooking"> | string
    branchId?: StringWithAggregatesFilter<"ProcedureBooking"> | string
    unitId?: StringWithAggregatesFilter<"ProcedureBooking"> | string
    resourceId?: StringWithAggregatesFilter<"ProcedureBooking"> | string
    patientId?: StringNullableWithAggregatesFilter<"ProcedureBooking"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"ProcedureBooking"> | string | null
    startAt?: DateTimeWithAggregatesFilter<"ProcedureBooking"> | Date | string
    endAt?: DateTimeWithAggregatesFilter<"ProcedureBooking"> | Date | string
    status?: EnumBookingStatusWithAggregatesFilter<"ProcedureBooking"> | $Enums.BookingStatus
    consentOk?: BoolWithAggregatesFilter<"ProcedureBooking"> | boolean
    anesthesiaOk?: BoolWithAggregatesFilter<"ProcedureBooking"> | boolean
    checklistOk?: BoolWithAggregatesFilter<"ProcedureBooking"> | boolean
    createdByUserId?: StringNullableWithAggregatesFilter<"ProcedureBooking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProcedureBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProcedureBooking"> | Date | string
  }

  export type GoLiveReportWhereInput = {
    AND?: GoLiveReportWhereInput | GoLiveReportWhereInput[]
    OR?: GoLiveReportWhereInput[]
    NOT?: GoLiveReportWhereInput | GoLiveReportWhereInput[]
    id?: StringFilter<"GoLiveReport"> | string
    branchId?: StringFilter<"GoLiveReport"> | string
    score?: IntFilter<"GoLiveReport"> | number
    blockers?: JsonFilter<"GoLiveReport">
    warnings?: JsonFilter<"GoLiveReport">
    snapshot?: JsonFilter<"GoLiveReport">
    createdByUserId?: StringNullableFilter<"GoLiveReport"> | string | null
    createdAt?: DateTimeFilter<"GoLiveReport"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type GoLiveReportOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    score?: SortOrder
    blockers?: SortOrder
    warnings?: SortOrder
    snapshot?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
  }

  export type GoLiveReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GoLiveReportWhereInput | GoLiveReportWhereInput[]
    OR?: GoLiveReportWhereInput[]
    NOT?: GoLiveReportWhereInput | GoLiveReportWhereInput[]
    branchId?: StringFilter<"GoLiveReport"> | string
    score?: IntFilter<"GoLiveReport"> | number
    blockers?: JsonFilter<"GoLiveReport">
    warnings?: JsonFilter<"GoLiveReport">
    snapshot?: JsonFilter<"GoLiveReport">
    createdByUserId?: StringNullableFilter<"GoLiveReport"> | string | null
    createdAt?: DateTimeFilter<"GoLiveReport"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type GoLiveReportOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    score?: SortOrder
    blockers?: SortOrder
    warnings?: SortOrder
    snapshot?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GoLiveReportCountOrderByAggregateInput
    _avg?: GoLiveReportAvgOrderByAggregateInput
    _max?: GoLiveReportMaxOrderByAggregateInput
    _min?: GoLiveReportMinOrderByAggregateInput
    _sum?: GoLiveReportSumOrderByAggregateInput
  }

  export type GoLiveReportScalarWhereWithAggregatesInput = {
    AND?: GoLiveReportScalarWhereWithAggregatesInput | GoLiveReportScalarWhereWithAggregatesInput[]
    OR?: GoLiveReportScalarWhereWithAggregatesInput[]
    NOT?: GoLiveReportScalarWhereWithAggregatesInput | GoLiveReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GoLiveReport"> | string
    branchId?: StringWithAggregatesFilter<"GoLiveReport"> | string
    score?: IntWithAggregatesFilter<"GoLiveReport"> | number
    blockers?: JsonWithAggregatesFilter<"GoLiveReport">
    warnings?: JsonWithAggregatesFilter<"GoLiveReport">
    snapshot?: JsonWithAggregatesFilter<"GoLiveReport">
    createdByUserId?: StringNullableWithAggregatesFilter<"GoLiveReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GoLiveReport"> | Date | string
  }

  export type BranchCreateInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCatalogCreateInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FacilityCategory
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branchLinks?: BranchFacilityCreateNestedManyWithoutFacilityInput
    departments?: DepartmentCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCatalogUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FacilityCategory
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branchLinks?: BranchFacilityUncheckedCreateNestedManyWithoutFacilityInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCatalogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFacilityCategoryFieldUpdateOperationsInput | $Enums.FacilityCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchLinks?: BranchFacilityUpdateManyWithoutFacilityNestedInput
    departments?: DepartmentUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityCatalogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFacilityCategoryFieldUpdateOperationsInput | $Enums.FacilityCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchLinks?: BranchFacilityUncheckedUpdateManyWithoutFacilityNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityCatalogCreateManyInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FacilityCategory
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityCatalogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFacilityCategoryFieldUpdateOperationsInput | $Enums.FacilityCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCatalogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFacilityCategoryFieldUpdateOperationsInput | $Enums.FacilityCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchFacilityCreateInput = {
    id?: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBranchFacilitiesInput
    facility: FacilityCatalogCreateNestedOneWithoutBranchLinksInput
  }

  export type BranchFacilityUncheckedCreateInput = {
    id?: string
    branchId: string
    facilityId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchFacilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBranchFacilitiesNestedInput
    facility?: FacilityCatalogUpdateOneRequiredWithoutBranchLinksNestedInput
  }

  export type BranchFacilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchFacilityCreateManyInput = {
    id?: string
    branchId: string
    facilityId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchFacilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchFacilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDepartmentsInput
    facility: FacilityCatalogCreateNestedOneWithoutDepartmentsInput
    headStaff?: StaffCreateNestedOneWithoutHeadedDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutDepartmentInput
    units?: UnitCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    branchId: string
    facilityId: string
    code: string
    name: string
    headStaffId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutDepartmentInput
    units?: UnitUncheckedCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetUncheckedCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDepartmentsNestedInput
    facility?: FacilityCatalogUpdateOneRequiredWithoutDepartmentsNestedInput
    headStaff?: StaffUpdateOneWithoutHeadedDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutDepartmentNestedInput
    units?: UnitUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    headStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutDepartmentNestedInput
    units?: UnitUncheckedUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUncheckedUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    branchId: string
    facilityId: string
    code: string
    name: string
    headStaffId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    headStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDoctorCreateInput = {
    id?: string
    isPrimary?: boolean
    assignedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutDoctorAssignmentsInput
    staff: StaffCreateNestedOneWithoutDoctorAssignmentsInput
  }

  export type DepartmentDoctorUncheckedCreateInput = {
    id?: string
    departmentId: string
    staffId: string
    isPrimary?: boolean
    assignedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentDoctorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutDoctorAssignmentsNestedInput
    staff?: StaffUpdateOneRequiredWithoutDoctorAssignmentsNestedInput
  }

  export type DepartmentDoctorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDoctorCreateManyInput = {
    id?: string
    departmentId: string
    staffId: string
    isPrimary?: boolean
    assignedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentDoctorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDoctorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyCreateInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSpecialtyInput
    staff?: StaffCreateNestedManyWithoutSpecialtyInput
    departmentLinks?: DepartmentSpecialtyCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutSpecialtyInput
    departmentLinks?: DepartmentSpecialtyUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSpecialtyNestedInput
    staff?: StaffUpdateManyWithoutSpecialtyNestedInput
    departmentLinks?: DepartmentSpecialtyUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutSpecialtyNestedInput
    departmentLinks?: DepartmentSpecialtyUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentSpecialtyCreateInput = {
    id?: string
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutDepartmentSpecialtiesInput
    specialty: SpecialtyCreateNestedOneWithoutDepartmentLinksInput
  }

  export type DepartmentSpecialtyUncheckedCreateInput = {
    id?: string
    departmentId: string
    specialtyId: string
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentSpecialtyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutDepartmentSpecialtiesNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutDepartmentLinksNestedInput
  }

  export type DepartmentSpecialtyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentSpecialtyCreateManyInput = {
    id?: string
    departmentId: string
    specialtyId: string
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentSpecialtyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentSpecialtyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    specialty?: SpecialtyCreateNestedOneWithoutStaffInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutStaffInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadStaffInput
    user?: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutStaffInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadStaffInput
    user?: UserUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    specialty?: SpecialtyUpdateOneWithoutStaffNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutStaffNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadStaffNestedInput
    user?: UserUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutStaffNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadStaffNestedInput
    user?: UserUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffCreateManyInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateInput = {
    id?: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    admissions?: AdmissionCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateInput = {
    id?: string
    branchId: string
    patientId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    admissions?: AdmissionUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterCreateManyInput = {
    id?: string
    branchId: string
    patientId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardCreateInput = {
    id?: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutWardsInput
    rooms?: RoomCreateNestedManyWithoutWardInput
  }

  export type WardUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutWardsNestedInput
    rooms?: RoomUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutWardNestedInput
  }

  export type WardCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    code: string
    name: string
    floor?: string | null
    type?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutRoomsInput
    ward: WardCreateNestedOneWithoutRoomsInput
    beds?: BedCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    branchId: string
    wardId: string
    code: string
    name: string
    floor?: string | null
    type?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    beds?: BedUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutRoomsNestedInput
    ward?: WardUpdateOneRequiredWithoutRoomsNestedInput
    beds?: BedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beds?: BedUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    branchId: string
    wardId: string
    code: string
    name: string
    floor?: string | null
    type?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedCreateInput = {
    id?: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBedInput
    room: RoomCreateNestedOneWithoutBedsInput
    admissions?: AdmissionCreateNestedManyWithoutBedInput
  }

  export type BedUncheckedCreateInput = {
    id?: string
    branchId: string
    roomId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutBedInput
  }

  export type BedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBedNestedInput
    room?: RoomUpdateOneRequiredWithoutBedsNestedInput
    admissions?: AdmissionUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutBedNestedInput
  }

  export type BedCreateManyInput = {
    id?: string
    branchId: string
    roomId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionCreateInput = {
    id?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutAdmissionInput
    encounter?: EncounterCreateNestedOneWithoutAdmissionsInput
    patient: PatientCreateNestedOneWithoutAdmissionInput
    bed?: BedCreateNestedOneWithoutAdmissionsInput
  }

  export type AdmissionUncheckedCreateInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutAdmissionNestedInput
    encounter?: EncounterUpdateOneWithoutAdmissionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAdmissionNestedInput
    bed?: BedUpdateOneWithoutAdmissionsNestedInput
  }

  export type AdmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionCreateManyInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTCreateInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutOTsInput
  }

  export type OTUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutOTsNestedInput
  }

  export type OTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffPlanCreateInput = {
    id?: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutTariffPlansInput
    rates?: TariffRateCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rates?: TariffRateUncheckedCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutTariffPlansNestedInput
    rates?: TariffRateUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rates?: TariffRateUncheckedUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCatalogItemCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCatalogItemUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCatalogItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCatalogItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCatalogItemCreateManyInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCatalogItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCatalogItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateCreateInput = {
    id?: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tariffPlan: TariffPlanCreateNestedOneWithoutRatesInput
  }

  export type TariffRateUncheckedCreateInput = {
    id?: string
    tariffPlanId: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tariffPlan?: TariffPlanUpdateOneRequiredWithoutRatesNestedInput
  }

  export type TariffRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tariffPlanId?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateCreateManyInput = {
    id?: string
    tariffPlanId: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tariffPlanId?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordCreateInput = {
    id?: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutConsentRecordsInput
  }

  export type ConsentRecordUncheckedCreateInput = {
    id?: string
    patientId: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
  }

  export type ConsentRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutConsentRecordsNestedInput
  }

  export type ConsentRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordCreateManyInput = {
    id?: string
    patientId: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
  }

  export type ConsentRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestCreateInput = {
    id?: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutRtbfRequestsInput
  }

  export type RtbfRequestUncheckedCreateInput = {
    id?: string
    patientId: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RtbfRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRtbfRequestsNestedInput
  }

  export type RtbfRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestCreateManyInput = {
    id?: string
    patientId: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RtbfRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseCreateInput = {
    id?: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStatutoryCasesInput
    patient: PatientCreateNestedOneWithoutStatutoryCasesInput
  }

  export type StatutoryCaseUncheckedCreateInput = {
    id?: string
    branchId: string
    patientId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStatutoryCasesNestedInput
    patient?: PatientUpdateOneRequiredWithoutStatutoryCasesNestedInput
  }

  export type StatutoryCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseCreateManyInput = {
    id?: string
    branchId: string
    patientId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventCreateInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutAuditEventsInput
    actorUser?: UserCreateNestedOneWithoutAuditEventsAsActorInput
  }

  export type AuditEventUncheckedCreateInput = {
    id?: string
    branchId?: string | null
    actorUserId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutAuditEventsNestedInput
    actorUser?: UserUpdateOneWithoutAuditEventsAsActorNestedInput
  }

  export type AuditEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventCreateManyInput = {
    id?: string
    branchId?: string | null
    actorUserId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboxEventCreateInput = {
    id?: string
    topic: string
    key?: string | null
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.OutboxStatus
    attempts?: number
    availableAt?: Date | string
    lockedAt?: Date | string | null
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboxEventUncheckedCreateInput = {
    id?: string
    topic: string
    key?: string | null
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.OutboxStatus
    attempts?: number
    availableAt?: Date | string
    lockedAt?: Date | string | null
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboxEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    attempts?: IntFieldUpdateOperationsInput | number
    availableAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboxEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    attempts?: IntFieldUpdateOperationsInput | number
    availableAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboxEventCreateManyInput = {
    id?: string
    topic: string
    key?: string | null
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.OutboxStatus
    attempts?: number
    availableAt?: Date | string
    lockedAt?: Date | string | null
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboxEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    attempts?: IntFieldUpdateOperationsInput | number
    availableAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboxEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    attempts?: IntFieldUpdateOperationsInput | number
    availableAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleGrants?: RoleTemplatePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleGrants?: RoleTemplatePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleGrants?: RoleTemplatePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleGrants?: RoleTemplatePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    code: string
    name: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateCreateInput = {
    id?: string
    code: string
    name: string
    scope?: $Enums.RoleScope
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: RoleTemplateVersionCreateNestedManyWithoutRoleTemplateInput
  }

  export type RoleTemplateUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    scope?: $Enums.RoleScope
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutRoleTemplateInput
  }

  export type RoleTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: RoleTemplateVersionUpdateManyWithoutRoleTemplateNestedInput
  }

  export type RoleTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: RoleTemplateVersionUncheckedUpdateManyWithoutRoleTemplateNestedInput
  }

  export type RoleTemplateCreateManyInput = {
    id?: string
    code: string
    name: string
    scope?: $Enums.RoleScope
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateVersionCreateInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleTemplate: RoleTemplateCreateNestedOneWithoutVersionsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedRoleVersionsInput
    permissions?: RoleTemplatePermissionCreateNestedManyWithoutRoleVersionInput
    users?: UserCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUncheckedCreateInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RoleTemplatePermissionUncheckedCreateNestedManyWithoutRoleVersionInput
    users?: UserUncheckedCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleTemplate?: RoleTemplateUpdateOneRequiredWithoutVersionsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedRoleVersionsNestedInput
    permissions?: RoleTemplatePermissionUpdateManyWithoutRoleVersionNestedInput
    users?: UserUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionCreateManyInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionCreateInput = {
    id?: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roleVersion: RoleTemplateVersionCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRoleGrantsInput
  }

  export type RoleTemplatePermissionUncheckedCreateInput = {
    id?: string
    roleVersionId: string
    permissionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleVersion?: RoleTemplateVersionUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRoleGrantsNestedInput
  }

  export type RoleTemplatePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleVersionId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionCreateManyInput = {
    id?: string
    roleVersionId: string
    permissionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleVersionId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyDefinitionCreateInput = {
    id?: string
    code: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: PolicyVersionCreateNestedManyWithoutPolicyInput
  }

  export type PolicyDefinitionUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: PolicyVersionUncheckedCreateNestedManyWithoutPolicyInput
  }

  export type PolicyDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: PolicyVersionUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: PolicyVersionUncheckedUpdateManyWithoutPolicyNestedInput
  }

  export type PolicyDefinitionCreateManyInput = {
    id?: string
    code: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionCreateInput = {
    id?: string
    scope?: $Enums.PolicyScope
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policy: PolicyDefinitionCreateNestedOneWithoutVersionsInput
    branch?: BranchCreateNestedOneWithoutPolicyVersionsInput
    branches?: PolicyVersionBranchCreateNestedManyWithoutPolicyVersionInput
    createdByUser?: UserCreateNestedOneWithoutPolicyVersionsCreatedByInput
    submittedByUser?: UserCreateNestedOneWithoutPolicyVersionsSubmittedByInput
    approvedByUser?: UserCreateNestedOneWithoutPolicyVersionsApprovedByInput
    rejectedByUser?: UserCreateNestedOneWithoutPolicyVersionsRejectedByInput
    retiredByUser?: UserCreateNestedOneWithoutPolicyVersionsRetiredByInput
  }

  export type PolicyVersionUncheckedCreateInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutPolicyVersionInput
  }

  export type PolicyVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policy?: PolicyDefinitionUpdateOneRequiredWithoutVersionsNestedInput
    branch?: BranchUpdateOneWithoutPolicyVersionsNestedInput
    branches?: PolicyVersionBranchUpdateManyWithoutPolicyVersionNestedInput
    createdByUser?: UserUpdateOneWithoutPolicyVersionsCreatedByNestedInput
    submittedByUser?: UserUpdateOneWithoutPolicyVersionsSubmittedByNestedInput
    approvedByUser?: UserUpdateOneWithoutPolicyVersionsApprovedByNestedInput
    rejectedByUser?: UserUpdateOneWithoutPolicyVersionsRejectedByNestedInput
    retiredByUser?: UserUpdateOneWithoutPolicyVersionsRetiredByNestedInput
  }

  export type PolicyVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: PolicyVersionBranchUncheckedUpdateManyWithoutPolicyVersionNestedInput
  }

  export type PolicyVersionCreateManyInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionBranchCreateInput = {
    id?: string
    createdAt?: Date | string
    policyVersion: PolicyVersionCreateNestedOneWithoutBranchesInput
    branch: BranchCreateNestedOneWithoutPolicyVersionBranchesInput
  }

  export type PolicyVersionBranchUncheckedCreateInput = {
    id?: string
    policyVersionId: string
    branchId: string
    createdAt?: Date | string
  }

  export type PolicyVersionBranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policyVersion?: PolicyVersionUpdateOneRequiredWithoutBranchesNestedInput
    branch?: BranchUpdateOneRequiredWithoutPolicyVersionBranchesNestedInput
  }

  export type PolicyVersionBranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyVersionId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionBranchCreateManyInput = {
    id?: string
    policyVersionId: string
    branchId: string
    createdAt?: Date | string
  }

  export type PolicyVersionBranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionBranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyVersionId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNodeCreateInput = {
    id?: string
    kind: $Enums.LocationKind
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutLocationNodesInput
    parent?: LocationNodeCreateNestedOneWithoutChildrenInput
    children?: LocationNodeCreateNestedManyWithoutParentInput
    revisions?: LocationNodeRevisionCreateNestedManyWithoutNodeInput
    EquipmentAsset?: EquipmentAssetCreateNestedManyWithoutLocationNodeInput
  }

  export type LocationNodeUncheckedCreateInput = {
    id?: string
    branchId: string
    kind: $Enums.LocationKind
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationNodeUncheckedCreateNestedManyWithoutParentInput
    revisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutNodeInput
    EquipmentAsset?: EquipmentAssetUncheckedCreateNestedManyWithoutLocationNodeInput
  }

  export type LocationNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLocationNodesNestedInput
    parent?: LocationNodeUpdateOneWithoutChildrenNestedInput
    children?: LocationNodeUpdateManyWithoutParentNestedInput
    revisions?: LocationNodeRevisionUpdateManyWithoutNodeNestedInput
    EquipmentAsset?: EquipmentAssetUpdateManyWithoutLocationNodeNestedInput
  }

  export type LocationNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationNodeUncheckedUpdateManyWithoutParentNestedInput
    revisions?: LocationNodeRevisionUncheckedUpdateManyWithoutNodeNestedInput
    EquipmentAsset?: EquipmentAssetUncheckedUpdateManyWithoutLocationNodeNestedInput
  }

  export type LocationNodeCreateManyInput = {
    id?: string
    branchId: string
    kind: $Enums.LocationKind
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNodeRevisionCreateInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    node: LocationNodeCreateNestedOneWithoutRevisionsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedLocationRevisionsInput
  }

  export type LocationNodeRevisionUncheckedCreateInput = {
    id?: string
    nodeId: string
    code: string
    name: string
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type LocationNodeRevisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: LocationNodeUpdateOneRequiredWithoutRevisionsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedLocationRevisionsNestedInput
  }

  export type LocationNodeRevisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNodeRevisionCreateManyInput = {
    id?: string
    nodeId: string
    code: string
    name: string
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type LocationNodeRevisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNodeRevisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitTypeCatalogCreateInput = {
    id?: string
    code: string
    name: string
    usesRoomsDefault?: boolean
    schedulableByDefault?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branchLinks?: BranchUnitTypeCreateNestedManyWithoutUnitTypeInput
    units?: UnitCreateNestedManyWithoutUnitTypeInput
  }

  export type UnitTypeCatalogUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    usesRoomsDefault?: boolean
    schedulableByDefault?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branchLinks?: BranchUnitTypeUncheckedCreateNestedManyWithoutUnitTypeInput
    units?: UnitUncheckedCreateNestedManyWithoutUnitTypeInput
  }

  export type UnitTypeCatalogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRoomsDefault?: BoolFieldUpdateOperationsInput | boolean
    schedulableByDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchLinks?: BranchUnitTypeUpdateManyWithoutUnitTypeNestedInput
    units?: UnitUpdateManyWithoutUnitTypeNestedInput
  }

  export type UnitTypeCatalogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRoomsDefault?: BoolFieldUpdateOperationsInput | boolean
    schedulableByDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchLinks?: BranchUnitTypeUncheckedUpdateManyWithoutUnitTypeNestedInput
    units?: UnitUncheckedUpdateManyWithoutUnitTypeNestedInput
  }

  export type UnitTypeCatalogCreateManyInput = {
    id?: string
    code: string
    name: string
    usesRoomsDefault?: boolean
    schedulableByDefault?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitTypeCatalogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRoomsDefault?: BoolFieldUpdateOperationsInput | boolean
    schedulableByDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitTypeCatalogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRoomsDefault?: BoolFieldUpdateOperationsInput | boolean
    schedulableByDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUnitTypeCreateInput = {
    id?: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitTypesEnabledInput
    unitType: UnitTypeCatalogCreateNestedOneWithoutBranchLinksInput
  }

  export type BranchUnitTypeUncheckedCreateInput = {
    id?: string
    branchId: string
    unitTypeId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUnitTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitTypesEnabledNestedInput
    unitType?: UnitTypeCatalogUpdateOneRequiredWithoutBranchLinksNestedInput
  }

  export type BranchUnitTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUnitTypeCreateManyInput = {
    id?: string
    branchId: string
    unitTypeId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUnitTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUnitTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    id?: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitsInput
    department: DepartmentCreateNestedOneWithoutUnitsInput
    unitType: UnitTypeCatalogCreateNestedOneWithoutUnitsInput
    rooms?: UnitRoomCreateNestedManyWithoutUnitInput
    resources?: UnitResourceCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    branchId: string
    departmentId: string
    unitTypeId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: UnitRoomUncheckedCreateNestedManyWithoutUnitInput
    resources?: UnitResourceUncheckedCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetUncheckedCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeCatalogUpdateOneRequiredWithoutUnitsNestedInput
    rooms?: UnitRoomUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: UnitRoomUncheckedUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUncheckedUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUncheckedUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    branchId: string
    departmentId: string
    unitTypeId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitRoomCreateInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutRoomsInput
    branch: BranchCreateNestedOneWithoutUnitRoomsInput
    resources?: UnitResourceCreateNestedManyWithoutRoomInput
    equipment?: EquipmentAssetCreateNestedManyWithoutRoomInput
  }

  export type UnitRoomUncheckedCreateInput = {
    id?: string
    unitId: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: UnitResourceUncheckedCreateNestedManyWithoutRoomInput
    equipment?: EquipmentAssetUncheckedCreateNestedManyWithoutRoomInput
  }

  export type UnitRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutRoomsNestedInput
    branch?: BranchUpdateOneRequiredWithoutUnitRoomsNestedInput
    resources?: UnitResourceUpdateManyWithoutRoomNestedInput
    equipment?: EquipmentAssetUpdateManyWithoutRoomNestedInput
  }

  export type UnitRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: UnitResourceUncheckedUpdateManyWithoutRoomNestedInput
    equipment?: EquipmentAssetUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type UnitRoomCreateManyInput = {
    id?: string
    unitId: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitResourceCreateInput = {
    id?: string
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitResourcesInput
    unit: UnitCreateNestedOneWithoutResourcesInput
    room?: UnitRoomCreateNestedOneWithoutResourcesInput
    bookings?: ProcedureBookingCreateNestedManyWithoutResourceInput
  }

  export type UnitResourceUncheckedCreateInput = {
    id?: string
    branchId: string
    unitId: string
    roomId?: string | null
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ProcedureBookingUncheckedCreateNestedManyWithoutResourceInput
  }

  export type UnitResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitResourcesNestedInput
    unit?: UnitUpdateOneRequiredWithoutResourcesNestedInput
    room?: UnitRoomUpdateOneWithoutResourcesNestedInput
    bookings?: ProcedureBookingUpdateManyWithoutResourceNestedInput
  }

  export type UnitResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ProcedureBookingUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type UnitResourceCreateManyInput = {
    id?: string
    branchId: string
    unitId: string
    roomId?: string | null
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssetCreateInput = {
    id?: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEquipmentAssetsInput
    ownerDepartment?: DepartmentCreateNestedOneWithoutEquipmentOwnedInput
    unit?: UnitCreateNestedOneWithoutEquipmentInput
    room?: UnitRoomCreateNestedOneWithoutEquipmentInput
    locationNode?: LocationNodeCreateNestedOneWithoutEquipmentAssetInput
    downtimeTickets?: DowntimeTicketCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    ownerDepartmentId?: string | null
    unitId?: string | null
    roomId?: string | null
    locationNodeId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    downtimeTickets?: DowntimeTicketUncheckedCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEquipmentAssetsNestedInput
    ownerDepartment?: DepartmentUpdateOneWithoutEquipmentOwnedNestedInput
    unit?: UnitUpdateOneWithoutEquipmentNestedInput
    room?: UnitRoomUpdateOneWithoutEquipmentNestedInput
    locationNode?: LocationNodeUpdateOneWithoutEquipmentAssetNestedInput
    downtimeTickets?: DowntimeTicketUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    locationNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeTickets?: DowntimeTicketUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    ownerDepartmentId?: string | null
    unitId?: string | null
    roomId?: string | null
    locationNodeId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentAssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    locationNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DowntimeTicketCreateInput = {
    id?: string
    status?: $Enums.DowntimeStatus
    reason: string
    notes?: string | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asset: EquipmentAssetCreateNestedOneWithoutDowntimeTicketsInput
  }

  export type DowntimeTicketUncheckedCreateInput = {
    id?: string
    assetId: string
    status?: $Enums.DowntimeStatus
    reason: string
    notes?: string | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DowntimeTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDowntimeStatusFieldUpdateOperationsInput | $Enums.DowntimeStatus
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: EquipmentAssetUpdateOneRequiredWithoutDowntimeTicketsNestedInput
  }

  export type DowntimeTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    status?: EnumDowntimeStatusFieldUpdateOperationsInput | $Enums.DowntimeStatus
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DowntimeTicketCreateManyInput = {
    id?: string
    assetId: string
    status?: $Enums.DowntimeStatus
    reason: string
    notes?: string | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DowntimeTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDowntimeStatusFieldUpdateOperationsInput | $Enums.DowntimeStatus
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DowntimeTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    status?: EnumDowntimeStatusFieldUpdateOperationsInput | $Enums.DowntimeStatus
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChargeMasterItemCreateInput = {
    id?: string
    code: string
    name: string
    category?: string | null
    unit?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutChargeMasterItemsInput
    mappings?: ServiceChargeMappingCreateNestedManyWithoutChargeMasterItemInput
  }

  export type ChargeMasterItemUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: string | null
    unit?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutChargeMasterItemInput
  }

  export type ChargeMasterItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutChargeMasterItemsNestedInput
    mappings?: ServiceChargeMappingUpdateManyWithoutChargeMasterItemNestedInput
  }

  export type ChargeMasterItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mappings?: ServiceChargeMappingUncheckedUpdateManyWithoutChargeMasterItemNestedInput
  }

  export type ChargeMasterItemCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: string | null
    unit?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChargeMasterItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChargeMasterItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceItemCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutServiceItemsInput
    mappings?: ServiceChargeMappingCreateNestedManyWithoutServiceItemInput
    fixIts?: FixItTaskCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category: string
    unit?: string | null
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutServiceItemInput
    fixIts?: FixItTaskUncheckedCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderable?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutServiceItemsNestedInput
    mappings?: ServiceChargeMappingUpdateManyWithoutServiceItemNestedInput
    fixIts?: FixItTaskUpdateManyWithoutServiceItemNestedInput
  }

  export type ServiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderable?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mappings?: ServiceChargeMappingUncheckedUpdateManyWithoutServiceItemNestedInput
    fixIts?: FixItTaskUncheckedUpdateManyWithoutServiceItemNestedInput
  }

  export type ServiceItemCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category: string
    unit?: string | null
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderable?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderable?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceChargeMappingCreateInput = {
    id?: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutServiceMappingsInput
    serviceItem: ServiceItemCreateNestedOneWithoutMappingsInput
    chargeMasterItem: ChargeMasterItemCreateNestedOneWithoutMappingsInput
  }

  export type ServiceChargeMappingUncheckedCreateInput = {
    id?: string
    branchId: string
    serviceItemId: string
    chargeMasterItemId: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceChargeMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutServiceMappingsNestedInput
    serviceItem?: ServiceItemUpdateOneRequiredWithoutMappingsNestedInput
    chargeMasterItem?: ChargeMasterItemUpdateOneRequiredWithoutMappingsNestedInput
  }

  export type ServiceChargeMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceItemId?: StringFieldUpdateOperationsInput | string
    chargeMasterItemId?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceChargeMappingCreateManyInput = {
    id?: string
    branchId: string
    serviceItemId: string
    chargeMasterItemId: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceChargeMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceChargeMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceItemId?: StringFieldUpdateOperationsInput | string
    chargeMasterItemId?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixItTaskCreateInput = {
    id?: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutFixItTasksInput
    serviceItem?: ServiceItemCreateNestedOneWithoutFixItsInput
    assignedToUser?: UserCreateNestedOneWithoutAssignedFixItsInput
  }

  export type FixItTaskUncheckedCreateInput = {
    id?: string
    branchId: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: string | null
    assignedToUserId?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixItTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutFixItTasksNestedInput
    serviceItem?: ServiceItemUpdateOneWithoutFixItsNestedInput
    assignedToUser?: UserUpdateOneWithoutAssignedFixItsNestedInput
  }

  export type FixItTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixItTaskCreateManyInput = {
    id?: string
    branchId: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: string | null
    assignedToUserId?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixItTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixItTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkImportJobCreateInput = {
    id?: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: number
    validRows?: number
    invalidRows?: number
    committedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutImportJobsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedImportJobsInput
  }

  export type BulkImportJobUncheckedCreateInput = {
    id?: string
    branchId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: number
    validRows?: number
    invalidRows?: number
    createdByUserId?: string | null
    committedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BulkImportJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: IntFieldUpdateOperationsInput | number
    validRows?: IntFieldUpdateOperationsInput | number
    invalidRows?: IntFieldUpdateOperationsInput | number
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutImportJobsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedImportJobsNestedInput
  }

  export type BulkImportJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: IntFieldUpdateOperationsInput | number
    validRows?: IntFieldUpdateOperationsInput | number
    invalidRows?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkImportJobCreateManyInput = {
    id?: string
    branchId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: number
    validRows?: number
    invalidRows?: number
    createdByUserId?: string | null
    committedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BulkImportJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: IntFieldUpdateOperationsInput | number
    validRows?: IntFieldUpdateOperationsInput | number
    invalidRows?: IntFieldUpdateOperationsInput | number
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkImportJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: IntFieldUpdateOperationsInput | number
    validRows?: IntFieldUpdateOperationsInput | number
    invalidRows?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureBookingCreateInput = {
    id?: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProcedureBookingsInput
    unit: UnitCreateNestedOneWithoutBookingsInput
    resource: UnitResourceCreateNestedOneWithoutBookingsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedBookingsInput
  }

  export type ProcedureBookingUncheckedCreateInput = {
    id?: string
    branchId: string
    unitId: string
    resourceId: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProcedureBookingsNestedInput
    unit?: UnitUpdateOneRequiredWithoutBookingsNestedInput
    resource?: UnitResourceUpdateOneRequiredWithoutBookingsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedBookingsNestedInput
  }

  export type ProcedureBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureBookingCreateManyInput = {
    id?: string
    branchId: string
    unitId: string
    resourceId: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoLiveReportCreateInput = {
    id?: string
    score: number
    blockers: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutGoLiveReportsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedGoLiveReportsInput
  }

  export type GoLiveReportUncheckedCreateInput = {
    id?: string
    branchId: string
    score: number
    blockers: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    snapshot: JsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type GoLiveReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    blockers?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutGoLiveReportsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedGoLiveReportsNestedInput
  }

  export type GoLiveReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    blockers?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    snapshot?: JsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoLiveReportCreateManyInput = {
    id?: string
    branchId: string
    score: number
    blockers: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    snapshot: JsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type GoLiveReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    blockers?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoLiveReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    blockers?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    snapshot?: JsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type WardListRelationFilter = {
    every?: WardWhereInput
    some?: WardWhereInput
    none?: WardWhereInput
  }

  export type OTListRelationFilter = {
    every?: OTWhereInput
    some?: OTWhereInput
    none?: OTWhereInput
  }

  export type TariffPlanListRelationFilter = {
    every?: TariffPlanWhereInput
    some?: TariffPlanWhereInput
    none?: TariffPlanWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type SpecialtyListRelationFilter = {
    every?: SpecialtyWhereInput
    some?: SpecialtyWhereInput
    none?: SpecialtyWhereInput
  }

  export type StaffListRelationFilter = {
    every?: StaffWhereInput
    some?: StaffWhereInput
    none?: StaffWhereInput
  }

  export type EncounterListRelationFilter = {
    every?: EncounterWhereInput
    some?: EncounterWhereInput
    none?: EncounterWhereInput
  }

  export type BedListRelationFilter = {
    every?: BedWhereInput
    some?: BedWhereInput
    none?: BedWhereInput
  }

  export type AdmissionListRelationFilter = {
    every?: AdmissionWhereInput
    some?: AdmissionWhereInput
    none?: AdmissionWhereInput
  }

  export type BranchFacilityListRelationFilter = {
    every?: BranchFacilityWhereInput
    some?: BranchFacilityWhereInput
    none?: BranchFacilityWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type StatutoryCaseListRelationFilter = {
    every?: StatutoryCaseWhereInput
    some?: StatutoryCaseWhereInput
    none?: StatutoryCaseWhereInput
  }

  export type AuditEventListRelationFilter = {
    every?: AuditEventWhereInput
    some?: AuditEventWhereInput
    none?: AuditEventWhereInput
  }

  export type PolicyVersionListRelationFilter = {
    every?: PolicyVersionWhereInput
    some?: PolicyVersionWhereInput
    none?: PolicyVersionWhereInput
  }

  export type PolicyVersionBranchListRelationFilter = {
    every?: PolicyVersionBranchWhereInput
    some?: PolicyVersionBranchWhereInput
    none?: PolicyVersionBranchWhereInput
  }

  export type LocationNodeListRelationFilter = {
    every?: LocationNodeWhereInput
    some?: LocationNodeWhereInput
    none?: LocationNodeWhereInput
  }

  export type BranchUnitTypeListRelationFilter = {
    every?: BranchUnitTypeWhereInput
    some?: BranchUnitTypeWhereInput
    none?: BranchUnitTypeWhereInput
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type UnitRoomListRelationFilter = {
    every?: UnitRoomWhereInput
    some?: UnitRoomWhereInput
    none?: UnitRoomWhereInput
  }

  export type UnitResourceListRelationFilter = {
    every?: UnitResourceWhereInput
    some?: UnitResourceWhereInput
    none?: UnitResourceWhereInput
  }

  export type EquipmentAssetListRelationFilter = {
    every?: EquipmentAssetWhereInput
    some?: EquipmentAssetWhereInput
    none?: EquipmentAssetWhereInput
  }

  export type ServiceItemListRelationFilter = {
    every?: ServiceItemWhereInput
    some?: ServiceItemWhereInput
    none?: ServiceItemWhereInput
  }

  export type ChargeMasterItemListRelationFilter = {
    every?: ChargeMasterItemWhereInput
    some?: ChargeMasterItemWhereInput
    none?: ChargeMasterItemWhereInput
  }

  export type ServiceChargeMappingListRelationFilter = {
    every?: ServiceChargeMappingWhereInput
    some?: ServiceChargeMappingWhereInput
    none?: ServiceChargeMappingWhereInput
  }

  export type FixItTaskListRelationFilter = {
    every?: FixItTaskWhereInput
    some?: FixItTaskWhereInput
    none?: FixItTaskWhereInput
  }

  export type BulkImportJobListRelationFilter = {
    every?: BulkImportJobWhereInput
    some?: BulkImportJobWhereInput
    none?: BulkImportJobWhereInput
  }

  export type ProcedureBookingListRelationFilter = {
    every?: ProcedureBookingWhereInput
    some?: ProcedureBookingWhereInput
    none?: ProcedureBookingWhereInput
  }

  export type GoLiveReportListRelationFilter = {
    every?: GoLiveReportWhereInput
    some?: GoLiveReportWhereInput
    none?: GoLiveReportWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OTOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TariffPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecialtyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchFacilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StatutoryCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PolicyVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PolicyVersionBranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchUnitTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentAssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChargeMasterItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceChargeMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FixItTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BulkImportJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcedureBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoLiveReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    gstNumber?: SortOrder
    address?: SortOrder
    contactPhone1?: SortOrder
    contactPhone2?: SortOrder
    contactEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    gstNumber?: SortOrder
    address?: SortOrder
    contactPhone1?: SortOrder
    contactPhone2?: SortOrder
    contactEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    gstNumber?: SortOrder
    address?: SortOrder
    contactPhone1?: SortOrder
    contactPhone2?: SortOrder
    contactEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumFacilityCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityCategory | EnumFacilityCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityCategory[] | ListEnumFacilityCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityCategory[] | ListEnumFacilityCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityCategoryFilter<$PrismaModel> | $Enums.FacilityCategory
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FacilityCatalogCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityCatalogAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type FacilityCatalogMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityCatalogMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityCatalogSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumFacilityCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityCategory | EnumFacilityCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityCategory[] | ListEnumFacilityCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityCategory[] | ListEnumFacilityCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FacilityCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFacilityCategoryFilter<$PrismaModel>
    _max?: NestedEnumFacilityCategoryFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type FacilityCatalogRelationFilter = {
    is?: FacilityCatalogWhereInput
    isNot?: FacilityCatalogWhereInput
  }

  export type BranchFacilityBranchIdFacilityIdCompoundUniqueInput = {
    branchId: string
    facilityId: string
  }

  export type BranchFacilityCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    facilityId?: SortOrder
    isEnabled?: SortOrder
    enabledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchFacilityMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    facilityId?: SortOrder
    isEnabled?: SortOrder
    enabledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchFacilityMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    facilityId?: SortOrder
    isEnabled?: SortOrder
    enabledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffNullableRelationFilter = {
    is?: StaffWhereInput | null
    isNot?: StaffWhereInput | null
  }

  export type DepartmentSpecialtyListRelationFilter = {
    every?: DepartmentSpecialtyWhereInput
    some?: DepartmentSpecialtyWhereInput
    none?: DepartmentSpecialtyWhereInput
  }

  export type DepartmentDoctorListRelationFilter = {
    every?: DepartmentDoctorWhereInput
    some?: DepartmentDoctorWhereInput
    none?: DepartmentDoctorWhereInput
  }

  export type DepartmentSpecialtyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentDoctorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentBranchIdFacilityIdCodeCompoundUniqueInput = {
    branchId: string
    facilityId: string
    code: string
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    facilityId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    headStaffId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    facilityId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    headStaffId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    facilityId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    headStaffId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type StaffRelationFilter = {
    is?: StaffWhereInput
    isNot?: StaffWhereInput
  }

  export type DepartmentDoctorDepartmentIdStaffIdCompoundUniqueInput = {
    departmentId: string
    staffId: string
  }

  export type DepartmentDoctorCountOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    staffId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentDoctorMaxOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    staffId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentDoctorMinOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    staffId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type SpecialtyCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyRelationFilter = {
    is?: SpecialtyWhereInput
    isNot?: SpecialtyWhereInput
  }

  export type DepartmentSpecialtyDepartmentIdSpecialtyIdCompoundUniqueInput = {
    departmentId: string
    specialtyId: string
  }

  export type DepartmentSpecialtyCountOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    specialtyId?: SortOrder
    isPrimary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentSpecialtyMaxOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    specialtyId?: SortOrder
    isPrimary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentSpecialtyMinOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    specialtyId?: SortOrder
    isPrimary?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentNullableRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type SpecialtyNullableRelationFilter = {
    is?: SpecialtyWhereInput | null
    isNot?: SpecialtyWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type StaffBranchIdEmpCodeCompoundUniqueInput = {
    branchId: string
    empCode: string
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    specialtyId?: SortOrder
    empCode?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    specialtyId?: SortOrder
    empCode?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    specialtyId?: SortOrder
    empCode?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BranchNullableRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type RoleTemplateVersionNullableRelationFilter = {
    is?: RoleTemplateVersionWhereInput | null
    isNot?: RoleTemplateVersionWhereInput | null
  }

  export type RoleTemplateVersionListRelationFilter = {
    every?: RoleTemplateVersionWhereInput
    some?: RoleTemplateVersionWhereInput
    none?: RoleTemplateVersionWhereInput
  }

  export type LocationNodeRevisionListRelationFilter = {
    every?: LocationNodeRevisionWhereInput
    some?: LocationNodeRevisionWhereInput
    none?: LocationNodeRevisionWhereInput
  }

  export type RoleTemplateVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationNodeRevisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    branchId?: SortOrder
    staffId?: SortOrder
    isActive?: SortOrder
    passwordHash?: SortOrder
    mustChangePassword?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    roleVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    branchId?: SortOrder
    staffId?: SortOrder
    isActive?: SortOrder
    passwordHash?: SortOrder
    mustChangePassword?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    roleVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    branchId?: SortOrder
    staffId?: SortOrder
    isActive?: SortOrder
    passwordHash?: SortOrder
    mustChangePassword?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    roleVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ConsentRecordListRelationFilter = {
    every?: ConsentRecordWhereInput
    some?: ConsentRecordWhereInput
    none?: ConsentRecordWhereInput
  }

  export type RtbfRequestListRelationFilter = {
    every?: RtbfRequestWhereInput
    some?: RtbfRequestWhereInput
    none?: RtbfRequestWhereInput
  }

  export type ConsentRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RtbfRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientBranchIdUhidCompoundUniqueInput = {
    branchId: string
    uhid: string
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    uhid?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    uhid?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    uhid?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEncounterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterType | EnumEncounterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterTypeFilter<$PrismaModel> | $Enums.EncounterType
  }

  export type PatientRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type EncounterCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEncounterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterType | EnumEncounterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterTypeWithAggregatesFilter<$PrismaModel> | $Enums.EncounterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEncounterTypeFilter<$PrismaModel>
    _max?: NestedEnumEncounterTypeFilter<$PrismaModel>
  }

  export type WardBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type WardCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    specialty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WardMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    specialty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WardMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    specialty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WardRelationFilter = {
    is?: WardWhereInput
    isNot?: WardWhereInput
  }

  export type RoomWardIdCodeCompoundUniqueInput = {
    wardId: string
    code: string
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    wardId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    wardId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    wardId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBedStateFilter<$PrismaModel = never> = {
    equals?: $Enums.BedState | EnumBedStateFieldRefInput<$PrismaModel>
    in?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStateFilter<$PrismaModel> | $Enums.BedState
  }

  export type RoomRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type BedRoomIdCodeCompoundUniqueInput = {
    roomId: string
    code: string
  }

  export type BedCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    roomId?: SortOrder
    code?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BedMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    roomId?: SortOrder
    code?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BedMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    roomId?: SortOrder
    code?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBedStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BedState | EnumBedStateFieldRefInput<$PrismaModel>
    in?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStateWithAggregatesFilter<$PrismaModel> | $Enums.BedState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBedStateFilter<$PrismaModel>
    _max?: NestedEnumBedStateFilter<$PrismaModel>
  }

  export type EncounterNullableRelationFilter = {
    is?: EncounterWhereInput | null
    isNot?: EncounterWhereInput | null
  }

  export type BedNullableRelationFilter = {
    is?: BedWhereInput | null
    isNot?: BedWhereInput | null
  }

  export type AdmissionCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    bedId?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    bedId?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    bedId?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type OTCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffRateListRelationFilter = {
    every?: TariffRateWhereInput
    some?: TariffRateWhereInput
    none?: TariffRateWhereInput
  }

  export type TariffRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TariffPlanBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type TariffPlanCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    payerType?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    payerType?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffPlanMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    payerType?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCatalogItemCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCatalogItemMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCatalogItemMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TariffPlanRelationFilter = {
    is?: TariffPlanWhereInput
    isNot?: TariffPlanWhereInput
  }

  export type TariffRateTariffPlanIdServiceCodeCompoundUniqueInput = {
    tariffPlanId: string
    serviceCode: string
  }

  export type TariffRateCountOrderByAggregateInput = {
    id?: SortOrder
    tariffPlanId?: SortOrder
    serviceCode?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffRateAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TariffRateMaxOrderByAggregateInput = {
    id?: SortOrder
    tariffPlanId?: SortOrder
    serviceCode?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffRateMinOrderByAggregateInput = {
    id?: SortOrder
    tariffPlanId?: SortOrder
    serviceCode?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffRateSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumConsentScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentScope | EnumConsentScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentScopeFilter<$PrismaModel> | $Enums.ConsentScope
  }

  export type EnumConsentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusFilter<$PrismaModel> | $Enums.ConsentStatus
  }

  export type ConsentRecordCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    scope?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsentRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    scope?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsentRecordMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    scope?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumConsentScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentScope | EnumConsentScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentScopeWithAggregatesFilter<$PrismaModel> | $Enums.ConsentScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentScopeFilter<$PrismaModel>
    _max?: NestedEnumConsentScopeFilter<$PrismaModel>
  }

  export type EnumConsentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConsentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentStatusFilter<$PrismaModel>
    _max?: NestedEnumConsentStatusFilter<$PrismaModel>
  }

  export type EnumRtbfStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RtbfStatus | EnumRtbfStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRtbfStatusFilter<$PrismaModel> | $Enums.RtbfStatus
  }

  export type RtbfRequestCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RtbfRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RtbfRequestMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRtbfStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RtbfStatus | EnumRtbfStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRtbfStatusWithAggregatesFilter<$PrismaModel> | $Enums.RtbfStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRtbfStatusFilter<$PrismaModel>
    _max?: NestedEnumRtbfStatusFilter<$PrismaModel>
  }

  export type StatutoryCaseCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    program?: SortOrder
    disease?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatutoryCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    program?: SortOrder
    disease?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatutoryCaseMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    program?: SortOrder
    disease?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditEventCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumOutboxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusFilter<$PrismaModel> | $Enums.OutboxStatus
  }

  export type OutboxEventCountOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    key?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    availableAt?: SortOrder
    lockedAt?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboxEventAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type OutboxEventMaxOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    key?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    availableAt?: SortOrder
    lockedAt?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboxEventMinOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    key?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    availableAt?: SortOrder
    lockedAt?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboxEventSumOrderByAggregateInput = {
    attempts?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumOutboxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusWithAggregatesFilter<$PrismaModel> | $Enums.OutboxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOutboxStatusFilter<$PrismaModel>
    _max?: NestedEnumOutboxStatusFilter<$PrismaModel>
  }

  export type RoleTemplatePermissionListRelationFilter = {
    every?: RoleTemplatePermissionWhereInput
    some?: RoleTemplatePermissionWhereInput
    none?: RoleTemplatePermissionWhereInput
  }

  export type RoleTemplatePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleScope | EnumRoleScopeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleScopeFilter<$PrismaModel> | $Enums.RoleScope
  }

  export type RoleTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleScope | EnumRoleScopeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleScopeWithAggregatesFilter<$PrismaModel> | $Enums.RoleScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleScopeFilter<$PrismaModel>
    _max?: NestedEnumRoleScopeFilter<$PrismaModel>
  }

  export type EnumRoleVersionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleVersionStatus | EnumRoleVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleVersionStatusFilter<$PrismaModel> | $Enums.RoleVersionStatus
  }

  export type RoleTemplateRelationFilter = {
    is?: RoleTemplateWhereInput
    isNot?: RoleTemplateWhereInput
  }

  export type RoleTemplateVersionRoleTemplateIdVersionCompoundUniqueInput = {
    roleTemplateId: string
    version: number
  }

  export type RoleTemplateVersionCountOrderByAggregateInput = {
    id?: SortOrder
    roleTemplateId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateVersionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type RoleTemplateVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleTemplateId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateVersionMinOrderByAggregateInput = {
    id?: SortOrder
    roleTemplateId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateVersionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumRoleVersionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleVersionStatus | EnumRoleVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleVersionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoleVersionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleVersionStatusFilter<$PrismaModel>
    _max?: NestedEnumRoleVersionStatusFilter<$PrismaModel>
  }

  export type RoleTemplateVersionRelationFilter = {
    is?: RoleTemplateVersionWhereInput
    isNot?: RoleTemplateVersionWhereInput
  }

  export type PermissionRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RoleTemplatePermissionRoleVersionIdPermissionIdCompoundUniqueInput = {
    roleVersionId: string
    permissionId: string
  }

  export type RoleTemplatePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleVersionId?: SortOrder
    permissionId?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplatePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleVersionId?: SortOrder
    permissionId?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplatePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleVersionId?: SortOrder
    permissionId?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPolicyScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyScope | EnumPolicyScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyScope[] | ListEnumPolicyScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyScope[] | ListEnumPolicyScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyScopeFilter<$PrismaModel> | $Enums.PolicyScope
  }

  export type EnumPolicyVersionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyVersionStatus | EnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyVersionStatus[] | ListEnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyVersionStatus[] | ListEnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyVersionStatusFilter<$PrismaModel> | $Enums.PolicyVersionStatus
  }

  export type PolicyDefinitionRelationFilter = {
    is?: PolicyDefinitionWhereInput
    isNot?: PolicyDefinitionWhereInput
  }

  export type PolicyVersionCountOrderByAggregateInput = {
    id?: SortOrder
    policyId?: SortOrder
    scope?: SortOrder
    branchId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    effectiveAt?: SortOrder
    notes?: SortOrder
    payload?: SortOrder
    applyToAllBranches?: SortOrder
    createdByUserId?: SortOrder
    submittedAt?: SortOrder
    submittedByUserId?: SortOrder
    approvedAt?: SortOrder
    approvedByUserId?: SortOrder
    approvalNote?: SortOrder
    rejectedAt?: SortOrder
    rejectedByUserId?: SortOrder
    rejectionReason?: SortOrder
    retiredAt?: SortOrder
    retiredByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyVersionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type PolicyVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    policyId?: SortOrder
    scope?: SortOrder
    branchId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    effectiveAt?: SortOrder
    notes?: SortOrder
    applyToAllBranches?: SortOrder
    createdByUserId?: SortOrder
    submittedAt?: SortOrder
    submittedByUserId?: SortOrder
    approvedAt?: SortOrder
    approvedByUserId?: SortOrder
    approvalNote?: SortOrder
    rejectedAt?: SortOrder
    rejectedByUserId?: SortOrder
    rejectionReason?: SortOrder
    retiredAt?: SortOrder
    retiredByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyVersionMinOrderByAggregateInput = {
    id?: SortOrder
    policyId?: SortOrder
    scope?: SortOrder
    branchId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    effectiveAt?: SortOrder
    notes?: SortOrder
    applyToAllBranches?: SortOrder
    createdByUserId?: SortOrder
    submittedAt?: SortOrder
    submittedByUserId?: SortOrder
    approvedAt?: SortOrder
    approvedByUserId?: SortOrder
    approvalNote?: SortOrder
    rejectedAt?: SortOrder
    rejectedByUserId?: SortOrder
    rejectionReason?: SortOrder
    retiredAt?: SortOrder
    retiredByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyVersionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumPolicyScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyScope | EnumPolicyScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyScope[] | ListEnumPolicyScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyScope[] | ListEnumPolicyScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyScopeWithAggregatesFilter<$PrismaModel> | $Enums.PolicyScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPolicyScopeFilter<$PrismaModel>
    _max?: NestedEnumPolicyScopeFilter<$PrismaModel>
  }

  export type EnumPolicyVersionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyVersionStatus | EnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyVersionStatus[] | ListEnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyVersionStatus[] | ListEnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyVersionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PolicyVersionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPolicyVersionStatusFilter<$PrismaModel>
    _max?: NestedEnumPolicyVersionStatusFilter<$PrismaModel>
  }

  export type PolicyVersionRelationFilter = {
    is?: PolicyVersionWhereInput
    isNot?: PolicyVersionWhereInput
  }

  export type PolicyVersionBranchPolicyVersionIdBranchIdCompoundUniqueInput = {
    policyVersionId: string
    branchId: string
  }

  export type PolicyVersionBranchCountOrderByAggregateInput = {
    id?: SortOrder
    policyVersionId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type PolicyVersionBranchMaxOrderByAggregateInput = {
    id?: SortOrder
    policyVersionId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type PolicyVersionBranchMinOrderByAggregateInput = {
    id?: SortOrder
    policyVersionId?: SortOrder
    branchId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLocationKindFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationKind | EnumLocationKindFieldRefInput<$PrismaModel>
    in?: $Enums.LocationKind[] | ListEnumLocationKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationKind[] | ListEnumLocationKindFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationKindFilter<$PrismaModel> | $Enums.LocationKind
  }

  export type LocationNodeNullableRelationFilter = {
    is?: LocationNodeWhereInput | null
    isNot?: LocationNodeWhereInput | null
  }

  export type LocationNodeCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    kind?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    kind?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationNodeMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    kind?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLocationKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationKind | EnumLocationKindFieldRefInput<$PrismaModel>
    in?: $Enums.LocationKind[] | ListEnumLocationKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationKind[] | ListEnumLocationKindFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationKindWithAggregatesFilter<$PrismaModel> | $Enums.LocationKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationKindFilter<$PrismaModel>
    _max?: NestedEnumLocationKindFilter<$PrismaModel>
  }

  export type LocationNodeRelationFilter = {
    is?: LocationNodeWhereInput
    isNot?: LocationNodeWhereInput
  }

  export type LocationNodeRevisionCountOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type LocationNodeRevisionMaxOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type LocationNodeRevisionMinOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type UnitTypeCatalogCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    usesRoomsDefault?: SortOrder
    schedulableByDefault?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitTypeCatalogAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UnitTypeCatalogMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    usesRoomsDefault?: SortOrder
    schedulableByDefault?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitTypeCatalogMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    usesRoomsDefault?: SortOrder
    schedulableByDefault?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitTypeCatalogSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UnitTypeCatalogRelationFilter = {
    is?: UnitTypeCatalogWhereInput
    isNot?: UnitTypeCatalogWhereInput
  }

  export type BranchUnitTypeBranchIdUnitTypeIdCompoundUniqueInput = {
    branchId: string
    unitTypeId: string
  }

  export type BranchUnitTypeCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitTypeId?: SortOrder
    isEnabled?: SortOrder
    enabledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchUnitTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitTypeId?: SortOrder
    isEnabled?: SortOrder
    enabledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchUnitTypeMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitTypeId?: SortOrder
    isEnabled?: SortOrder
    enabledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    unitTypeId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    usesRooms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    unitTypeId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    usesRooms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    unitTypeId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    usesRooms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type UnitRoomUnitIdCodeCompoundUniqueInput = {
    unitId: string
    code: string
  }

  export type UnitRoomCountOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitRoomMinOrderByAggregateInput = {
    id?: SortOrder
    unitId?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUnitResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitResourceType | EnumUnitResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitResourceType[] | ListEnumUnitResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitResourceType[] | ListEnumUnitResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitResourceTypeFilter<$PrismaModel> | $Enums.UnitResourceType
  }

  export type EnumUnitResourceStateFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitResourceState | EnumUnitResourceStateFieldRefInput<$PrismaModel>
    in?: $Enums.UnitResourceState[] | ListEnumUnitResourceStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitResourceState[] | ListEnumUnitResourceStateFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitResourceStateFilter<$PrismaModel> | $Enums.UnitResourceState
  }

  export type UnitRoomNullableRelationFilter = {
    is?: UnitRoomWhereInput | null
    isNot?: UnitRoomWhereInput | null
  }

  export type UnitResourceUnitIdCodeCompoundUniqueInput = {
    unitId: string
    code: string
  }

  export type UnitResourceCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitId?: SortOrder
    roomId?: SortOrder
    resourceType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    isSchedulable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitId?: SortOrder
    roomId?: SortOrder
    resourceType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    isSchedulable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitResourceMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitId?: SortOrder
    roomId?: SortOrder
    resourceType?: SortOrder
    code?: SortOrder
    name?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    isSchedulable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUnitResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitResourceType | EnumUnitResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitResourceType[] | ListEnumUnitResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitResourceType[] | ListEnumUnitResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.UnitResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumUnitResourceTypeFilter<$PrismaModel>
  }

  export type EnumUnitResourceStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitResourceState | EnumUnitResourceStateFieldRefInput<$PrismaModel>
    in?: $Enums.UnitResourceState[] | ListEnumUnitResourceStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitResourceState[] | ListEnumUnitResourceStateFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitResourceStateWithAggregatesFilter<$PrismaModel> | $Enums.UnitResourceState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitResourceStateFilter<$PrismaModel>
    _max?: NestedEnumUnitResourceStateFilter<$PrismaModel>
  }

  export type EnumEquipmentComplianceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentComplianceCategory | EnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentComplianceCategory[] | ListEnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentComplianceCategory[] | ListEnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentComplianceCategoryFilter<$PrismaModel> | $Enums.EquipmentComplianceCategory
  }

  export type EnumEquipmentOperationalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentOperationalStatus | EnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentOperationalStatus[] | ListEnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentOperationalStatus[] | ListEnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentOperationalStatusFilter<$PrismaModel> | $Enums.EquipmentOperationalStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UnitNullableRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type DowntimeTicketListRelationFilter = {
    every?: DowntimeTicketWhereInput
    some?: DowntimeTicketWhereInput
    none?: DowntimeTicketWhereInput
  }

  export type DowntimeTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentAssetBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type EquipmentAssetCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    make?: SortOrder
    model?: SortOrder
    serial?: SortOrder
    ownerDepartmentId?: SortOrder
    unitId?: SortOrder
    roomId?: SortOrder
    locationNodeId?: SortOrder
    operationalStatus?: SortOrder
    amcVendor?: SortOrder
    amcValidFrom?: SortOrder
    amcValidTo?: SortOrder
    warrantyValidTo?: SortOrder
    pmFrequencyDays?: SortOrder
    nextPmDueAt?: SortOrder
    aerbLicenseNo?: SortOrder
    aerbValidTo?: SortOrder
    pcpndtRegNo?: SortOrder
    pcpndtValidTo?: SortOrder
    isSchedulable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentAssetAvgOrderByAggregateInput = {
    pmFrequencyDays?: SortOrder
  }

  export type EquipmentAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    make?: SortOrder
    model?: SortOrder
    serial?: SortOrder
    ownerDepartmentId?: SortOrder
    unitId?: SortOrder
    roomId?: SortOrder
    locationNodeId?: SortOrder
    operationalStatus?: SortOrder
    amcVendor?: SortOrder
    amcValidFrom?: SortOrder
    amcValidTo?: SortOrder
    warrantyValidTo?: SortOrder
    pmFrequencyDays?: SortOrder
    nextPmDueAt?: SortOrder
    aerbLicenseNo?: SortOrder
    aerbValidTo?: SortOrder
    pcpndtRegNo?: SortOrder
    pcpndtValidTo?: SortOrder
    isSchedulable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentAssetMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    make?: SortOrder
    model?: SortOrder
    serial?: SortOrder
    ownerDepartmentId?: SortOrder
    unitId?: SortOrder
    roomId?: SortOrder
    locationNodeId?: SortOrder
    operationalStatus?: SortOrder
    amcVendor?: SortOrder
    amcValidFrom?: SortOrder
    amcValidTo?: SortOrder
    warrantyValidTo?: SortOrder
    pmFrequencyDays?: SortOrder
    nextPmDueAt?: SortOrder
    aerbLicenseNo?: SortOrder
    aerbValidTo?: SortOrder
    pcpndtRegNo?: SortOrder
    pcpndtValidTo?: SortOrder
    isSchedulable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentAssetSumOrderByAggregateInput = {
    pmFrequencyDays?: SortOrder
  }

  export type EnumEquipmentComplianceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentComplianceCategory | EnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentComplianceCategory[] | ListEnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentComplianceCategory[] | ListEnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentComplianceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentComplianceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentComplianceCategoryFilter<$PrismaModel>
    _max?: NestedEnumEquipmentComplianceCategoryFilter<$PrismaModel>
  }

  export type EnumEquipmentOperationalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentOperationalStatus | EnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentOperationalStatus[] | ListEnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentOperationalStatus[] | ListEnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentOperationalStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentOperationalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentOperationalStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentOperationalStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumDowntimeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DowntimeStatus | EnumDowntimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DowntimeStatus[] | ListEnumDowntimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DowntimeStatus[] | ListEnumDowntimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDowntimeStatusFilter<$PrismaModel> | $Enums.DowntimeStatus
  }

  export type EquipmentAssetRelationFilter = {
    is?: EquipmentAssetWhereInput
    isNot?: EquipmentAssetWhereInput
  }

  export type DowntimeTicketCountOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DowntimeTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DowntimeTicketMinOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDowntimeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DowntimeStatus | EnumDowntimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DowntimeStatus[] | ListEnumDowntimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DowntimeStatus[] | ListEnumDowntimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDowntimeStatusWithAggregatesFilter<$PrismaModel> | $Enums.DowntimeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDowntimeStatusFilter<$PrismaModel>
    _max?: NestedEnumDowntimeStatusFilter<$PrismaModel>
  }

  export type ChargeMasterItemBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type ChargeMasterItemCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChargeMasterItemMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChargeMasterItemMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceItemBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type ServiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    isOrderable?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    isOrderable?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    isOrderable?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceItemRelationFilter = {
    is?: ServiceItemWhereInput
    isNot?: ServiceItemWhereInput
  }

  export type ChargeMasterItemRelationFilter = {
    is?: ChargeMasterItemWhereInput
    isNot?: ChargeMasterItemWhereInput
  }

  export type ServiceChargeMappingCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    serviceItemId?: SortOrder
    chargeMasterItemId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceChargeMappingAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ServiceChargeMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    serviceItemId?: SortOrder
    chargeMasterItemId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceChargeMappingMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    serviceItemId?: SortOrder
    chargeMasterItemId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceChargeMappingSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumFixItTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FixItType | EnumFixItTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FixItType[] | ListEnumFixItTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FixItType[] | ListEnumFixItTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFixItTypeFilter<$PrismaModel> | $Enums.FixItType
  }

  export type EnumFixItStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FixItStatus | EnumFixItStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FixItStatus[] | ListEnumFixItStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FixItStatus[] | ListEnumFixItStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFixItStatusFilter<$PrismaModel> | $Enums.FixItStatus
  }

  export type ServiceItemNullableRelationFilter = {
    is?: ServiceItemWhereInput | null
    isNot?: ServiceItemWhereInput | null
  }

  export type FixItTaskCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    details?: SortOrder
    serviceItemId?: SortOrder
    assignedToUserId?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FixItTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    serviceItemId?: SortOrder
    assignedToUserId?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FixItTaskMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    title?: SortOrder
    serviceItemId?: SortOrder
    assignedToUserId?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFixItTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FixItType | EnumFixItTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FixItType[] | ListEnumFixItTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FixItType[] | ListEnumFixItTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFixItTypeWithAggregatesFilter<$PrismaModel> | $Enums.FixItType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFixItTypeFilter<$PrismaModel>
    _max?: NestedEnumFixItTypeFilter<$PrismaModel>
  }

  export type EnumFixItStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FixItStatus | EnumFixItStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FixItStatus[] | ListEnumFixItStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FixItStatus[] | ListEnumFixItStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFixItStatusWithAggregatesFilter<$PrismaModel> | $Enums.FixItStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFixItStatusFilter<$PrismaModel>
    _max?: NestedEnumFixItStatusFilter<$PrismaModel>
  }

  export type EnumImportEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportEntityType | EnumImportEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportEntityTypeFilter<$PrismaModel> | $Enums.ImportEntityType
  }

  export type EnumImportJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobStatus | EnumImportJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobStatusFilter<$PrismaModel> | $Enums.ImportJobStatus
  }

  export type BulkImportJobCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    fileName?: SortOrder
    payload?: SortOrder
    errors?: SortOrder
    totalRows?: SortOrder
    validRows?: SortOrder
    invalidRows?: SortOrder
    createdByUserId?: SortOrder
    committedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BulkImportJobAvgOrderByAggregateInput = {
    totalRows?: SortOrder
    validRows?: SortOrder
    invalidRows?: SortOrder
  }

  export type BulkImportJobMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    fileName?: SortOrder
    totalRows?: SortOrder
    validRows?: SortOrder
    invalidRows?: SortOrder
    createdByUserId?: SortOrder
    committedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BulkImportJobMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    fileName?: SortOrder
    totalRows?: SortOrder
    validRows?: SortOrder
    invalidRows?: SortOrder
    createdByUserId?: SortOrder
    committedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BulkImportJobSumOrderByAggregateInput = {
    totalRows?: SortOrder
    validRows?: SortOrder
    invalidRows?: SortOrder
  }

  export type EnumImportEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportEntityType | EnumImportEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImportEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumImportEntityTypeFilter<$PrismaModel>
  }

  export type EnumImportJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobStatus | EnumImportJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportJobStatusFilter<$PrismaModel>
    _max?: NestedEnumImportJobStatusFilter<$PrismaModel>
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type UnitResourceRelationFilter = {
    is?: UnitResourceWhereInput
    isNot?: UnitResourceWhereInput
  }

  export type ProcedureBookingCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitId?: SortOrder
    resourceId?: SortOrder
    patientId?: SortOrder
    departmentId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    consentOk?: SortOrder
    anesthesiaOk?: SortOrder
    checklistOk?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcedureBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitId?: SortOrder
    resourceId?: SortOrder
    patientId?: SortOrder
    departmentId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    consentOk?: SortOrder
    anesthesiaOk?: SortOrder
    checklistOk?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProcedureBookingMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    unitId?: SortOrder
    resourceId?: SortOrder
    patientId?: SortOrder
    departmentId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    consentOk?: SortOrder
    anesthesiaOk?: SortOrder
    checklistOk?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type GoLiveReportCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    score?: SortOrder
    blockers?: SortOrder
    warnings?: SortOrder
    snapshot?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type GoLiveReportAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type GoLiveReportMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    score?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type GoLiveReportMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    score?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type GoLiveReportSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type DepartmentCreateNestedManyWithoutBranchInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutBranchInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type WardCreateNestedManyWithoutBranchInput = {
    create?: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput> | WardCreateWithoutBranchInput[] | WardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WardCreateOrConnectWithoutBranchInput | WardCreateOrConnectWithoutBranchInput[]
    createMany?: WardCreateManyBranchInputEnvelope
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
  }

  export type OTCreateNestedManyWithoutBranchInput = {
    create?: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput> | OTCreateWithoutBranchInput[] | OTUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: OTCreateOrConnectWithoutBranchInput | OTCreateOrConnectWithoutBranchInput[]
    createMany?: OTCreateManyBranchInputEnvelope
    connect?: OTWhereUniqueInput | OTWhereUniqueInput[]
  }

  export type TariffPlanCreateNestedManyWithoutBranchInput = {
    create?: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput> | TariffPlanCreateWithoutBranchInput[] | TariffPlanUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutBranchInput | TariffPlanCreateOrConnectWithoutBranchInput[]
    createMany?: TariffPlanCreateManyBranchInputEnvelope
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutBranchInput = {
    create?: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput> | AssetCreateWithoutBranchInput[] | AssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBranchInput | AssetCreateOrConnectWithoutBranchInput[]
    createMany?: AssetCreateManyBranchInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type SpecialtyCreateNestedManyWithoutBranchInput = {
    create?: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput> | SpecialtyCreateWithoutBranchInput[] | SpecialtyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutBranchInput | SpecialtyCreateOrConnectWithoutBranchInput[]
    createMany?: SpecialtyCreateManyBranchInputEnvelope
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
  }

  export type StaffCreateNestedManyWithoutBranchInput = {
    create?: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput> | StaffCreateWithoutBranchInput[] | StaffUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutBranchInput | StaffCreateOrConnectWithoutBranchInput[]
    createMany?: StaffCreateManyBranchInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutBranchInput = {
    create?: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput> | EncounterCreateWithoutBranchInput[] | EncounterUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutBranchInput | EncounterCreateOrConnectWithoutBranchInput[]
    createMany?: EncounterCreateManyBranchInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type BedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput> | BedCreateWithoutBranchInput[] | BedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBranchInput | BedCreateOrConnectWithoutBranchInput[]
    createMany?: BedCreateManyBranchInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type AdmissionCreateNestedManyWithoutBranchInput = {
    create?: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput> | AdmissionCreateWithoutBranchInput[] | AdmissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBranchInput | AdmissionCreateOrConnectWithoutBranchInput[]
    createMany?: AdmissionCreateManyBranchInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type BranchFacilityCreateNestedManyWithoutBranchInput = {
    create?: XOR<BranchFacilityCreateWithoutBranchInput, BranchFacilityUncheckedCreateWithoutBranchInput> | BranchFacilityCreateWithoutBranchInput[] | BranchFacilityUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchFacilityCreateOrConnectWithoutBranchInput | BranchFacilityCreateOrConnectWithoutBranchInput[]
    createMany?: BranchFacilityCreateManyBranchInputEnvelope
    connect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutBranchInput = {
    create?: XOR<RoomCreateWithoutBranchInput, RoomUncheckedCreateWithoutBranchInput> | RoomCreateWithoutBranchInput[] | RoomUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBranchInput | RoomCreateOrConnectWithoutBranchInput[]
    createMany?: RoomCreateManyBranchInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type StatutoryCaseCreateNestedManyWithoutBranchInput = {
    create?: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput> | StatutoryCaseCreateWithoutBranchInput[] | StatutoryCaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutBranchInput | StatutoryCaseCreateOrConnectWithoutBranchInput[]
    createMany?: StatutoryCaseCreateManyBranchInputEnvelope
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
  }

  export type AuditEventCreateNestedManyWithoutBranchInput = {
    create?: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput> | AuditEventCreateWithoutBranchInput[] | AuditEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutBranchInput | AuditEventCreateOrConnectWithoutBranchInput[]
    createMany?: AuditEventCreateManyBranchInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type PolicyVersionCreateNestedManyWithoutBranchInput = {
    create?: XOR<PolicyVersionCreateWithoutBranchInput, PolicyVersionUncheckedCreateWithoutBranchInput> | PolicyVersionCreateWithoutBranchInput[] | PolicyVersionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutBranchInput | PolicyVersionCreateOrConnectWithoutBranchInput[]
    createMany?: PolicyVersionCreateManyBranchInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionBranchCreateNestedManyWithoutBranchInput = {
    create?: XOR<PolicyVersionBranchCreateWithoutBranchInput, PolicyVersionBranchUncheckedCreateWithoutBranchInput> | PolicyVersionBranchCreateWithoutBranchInput[] | PolicyVersionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PolicyVersionBranchCreateOrConnectWithoutBranchInput | PolicyVersionBranchCreateOrConnectWithoutBranchInput[]
    createMany?: PolicyVersionBranchCreateManyBranchInputEnvelope
    connect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
  }

  export type LocationNodeCreateNestedManyWithoutBranchInput = {
    create?: XOR<LocationNodeCreateWithoutBranchInput, LocationNodeUncheckedCreateWithoutBranchInput> | LocationNodeCreateWithoutBranchInput[] | LocationNodeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LocationNodeCreateOrConnectWithoutBranchInput | LocationNodeCreateOrConnectWithoutBranchInput[]
    createMany?: LocationNodeCreateManyBranchInputEnvelope
    connect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
  }

  export type BranchUnitTypeCreateNestedManyWithoutBranchInput = {
    create?: XOR<BranchUnitTypeCreateWithoutBranchInput, BranchUnitTypeUncheckedCreateWithoutBranchInput> | BranchUnitTypeCreateWithoutBranchInput[] | BranchUnitTypeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchUnitTypeCreateOrConnectWithoutBranchInput | BranchUnitTypeCreateOrConnectWithoutBranchInput[]
    createMany?: BranchUnitTypeCreateManyBranchInputEnvelope
    connect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutBranchInput = {
    create?: XOR<UnitCreateWithoutBranchInput, UnitUncheckedCreateWithoutBranchInput> | UnitCreateWithoutBranchInput[] | UnitUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutBranchInput | UnitCreateOrConnectWithoutBranchInput[]
    createMany?: UnitCreateManyBranchInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitRoomCreateNestedManyWithoutBranchInput = {
    create?: XOR<UnitRoomCreateWithoutBranchInput, UnitRoomUncheckedCreateWithoutBranchInput> | UnitRoomCreateWithoutBranchInput[] | UnitRoomUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitRoomCreateOrConnectWithoutBranchInput | UnitRoomCreateOrConnectWithoutBranchInput[]
    createMany?: UnitRoomCreateManyBranchInputEnvelope
    connect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
  }

  export type UnitResourceCreateNestedManyWithoutBranchInput = {
    create?: XOR<UnitResourceCreateWithoutBranchInput, UnitResourceUncheckedCreateWithoutBranchInput> | UnitResourceCreateWithoutBranchInput[] | UnitResourceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutBranchInput | UnitResourceCreateOrConnectWithoutBranchInput[]
    createMany?: UnitResourceCreateManyBranchInputEnvelope
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
  }

  export type EquipmentAssetCreateNestedManyWithoutBranchInput = {
    create?: XOR<EquipmentAssetCreateWithoutBranchInput, EquipmentAssetUncheckedCreateWithoutBranchInput> | EquipmentAssetCreateWithoutBranchInput[] | EquipmentAssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutBranchInput | EquipmentAssetCreateOrConnectWithoutBranchInput[]
    createMany?: EquipmentAssetCreateManyBranchInputEnvelope
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
  }

  export type ServiceItemCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceItemCreateWithoutBranchInput, ServiceItemUncheckedCreateWithoutBranchInput> | ServiceItemCreateWithoutBranchInput[] | ServiceItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceItemCreateOrConnectWithoutBranchInput | ServiceItemCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceItemCreateManyBranchInputEnvelope
    connect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
  }

  export type ChargeMasterItemCreateNestedManyWithoutBranchInput = {
    create?: XOR<ChargeMasterItemCreateWithoutBranchInput, ChargeMasterItemUncheckedCreateWithoutBranchInput> | ChargeMasterItemCreateWithoutBranchInput[] | ChargeMasterItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ChargeMasterItemCreateOrConnectWithoutBranchInput | ChargeMasterItemCreateOrConnectWithoutBranchInput[]
    createMany?: ChargeMasterItemCreateManyBranchInputEnvelope
    connect?: ChargeMasterItemWhereUniqueInput | ChargeMasterItemWhereUniqueInput[]
  }

  export type ServiceChargeMappingCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutBranchInput, ServiceChargeMappingUncheckedCreateWithoutBranchInput> | ServiceChargeMappingCreateWithoutBranchInput[] | ServiceChargeMappingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutBranchInput | ServiceChargeMappingCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceChargeMappingCreateManyBranchInputEnvelope
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
  }

  export type FixItTaskCreateNestedManyWithoutBranchInput = {
    create?: XOR<FixItTaskCreateWithoutBranchInput, FixItTaskUncheckedCreateWithoutBranchInput> | FixItTaskCreateWithoutBranchInput[] | FixItTaskUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutBranchInput | FixItTaskCreateOrConnectWithoutBranchInput[]
    createMany?: FixItTaskCreateManyBranchInputEnvelope
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
  }

  export type BulkImportJobCreateNestedManyWithoutBranchInput = {
    create?: XOR<BulkImportJobCreateWithoutBranchInput, BulkImportJobUncheckedCreateWithoutBranchInput> | BulkImportJobCreateWithoutBranchInput[] | BulkImportJobUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BulkImportJobCreateOrConnectWithoutBranchInput | BulkImportJobCreateOrConnectWithoutBranchInput[]
    createMany?: BulkImportJobCreateManyBranchInputEnvelope
    connect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
  }

  export type ProcedureBookingCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProcedureBookingCreateWithoutBranchInput, ProcedureBookingUncheckedCreateWithoutBranchInput> | ProcedureBookingCreateWithoutBranchInput[] | ProcedureBookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutBranchInput | ProcedureBookingCreateOrConnectWithoutBranchInput[]
    createMany?: ProcedureBookingCreateManyBranchInputEnvelope
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
  }

  export type GoLiveReportCreateNestedManyWithoutBranchInput = {
    create?: XOR<GoLiveReportCreateWithoutBranchInput, GoLiveReportUncheckedCreateWithoutBranchInput> | GoLiveReportCreateWithoutBranchInput[] | GoLiveReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: GoLiveReportCreateOrConnectWithoutBranchInput | GoLiveReportCreateOrConnectWithoutBranchInput[]
    createMany?: GoLiveReportCreateManyBranchInputEnvelope
    connect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type WardUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput> | WardCreateWithoutBranchInput[] | WardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WardCreateOrConnectWithoutBranchInput | WardCreateOrConnectWithoutBranchInput[]
    createMany?: WardCreateManyBranchInputEnvelope
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
  }

  export type OTUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput> | OTCreateWithoutBranchInput[] | OTUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: OTCreateOrConnectWithoutBranchInput | OTCreateOrConnectWithoutBranchInput[]
    createMany?: OTCreateManyBranchInputEnvelope
    connect?: OTWhereUniqueInput | OTWhereUniqueInput[]
  }

  export type TariffPlanUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput> | TariffPlanCreateWithoutBranchInput[] | TariffPlanUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutBranchInput | TariffPlanCreateOrConnectWithoutBranchInput[]
    createMany?: TariffPlanCreateManyBranchInputEnvelope
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput> | AssetCreateWithoutBranchInput[] | AssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBranchInput | AssetCreateOrConnectWithoutBranchInput[]
    createMany?: AssetCreateManyBranchInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type SpecialtyUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput> | SpecialtyCreateWithoutBranchInput[] | SpecialtyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutBranchInput | SpecialtyCreateOrConnectWithoutBranchInput[]
    createMany?: SpecialtyCreateManyBranchInputEnvelope
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput> | StaffCreateWithoutBranchInput[] | StaffUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutBranchInput | StaffCreateOrConnectWithoutBranchInput[]
    createMany?: StaffCreateManyBranchInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput> | EncounterCreateWithoutBranchInput[] | EncounterUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutBranchInput | EncounterCreateOrConnectWithoutBranchInput[]
    createMany?: EncounterCreateManyBranchInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type BedUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput> | BedCreateWithoutBranchInput[] | BedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBranchInput | BedCreateOrConnectWithoutBranchInput[]
    createMany?: BedCreateManyBranchInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput> | AdmissionCreateWithoutBranchInput[] | AdmissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBranchInput | AdmissionCreateOrConnectWithoutBranchInput[]
    createMany?: AdmissionCreateManyBranchInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type BranchFacilityUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BranchFacilityCreateWithoutBranchInput, BranchFacilityUncheckedCreateWithoutBranchInput> | BranchFacilityCreateWithoutBranchInput[] | BranchFacilityUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchFacilityCreateOrConnectWithoutBranchInput | BranchFacilityCreateOrConnectWithoutBranchInput[]
    createMany?: BranchFacilityCreateManyBranchInputEnvelope
    connect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<RoomCreateWithoutBranchInput, RoomUncheckedCreateWithoutBranchInput> | RoomCreateWithoutBranchInput[] | RoomUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBranchInput | RoomCreateOrConnectWithoutBranchInput[]
    createMany?: RoomCreateManyBranchInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput> | StatutoryCaseCreateWithoutBranchInput[] | StatutoryCaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutBranchInput | StatutoryCaseCreateOrConnectWithoutBranchInput[]
    createMany?: StatutoryCaseCreateManyBranchInputEnvelope
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
  }

  export type AuditEventUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput> | AuditEventCreateWithoutBranchInput[] | AuditEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutBranchInput | AuditEventCreateOrConnectWithoutBranchInput[]
    createMany?: AuditEventCreateManyBranchInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type PolicyVersionUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<PolicyVersionCreateWithoutBranchInput, PolicyVersionUncheckedCreateWithoutBranchInput> | PolicyVersionCreateWithoutBranchInput[] | PolicyVersionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutBranchInput | PolicyVersionCreateOrConnectWithoutBranchInput[]
    createMany?: PolicyVersionCreateManyBranchInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<PolicyVersionBranchCreateWithoutBranchInput, PolicyVersionBranchUncheckedCreateWithoutBranchInput> | PolicyVersionBranchCreateWithoutBranchInput[] | PolicyVersionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PolicyVersionBranchCreateOrConnectWithoutBranchInput | PolicyVersionBranchCreateOrConnectWithoutBranchInput[]
    createMany?: PolicyVersionBranchCreateManyBranchInputEnvelope
    connect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
  }

  export type LocationNodeUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<LocationNodeCreateWithoutBranchInput, LocationNodeUncheckedCreateWithoutBranchInput> | LocationNodeCreateWithoutBranchInput[] | LocationNodeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LocationNodeCreateOrConnectWithoutBranchInput | LocationNodeCreateOrConnectWithoutBranchInput[]
    createMany?: LocationNodeCreateManyBranchInputEnvelope
    connect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
  }

  export type BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BranchUnitTypeCreateWithoutBranchInput, BranchUnitTypeUncheckedCreateWithoutBranchInput> | BranchUnitTypeCreateWithoutBranchInput[] | BranchUnitTypeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchUnitTypeCreateOrConnectWithoutBranchInput | BranchUnitTypeCreateOrConnectWithoutBranchInput[]
    createMany?: BranchUnitTypeCreateManyBranchInputEnvelope
    connect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UnitCreateWithoutBranchInput, UnitUncheckedCreateWithoutBranchInput> | UnitCreateWithoutBranchInput[] | UnitUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutBranchInput | UnitCreateOrConnectWithoutBranchInput[]
    createMany?: UnitCreateManyBranchInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitRoomUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UnitRoomCreateWithoutBranchInput, UnitRoomUncheckedCreateWithoutBranchInput> | UnitRoomCreateWithoutBranchInput[] | UnitRoomUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitRoomCreateOrConnectWithoutBranchInput | UnitRoomCreateOrConnectWithoutBranchInput[]
    createMany?: UnitRoomCreateManyBranchInputEnvelope
    connect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
  }

  export type UnitResourceUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UnitResourceCreateWithoutBranchInput, UnitResourceUncheckedCreateWithoutBranchInput> | UnitResourceCreateWithoutBranchInput[] | UnitResourceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutBranchInput | UnitResourceCreateOrConnectWithoutBranchInput[]
    createMany?: UnitResourceCreateManyBranchInputEnvelope
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
  }

  export type EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<EquipmentAssetCreateWithoutBranchInput, EquipmentAssetUncheckedCreateWithoutBranchInput> | EquipmentAssetCreateWithoutBranchInput[] | EquipmentAssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutBranchInput | EquipmentAssetCreateOrConnectWithoutBranchInput[]
    createMany?: EquipmentAssetCreateManyBranchInputEnvelope
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
  }

  export type ServiceItemUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceItemCreateWithoutBranchInput, ServiceItemUncheckedCreateWithoutBranchInput> | ServiceItemCreateWithoutBranchInput[] | ServiceItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceItemCreateOrConnectWithoutBranchInput | ServiceItemCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceItemCreateManyBranchInputEnvelope
    connect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
  }

  export type ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ChargeMasterItemCreateWithoutBranchInput, ChargeMasterItemUncheckedCreateWithoutBranchInput> | ChargeMasterItemCreateWithoutBranchInput[] | ChargeMasterItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ChargeMasterItemCreateOrConnectWithoutBranchInput | ChargeMasterItemCreateOrConnectWithoutBranchInput[]
    createMany?: ChargeMasterItemCreateManyBranchInputEnvelope
    connect?: ChargeMasterItemWhereUniqueInput | ChargeMasterItemWhereUniqueInput[]
  }

  export type ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutBranchInput, ServiceChargeMappingUncheckedCreateWithoutBranchInput> | ServiceChargeMappingCreateWithoutBranchInput[] | ServiceChargeMappingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutBranchInput | ServiceChargeMappingCreateOrConnectWithoutBranchInput[]
    createMany?: ServiceChargeMappingCreateManyBranchInputEnvelope
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
  }

  export type FixItTaskUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<FixItTaskCreateWithoutBranchInput, FixItTaskUncheckedCreateWithoutBranchInput> | FixItTaskCreateWithoutBranchInput[] | FixItTaskUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutBranchInput | FixItTaskCreateOrConnectWithoutBranchInput[]
    createMany?: FixItTaskCreateManyBranchInputEnvelope
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
  }

  export type BulkImportJobUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BulkImportJobCreateWithoutBranchInput, BulkImportJobUncheckedCreateWithoutBranchInput> | BulkImportJobCreateWithoutBranchInput[] | BulkImportJobUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BulkImportJobCreateOrConnectWithoutBranchInput | BulkImportJobCreateOrConnectWithoutBranchInput[]
    createMany?: BulkImportJobCreateManyBranchInputEnvelope
    connect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
  }

  export type ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<ProcedureBookingCreateWithoutBranchInput, ProcedureBookingUncheckedCreateWithoutBranchInput> | ProcedureBookingCreateWithoutBranchInput[] | ProcedureBookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutBranchInput | ProcedureBookingCreateOrConnectWithoutBranchInput[]
    createMany?: ProcedureBookingCreateManyBranchInputEnvelope
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
  }

  export type GoLiveReportUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<GoLiveReportCreateWithoutBranchInput, GoLiveReportUncheckedCreateWithoutBranchInput> | GoLiveReportCreateWithoutBranchInput[] | GoLiveReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: GoLiveReportCreateOrConnectWithoutBranchInput | GoLiveReportCreateOrConnectWithoutBranchInput[]
    createMany?: GoLiveReportCreateManyBranchInputEnvelope
    connect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DepartmentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutBranchInput | DepartmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutBranchInput | DepartmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutBranchInput | DepartmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutBranchInput | PatientUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutBranchInput | PatientUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutBranchInput | PatientUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type WardUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput> | WardCreateWithoutBranchInput[] | WardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WardCreateOrConnectWithoutBranchInput | WardCreateOrConnectWithoutBranchInput[]
    upsert?: WardUpsertWithWhereUniqueWithoutBranchInput | WardUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WardCreateManyBranchInputEnvelope
    set?: WardWhereUniqueInput | WardWhereUniqueInput[]
    disconnect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    delete?: WardWhereUniqueInput | WardWhereUniqueInput[]
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    update?: WardUpdateWithWhereUniqueWithoutBranchInput | WardUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WardUpdateManyWithWhereWithoutBranchInput | WardUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WardScalarWhereInput | WardScalarWhereInput[]
  }

  export type OTUpdateManyWithoutBranchNestedInput = {
    create?: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput> | OTCreateWithoutBranchInput[] | OTUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: OTCreateOrConnectWithoutBranchInput | OTCreateOrConnectWithoutBranchInput[]
    upsert?: OTUpsertWithWhereUniqueWithoutBranchInput | OTUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: OTCreateManyBranchInputEnvelope
    set?: OTWhereUniqueInput | OTWhereUniqueInput[]
    disconnect?: OTWhereUniqueInput | OTWhereUniqueInput[]
    delete?: OTWhereUniqueInput | OTWhereUniqueInput[]
    connect?: OTWhereUniqueInput | OTWhereUniqueInput[]
    update?: OTUpdateWithWhereUniqueWithoutBranchInput | OTUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: OTUpdateManyWithWhereWithoutBranchInput | OTUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: OTScalarWhereInput | OTScalarWhereInput[]
  }

  export type TariffPlanUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput> | TariffPlanCreateWithoutBranchInput[] | TariffPlanUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutBranchInput | TariffPlanCreateOrConnectWithoutBranchInput[]
    upsert?: TariffPlanUpsertWithWhereUniqueWithoutBranchInput | TariffPlanUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TariffPlanCreateManyBranchInputEnvelope
    set?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    disconnect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    delete?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    update?: TariffPlanUpdateWithWhereUniqueWithoutBranchInput | TariffPlanUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TariffPlanUpdateManyWithWhereWithoutBranchInput | TariffPlanUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput> | AssetCreateWithoutBranchInput[] | AssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBranchInput | AssetCreateOrConnectWithoutBranchInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutBranchInput | AssetUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AssetCreateManyBranchInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutBranchInput | AssetUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutBranchInput | AssetUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type SpecialtyUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput> | SpecialtyCreateWithoutBranchInput[] | SpecialtyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutBranchInput | SpecialtyCreateOrConnectWithoutBranchInput[]
    upsert?: SpecialtyUpsertWithWhereUniqueWithoutBranchInput | SpecialtyUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SpecialtyCreateManyBranchInputEnvelope
    set?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    disconnect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    delete?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    update?: SpecialtyUpdateWithWhereUniqueWithoutBranchInput | SpecialtyUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SpecialtyUpdateManyWithWhereWithoutBranchInput | SpecialtyUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
  }

  export type StaffUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput> | StaffCreateWithoutBranchInput[] | StaffUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutBranchInput | StaffCreateOrConnectWithoutBranchInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutBranchInput | StaffUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StaffCreateManyBranchInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutBranchInput | StaffUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutBranchInput | StaffUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput> | EncounterCreateWithoutBranchInput[] | EncounterUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutBranchInput | EncounterCreateOrConnectWithoutBranchInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutBranchInput | EncounterUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EncounterCreateManyBranchInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutBranchInput | EncounterUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutBranchInput | EncounterUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type BedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput> | BedCreateWithoutBranchInput[] | BedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBranchInput | BedCreateOrConnectWithoutBranchInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutBranchInput | BedUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BedCreateManyBranchInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutBranchInput | BedUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BedUpdateManyWithWhereWithoutBranchInput | BedUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type AdmissionUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput> | AdmissionCreateWithoutBranchInput[] | AdmissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBranchInput | AdmissionCreateOrConnectWithoutBranchInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutBranchInput | AdmissionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AdmissionCreateManyBranchInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutBranchInput | AdmissionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutBranchInput | AdmissionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type BranchFacilityUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BranchFacilityCreateWithoutBranchInput, BranchFacilityUncheckedCreateWithoutBranchInput> | BranchFacilityCreateWithoutBranchInput[] | BranchFacilityUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchFacilityCreateOrConnectWithoutBranchInput | BranchFacilityCreateOrConnectWithoutBranchInput[]
    upsert?: BranchFacilityUpsertWithWhereUniqueWithoutBranchInput | BranchFacilityUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BranchFacilityCreateManyBranchInputEnvelope
    set?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    disconnect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    delete?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    connect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    update?: BranchFacilityUpdateWithWhereUniqueWithoutBranchInput | BranchFacilityUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BranchFacilityUpdateManyWithWhereWithoutBranchInput | BranchFacilityUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BranchFacilityScalarWhereInput | BranchFacilityScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutBranchNestedInput = {
    create?: XOR<RoomCreateWithoutBranchInput, RoomUncheckedCreateWithoutBranchInput> | RoomCreateWithoutBranchInput[] | RoomUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBranchInput | RoomCreateOrConnectWithoutBranchInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBranchInput | RoomUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: RoomCreateManyBranchInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBranchInput | RoomUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBranchInput | RoomUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type StatutoryCaseUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput> | StatutoryCaseCreateWithoutBranchInput[] | StatutoryCaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutBranchInput | StatutoryCaseCreateOrConnectWithoutBranchInput[]
    upsert?: StatutoryCaseUpsertWithWhereUniqueWithoutBranchInput | StatutoryCaseUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StatutoryCaseCreateManyBranchInputEnvelope
    set?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    disconnect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    delete?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    update?: StatutoryCaseUpdateWithWhereUniqueWithoutBranchInput | StatutoryCaseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StatutoryCaseUpdateManyWithWhereWithoutBranchInput | StatutoryCaseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
  }

  export type AuditEventUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput> | AuditEventCreateWithoutBranchInput[] | AuditEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutBranchInput | AuditEventCreateOrConnectWithoutBranchInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutBranchInput | AuditEventUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AuditEventCreateManyBranchInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutBranchInput | AuditEventUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutBranchInput | AuditEventUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type PolicyVersionUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutBranchInput, PolicyVersionUncheckedCreateWithoutBranchInput> | PolicyVersionCreateWithoutBranchInput[] | PolicyVersionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutBranchInput | PolicyVersionCreateOrConnectWithoutBranchInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutBranchInput | PolicyVersionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PolicyVersionCreateManyBranchInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutBranchInput | PolicyVersionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutBranchInput | PolicyVersionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyVersionBranchUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PolicyVersionBranchCreateWithoutBranchInput, PolicyVersionBranchUncheckedCreateWithoutBranchInput> | PolicyVersionBranchCreateWithoutBranchInput[] | PolicyVersionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PolicyVersionBranchCreateOrConnectWithoutBranchInput | PolicyVersionBranchCreateOrConnectWithoutBranchInput[]
    upsert?: PolicyVersionBranchUpsertWithWhereUniqueWithoutBranchInput | PolicyVersionBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PolicyVersionBranchCreateManyBranchInputEnvelope
    set?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    disconnect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    delete?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    connect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    update?: PolicyVersionBranchUpdateWithWhereUniqueWithoutBranchInput | PolicyVersionBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PolicyVersionBranchUpdateManyWithWhereWithoutBranchInput | PolicyVersionBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PolicyVersionBranchScalarWhereInput | PolicyVersionBranchScalarWhereInput[]
  }

  export type LocationNodeUpdateManyWithoutBranchNestedInput = {
    create?: XOR<LocationNodeCreateWithoutBranchInput, LocationNodeUncheckedCreateWithoutBranchInput> | LocationNodeCreateWithoutBranchInput[] | LocationNodeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LocationNodeCreateOrConnectWithoutBranchInput | LocationNodeCreateOrConnectWithoutBranchInput[]
    upsert?: LocationNodeUpsertWithWhereUniqueWithoutBranchInput | LocationNodeUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: LocationNodeCreateManyBranchInputEnvelope
    set?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    disconnect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    delete?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    connect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    update?: LocationNodeUpdateWithWhereUniqueWithoutBranchInput | LocationNodeUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: LocationNodeUpdateManyWithWhereWithoutBranchInput | LocationNodeUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: LocationNodeScalarWhereInput | LocationNodeScalarWhereInput[]
  }

  export type BranchUnitTypeUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BranchUnitTypeCreateWithoutBranchInput, BranchUnitTypeUncheckedCreateWithoutBranchInput> | BranchUnitTypeCreateWithoutBranchInput[] | BranchUnitTypeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchUnitTypeCreateOrConnectWithoutBranchInput | BranchUnitTypeCreateOrConnectWithoutBranchInput[]
    upsert?: BranchUnitTypeUpsertWithWhereUniqueWithoutBranchInput | BranchUnitTypeUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BranchUnitTypeCreateManyBranchInputEnvelope
    set?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    disconnect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    delete?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    connect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    update?: BranchUnitTypeUpdateWithWhereUniqueWithoutBranchInput | BranchUnitTypeUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BranchUnitTypeUpdateManyWithWhereWithoutBranchInput | BranchUnitTypeUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BranchUnitTypeScalarWhereInput | BranchUnitTypeScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UnitCreateWithoutBranchInput, UnitUncheckedCreateWithoutBranchInput> | UnitCreateWithoutBranchInput[] | UnitUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutBranchInput | UnitCreateOrConnectWithoutBranchInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutBranchInput | UnitUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UnitCreateManyBranchInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutBranchInput | UnitUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutBranchInput | UnitUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitRoomUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UnitRoomCreateWithoutBranchInput, UnitRoomUncheckedCreateWithoutBranchInput> | UnitRoomCreateWithoutBranchInput[] | UnitRoomUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitRoomCreateOrConnectWithoutBranchInput | UnitRoomCreateOrConnectWithoutBranchInput[]
    upsert?: UnitRoomUpsertWithWhereUniqueWithoutBranchInput | UnitRoomUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UnitRoomCreateManyBranchInputEnvelope
    set?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    disconnect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    delete?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    connect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    update?: UnitRoomUpdateWithWhereUniqueWithoutBranchInput | UnitRoomUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UnitRoomUpdateManyWithWhereWithoutBranchInput | UnitRoomUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UnitRoomScalarWhereInput | UnitRoomScalarWhereInput[]
  }

  export type UnitResourceUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UnitResourceCreateWithoutBranchInput, UnitResourceUncheckedCreateWithoutBranchInput> | UnitResourceCreateWithoutBranchInput[] | UnitResourceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutBranchInput | UnitResourceCreateOrConnectWithoutBranchInput[]
    upsert?: UnitResourceUpsertWithWhereUniqueWithoutBranchInput | UnitResourceUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UnitResourceCreateManyBranchInputEnvelope
    set?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    disconnect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    delete?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    update?: UnitResourceUpdateWithWhereUniqueWithoutBranchInput | UnitResourceUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UnitResourceUpdateManyWithWhereWithoutBranchInput | UnitResourceUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UnitResourceScalarWhereInput | UnitResourceScalarWhereInput[]
  }

  export type EquipmentAssetUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EquipmentAssetCreateWithoutBranchInput, EquipmentAssetUncheckedCreateWithoutBranchInput> | EquipmentAssetCreateWithoutBranchInput[] | EquipmentAssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutBranchInput | EquipmentAssetCreateOrConnectWithoutBranchInput[]
    upsert?: EquipmentAssetUpsertWithWhereUniqueWithoutBranchInput | EquipmentAssetUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EquipmentAssetCreateManyBranchInputEnvelope
    set?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    disconnect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    delete?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    update?: EquipmentAssetUpdateWithWhereUniqueWithoutBranchInput | EquipmentAssetUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EquipmentAssetUpdateManyWithWhereWithoutBranchInput | EquipmentAssetUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
  }

  export type ServiceItemUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceItemCreateWithoutBranchInput, ServiceItemUncheckedCreateWithoutBranchInput> | ServiceItemCreateWithoutBranchInput[] | ServiceItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceItemCreateOrConnectWithoutBranchInput | ServiceItemCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceItemUpsertWithWhereUniqueWithoutBranchInput | ServiceItemUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceItemCreateManyBranchInputEnvelope
    set?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    disconnect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    delete?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    connect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    update?: ServiceItemUpdateWithWhereUniqueWithoutBranchInput | ServiceItemUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceItemUpdateManyWithWhereWithoutBranchInput | ServiceItemUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceItemScalarWhereInput | ServiceItemScalarWhereInput[]
  }

  export type ChargeMasterItemUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ChargeMasterItemCreateWithoutBranchInput, ChargeMasterItemUncheckedCreateWithoutBranchInput> | ChargeMasterItemCreateWithoutBranchInput[] | ChargeMasterItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ChargeMasterItemCreateOrConnectWithoutBranchInput | ChargeMasterItemCreateOrConnectWithoutBranchInput[]
    upsert?: ChargeMasterItemUpsertWithWhereUniqueWithoutBranchInput | ChargeMasterItemUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ChargeMasterItemCreateManyBranchInputEnvelope
    set?: ChargeMasterItemWhereUniqueInput | ChargeMasterItemWhereUniqueInput[]
    disconnect?: ChargeMasterItemWhereUniqueInput | ChargeMasterItemWhereUniqueInput[]
    delete?: ChargeMasterItemWhereUniqueInput | ChargeMasterItemWhereUniqueInput[]
    connect?: ChargeMasterItemWhereUniqueInput | ChargeMasterItemWhereUniqueInput[]
    update?: ChargeMasterItemUpdateWithWhereUniqueWithoutBranchInput | ChargeMasterItemUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ChargeMasterItemUpdateManyWithWhereWithoutBranchInput | ChargeMasterItemUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ChargeMasterItemScalarWhereInput | ChargeMasterItemScalarWhereInput[]
  }

  export type ServiceChargeMappingUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutBranchInput, ServiceChargeMappingUncheckedCreateWithoutBranchInput> | ServiceChargeMappingCreateWithoutBranchInput[] | ServiceChargeMappingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutBranchInput | ServiceChargeMappingCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceChargeMappingUpsertWithWhereUniqueWithoutBranchInput | ServiceChargeMappingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceChargeMappingCreateManyBranchInputEnvelope
    set?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    disconnect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    delete?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    update?: ServiceChargeMappingUpdateWithWhereUniqueWithoutBranchInput | ServiceChargeMappingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceChargeMappingUpdateManyWithWhereWithoutBranchInput | ServiceChargeMappingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceChargeMappingScalarWhereInput | ServiceChargeMappingScalarWhereInput[]
  }

  export type FixItTaskUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FixItTaskCreateWithoutBranchInput, FixItTaskUncheckedCreateWithoutBranchInput> | FixItTaskCreateWithoutBranchInput[] | FixItTaskUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutBranchInput | FixItTaskCreateOrConnectWithoutBranchInput[]
    upsert?: FixItTaskUpsertWithWhereUniqueWithoutBranchInput | FixItTaskUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FixItTaskCreateManyBranchInputEnvelope
    set?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    disconnect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    delete?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    update?: FixItTaskUpdateWithWhereUniqueWithoutBranchInput | FixItTaskUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FixItTaskUpdateManyWithWhereWithoutBranchInput | FixItTaskUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FixItTaskScalarWhereInput | FixItTaskScalarWhereInput[]
  }

  export type BulkImportJobUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BulkImportJobCreateWithoutBranchInput, BulkImportJobUncheckedCreateWithoutBranchInput> | BulkImportJobCreateWithoutBranchInput[] | BulkImportJobUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BulkImportJobCreateOrConnectWithoutBranchInput | BulkImportJobCreateOrConnectWithoutBranchInput[]
    upsert?: BulkImportJobUpsertWithWhereUniqueWithoutBranchInput | BulkImportJobUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BulkImportJobCreateManyBranchInputEnvelope
    set?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    disconnect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    delete?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    connect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    update?: BulkImportJobUpdateWithWhereUniqueWithoutBranchInput | BulkImportJobUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BulkImportJobUpdateManyWithWhereWithoutBranchInput | BulkImportJobUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BulkImportJobScalarWhereInput | BulkImportJobScalarWhereInput[]
  }

  export type ProcedureBookingUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProcedureBookingCreateWithoutBranchInput, ProcedureBookingUncheckedCreateWithoutBranchInput> | ProcedureBookingCreateWithoutBranchInput[] | ProcedureBookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutBranchInput | ProcedureBookingCreateOrConnectWithoutBranchInput[]
    upsert?: ProcedureBookingUpsertWithWhereUniqueWithoutBranchInput | ProcedureBookingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProcedureBookingCreateManyBranchInputEnvelope
    set?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    disconnect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    delete?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    update?: ProcedureBookingUpdateWithWhereUniqueWithoutBranchInput | ProcedureBookingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProcedureBookingUpdateManyWithWhereWithoutBranchInput | ProcedureBookingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProcedureBookingScalarWhereInput | ProcedureBookingScalarWhereInput[]
  }

  export type GoLiveReportUpdateManyWithoutBranchNestedInput = {
    create?: XOR<GoLiveReportCreateWithoutBranchInput, GoLiveReportUncheckedCreateWithoutBranchInput> | GoLiveReportCreateWithoutBranchInput[] | GoLiveReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: GoLiveReportCreateOrConnectWithoutBranchInput | GoLiveReportCreateOrConnectWithoutBranchInput[]
    upsert?: GoLiveReportUpsertWithWhereUniqueWithoutBranchInput | GoLiveReportUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: GoLiveReportCreateManyBranchInputEnvelope
    set?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    disconnect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    delete?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    connect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    update?: GoLiveReportUpdateWithWhereUniqueWithoutBranchInput | GoLiveReportUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: GoLiveReportUpdateManyWithWhereWithoutBranchInput | GoLiveReportUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: GoLiveReportScalarWhereInput | GoLiveReportScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutBranchInput | DepartmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutBranchInput | DepartmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutBranchInput | DepartmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutBranchInput | PatientUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutBranchInput | PatientUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutBranchInput | PatientUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type WardUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput> | WardCreateWithoutBranchInput[] | WardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WardCreateOrConnectWithoutBranchInput | WardCreateOrConnectWithoutBranchInput[]
    upsert?: WardUpsertWithWhereUniqueWithoutBranchInput | WardUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WardCreateManyBranchInputEnvelope
    set?: WardWhereUniqueInput | WardWhereUniqueInput[]
    disconnect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    delete?: WardWhereUniqueInput | WardWhereUniqueInput[]
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    update?: WardUpdateWithWhereUniqueWithoutBranchInput | WardUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WardUpdateManyWithWhereWithoutBranchInput | WardUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WardScalarWhereInput | WardScalarWhereInput[]
  }

  export type OTUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput> | OTCreateWithoutBranchInput[] | OTUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: OTCreateOrConnectWithoutBranchInput | OTCreateOrConnectWithoutBranchInput[]
    upsert?: OTUpsertWithWhereUniqueWithoutBranchInput | OTUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: OTCreateManyBranchInputEnvelope
    set?: OTWhereUniqueInput | OTWhereUniqueInput[]
    disconnect?: OTWhereUniqueInput | OTWhereUniqueInput[]
    delete?: OTWhereUniqueInput | OTWhereUniqueInput[]
    connect?: OTWhereUniqueInput | OTWhereUniqueInput[]
    update?: OTUpdateWithWhereUniqueWithoutBranchInput | OTUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: OTUpdateManyWithWhereWithoutBranchInput | OTUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: OTScalarWhereInput | OTScalarWhereInput[]
  }

  export type TariffPlanUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput> | TariffPlanCreateWithoutBranchInput[] | TariffPlanUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutBranchInput | TariffPlanCreateOrConnectWithoutBranchInput[]
    upsert?: TariffPlanUpsertWithWhereUniqueWithoutBranchInput | TariffPlanUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TariffPlanCreateManyBranchInputEnvelope
    set?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    disconnect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    delete?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    update?: TariffPlanUpdateWithWhereUniqueWithoutBranchInput | TariffPlanUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TariffPlanUpdateManyWithWhereWithoutBranchInput | TariffPlanUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput> | AssetCreateWithoutBranchInput[] | AssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBranchInput | AssetCreateOrConnectWithoutBranchInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutBranchInput | AssetUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AssetCreateManyBranchInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutBranchInput | AssetUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutBranchInput | AssetUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type SpecialtyUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput> | SpecialtyCreateWithoutBranchInput[] | SpecialtyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutBranchInput | SpecialtyCreateOrConnectWithoutBranchInput[]
    upsert?: SpecialtyUpsertWithWhereUniqueWithoutBranchInput | SpecialtyUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SpecialtyCreateManyBranchInputEnvelope
    set?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    disconnect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    delete?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    update?: SpecialtyUpdateWithWhereUniqueWithoutBranchInput | SpecialtyUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SpecialtyUpdateManyWithWhereWithoutBranchInput | SpecialtyUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput> | StaffCreateWithoutBranchInput[] | StaffUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutBranchInput | StaffCreateOrConnectWithoutBranchInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutBranchInput | StaffUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StaffCreateManyBranchInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutBranchInput | StaffUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutBranchInput | StaffUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput> | EncounterCreateWithoutBranchInput[] | EncounterUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutBranchInput | EncounterCreateOrConnectWithoutBranchInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutBranchInput | EncounterUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EncounterCreateManyBranchInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutBranchInput | EncounterUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutBranchInput | EncounterUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type BedUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput> | BedCreateWithoutBranchInput[] | BedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBranchInput | BedCreateOrConnectWithoutBranchInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutBranchInput | BedUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BedCreateManyBranchInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutBranchInput | BedUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BedUpdateManyWithWhereWithoutBranchInput | BedUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput> | AdmissionCreateWithoutBranchInput[] | AdmissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBranchInput | AdmissionCreateOrConnectWithoutBranchInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutBranchInput | AdmissionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AdmissionCreateManyBranchInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutBranchInput | AdmissionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutBranchInput | AdmissionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BranchFacilityCreateWithoutBranchInput, BranchFacilityUncheckedCreateWithoutBranchInput> | BranchFacilityCreateWithoutBranchInput[] | BranchFacilityUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchFacilityCreateOrConnectWithoutBranchInput | BranchFacilityCreateOrConnectWithoutBranchInput[]
    upsert?: BranchFacilityUpsertWithWhereUniqueWithoutBranchInput | BranchFacilityUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BranchFacilityCreateManyBranchInputEnvelope
    set?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    disconnect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    delete?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    connect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    update?: BranchFacilityUpdateWithWhereUniqueWithoutBranchInput | BranchFacilityUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BranchFacilityUpdateManyWithWhereWithoutBranchInput | BranchFacilityUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BranchFacilityScalarWhereInput | BranchFacilityScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<RoomCreateWithoutBranchInput, RoomUncheckedCreateWithoutBranchInput> | RoomCreateWithoutBranchInput[] | RoomUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBranchInput | RoomCreateOrConnectWithoutBranchInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBranchInput | RoomUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: RoomCreateManyBranchInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBranchInput | RoomUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBranchInput | RoomUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput> | StatutoryCaseCreateWithoutBranchInput[] | StatutoryCaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutBranchInput | StatutoryCaseCreateOrConnectWithoutBranchInput[]
    upsert?: StatutoryCaseUpsertWithWhereUniqueWithoutBranchInput | StatutoryCaseUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StatutoryCaseCreateManyBranchInputEnvelope
    set?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    disconnect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    delete?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    update?: StatutoryCaseUpdateWithWhereUniqueWithoutBranchInput | StatutoryCaseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StatutoryCaseUpdateManyWithWhereWithoutBranchInput | StatutoryCaseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
  }

  export type AuditEventUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput> | AuditEventCreateWithoutBranchInput[] | AuditEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutBranchInput | AuditEventCreateOrConnectWithoutBranchInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutBranchInput | AuditEventUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AuditEventCreateManyBranchInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutBranchInput | AuditEventUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutBranchInput | AuditEventUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutBranchInput, PolicyVersionUncheckedCreateWithoutBranchInput> | PolicyVersionCreateWithoutBranchInput[] | PolicyVersionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutBranchInput | PolicyVersionCreateOrConnectWithoutBranchInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutBranchInput | PolicyVersionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PolicyVersionCreateManyBranchInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutBranchInput | PolicyVersionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutBranchInput | PolicyVersionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PolicyVersionBranchCreateWithoutBranchInput, PolicyVersionBranchUncheckedCreateWithoutBranchInput> | PolicyVersionBranchCreateWithoutBranchInput[] | PolicyVersionBranchUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PolicyVersionBranchCreateOrConnectWithoutBranchInput | PolicyVersionBranchCreateOrConnectWithoutBranchInput[]
    upsert?: PolicyVersionBranchUpsertWithWhereUniqueWithoutBranchInput | PolicyVersionBranchUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PolicyVersionBranchCreateManyBranchInputEnvelope
    set?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    disconnect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    delete?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    connect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    update?: PolicyVersionBranchUpdateWithWhereUniqueWithoutBranchInput | PolicyVersionBranchUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PolicyVersionBranchUpdateManyWithWhereWithoutBranchInput | PolicyVersionBranchUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PolicyVersionBranchScalarWhereInput | PolicyVersionBranchScalarWhereInput[]
  }

  export type LocationNodeUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<LocationNodeCreateWithoutBranchInput, LocationNodeUncheckedCreateWithoutBranchInput> | LocationNodeCreateWithoutBranchInput[] | LocationNodeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: LocationNodeCreateOrConnectWithoutBranchInput | LocationNodeCreateOrConnectWithoutBranchInput[]
    upsert?: LocationNodeUpsertWithWhereUniqueWithoutBranchInput | LocationNodeUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: LocationNodeCreateManyBranchInputEnvelope
    set?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    disconnect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    delete?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    connect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    update?: LocationNodeUpdateWithWhereUniqueWithoutBranchInput | LocationNodeUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: LocationNodeUpdateManyWithWhereWithoutBranchInput | LocationNodeUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: LocationNodeScalarWhereInput | LocationNodeScalarWhereInput[]
  }

  export type BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BranchUnitTypeCreateWithoutBranchInput, BranchUnitTypeUncheckedCreateWithoutBranchInput> | BranchUnitTypeCreateWithoutBranchInput[] | BranchUnitTypeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BranchUnitTypeCreateOrConnectWithoutBranchInput | BranchUnitTypeCreateOrConnectWithoutBranchInput[]
    upsert?: BranchUnitTypeUpsertWithWhereUniqueWithoutBranchInput | BranchUnitTypeUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BranchUnitTypeCreateManyBranchInputEnvelope
    set?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    disconnect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    delete?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    connect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    update?: BranchUnitTypeUpdateWithWhereUniqueWithoutBranchInput | BranchUnitTypeUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BranchUnitTypeUpdateManyWithWhereWithoutBranchInput | BranchUnitTypeUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BranchUnitTypeScalarWhereInput | BranchUnitTypeScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UnitCreateWithoutBranchInput, UnitUncheckedCreateWithoutBranchInput> | UnitCreateWithoutBranchInput[] | UnitUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutBranchInput | UnitCreateOrConnectWithoutBranchInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutBranchInput | UnitUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UnitCreateManyBranchInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutBranchInput | UnitUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutBranchInput | UnitUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitRoomUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UnitRoomCreateWithoutBranchInput, UnitRoomUncheckedCreateWithoutBranchInput> | UnitRoomCreateWithoutBranchInput[] | UnitRoomUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitRoomCreateOrConnectWithoutBranchInput | UnitRoomCreateOrConnectWithoutBranchInput[]
    upsert?: UnitRoomUpsertWithWhereUniqueWithoutBranchInput | UnitRoomUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UnitRoomCreateManyBranchInputEnvelope
    set?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    disconnect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    delete?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    connect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    update?: UnitRoomUpdateWithWhereUniqueWithoutBranchInput | UnitRoomUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UnitRoomUpdateManyWithWhereWithoutBranchInput | UnitRoomUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UnitRoomScalarWhereInput | UnitRoomScalarWhereInput[]
  }

  export type UnitResourceUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UnitResourceCreateWithoutBranchInput, UnitResourceUncheckedCreateWithoutBranchInput> | UnitResourceCreateWithoutBranchInput[] | UnitResourceUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutBranchInput | UnitResourceCreateOrConnectWithoutBranchInput[]
    upsert?: UnitResourceUpsertWithWhereUniqueWithoutBranchInput | UnitResourceUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UnitResourceCreateManyBranchInputEnvelope
    set?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    disconnect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    delete?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    update?: UnitResourceUpdateWithWhereUniqueWithoutBranchInput | UnitResourceUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UnitResourceUpdateManyWithWhereWithoutBranchInput | UnitResourceUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UnitResourceScalarWhereInput | UnitResourceScalarWhereInput[]
  }

  export type EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EquipmentAssetCreateWithoutBranchInput, EquipmentAssetUncheckedCreateWithoutBranchInput> | EquipmentAssetCreateWithoutBranchInput[] | EquipmentAssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutBranchInput | EquipmentAssetCreateOrConnectWithoutBranchInput[]
    upsert?: EquipmentAssetUpsertWithWhereUniqueWithoutBranchInput | EquipmentAssetUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EquipmentAssetCreateManyBranchInputEnvelope
    set?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    disconnect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    delete?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    update?: EquipmentAssetUpdateWithWhereUniqueWithoutBranchInput | EquipmentAssetUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EquipmentAssetUpdateManyWithWhereWithoutBranchInput | EquipmentAssetUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
  }

  export type ServiceItemUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceItemCreateWithoutBranchInput, ServiceItemUncheckedCreateWithoutBranchInput> | ServiceItemCreateWithoutBranchInput[] | ServiceItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceItemCreateOrConnectWithoutBranchInput | ServiceItemCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceItemUpsertWithWhereUniqueWithoutBranchInput | ServiceItemUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceItemCreateManyBranchInputEnvelope
    set?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    disconnect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    delete?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    connect?: ServiceItemWhereUniqueInput | ServiceItemWhereUniqueInput[]
    update?: ServiceItemUpdateWithWhereUniqueWithoutBranchInput | ServiceItemUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceItemUpdateManyWithWhereWithoutBranchInput | ServiceItemUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceItemScalarWhereInput | ServiceItemScalarWhereInput[]
  }

  export type ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ChargeMasterItemCreateWithoutBranchInput, ChargeMasterItemUncheckedCreateWithoutBranchInput> | ChargeMasterItemCreateWithoutBranchInput[] | ChargeMasterItemUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ChargeMasterItemCreateOrConnectWithoutBranchInput | ChargeMasterItemCreateOrConnectWithoutBranchInput[]
    upsert?: ChargeMasterItemUpsertWithWhereUniqueWithoutBranchInput | ChargeMasterItemUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ChargeMasterItemCreateManyBranchInputEnvelope
    set?: ChargeMasterItemWhereUniqueInput | ChargeMasterItemWhereUniqueInput[]
    disconnect?: ChargeMasterItemWhereUniqueInput | ChargeMasterItemWhereUniqueInput[]
    delete?: ChargeMasterItemWhereUniqueInput | ChargeMasterItemWhereUniqueInput[]
    connect?: ChargeMasterItemWhereUniqueInput | ChargeMasterItemWhereUniqueInput[]
    update?: ChargeMasterItemUpdateWithWhereUniqueWithoutBranchInput | ChargeMasterItemUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ChargeMasterItemUpdateManyWithWhereWithoutBranchInput | ChargeMasterItemUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ChargeMasterItemScalarWhereInput | ChargeMasterItemScalarWhereInput[]
  }

  export type ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutBranchInput, ServiceChargeMappingUncheckedCreateWithoutBranchInput> | ServiceChargeMappingCreateWithoutBranchInput[] | ServiceChargeMappingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutBranchInput | ServiceChargeMappingCreateOrConnectWithoutBranchInput[]
    upsert?: ServiceChargeMappingUpsertWithWhereUniqueWithoutBranchInput | ServiceChargeMappingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ServiceChargeMappingCreateManyBranchInputEnvelope
    set?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    disconnect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    delete?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    update?: ServiceChargeMappingUpdateWithWhereUniqueWithoutBranchInput | ServiceChargeMappingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ServiceChargeMappingUpdateManyWithWhereWithoutBranchInput | ServiceChargeMappingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ServiceChargeMappingScalarWhereInput | ServiceChargeMappingScalarWhereInput[]
  }

  export type FixItTaskUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FixItTaskCreateWithoutBranchInput, FixItTaskUncheckedCreateWithoutBranchInput> | FixItTaskCreateWithoutBranchInput[] | FixItTaskUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutBranchInput | FixItTaskCreateOrConnectWithoutBranchInput[]
    upsert?: FixItTaskUpsertWithWhereUniqueWithoutBranchInput | FixItTaskUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FixItTaskCreateManyBranchInputEnvelope
    set?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    disconnect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    delete?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    update?: FixItTaskUpdateWithWhereUniqueWithoutBranchInput | FixItTaskUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FixItTaskUpdateManyWithWhereWithoutBranchInput | FixItTaskUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FixItTaskScalarWhereInput | FixItTaskScalarWhereInput[]
  }

  export type BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BulkImportJobCreateWithoutBranchInput, BulkImportJobUncheckedCreateWithoutBranchInput> | BulkImportJobCreateWithoutBranchInput[] | BulkImportJobUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BulkImportJobCreateOrConnectWithoutBranchInput | BulkImportJobCreateOrConnectWithoutBranchInput[]
    upsert?: BulkImportJobUpsertWithWhereUniqueWithoutBranchInput | BulkImportJobUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BulkImportJobCreateManyBranchInputEnvelope
    set?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    disconnect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    delete?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    connect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    update?: BulkImportJobUpdateWithWhereUniqueWithoutBranchInput | BulkImportJobUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BulkImportJobUpdateManyWithWhereWithoutBranchInput | BulkImportJobUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BulkImportJobScalarWhereInput | BulkImportJobScalarWhereInput[]
  }

  export type ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<ProcedureBookingCreateWithoutBranchInput, ProcedureBookingUncheckedCreateWithoutBranchInput> | ProcedureBookingCreateWithoutBranchInput[] | ProcedureBookingUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutBranchInput | ProcedureBookingCreateOrConnectWithoutBranchInput[]
    upsert?: ProcedureBookingUpsertWithWhereUniqueWithoutBranchInput | ProcedureBookingUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: ProcedureBookingCreateManyBranchInputEnvelope
    set?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    disconnect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    delete?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    update?: ProcedureBookingUpdateWithWhereUniqueWithoutBranchInput | ProcedureBookingUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: ProcedureBookingUpdateManyWithWhereWithoutBranchInput | ProcedureBookingUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: ProcedureBookingScalarWhereInput | ProcedureBookingScalarWhereInput[]
  }

  export type GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<GoLiveReportCreateWithoutBranchInput, GoLiveReportUncheckedCreateWithoutBranchInput> | GoLiveReportCreateWithoutBranchInput[] | GoLiveReportUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: GoLiveReportCreateOrConnectWithoutBranchInput | GoLiveReportCreateOrConnectWithoutBranchInput[]
    upsert?: GoLiveReportUpsertWithWhereUniqueWithoutBranchInput | GoLiveReportUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: GoLiveReportCreateManyBranchInputEnvelope
    set?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    disconnect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    delete?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    connect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    update?: GoLiveReportUpdateWithWhereUniqueWithoutBranchInput | GoLiveReportUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: GoLiveReportUpdateManyWithWhereWithoutBranchInput | GoLiveReportUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: GoLiveReportScalarWhereInput | GoLiveReportScalarWhereInput[]
  }

  export type BranchFacilityCreateNestedManyWithoutFacilityInput = {
    create?: XOR<BranchFacilityCreateWithoutFacilityInput, BranchFacilityUncheckedCreateWithoutFacilityInput> | BranchFacilityCreateWithoutFacilityInput[] | BranchFacilityUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: BranchFacilityCreateOrConnectWithoutFacilityInput | BranchFacilityCreateOrConnectWithoutFacilityInput[]
    createMany?: BranchFacilityCreateManyFacilityInputEnvelope
    connect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutFacilityInput = {
    create?: XOR<DepartmentCreateWithoutFacilityInput, DepartmentUncheckedCreateWithoutFacilityInput> | DepartmentCreateWithoutFacilityInput[] | DepartmentUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacilityInput | DepartmentCreateOrConnectWithoutFacilityInput[]
    createMany?: DepartmentCreateManyFacilityInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type BranchFacilityUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<BranchFacilityCreateWithoutFacilityInput, BranchFacilityUncheckedCreateWithoutFacilityInput> | BranchFacilityCreateWithoutFacilityInput[] | BranchFacilityUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: BranchFacilityCreateOrConnectWithoutFacilityInput | BranchFacilityCreateOrConnectWithoutFacilityInput[]
    createMany?: BranchFacilityCreateManyFacilityInputEnvelope
    connect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutFacilityInput = {
    create?: XOR<DepartmentCreateWithoutFacilityInput, DepartmentUncheckedCreateWithoutFacilityInput> | DepartmentCreateWithoutFacilityInput[] | DepartmentUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacilityInput | DepartmentCreateOrConnectWithoutFacilityInput[]
    createMany?: DepartmentCreateManyFacilityInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type EnumFacilityCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FacilityCategory
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BranchFacilityUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<BranchFacilityCreateWithoutFacilityInput, BranchFacilityUncheckedCreateWithoutFacilityInput> | BranchFacilityCreateWithoutFacilityInput[] | BranchFacilityUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: BranchFacilityCreateOrConnectWithoutFacilityInput | BranchFacilityCreateOrConnectWithoutFacilityInput[]
    upsert?: BranchFacilityUpsertWithWhereUniqueWithoutFacilityInput | BranchFacilityUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: BranchFacilityCreateManyFacilityInputEnvelope
    set?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    disconnect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    delete?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    connect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    update?: BranchFacilityUpdateWithWhereUniqueWithoutFacilityInput | BranchFacilityUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: BranchFacilityUpdateManyWithWhereWithoutFacilityInput | BranchFacilityUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: BranchFacilityScalarWhereInput | BranchFacilityScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<DepartmentCreateWithoutFacilityInput, DepartmentUncheckedCreateWithoutFacilityInput> | DepartmentCreateWithoutFacilityInput[] | DepartmentUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacilityInput | DepartmentCreateOrConnectWithoutFacilityInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutFacilityInput | DepartmentUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: DepartmentCreateManyFacilityInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutFacilityInput | DepartmentUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutFacilityInput | DepartmentUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type BranchFacilityUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<BranchFacilityCreateWithoutFacilityInput, BranchFacilityUncheckedCreateWithoutFacilityInput> | BranchFacilityCreateWithoutFacilityInput[] | BranchFacilityUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: BranchFacilityCreateOrConnectWithoutFacilityInput | BranchFacilityCreateOrConnectWithoutFacilityInput[]
    upsert?: BranchFacilityUpsertWithWhereUniqueWithoutFacilityInput | BranchFacilityUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: BranchFacilityCreateManyFacilityInputEnvelope
    set?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    disconnect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    delete?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    connect?: BranchFacilityWhereUniqueInput | BranchFacilityWhereUniqueInput[]
    update?: BranchFacilityUpdateWithWhereUniqueWithoutFacilityInput | BranchFacilityUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: BranchFacilityUpdateManyWithWhereWithoutFacilityInput | BranchFacilityUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: BranchFacilityScalarWhereInput | BranchFacilityScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?: XOR<DepartmentCreateWithoutFacilityInput, DepartmentUncheckedCreateWithoutFacilityInput> | DepartmentCreateWithoutFacilityInput[] | DepartmentUncheckedCreateWithoutFacilityInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutFacilityInput | DepartmentCreateOrConnectWithoutFacilityInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutFacilityInput | DepartmentUpsertWithWhereUniqueWithoutFacilityInput[]
    createMany?: DepartmentCreateManyFacilityInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutFacilityInput | DepartmentUpdateWithWhereUniqueWithoutFacilityInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutFacilityInput | DepartmentUpdateManyWithWhereWithoutFacilityInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutBranchFacilitiesInput = {
    create?: XOR<BranchCreateWithoutBranchFacilitiesInput, BranchUncheckedCreateWithoutBranchFacilitiesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBranchFacilitiesInput
    connect?: BranchWhereUniqueInput
  }

  export type FacilityCatalogCreateNestedOneWithoutBranchLinksInput = {
    create?: XOR<FacilityCatalogCreateWithoutBranchLinksInput, FacilityCatalogUncheckedCreateWithoutBranchLinksInput>
    connectOrCreate?: FacilityCatalogCreateOrConnectWithoutBranchLinksInput
    connect?: FacilityCatalogWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutBranchFacilitiesNestedInput = {
    create?: XOR<BranchCreateWithoutBranchFacilitiesInput, BranchUncheckedCreateWithoutBranchFacilitiesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBranchFacilitiesInput
    upsert?: BranchUpsertWithoutBranchFacilitiesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutBranchFacilitiesInput, BranchUpdateWithoutBranchFacilitiesInput>, BranchUncheckedUpdateWithoutBranchFacilitiesInput>
  }

  export type FacilityCatalogUpdateOneRequiredWithoutBranchLinksNestedInput = {
    create?: XOR<FacilityCatalogCreateWithoutBranchLinksInput, FacilityCatalogUncheckedCreateWithoutBranchLinksInput>
    connectOrCreate?: FacilityCatalogCreateOrConnectWithoutBranchLinksInput
    upsert?: FacilityCatalogUpsertWithoutBranchLinksInput
    connect?: FacilityCatalogWhereUniqueInput
    update?: XOR<XOR<FacilityCatalogUpdateToOneWithWhereWithoutBranchLinksInput, FacilityCatalogUpdateWithoutBranchLinksInput>, FacilityCatalogUncheckedUpdateWithoutBranchLinksInput>
  }

  export type BranchCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDepartmentsInput
    connect?: BranchWhereUniqueInput
  }

  export type FacilityCatalogCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<FacilityCatalogCreateWithoutDepartmentsInput, FacilityCatalogUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: FacilityCatalogCreateOrConnectWithoutDepartmentsInput
    connect?: FacilityCatalogWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutHeadedDepartmentsInput = {
    create?: XOR<StaffCreateWithoutHeadedDepartmentsInput, StaffUncheckedCreateWithoutHeadedDepartmentsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutHeadedDepartmentsInput
    connect?: StaffWhereUniqueInput
  }

  export type StaffCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type DepartmentSpecialtyCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentSpecialtyCreateWithoutDepartmentInput, DepartmentSpecialtyUncheckedCreateWithoutDepartmentInput> | DepartmentSpecialtyCreateWithoutDepartmentInput[] | DepartmentSpecialtyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentSpecialtyCreateOrConnectWithoutDepartmentInput | DepartmentSpecialtyCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentSpecialtyCreateManyDepartmentInputEnvelope
    connect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
  }

  export type DepartmentDoctorCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentDoctorCreateWithoutDepartmentInput, DepartmentDoctorUncheckedCreateWithoutDepartmentInput> | DepartmentDoctorCreateWithoutDepartmentInput[] | DepartmentDoctorUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentDoctorCreateOrConnectWithoutDepartmentInput | DepartmentDoctorCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentDoctorCreateManyDepartmentInputEnvelope
    connect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput> | UnitCreateWithoutDepartmentInput[] | UnitUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutDepartmentInput | UnitCreateOrConnectWithoutDepartmentInput[]
    createMany?: UnitCreateManyDepartmentInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type EquipmentAssetCreateNestedManyWithoutOwnerDepartmentInput = {
    create?: XOR<EquipmentAssetCreateWithoutOwnerDepartmentInput, EquipmentAssetUncheckedCreateWithoutOwnerDepartmentInput> | EquipmentAssetCreateWithoutOwnerDepartmentInput[] | EquipmentAssetUncheckedCreateWithoutOwnerDepartmentInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutOwnerDepartmentInput | EquipmentAssetCreateOrConnectWithoutOwnerDepartmentInput[]
    createMany?: EquipmentAssetCreateManyOwnerDepartmentInputEnvelope
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type DepartmentSpecialtyUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentSpecialtyCreateWithoutDepartmentInput, DepartmentSpecialtyUncheckedCreateWithoutDepartmentInput> | DepartmentSpecialtyCreateWithoutDepartmentInput[] | DepartmentSpecialtyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentSpecialtyCreateOrConnectWithoutDepartmentInput | DepartmentSpecialtyCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentSpecialtyCreateManyDepartmentInputEnvelope
    connect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
  }

  export type DepartmentDoctorUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DepartmentDoctorCreateWithoutDepartmentInput, DepartmentDoctorUncheckedCreateWithoutDepartmentInput> | DepartmentDoctorCreateWithoutDepartmentInput[] | DepartmentDoctorUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentDoctorCreateOrConnectWithoutDepartmentInput | DepartmentDoctorCreateOrConnectWithoutDepartmentInput[]
    createMany?: DepartmentDoctorCreateManyDepartmentInputEnvelope
    connect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput> | UnitCreateWithoutDepartmentInput[] | UnitUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutDepartmentInput | UnitCreateOrConnectWithoutDepartmentInput[]
    createMany?: UnitCreateManyDepartmentInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type EquipmentAssetUncheckedCreateNestedManyWithoutOwnerDepartmentInput = {
    create?: XOR<EquipmentAssetCreateWithoutOwnerDepartmentInput, EquipmentAssetUncheckedCreateWithoutOwnerDepartmentInput> | EquipmentAssetCreateWithoutOwnerDepartmentInput[] | EquipmentAssetUncheckedCreateWithoutOwnerDepartmentInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutOwnerDepartmentInput | EquipmentAssetCreateOrConnectWithoutOwnerDepartmentInput[]
    createMany?: EquipmentAssetCreateManyOwnerDepartmentInputEnvelope
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDepartmentsInput
    upsert?: BranchUpsertWithoutDepartmentsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutDepartmentsInput, BranchUpdateWithoutDepartmentsInput>, BranchUncheckedUpdateWithoutDepartmentsInput>
  }

  export type FacilityCatalogUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<FacilityCatalogCreateWithoutDepartmentsInput, FacilityCatalogUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: FacilityCatalogCreateOrConnectWithoutDepartmentsInput
    upsert?: FacilityCatalogUpsertWithoutDepartmentsInput
    connect?: FacilityCatalogWhereUniqueInput
    update?: XOR<XOR<FacilityCatalogUpdateToOneWithWhereWithoutDepartmentsInput, FacilityCatalogUpdateWithoutDepartmentsInput>, FacilityCatalogUncheckedUpdateWithoutDepartmentsInput>
  }

  export type StaffUpdateOneWithoutHeadedDepartmentsNestedInput = {
    create?: XOR<StaffCreateWithoutHeadedDepartmentsInput, StaffUncheckedCreateWithoutHeadedDepartmentsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutHeadedDepartmentsInput
    upsert?: StaffUpsertWithoutHeadedDepartmentsInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutHeadedDepartmentsInput, StaffUpdateWithoutHeadedDepartmentsInput>, StaffUncheckedUpdateWithoutHeadedDepartmentsInput>
  }

  export type StaffUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutDepartmentInput | StaffUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutDepartmentInput | StaffUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutDepartmentInput | StaffUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type DepartmentSpecialtyUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentSpecialtyCreateWithoutDepartmentInput, DepartmentSpecialtyUncheckedCreateWithoutDepartmentInput> | DepartmentSpecialtyCreateWithoutDepartmentInput[] | DepartmentSpecialtyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentSpecialtyCreateOrConnectWithoutDepartmentInput | DepartmentSpecialtyCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentSpecialtyUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentSpecialtyUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentSpecialtyCreateManyDepartmentInputEnvelope
    set?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    disconnect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    delete?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    connect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    update?: DepartmentSpecialtyUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentSpecialtyUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentSpecialtyUpdateManyWithWhereWithoutDepartmentInput | DepartmentSpecialtyUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentSpecialtyScalarWhereInput | DepartmentSpecialtyScalarWhereInput[]
  }

  export type DepartmentDoctorUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentDoctorCreateWithoutDepartmentInput, DepartmentDoctorUncheckedCreateWithoutDepartmentInput> | DepartmentDoctorCreateWithoutDepartmentInput[] | DepartmentDoctorUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentDoctorCreateOrConnectWithoutDepartmentInput | DepartmentDoctorCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentDoctorUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentDoctorUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentDoctorCreateManyDepartmentInputEnvelope
    set?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    disconnect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    delete?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    connect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    update?: DepartmentDoctorUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentDoctorUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentDoctorUpdateManyWithWhereWithoutDepartmentInput | DepartmentDoctorUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentDoctorScalarWhereInput | DepartmentDoctorScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput> | UnitCreateWithoutDepartmentInput[] | UnitUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutDepartmentInput | UnitCreateOrConnectWithoutDepartmentInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutDepartmentInput | UnitUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UnitCreateManyDepartmentInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutDepartmentInput | UnitUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutDepartmentInput | UnitUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type EquipmentAssetUpdateManyWithoutOwnerDepartmentNestedInput = {
    create?: XOR<EquipmentAssetCreateWithoutOwnerDepartmentInput, EquipmentAssetUncheckedCreateWithoutOwnerDepartmentInput> | EquipmentAssetCreateWithoutOwnerDepartmentInput[] | EquipmentAssetUncheckedCreateWithoutOwnerDepartmentInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutOwnerDepartmentInput | EquipmentAssetCreateOrConnectWithoutOwnerDepartmentInput[]
    upsert?: EquipmentAssetUpsertWithWhereUniqueWithoutOwnerDepartmentInput | EquipmentAssetUpsertWithWhereUniqueWithoutOwnerDepartmentInput[]
    createMany?: EquipmentAssetCreateManyOwnerDepartmentInputEnvelope
    set?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    disconnect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    delete?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    update?: EquipmentAssetUpdateWithWhereUniqueWithoutOwnerDepartmentInput | EquipmentAssetUpdateWithWhereUniqueWithoutOwnerDepartmentInput[]
    updateMany?: EquipmentAssetUpdateManyWithWhereWithoutOwnerDepartmentInput | EquipmentAssetUpdateManyWithWhereWithoutOwnerDepartmentInput[]
    deleteMany?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutDepartmentInput | StaffUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutDepartmentInput | StaffUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutDepartmentInput | StaffUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type DepartmentSpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentSpecialtyCreateWithoutDepartmentInput, DepartmentSpecialtyUncheckedCreateWithoutDepartmentInput> | DepartmentSpecialtyCreateWithoutDepartmentInput[] | DepartmentSpecialtyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentSpecialtyCreateOrConnectWithoutDepartmentInput | DepartmentSpecialtyCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentSpecialtyUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentSpecialtyUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentSpecialtyCreateManyDepartmentInputEnvelope
    set?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    disconnect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    delete?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    connect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    update?: DepartmentSpecialtyUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentSpecialtyUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentSpecialtyUpdateManyWithWhereWithoutDepartmentInput | DepartmentSpecialtyUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentSpecialtyScalarWhereInput | DepartmentSpecialtyScalarWhereInput[]
  }

  export type DepartmentDoctorUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DepartmentDoctorCreateWithoutDepartmentInput, DepartmentDoctorUncheckedCreateWithoutDepartmentInput> | DepartmentDoctorCreateWithoutDepartmentInput[] | DepartmentDoctorUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DepartmentDoctorCreateOrConnectWithoutDepartmentInput | DepartmentDoctorCreateOrConnectWithoutDepartmentInput[]
    upsert?: DepartmentDoctorUpsertWithWhereUniqueWithoutDepartmentInput | DepartmentDoctorUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DepartmentDoctorCreateManyDepartmentInputEnvelope
    set?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    disconnect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    delete?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    connect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    update?: DepartmentDoctorUpdateWithWhereUniqueWithoutDepartmentInput | DepartmentDoctorUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DepartmentDoctorUpdateManyWithWhereWithoutDepartmentInput | DepartmentDoctorUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DepartmentDoctorScalarWhereInput | DepartmentDoctorScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput> | UnitCreateWithoutDepartmentInput[] | UnitUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutDepartmentInput | UnitCreateOrConnectWithoutDepartmentInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutDepartmentInput | UnitUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UnitCreateManyDepartmentInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutDepartmentInput | UnitUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutDepartmentInput | UnitUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type EquipmentAssetUncheckedUpdateManyWithoutOwnerDepartmentNestedInput = {
    create?: XOR<EquipmentAssetCreateWithoutOwnerDepartmentInput, EquipmentAssetUncheckedCreateWithoutOwnerDepartmentInput> | EquipmentAssetCreateWithoutOwnerDepartmentInput[] | EquipmentAssetUncheckedCreateWithoutOwnerDepartmentInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutOwnerDepartmentInput | EquipmentAssetCreateOrConnectWithoutOwnerDepartmentInput[]
    upsert?: EquipmentAssetUpsertWithWhereUniqueWithoutOwnerDepartmentInput | EquipmentAssetUpsertWithWhereUniqueWithoutOwnerDepartmentInput[]
    createMany?: EquipmentAssetCreateManyOwnerDepartmentInputEnvelope
    set?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    disconnect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    delete?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    update?: EquipmentAssetUpdateWithWhereUniqueWithoutOwnerDepartmentInput | EquipmentAssetUpdateWithWhereUniqueWithoutOwnerDepartmentInput[]
    updateMany?: EquipmentAssetUpdateManyWithWhereWithoutOwnerDepartmentInput | EquipmentAssetUpdateManyWithWhereWithoutOwnerDepartmentInput[]
    deleteMany?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutDoctorAssignmentsInput = {
    create?: XOR<DepartmentCreateWithoutDoctorAssignmentsInput, DepartmentUncheckedCreateWithoutDoctorAssignmentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDoctorAssignmentsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutDoctorAssignmentsInput = {
    create?: XOR<StaffCreateWithoutDoctorAssignmentsInput, StaffUncheckedCreateWithoutDoctorAssignmentsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutDoctorAssignmentsInput
    connect?: StaffWhereUniqueInput
  }

  export type DepartmentUpdateOneRequiredWithoutDoctorAssignmentsNestedInput = {
    create?: XOR<DepartmentCreateWithoutDoctorAssignmentsInput, DepartmentUncheckedCreateWithoutDoctorAssignmentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDoctorAssignmentsInput
    upsert?: DepartmentUpsertWithoutDoctorAssignmentsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutDoctorAssignmentsInput, DepartmentUpdateWithoutDoctorAssignmentsInput>, DepartmentUncheckedUpdateWithoutDoctorAssignmentsInput>
  }

  export type StaffUpdateOneRequiredWithoutDoctorAssignmentsNestedInput = {
    create?: XOR<StaffCreateWithoutDoctorAssignmentsInput, StaffUncheckedCreateWithoutDoctorAssignmentsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutDoctorAssignmentsInput
    upsert?: StaffUpsertWithoutDoctorAssignmentsInput
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutDoctorAssignmentsInput, StaffUpdateWithoutDoctorAssignmentsInput>, StaffUncheckedUpdateWithoutDoctorAssignmentsInput>
  }

  export type BranchCreateNestedOneWithoutSpecialtyInput = {
    create?: XOR<BranchCreateWithoutSpecialtyInput, BranchUncheckedCreateWithoutSpecialtyInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSpecialtyInput
    connect?: BranchWhereUniqueInput
  }

  export type StaffCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput> | StaffCreateWithoutSpecialtyInput[] | StaffUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSpecialtyInput | StaffCreateOrConnectWithoutSpecialtyInput[]
    createMany?: StaffCreateManySpecialtyInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type DepartmentSpecialtyCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<DepartmentSpecialtyCreateWithoutSpecialtyInput, DepartmentSpecialtyUncheckedCreateWithoutSpecialtyInput> | DepartmentSpecialtyCreateWithoutSpecialtyInput[] | DepartmentSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: DepartmentSpecialtyCreateOrConnectWithoutSpecialtyInput | DepartmentSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    createMany?: DepartmentSpecialtyCreateManySpecialtyInputEnvelope
    connect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput> | StaffCreateWithoutSpecialtyInput[] | StaffUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSpecialtyInput | StaffCreateOrConnectWithoutSpecialtyInput[]
    createMany?: StaffCreateManySpecialtyInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type DepartmentSpecialtyUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<DepartmentSpecialtyCreateWithoutSpecialtyInput, DepartmentSpecialtyUncheckedCreateWithoutSpecialtyInput> | DepartmentSpecialtyCreateWithoutSpecialtyInput[] | DepartmentSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: DepartmentSpecialtyCreateOrConnectWithoutSpecialtyInput | DepartmentSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    createMany?: DepartmentSpecialtyCreateManySpecialtyInputEnvelope
    connect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutSpecialtyNestedInput = {
    create?: XOR<BranchCreateWithoutSpecialtyInput, BranchUncheckedCreateWithoutSpecialtyInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSpecialtyInput
    upsert?: BranchUpsertWithoutSpecialtyInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSpecialtyInput, BranchUpdateWithoutSpecialtyInput>, BranchUncheckedUpdateWithoutSpecialtyInput>
  }

  export type StaffUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput> | StaffCreateWithoutSpecialtyInput[] | StaffUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSpecialtyInput | StaffCreateOrConnectWithoutSpecialtyInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutSpecialtyInput | StaffUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: StaffCreateManySpecialtyInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutSpecialtyInput | StaffUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutSpecialtyInput | StaffUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type DepartmentSpecialtyUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<DepartmentSpecialtyCreateWithoutSpecialtyInput, DepartmentSpecialtyUncheckedCreateWithoutSpecialtyInput> | DepartmentSpecialtyCreateWithoutSpecialtyInput[] | DepartmentSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: DepartmentSpecialtyCreateOrConnectWithoutSpecialtyInput | DepartmentSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    upsert?: DepartmentSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput | DepartmentSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: DepartmentSpecialtyCreateManySpecialtyInputEnvelope
    set?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    disconnect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    delete?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    connect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    update?: DepartmentSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput | DepartmentSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: DepartmentSpecialtyUpdateManyWithWhereWithoutSpecialtyInput | DepartmentSpecialtyUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: DepartmentSpecialtyScalarWhereInput | DepartmentSpecialtyScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput> | StaffCreateWithoutSpecialtyInput[] | StaffUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSpecialtyInput | StaffCreateOrConnectWithoutSpecialtyInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutSpecialtyInput | StaffUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: StaffCreateManySpecialtyInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutSpecialtyInput | StaffUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutSpecialtyInput | StaffUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type DepartmentSpecialtyUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<DepartmentSpecialtyCreateWithoutSpecialtyInput, DepartmentSpecialtyUncheckedCreateWithoutSpecialtyInput> | DepartmentSpecialtyCreateWithoutSpecialtyInput[] | DepartmentSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: DepartmentSpecialtyCreateOrConnectWithoutSpecialtyInput | DepartmentSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    upsert?: DepartmentSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput | DepartmentSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: DepartmentSpecialtyCreateManySpecialtyInputEnvelope
    set?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    disconnect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    delete?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    connect?: DepartmentSpecialtyWhereUniqueInput | DepartmentSpecialtyWhereUniqueInput[]
    update?: DepartmentSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput | DepartmentSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: DepartmentSpecialtyUpdateManyWithWhereWithoutSpecialtyInput | DepartmentSpecialtyUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: DepartmentSpecialtyScalarWhereInput | DepartmentSpecialtyScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutDepartmentSpecialtiesInput = {
    create?: XOR<DepartmentCreateWithoutDepartmentSpecialtiesInput, DepartmentUncheckedCreateWithoutDepartmentSpecialtiesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDepartmentSpecialtiesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutDepartmentLinksInput = {
    create?: XOR<SpecialtyCreateWithoutDepartmentLinksInput, SpecialtyUncheckedCreateWithoutDepartmentLinksInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutDepartmentLinksInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type DepartmentUpdateOneRequiredWithoutDepartmentSpecialtiesNestedInput = {
    create?: XOR<DepartmentCreateWithoutDepartmentSpecialtiesInput, DepartmentUncheckedCreateWithoutDepartmentSpecialtiesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutDepartmentSpecialtiesInput
    upsert?: DepartmentUpsertWithoutDepartmentSpecialtiesInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutDepartmentSpecialtiesInput, DepartmentUpdateWithoutDepartmentSpecialtiesInput>, DepartmentUncheckedUpdateWithoutDepartmentSpecialtiesInput>
  }

  export type SpecialtyUpdateOneRequiredWithoutDepartmentLinksNestedInput = {
    create?: XOR<SpecialtyCreateWithoutDepartmentLinksInput, SpecialtyUncheckedCreateWithoutDepartmentLinksInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutDepartmentLinksInput
    upsert?: SpecialtyUpsertWithoutDepartmentLinksInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<XOR<SpecialtyUpdateToOneWithWhereWithoutDepartmentLinksInput, SpecialtyUpdateWithoutDepartmentLinksInput>, SpecialtyUncheckedUpdateWithoutDepartmentLinksInput>
  }

  export type BranchCreateNestedOneWithoutStaffInput = {
    create?: XOR<BranchCreateWithoutStaffInput, BranchUncheckedCreateWithoutStaffInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStaffInput
    connect?: BranchWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutStaffInput = {
    create?: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffInput
    connect?: DepartmentWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutStaffInput = {
    create?: XOR<SpecialtyCreateWithoutStaffInput, SpecialtyUncheckedCreateWithoutStaffInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutStaffInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type DepartmentDoctorCreateNestedManyWithoutStaffInput = {
    create?: XOR<DepartmentDoctorCreateWithoutStaffInput, DepartmentDoctorUncheckedCreateWithoutStaffInput> | DepartmentDoctorCreateWithoutStaffInput[] | DepartmentDoctorUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: DepartmentDoctorCreateOrConnectWithoutStaffInput | DepartmentDoctorCreateOrConnectWithoutStaffInput[]
    createMany?: DepartmentDoctorCreateManyStaffInputEnvelope
    connect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutHeadStaffInput = {
    create?: XOR<DepartmentCreateWithoutHeadStaffInput, DepartmentUncheckedCreateWithoutHeadStaffInput> | DepartmentCreateWithoutHeadStaffInput[] | DepartmentUncheckedCreateWithoutHeadStaffInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadStaffInput | DepartmentCreateOrConnectWithoutHeadStaffInput[]
    createMany?: DepartmentCreateManyHeadStaffInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutStaffInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentDoctorUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<DepartmentDoctorCreateWithoutStaffInput, DepartmentDoctorUncheckedCreateWithoutStaffInput> | DepartmentDoctorCreateWithoutStaffInput[] | DepartmentDoctorUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: DepartmentDoctorCreateOrConnectWithoutStaffInput | DepartmentDoctorCreateOrConnectWithoutStaffInput[]
    createMany?: DepartmentDoctorCreateManyStaffInputEnvelope
    connect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutHeadStaffInput = {
    create?: XOR<DepartmentCreateWithoutHeadStaffInput, DepartmentUncheckedCreateWithoutHeadStaffInput> | DepartmentCreateWithoutHeadStaffInput[] | DepartmentUncheckedCreateWithoutHeadStaffInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadStaffInput | DepartmentCreateOrConnectWithoutHeadStaffInput[]
    createMany?: DepartmentCreateManyHeadStaffInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutStaffInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    connect?: UserWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<BranchCreateWithoutStaffInput, BranchUncheckedCreateWithoutStaffInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStaffInput
    upsert?: BranchUpsertWithoutStaffInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutStaffInput, BranchUpdateWithoutStaffInput>, BranchUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentUpdateOneWithoutStaffNestedInput = {
    create?: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffInput
    upsert?: DepartmentUpsertWithoutStaffInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutStaffInput, DepartmentUpdateWithoutStaffInput>, DepartmentUncheckedUpdateWithoutStaffInput>
  }

  export type SpecialtyUpdateOneWithoutStaffNestedInput = {
    create?: XOR<SpecialtyCreateWithoutStaffInput, SpecialtyUncheckedCreateWithoutStaffInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutStaffInput
    upsert?: SpecialtyUpsertWithoutStaffInput
    disconnect?: SpecialtyWhereInput | boolean
    delete?: SpecialtyWhereInput | boolean
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<XOR<SpecialtyUpdateToOneWithWhereWithoutStaffInput, SpecialtyUpdateWithoutStaffInput>, SpecialtyUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentDoctorUpdateManyWithoutStaffNestedInput = {
    create?: XOR<DepartmentDoctorCreateWithoutStaffInput, DepartmentDoctorUncheckedCreateWithoutStaffInput> | DepartmentDoctorCreateWithoutStaffInput[] | DepartmentDoctorUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: DepartmentDoctorCreateOrConnectWithoutStaffInput | DepartmentDoctorCreateOrConnectWithoutStaffInput[]
    upsert?: DepartmentDoctorUpsertWithWhereUniqueWithoutStaffInput | DepartmentDoctorUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: DepartmentDoctorCreateManyStaffInputEnvelope
    set?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    disconnect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    delete?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    connect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    update?: DepartmentDoctorUpdateWithWhereUniqueWithoutStaffInput | DepartmentDoctorUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: DepartmentDoctorUpdateManyWithWhereWithoutStaffInput | DepartmentDoctorUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: DepartmentDoctorScalarWhereInput | DepartmentDoctorScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutHeadStaffNestedInput = {
    create?: XOR<DepartmentCreateWithoutHeadStaffInput, DepartmentUncheckedCreateWithoutHeadStaffInput> | DepartmentCreateWithoutHeadStaffInput[] | DepartmentUncheckedCreateWithoutHeadStaffInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadStaffInput | DepartmentCreateOrConnectWithoutHeadStaffInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutHeadStaffInput | DepartmentUpsertWithWhereUniqueWithoutHeadStaffInput[]
    createMany?: DepartmentCreateManyHeadStaffInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutHeadStaffInput | DepartmentUpdateWithWhereUniqueWithoutHeadStaffInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutHeadStaffInput | DepartmentUpdateManyWithWhereWithoutHeadStaffInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserUpdateOneWithoutStaffNestedInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    upsert?: UserUpsertWithoutStaffInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffInput, UserUpdateWithoutStaffInput>, UserUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentDoctorUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<DepartmentDoctorCreateWithoutStaffInput, DepartmentDoctorUncheckedCreateWithoutStaffInput> | DepartmentDoctorCreateWithoutStaffInput[] | DepartmentDoctorUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: DepartmentDoctorCreateOrConnectWithoutStaffInput | DepartmentDoctorCreateOrConnectWithoutStaffInput[]
    upsert?: DepartmentDoctorUpsertWithWhereUniqueWithoutStaffInput | DepartmentDoctorUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: DepartmentDoctorCreateManyStaffInputEnvelope
    set?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    disconnect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    delete?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    connect?: DepartmentDoctorWhereUniqueInput | DepartmentDoctorWhereUniqueInput[]
    update?: DepartmentDoctorUpdateWithWhereUniqueWithoutStaffInput | DepartmentDoctorUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: DepartmentDoctorUpdateManyWithWhereWithoutStaffInput | DepartmentDoctorUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: DepartmentDoctorScalarWhereInput | DepartmentDoctorScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutHeadStaffNestedInput = {
    create?: XOR<DepartmentCreateWithoutHeadStaffInput, DepartmentUncheckedCreateWithoutHeadStaffInput> | DepartmentCreateWithoutHeadStaffInput[] | DepartmentUncheckedCreateWithoutHeadStaffInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadStaffInput | DepartmentCreateOrConnectWithoutHeadStaffInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutHeadStaffInput | DepartmentUpsertWithWhereUniqueWithoutHeadStaffInput[]
    createMany?: DepartmentCreateManyHeadStaffInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutHeadStaffInput | DepartmentUpdateWithWhereUniqueWithoutHeadStaffInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutHeadStaffInput | DepartmentUpdateManyWithWhereWithoutHeadStaffInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutStaffNestedInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    upsert?: UserUpsertWithoutStaffInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffInput, UserUpdateWithoutStaffInput>, UserUncheckedUpdateWithoutStaffInput>
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    connect?: StaffWhereUniqueInput
  }

  export type RoleTemplateVersionCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutUsersInput, RoleTemplateVersionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutUsersInput
    connect?: RoleTemplateVersionWhereUniqueInput
  }

  export type RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput> | RoleTemplateVersionCreateWithoutCreatedByUserInput[] | RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput | RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: RoleTemplateVersionCreateManyCreatedByUserInputEnvelope
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
  }

  export type AuditEventCreateNestedManyWithoutActorUserInput = {
    create?: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput> | AuditEventCreateWithoutActorUserInput[] | AuditEventUncheckedCreateWithoutActorUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorUserInput | AuditEventCreateOrConnectWithoutActorUserInput[]
    createMany?: AuditEventCreateManyActorUserInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type PolicyVersionCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<PolicyVersionCreateWithoutCreatedByUserInput, PolicyVersionUncheckedCreateWithoutCreatedByUserInput> | PolicyVersionCreateWithoutCreatedByUserInput[] | PolicyVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutCreatedByUserInput | PolicyVersionCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: PolicyVersionCreateManyCreatedByUserInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionCreateNestedManyWithoutSubmittedByUserInput = {
    create?: XOR<PolicyVersionCreateWithoutSubmittedByUserInput, PolicyVersionUncheckedCreateWithoutSubmittedByUserInput> | PolicyVersionCreateWithoutSubmittedByUserInput[] | PolicyVersionUncheckedCreateWithoutSubmittedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutSubmittedByUserInput | PolicyVersionCreateOrConnectWithoutSubmittedByUserInput[]
    createMany?: PolicyVersionCreateManySubmittedByUserInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionCreateNestedManyWithoutApprovedByUserInput = {
    create?: XOR<PolicyVersionCreateWithoutApprovedByUserInput, PolicyVersionUncheckedCreateWithoutApprovedByUserInput> | PolicyVersionCreateWithoutApprovedByUserInput[] | PolicyVersionUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutApprovedByUserInput | PolicyVersionCreateOrConnectWithoutApprovedByUserInput[]
    createMany?: PolicyVersionCreateManyApprovedByUserInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionCreateNestedManyWithoutRejectedByUserInput = {
    create?: XOR<PolicyVersionCreateWithoutRejectedByUserInput, PolicyVersionUncheckedCreateWithoutRejectedByUserInput> | PolicyVersionCreateWithoutRejectedByUserInput[] | PolicyVersionUncheckedCreateWithoutRejectedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutRejectedByUserInput | PolicyVersionCreateOrConnectWithoutRejectedByUserInput[]
    createMany?: PolicyVersionCreateManyRejectedByUserInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionCreateNestedManyWithoutRetiredByUserInput = {
    create?: XOR<PolicyVersionCreateWithoutRetiredByUserInput, PolicyVersionUncheckedCreateWithoutRetiredByUserInput> | PolicyVersionCreateWithoutRetiredByUserInput[] | PolicyVersionUncheckedCreateWithoutRetiredByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutRetiredByUserInput | PolicyVersionCreateOrConnectWithoutRetiredByUserInput[]
    createMany?: PolicyVersionCreateManyRetiredByUserInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<LocationNodeRevisionCreateWithoutCreatedByUserInput, LocationNodeRevisionUncheckedCreateWithoutCreatedByUserInput> | LocationNodeRevisionCreateWithoutCreatedByUserInput[] | LocationNodeRevisionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: LocationNodeRevisionCreateOrConnectWithoutCreatedByUserInput | LocationNodeRevisionCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: LocationNodeRevisionCreateManyCreatedByUserInputEnvelope
    connect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
  }

  export type BulkImportJobCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<BulkImportJobCreateWithoutCreatedByUserInput, BulkImportJobUncheckedCreateWithoutCreatedByUserInput> | BulkImportJobCreateWithoutCreatedByUserInput[] | BulkImportJobUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: BulkImportJobCreateOrConnectWithoutCreatedByUserInput | BulkImportJobCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: BulkImportJobCreateManyCreatedByUserInputEnvelope
    connect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
  }

  export type FixItTaskCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<FixItTaskCreateWithoutAssignedToUserInput, FixItTaskUncheckedCreateWithoutAssignedToUserInput> | FixItTaskCreateWithoutAssignedToUserInput[] | FixItTaskUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutAssignedToUserInput | FixItTaskCreateOrConnectWithoutAssignedToUserInput[]
    createMany?: FixItTaskCreateManyAssignedToUserInputEnvelope
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
  }

  export type ProcedureBookingCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<ProcedureBookingCreateWithoutCreatedByUserInput, ProcedureBookingUncheckedCreateWithoutCreatedByUserInput> | ProcedureBookingCreateWithoutCreatedByUserInput[] | ProcedureBookingUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutCreatedByUserInput | ProcedureBookingCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: ProcedureBookingCreateManyCreatedByUserInputEnvelope
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
  }

  export type GoLiveReportCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<GoLiveReportCreateWithoutCreatedByUserInput, GoLiveReportUncheckedCreateWithoutCreatedByUserInput> | GoLiveReportCreateWithoutCreatedByUserInput[] | GoLiveReportUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: GoLiveReportCreateOrConnectWithoutCreatedByUserInput | GoLiveReportCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: GoLiveReportCreateManyCreatedByUserInputEnvelope
    connect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
  }

  export type RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput> | RoleTemplateVersionCreateWithoutCreatedByUserInput[] | RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput | RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: RoleTemplateVersionCreateManyCreatedByUserInputEnvelope
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
  }

  export type AuditEventUncheckedCreateNestedManyWithoutActorUserInput = {
    create?: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput> | AuditEventCreateWithoutActorUserInput[] | AuditEventUncheckedCreateWithoutActorUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorUserInput | AuditEventCreateOrConnectWithoutActorUserInput[]
    createMany?: AuditEventCreateManyActorUserInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<PolicyVersionCreateWithoutCreatedByUserInput, PolicyVersionUncheckedCreateWithoutCreatedByUserInput> | PolicyVersionCreateWithoutCreatedByUserInput[] | PolicyVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutCreatedByUserInput | PolicyVersionCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: PolicyVersionCreateManyCreatedByUserInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput = {
    create?: XOR<PolicyVersionCreateWithoutSubmittedByUserInput, PolicyVersionUncheckedCreateWithoutSubmittedByUserInput> | PolicyVersionCreateWithoutSubmittedByUserInput[] | PolicyVersionUncheckedCreateWithoutSubmittedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutSubmittedByUserInput | PolicyVersionCreateOrConnectWithoutSubmittedByUserInput[]
    createMany?: PolicyVersionCreateManySubmittedByUserInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput = {
    create?: XOR<PolicyVersionCreateWithoutApprovedByUserInput, PolicyVersionUncheckedCreateWithoutApprovedByUserInput> | PolicyVersionCreateWithoutApprovedByUserInput[] | PolicyVersionUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutApprovedByUserInput | PolicyVersionCreateOrConnectWithoutApprovedByUserInput[]
    createMany?: PolicyVersionCreateManyApprovedByUserInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput = {
    create?: XOR<PolicyVersionCreateWithoutRejectedByUserInput, PolicyVersionUncheckedCreateWithoutRejectedByUserInput> | PolicyVersionCreateWithoutRejectedByUserInput[] | PolicyVersionUncheckedCreateWithoutRejectedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutRejectedByUserInput | PolicyVersionCreateOrConnectWithoutRejectedByUserInput[]
    createMany?: PolicyVersionCreateManyRejectedByUserInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput = {
    create?: XOR<PolicyVersionCreateWithoutRetiredByUserInput, PolicyVersionUncheckedCreateWithoutRetiredByUserInput> | PolicyVersionCreateWithoutRetiredByUserInput[] | PolicyVersionUncheckedCreateWithoutRetiredByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutRetiredByUserInput | PolicyVersionCreateOrConnectWithoutRetiredByUserInput[]
    createMany?: PolicyVersionCreateManyRetiredByUserInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<LocationNodeRevisionCreateWithoutCreatedByUserInput, LocationNodeRevisionUncheckedCreateWithoutCreatedByUserInput> | LocationNodeRevisionCreateWithoutCreatedByUserInput[] | LocationNodeRevisionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: LocationNodeRevisionCreateOrConnectWithoutCreatedByUserInput | LocationNodeRevisionCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: LocationNodeRevisionCreateManyCreatedByUserInputEnvelope
    connect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
  }

  export type BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<BulkImportJobCreateWithoutCreatedByUserInput, BulkImportJobUncheckedCreateWithoutCreatedByUserInput> | BulkImportJobCreateWithoutCreatedByUserInput[] | BulkImportJobUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: BulkImportJobCreateOrConnectWithoutCreatedByUserInput | BulkImportJobCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: BulkImportJobCreateManyCreatedByUserInputEnvelope
    connect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
  }

  export type FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<FixItTaskCreateWithoutAssignedToUserInput, FixItTaskUncheckedCreateWithoutAssignedToUserInput> | FixItTaskCreateWithoutAssignedToUserInput[] | FixItTaskUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutAssignedToUserInput | FixItTaskCreateOrConnectWithoutAssignedToUserInput[]
    createMany?: FixItTaskCreateManyAssignedToUserInputEnvelope
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
  }

  export type ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<ProcedureBookingCreateWithoutCreatedByUserInput, ProcedureBookingUncheckedCreateWithoutCreatedByUserInput> | ProcedureBookingCreateWithoutCreatedByUserInput[] | ProcedureBookingUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutCreatedByUserInput | ProcedureBookingCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: ProcedureBookingCreateManyCreatedByUserInputEnvelope
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
  }

  export type GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<GoLiveReportCreateWithoutCreatedByUserInput, GoLiveReportUncheckedCreateWithoutCreatedByUserInput> | GoLiveReportCreateWithoutCreatedByUserInput[] | GoLiveReportUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: GoLiveReportCreateOrConnectWithoutCreatedByUserInput | GoLiveReportCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: GoLiveReportCreateManyCreatedByUserInputEnvelope
    connect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type StaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    upsert?: StaffUpsertWithoutUserInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutUserInput, StaffUpdateWithoutUserInput>, StaffUncheckedUpdateWithoutUserInput>
  }

  export type RoleTemplateVersionUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutUsersInput, RoleTemplateVersionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutUsersInput
    upsert?: RoleTemplateVersionUpsertWithoutUsersInput
    disconnect?: RoleTemplateVersionWhereInput | boolean
    delete?: RoleTemplateVersionWhereInput | boolean
    connect?: RoleTemplateVersionWhereUniqueInput
    update?: XOR<XOR<RoleTemplateVersionUpdateToOneWithWhereWithoutUsersInput, RoleTemplateVersionUpdateWithoutUsersInput>, RoleTemplateVersionUncheckedUpdateWithoutUsersInput>
  }

  export type RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput> | RoleTemplateVersionCreateWithoutCreatedByUserInput[] | RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput | RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: RoleTemplateVersionUpsertWithWhereUniqueWithoutCreatedByUserInput | RoleTemplateVersionUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: RoleTemplateVersionCreateManyCreatedByUserInputEnvelope
    set?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    disconnect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    delete?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    update?: RoleTemplateVersionUpdateWithWhereUniqueWithoutCreatedByUserInput | RoleTemplateVersionUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: RoleTemplateVersionUpdateManyWithWhereWithoutCreatedByUserInput | RoleTemplateVersionUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
  }

  export type AuditEventUpdateManyWithoutActorUserNestedInput = {
    create?: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput> | AuditEventCreateWithoutActorUserInput[] | AuditEventUncheckedCreateWithoutActorUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorUserInput | AuditEventCreateOrConnectWithoutActorUserInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutActorUserInput | AuditEventUpsertWithWhereUniqueWithoutActorUserInput[]
    createMany?: AuditEventCreateManyActorUserInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutActorUserInput | AuditEventUpdateWithWhereUniqueWithoutActorUserInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutActorUserInput | AuditEventUpdateManyWithWhereWithoutActorUserInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type PolicyVersionUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutCreatedByUserInput, PolicyVersionUncheckedCreateWithoutCreatedByUserInput> | PolicyVersionCreateWithoutCreatedByUserInput[] | PolicyVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutCreatedByUserInput | PolicyVersionCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutCreatedByUserInput | PolicyVersionUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: PolicyVersionCreateManyCreatedByUserInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutCreatedByUserInput | PolicyVersionUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutCreatedByUserInput | PolicyVersionUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutSubmittedByUserInput, PolicyVersionUncheckedCreateWithoutSubmittedByUserInput> | PolicyVersionCreateWithoutSubmittedByUserInput[] | PolicyVersionUncheckedCreateWithoutSubmittedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutSubmittedByUserInput | PolicyVersionCreateOrConnectWithoutSubmittedByUserInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutSubmittedByUserInput | PolicyVersionUpsertWithWhereUniqueWithoutSubmittedByUserInput[]
    createMany?: PolicyVersionCreateManySubmittedByUserInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutSubmittedByUserInput | PolicyVersionUpdateWithWhereUniqueWithoutSubmittedByUserInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutSubmittedByUserInput | PolicyVersionUpdateManyWithWhereWithoutSubmittedByUserInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyVersionUpdateManyWithoutApprovedByUserNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutApprovedByUserInput, PolicyVersionUncheckedCreateWithoutApprovedByUserInput> | PolicyVersionCreateWithoutApprovedByUserInput[] | PolicyVersionUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutApprovedByUserInput | PolicyVersionCreateOrConnectWithoutApprovedByUserInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutApprovedByUserInput | PolicyVersionUpsertWithWhereUniqueWithoutApprovedByUserInput[]
    createMany?: PolicyVersionCreateManyApprovedByUserInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutApprovedByUserInput | PolicyVersionUpdateWithWhereUniqueWithoutApprovedByUserInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutApprovedByUserInput | PolicyVersionUpdateManyWithWhereWithoutApprovedByUserInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyVersionUpdateManyWithoutRejectedByUserNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutRejectedByUserInput, PolicyVersionUncheckedCreateWithoutRejectedByUserInput> | PolicyVersionCreateWithoutRejectedByUserInput[] | PolicyVersionUncheckedCreateWithoutRejectedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutRejectedByUserInput | PolicyVersionCreateOrConnectWithoutRejectedByUserInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutRejectedByUserInput | PolicyVersionUpsertWithWhereUniqueWithoutRejectedByUserInput[]
    createMany?: PolicyVersionCreateManyRejectedByUserInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutRejectedByUserInput | PolicyVersionUpdateWithWhereUniqueWithoutRejectedByUserInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutRejectedByUserInput | PolicyVersionUpdateManyWithWhereWithoutRejectedByUserInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyVersionUpdateManyWithoutRetiredByUserNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutRetiredByUserInput, PolicyVersionUncheckedCreateWithoutRetiredByUserInput> | PolicyVersionCreateWithoutRetiredByUserInput[] | PolicyVersionUncheckedCreateWithoutRetiredByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutRetiredByUserInput | PolicyVersionCreateOrConnectWithoutRetiredByUserInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutRetiredByUserInput | PolicyVersionUpsertWithWhereUniqueWithoutRetiredByUserInput[]
    createMany?: PolicyVersionCreateManyRetiredByUserInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutRetiredByUserInput | PolicyVersionUpdateWithWhereUniqueWithoutRetiredByUserInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutRetiredByUserInput | PolicyVersionUpdateManyWithWhereWithoutRetiredByUserInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<LocationNodeRevisionCreateWithoutCreatedByUserInput, LocationNodeRevisionUncheckedCreateWithoutCreatedByUserInput> | LocationNodeRevisionCreateWithoutCreatedByUserInput[] | LocationNodeRevisionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: LocationNodeRevisionCreateOrConnectWithoutCreatedByUserInput | LocationNodeRevisionCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: LocationNodeRevisionUpsertWithWhereUniqueWithoutCreatedByUserInput | LocationNodeRevisionUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: LocationNodeRevisionCreateManyCreatedByUserInputEnvelope
    set?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    disconnect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    delete?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    connect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    update?: LocationNodeRevisionUpdateWithWhereUniqueWithoutCreatedByUserInput | LocationNodeRevisionUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: LocationNodeRevisionUpdateManyWithWhereWithoutCreatedByUserInput | LocationNodeRevisionUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: LocationNodeRevisionScalarWhereInput | LocationNodeRevisionScalarWhereInput[]
  }

  export type BulkImportJobUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<BulkImportJobCreateWithoutCreatedByUserInput, BulkImportJobUncheckedCreateWithoutCreatedByUserInput> | BulkImportJobCreateWithoutCreatedByUserInput[] | BulkImportJobUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: BulkImportJobCreateOrConnectWithoutCreatedByUserInput | BulkImportJobCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: BulkImportJobUpsertWithWhereUniqueWithoutCreatedByUserInput | BulkImportJobUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: BulkImportJobCreateManyCreatedByUserInputEnvelope
    set?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    disconnect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    delete?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    connect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    update?: BulkImportJobUpdateWithWhereUniqueWithoutCreatedByUserInput | BulkImportJobUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: BulkImportJobUpdateManyWithWhereWithoutCreatedByUserInput | BulkImportJobUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: BulkImportJobScalarWhereInput | BulkImportJobScalarWhereInput[]
  }

  export type FixItTaskUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<FixItTaskCreateWithoutAssignedToUserInput, FixItTaskUncheckedCreateWithoutAssignedToUserInput> | FixItTaskCreateWithoutAssignedToUserInput[] | FixItTaskUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutAssignedToUserInput | FixItTaskCreateOrConnectWithoutAssignedToUserInput[]
    upsert?: FixItTaskUpsertWithWhereUniqueWithoutAssignedToUserInput | FixItTaskUpsertWithWhereUniqueWithoutAssignedToUserInput[]
    createMany?: FixItTaskCreateManyAssignedToUserInputEnvelope
    set?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    disconnect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    delete?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    update?: FixItTaskUpdateWithWhereUniqueWithoutAssignedToUserInput | FixItTaskUpdateWithWhereUniqueWithoutAssignedToUserInput[]
    updateMany?: FixItTaskUpdateManyWithWhereWithoutAssignedToUserInput | FixItTaskUpdateManyWithWhereWithoutAssignedToUserInput[]
    deleteMany?: FixItTaskScalarWhereInput | FixItTaskScalarWhereInput[]
  }

  export type ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<ProcedureBookingCreateWithoutCreatedByUserInput, ProcedureBookingUncheckedCreateWithoutCreatedByUserInput> | ProcedureBookingCreateWithoutCreatedByUserInput[] | ProcedureBookingUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutCreatedByUserInput | ProcedureBookingCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: ProcedureBookingUpsertWithWhereUniqueWithoutCreatedByUserInput | ProcedureBookingUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: ProcedureBookingCreateManyCreatedByUserInputEnvelope
    set?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    disconnect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    delete?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    update?: ProcedureBookingUpdateWithWhereUniqueWithoutCreatedByUserInput | ProcedureBookingUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: ProcedureBookingUpdateManyWithWhereWithoutCreatedByUserInput | ProcedureBookingUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: ProcedureBookingScalarWhereInput | ProcedureBookingScalarWhereInput[]
  }

  export type GoLiveReportUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<GoLiveReportCreateWithoutCreatedByUserInput, GoLiveReportUncheckedCreateWithoutCreatedByUserInput> | GoLiveReportCreateWithoutCreatedByUserInput[] | GoLiveReportUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: GoLiveReportCreateOrConnectWithoutCreatedByUserInput | GoLiveReportCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: GoLiveReportUpsertWithWhereUniqueWithoutCreatedByUserInput | GoLiveReportUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: GoLiveReportCreateManyCreatedByUserInputEnvelope
    set?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    disconnect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    delete?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    connect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    update?: GoLiveReportUpdateWithWhereUniqueWithoutCreatedByUserInput | GoLiveReportUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: GoLiveReportUpdateManyWithWhereWithoutCreatedByUserInput | GoLiveReportUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: GoLiveReportScalarWhereInput | GoLiveReportScalarWhereInput[]
  }

  export type RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput> | RoleTemplateVersionCreateWithoutCreatedByUserInput[] | RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput | RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: RoleTemplateVersionUpsertWithWhereUniqueWithoutCreatedByUserInput | RoleTemplateVersionUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: RoleTemplateVersionCreateManyCreatedByUserInputEnvelope
    set?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    disconnect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    delete?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    update?: RoleTemplateVersionUpdateWithWhereUniqueWithoutCreatedByUserInput | RoleTemplateVersionUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: RoleTemplateVersionUpdateManyWithWhereWithoutCreatedByUserInput | RoleTemplateVersionUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
  }

  export type AuditEventUncheckedUpdateManyWithoutActorUserNestedInput = {
    create?: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput> | AuditEventCreateWithoutActorUserInput[] | AuditEventUncheckedCreateWithoutActorUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorUserInput | AuditEventCreateOrConnectWithoutActorUserInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutActorUserInput | AuditEventUpsertWithWhereUniqueWithoutActorUserInput[]
    createMany?: AuditEventCreateManyActorUserInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutActorUserInput | AuditEventUpdateWithWhereUniqueWithoutActorUserInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutActorUserInput | AuditEventUpdateManyWithWhereWithoutActorUserInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutCreatedByUserInput, PolicyVersionUncheckedCreateWithoutCreatedByUserInput> | PolicyVersionCreateWithoutCreatedByUserInput[] | PolicyVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutCreatedByUserInput | PolicyVersionCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutCreatedByUserInput | PolicyVersionUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: PolicyVersionCreateManyCreatedByUserInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutCreatedByUserInput | PolicyVersionUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutCreatedByUserInput | PolicyVersionUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutSubmittedByUserInput, PolicyVersionUncheckedCreateWithoutSubmittedByUserInput> | PolicyVersionCreateWithoutSubmittedByUserInput[] | PolicyVersionUncheckedCreateWithoutSubmittedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutSubmittedByUserInput | PolicyVersionCreateOrConnectWithoutSubmittedByUserInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutSubmittedByUserInput | PolicyVersionUpsertWithWhereUniqueWithoutSubmittedByUserInput[]
    createMany?: PolicyVersionCreateManySubmittedByUserInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutSubmittedByUserInput | PolicyVersionUpdateWithWhereUniqueWithoutSubmittedByUserInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutSubmittedByUserInput | PolicyVersionUpdateManyWithWhereWithoutSubmittedByUserInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutApprovedByUserInput, PolicyVersionUncheckedCreateWithoutApprovedByUserInput> | PolicyVersionCreateWithoutApprovedByUserInput[] | PolicyVersionUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutApprovedByUserInput | PolicyVersionCreateOrConnectWithoutApprovedByUserInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutApprovedByUserInput | PolicyVersionUpsertWithWhereUniqueWithoutApprovedByUserInput[]
    createMany?: PolicyVersionCreateManyApprovedByUserInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutApprovedByUserInput | PolicyVersionUpdateWithWhereUniqueWithoutApprovedByUserInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutApprovedByUserInput | PolicyVersionUpdateManyWithWhereWithoutApprovedByUserInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutRejectedByUserInput, PolicyVersionUncheckedCreateWithoutRejectedByUserInput> | PolicyVersionCreateWithoutRejectedByUserInput[] | PolicyVersionUncheckedCreateWithoutRejectedByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutRejectedByUserInput | PolicyVersionCreateOrConnectWithoutRejectedByUserInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutRejectedByUserInput | PolicyVersionUpsertWithWhereUniqueWithoutRejectedByUserInput[]
    createMany?: PolicyVersionCreateManyRejectedByUserInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutRejectedByUserInput | PolicyVersionUpdateWithWhereUniqueWithoutRejectedByUserInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutRejectedByUserInput | PolicyVersionUpdateManyWithWhereWithoutRejectedByUserInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutRetiredByUserInput, PolicyVersionUncheckedCreateWithoutRetiredByUserInput> | PolicyVersionCreateWithoutRetiredByUserInput[] | PolicyVersionUncheckedCreateWithoutRetiredByUserInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutRetiredByUserInput | PolicyVersionCreateOrConnectWithoutRetiredByUserInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutRetiredByUserInput | PolicyVersionUpsertWithWhereUniqueWithoutRetiredByUserInput[]
    createMany?: PolicyVersionCreateManyRetiredByUserInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutRetiredByUserInput | PolicyVersionUpdateWithWhereUniqueWithoutRetiredByUserInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutRetiredByUserInput | PolicyVersionUpdateManyWithWhereWithoutRetiredByUserInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<LocationNodeRevisionCreateWithoutCreatedByUserInput, LocationNodeRevisionUncheckedCreateWithoutCreatedByUserInput> | LocationNodeRevisionCreateWithoutCreatedByUserInput[] | LocationNodeRevisionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: LocationNodeRevisionCreateOrConnectWithoutCreatedByUserInput | LocationNodeRevisionCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: LocationNodeRevisionUpsertWithWhereUniqueWithoutCreatedByUserInput | LocationNodeRevisionUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: LocationNodeRevisionCreateManyCreatedByUserInputEnvelope
    set?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    disconnect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    delete?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    connect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    update?: LocationNodeRevisionUpdateWithWhereUniqueWithoutCreatedByUserInput | LocationNodeRevisionUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: LocationNodeRevisionUpdateManyWithWhereWithoutCreatedByUserInput | LocationNodeRevisionUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: LocationNodeRevisionScalarWhereInput | LocationNodeRevisionScalarWhereInput[]
  }

  export type BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<BulkImportJobCreateWithoutCreatedByUserInput, BulkImportJobUncheckedCreateWithoutCreatedByUserInput> | BulkImportJobCreateWithoutCreatedByUserInput[] | BulkImportJobUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: BulkImportJobCreateOrConnectWithoutCreatedByUserInput | BulkImportJobCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: BulkImportJobUpsertWithWhereUniqueWithoutCreatedByUserInput | BulkImportJobUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: BulkImportJobCreateManyCreatedByUserInputEnvelope
    set?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    disconnect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    delete?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    connect?: BulkImportJobWhereUniqueInput | BulkImportJobWhereUniqueInput[]
    update?: BulkImportJobUpdateWithWhereUniqueWithoutCreatedByUserInput | BulkImportJobUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: BulkImportJobUpdateManyWithWhereWithoutCreatedByUserInput | BulkImportJobUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: BulkImportJobScalarWhereInput | BulkImportJobScalarWhereInput[]
  }

  export type FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<FixItTaskCreateWithoutAssignedToUserInput, FixItTaskUncheckedCreateWithoutAssignedToUserInput> | FixItTaskCreateWithoutAssignedToUserInput[] | FixItTaskUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutAssignedToUserInput | FixItTaskCreateOrConnectWithoutAssignedToUserInput[]
    upsert?: FixItTaskUpsertWithWhereUniqueWithoutAssignedToUserInput | FixItTaskUpsertWithWhereUniqueWithoutAssignedToUserInput[]
    createMany?: FixItTaskCreateManyAssignedToUserInputEnvelope
    set?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    disconnect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    delete?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    update?: FixItTaskUpdateWithWhereUniqueWithoutAssignedToUserInput | FixItTaskUpdateWithWhereUniqueWithoutAssignedToUserInput[]
    updateMany?: FixItTaskUpdateManyWithWhereWithoutAssignedToUserInput | FixItTaskUpdateManyWithWhereWithoutAssignedToUserInput[]
    deleteMany?: FixItTaskScalarWhereInput | FixItTaskScalarWhereInput[]
  }

  export type ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<ProcedureBookingCreateWithoutCreatedByUserInput, ProcedureBookingUncheckedCreateWithoutCreatedByUserInput> | ProcedureBookingCreateWithoutCreatedByUserInput[] | ProcedureBookingUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutCreatedByUserInput | ProcedureBookingCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: ProcedureBookingUpsertWithWhereUniqueWithoutCreatedByUserInput | ProcedureBookingUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: ProcedureBookingCreateManyCreatedByUserInputEnvelope
    set?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    disconnect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    delete?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    update?: ProcedureBookingUpdateWithWhereUniqueWithoutCreatedByUserInput | ProcedureBookingUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: ProcedureBookingUpdateManyWithWhereWithoutCreatedByUserInput | ProcedureBookingUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: ProcedureBookingScalarWhereInput | ProcedureBookingScalarWhereInput[]
  }

  export type GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<GoLiveReportCreateWithoutCreatedByUserInput, GoLiveReportUncheckedCreateWithoutCreatedByUserInput> | GoLiveReportCreateWithoutCreatedByUserInput[] | GoLiveReportUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: GoLiveReportCreateOrConnectWithoutCreatedByUserInput | GoLiveReportCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: GoLiveReportUpsertWithWhereUniqueWithoutCreatedByUserInput | GoLiveReportUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: GoLiveReportCreateManyCreatedByUserInputEnvelope
    set?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    disconnect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    delete?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    connect?: GoLiveReportWhereUniqueInput | GoLiveReportWhereUniqueInput[]
    update?: GoLiveReportUpdateWithWhereUniqueWithoutCreatedByUserInput | GoLiveReportUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: GoLiveReportUpdateManyWithWhereWithoutCreatedByUserInput | GoLiveReportUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: GoLiveReportScalarWhereInput | GoLiveReportScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutPatientsInput = {
    create?: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPatientsInput
    connect?: BranchWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutPatientInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type AdmissionCreateNestedManyWithoutPatientInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type ConsentRecordCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput> | ConsentRecordCreateWithoutPatientInput[] | ConsentRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsentRecordCreateOrConnectWithoutPatientInput | ConsentRecordCreateOrConnectWithoutPatientInput[]
    createMany?: ConsentRecordCreateManyPatientInputEnvelope
    connect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
  }

  export type RtbfRequestCreateNestedManyWithoutPatientInput = {
    create?: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput> | RtbfRequestCreateWithoutPatientInput[] | RtbfRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RtbfRequestCreateOrConnectWithoutPatientInput | RtbfRequestCreateOrConnectWithoutPatientInput[]
    createMany?: RtbfRequestCreateManyPatientInputEnvelope
    connect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
  }

  export type StatutoryCaseCreateNestedManyWithoutPatientInput = {
    create?: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput> | StatutoryCaseCreateWithoutPatientInput[] | StatutoryCaseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutPatientInput | StatutoryCaseCreateOrConnectWithoutPatientInput[]
    createMany?: StatutoryCaseCreateManyPatientInputEnvelope
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type ConsentRecordUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput> | ConsentRecordCreateWithoutPatientInput[] | ConsentRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsentRecordCreateOrConnectWithoutPatientInput | ConsentRecordCreateOrConnectWithoutPatientInput[]
    createMany?: ConsentRecordCreateManyPatientInputEnvelope
    connect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
  }

  export type RtbfRequestUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput> | RtbfRequestCreateWithoutPatientInput[] | RtbfRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RtbfRequestCreateOrConnectWithoutPatientInput | RtbfRequestCreateOrConnectWithoutPatientInput[]
    createMany?: RtbfRequestCreateManyPatientInputEnvelope
    connect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
  }

  export type StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput> | StatutoryCaseCreateWithoutPatientInput[] | StatutoryCaseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutPatientInput | StatutoryCaseCreateOrConnectWithoutPatientInput[]
    createMany?: StatutoryCaseCreateManyPatientInputEnvelope
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPatientsInput
    upsert?: BranchUpsertWithoutPatientsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutPatientsInput, BranchUpdateWithoutPatientsInput>, BranchUncheckedUpdateWithoutPatientsInput>
  }

  export type EncounterUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientInput | EncounterUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientInput | EncounterUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientInput | EncounterUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type AdmissionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutPatientInput | AdmissionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutPatientInput | AdmissionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutPatientInput | AdmissionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type ConsentRecordUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput> | ConsentRecordCreateWithoutPatientInput[] | ConsentRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsentRecordCreateOrConnectWithoutPatientInput | ConsentRecordCreateOrConnectWithoutPatientInput[]
    upsert?: ConsentRecordUpsertWithWhereUniqueWithoutPatientInput | ConsentRecordUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsentRecordCreateManyPatientInputEnvelope
    set?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    disconnect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    delete?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    connect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    update?: ConsentRecordUpdateWithWhereUniqueWithoutPatientInput | ConsentRecordUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsentRecordUpdateManyWithWhereWithoutPatientInput | ConsentRecordUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsentRecordScalarWhereInput | ConsentRecordScalarWhereInput[]
  }

  export type RtbfRequestUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput> | RtbfRequestCreateWithoutPatientInput[] | RtbfRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RtbfRequestCreateOrConnectWithoutPatientInput | RtbfRequestCreateOrConnectWithoutPatientInput[]
    upsert?: RtbfRequestUpsertWithWhereUniqueWithoutPatientInput | RtbfRequestUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RtbfRequestCreateManyPatientInputEnvelope
    set?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    disconnect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    delete?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    connect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    update?: RtbfRequestUpdateWithWhereUniqueWithoutPatientInput | RtbfRequestUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RtbfRequestUpdateManyWithWhereWithoutPatientInput | RtbfRequestUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RtbfRequestScalarWhereInput | RtbfRequestScalarWhereInput[]
  }

  export type StatutoryCaseUpdateManyWithoutPatientNestedInput = {
    create?: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput> | StatutoryCaseCreateWithoutPatientInput[] | StatutoryCaseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutPatientInput | StatutoryCaseCreateOrConnectWithoutPatientInput[]
    upsert?: StatutoryCaseUpsertWithWhereUniqueWithoutPatientInput | StatutoryCaseUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: StatutoryCaseCreateManyPatientInputEnvelope
    set?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    disconnect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    delete?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    update?: StatutoryCaseUpdateWithWhereUniqueWithoutPatientInput | StatutoryCaseUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: StatutoryCaseUpdateManyWithWhereWithoutPatientInput | StatutoryCaseUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientInput | EncounterUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientInput | EncounterUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientInput | EncounterUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutPatientInput | AdmissionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutPatientInput | AdmissionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutPatientInput | AdmissionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput> | ConsentRecordCreateWithoutPatientInput[] | ConsentRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsentRecordCreateOrConnectWithoutPatientInput | ConsentRecordCreateOrConnectWithoutPatientInput[]
    upsert?: ConsentRecordUpsertWithWhereUniqueWithoutPatientInput | ConsentRecordUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsentRecordCreateManyPatientInputEnvelope
    set?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    disconnect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    delete?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    connect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    update?: ConsentRecordUpdateWithWhereUniqueWithoutPatientInput | ConsentRecordUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsentRecordUpdateManyWithWhereWithoutPatientInput | ConsentRecordUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsentRecordScalarWhereInput | ConsentRecordScalarWhereInput[]
  }

  export type RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput> | RtbfRequestCreateWithoutPatientInput[] | RtbfRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RtbfRequestCreateOrConnectWithoutPatientInput | RtbfRequestCreateOrConnectWithoutPatientInput[]
    upsert?: RtbfRequestUpsertWithWhereUniqueWithoutPatientInput | RtbfRequestUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RtbfRequestCreateManyPatientInputEnvelope
    set?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    disconnect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    delete?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    connect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    update?: RtbfRequestUpdateWithWhereUniqueWithoutPatientInput | RtbfRequestUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RtbfRequestUpdateManyWithWhereWithoutPatientInput | RtbfRequestUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RtbfRequestScalarWhereInput | RtbfRequestScalarWhereInput[]
  }

  export type StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput> | StatutoryCaseCreateWithoutPatientInput[] | StatutoryCaseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutPatientInput | StatutoryCaseCreateOrConnectWithoutPatientInput[]
    upsert?: StatutoryCaseUpsertWithWhereUniqueWithoutPatientInput | StatutoryCaseUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: StatutoryCaseCreateManyPatientInputEnvelope
    set?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    disconnect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    delete?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    update?: StatutoryCaseUpdateWithWhereUniqueWithoutPatientInput | StatutoryCaseUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: StatutoryCaseUpdateManyWithWhereWithoutPatientInput | StatutoryCaseUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutEncounterInput = {
    create?: XOR<BranchCreateWithoutEncounterInput, BranchUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEncounterInput
    connect?: BranchWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutEncountersInput = {
    create?: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEncountersInput
    connect?: PatientWhereUniqueInput
  }

  export type AdmissionCreateNestedManyWithoutEncounterInput = {
    create?: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput> | AdmissionCreateWithoutEncounterInput[] | AdmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutEncounterInput | AdmissionCreateOrConnectWithoutEncounterInput[]
    createMany?: AdmissionCreateManyEncounterInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput> | AdmissionCreateWithoutEncounterInput[] | AdmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutEncounterInput | AdmissionCreateOrConnectWithoutEncounterInput[]
    createMany?: AdmissionCreateManyEncounterInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type EnumEncounterTypeFieldUpdateOperationsInput = {
    set?: $Enums.EncounterType
  }

  export type BranchUpdateOneRequiredWithoutEncounterNestedInput = {
    create?: XOR<BranchCreateWithoutEncounterInput, BranchUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEncounterInput
    upsert?: BranchUpsertWithoutEncounterInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutEncounterInput, BranchUpdateWithoutEncounterInput>, BranchUncheckedUpdateWithoutEncounterInput>
  }

  export type PatientUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEncountersInput
    upsert?: PatientUpsertWithoutEncountersInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutEncountersInput, PatientUpdateWithoutEncountersInput>, PatientUncheckedUpdateWithoutEncountersInput>
  }

  export type AdmissionUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput> | AdmissionCreateWithoutEncounterInput[] | AdmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutEncounterInput | AdmissionCreateOrConnectWithoutEncounterInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutEncounterInput | AdmissionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: AdmissionCreateManyEncounterInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutEncounterInput | AdmissionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutEncounterInput | AdmissionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput> | AdmissionCreateWithoutEncounterInput[] | AdmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutEncounterInput | AdmissionCreateOrConnectWithoutEncounterInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutEncounterInput | AdmissionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: AdmissionCreateManyEncounterInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutEncounterInput | AdmissionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutEncounterInput | AdmissionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutWardsInput = {
    create?: XOR<BranchCreateWithoutWardsInput, BranchUncheckedCreateWithoutWardsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWardsInput
    connect?: BranchWhereUniqueInput
  }

  export type RoomCreateNestedManyWithoutWardInput = {
    create?: XOR<RoomCreateWithoutWardInput, RoomUncheckedCreateWithoutWardInput> | RoomCreateWithoutWardInput[] | RoomUncheckedCreateWithoutWardInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutWardInput | RoomCreateOrConnectWithoutWardInput[]
    createMany?: RoomCreateManyWardInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<RoomCreateWithoutWardInput, RoomUncheckedCreateWithoutWardInput> | RoomCreateWithoutWardInput[] | RoomUncheckedCreateWithoutWardInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutWardInput | RoomCreateOrConnectWithoutWardInput[]
    createMany?: RoomCreateManyWardInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutWardsNestedInput = {
    create?: XOR<BranchCreateWithoutWardsInput, BranchUncheckedCreateWithoutWardsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWardsInput
    upsert?: BranchUpsertWithoutWardsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutWardsInput, BranchUpdateWithoutWardsInput>, BranchUncheckedUpdateWithoutWardsInput>
  }

  export type RoomUpdateManyWithoutWardNestedInput = {
    create?: XOR<RoomCreateWithoutWardInput, RoomUncheckedCreateWithoutWardInput> | RoomCreateWithoutWardInput[] | RoomUncheckedCreateWithoutWardInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutWardInput | RoomCreateOrConnectWithoutWardInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutWardInput | RoomUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: RoomCreateManyWardInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutWardInput | RoomUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutWardInput | RoomUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<RoomCreateWithoutWardInput, RoomUncheckedCreateWithoutWardInput> | RoomCreateWithoutWardInput[] | RoomUncheckedCreateWithoutWardInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutWardInput | RoomCreateOrConnectWithoutWardInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutWardInput | RoomUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: RoomCreateManyWardInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutWardInput | RoomUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutWardInput | RoomUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutRoomsInput = {
    create?: XOR<BranchCreateWithoutRoomsInput, BranchUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutRoomsInput
    connect?: BranchWhereUniqueInput
  }

  export type WardCreateNestedOneWithoutRoomsInput = {
    create?: XOR<WardCreateWithoutRoomsInput, WardUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: WardCreateOrConnectWithoutRoomsInput
    connect?: WardWhereUniqueInput
  }

  export type BedCreateNestedManyWithoutRoomInput = {
    create?: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput> | BedCreateWithoutRoomInput[] | BedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BedCreateOrConnectWithoutRoomInput | BedCreateOrConnectWithoutRoomInput[]
    createMany?: BedCreateManyRoomInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type BedUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput> | BedCreateWithoutRoomInput[] | BedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BedCreateOrConnectWithoutRoomInput | BedCreateOrConnectWithoutRoomInput[]
    createMany?: BedCreateManyRoomInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<BranchCreateWithoutRoomsInput, BranchUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutRoomsInput
    upsert?: BranchUpsertWithoutRoomsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutRoomsInput, BranchUpdateWithoutRoomsInput>, BranchUncheckedUpdateWithoutRoomsInput>
  }

  export type WardUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<WardCreateWithoutRoomsInput, WardUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: WardCreateOrConnectWithoutRoomsInput
    upsert?: WardUpsertWithoutRoomsInput
    connect?: WardWhereUniqueInput
    update?: XOR<XOR<WardUpdateToOneWithWhereWithoutRoomsInput, WardUpdateWithoutRoomsInput>, WardUncheckedUpdateWithoutRoomsInput>
  }

  export type BedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput> | BedCreateWithoutRoomInput[] | BedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BedCreateOrConnectWithoutRoomInput | BedCreateOrConnectWithoutRoomInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutRoomInput | BedUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: BedCreateManyRoomInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutRoomInput | BedUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: BedUpdateManyWithWhereWithoutRoomInput | BedUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type BedUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput> | BedCreateWithoutRoomInput[] | BedUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BedCreateOrConnectWithoutRoomInput | BedCreateOrConnectWithoutRoomInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutRoomInput | BedUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: BedCreateManyRoomInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutRoomInput | BedUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: BedUpdateManyWithWhereWithoutRoomInput | BedUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutBedInput = {
    create?: XOR<BranchCreateWithoutBedInput, BranchUncheckedCreateWithoutBedInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBedInput
    connect?: BranchWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutBedsInput = {
    create?: XOR<RoomCreateWithoutBedsInput, RoomUncheckedCreateWithoutBedsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutBedsInput
    connect?: RoomWhereUniqueInput
  }

  export type AdmissionCreateNestedManyWithoutBedInput = {
    create?: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput> | AdmissionCreateWithoutBedInput[] | AdmissionUncheckedCreateWithoutBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBedInput | AdmissionCreateOrConnectWithoutBedInput[]
    createMany?: AdmissionCreateManyBedInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutBedInput = {
    create?: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput> | AdmissionCreateWithoutBedInput[] | AdmissionUncheckedCreateWithoutBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBedInput | AdmissionCreateOrConnectWithoutBedInput[]
    createMany?: AdmissionCreateManyBedInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type EnumBedStateFieldUpdateOperationsInput = {
    set?: $Enums.BedState
  }

  export type BranchUpdateOneRequiredWithoutBedNestedInput = {
    create?: XOR<BranchCreateWithoutBedInput, BranchUncheckedCreateWithoutBedInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBedInput
    upsert?: BranchUpsertWithoutBedInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutBedInput, BranchUpdateWithoutBedInput>, BranchUncheckedUpdateWithoutBedInput>
  }

  export type RoomUpdateOneRequiredWithoutBedsNestedInput = {
    create?: XOR<RoomCreateWithoutBedsInput, RoomUncheckedCreateWithoutBedsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutBedsInput
    upsert?: RoomUpsertWithoutBedsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutBedsInput, RoomUpdateWithoutBedsInput>, RoomUncheckedUpdateWithoutBedsInput>
  }

  export type AdmissionUpdateManyWithoutBedNestedInput = {
    create?: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput> | AdmissionCreateWithoutBedInput[] | AdmissionUncheckedCreateWithoutBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBedInput | AdmissionCreateOrConnectWithoutBedInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutBedInput | AdmissionUpsertWithWhereUniqueWithoutBedInput[]
    createMany?: AdmissionCreateManyBedInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutBedInput | AdmissionUpdateWithWhereUniqueWithoutBedInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutBedInput | AdmissionUpdateManyWithWhereWithoutBedInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutBedNestedInput = {
    create?: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput> | AdmissionCreateWithoutBedInput[] | AdmissionUncheckedCreateWithoutBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBedInput | AdmissionCreateOrConnectWithoutBedInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutBedInput | AdmissionUpsertWithWhereUniqueWithoutBedInput[]
    createMany?: AdmissionCreateManyBedInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutBedInput | AdmissionUpdateWithWhereUniqueWithoutBedInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutBedInput | AdmissionUpdateManyWithWhereWithoutBedInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutAdmissionInput = {
    create?: XOR<BranchCreateWithoutAdmissionInput, BranchUncheckedCreateWithoutAdmissionInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAdmissionInput
    connect?: BranchWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<EncounterCreateWithoutAdmissionsInput, EncounterUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutAdmissionsInput
    connect?: EncounterWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutAdmissionInput = {
    create?: XOR<PatientCreateWithoutAdmissionInput, PatientUncheckedCreateWithoutAdmissionInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAdmissionInput
    connect?: PatientWhereUniqueInput
  }

  export type BedCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<BedCreateWithoutAdmissionsInput, BedUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: BedCreateOrConnectWithoutAdmissionsInput
    connect?: BedWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutAdmissionNestedInput = {
    create?: XOR<BranchCreateWithoutAdmissionInput, BranchUncheckedCreateWithoutAdmissionInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAdmissionInput
    upsert?: BranchUpsertWithoutAdmissionInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAdmissionInput, BranchUpdateWithoutAdmissionInput>, BranchUncheckedUpdateWithoutAdmissionInput>
  }

  export type EncounterUpdateOneWithoutAdmissionsNestedInput = {
    create?: XOR<EncounterCreateWithoutAdmissionsInput, EncounterUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutAdmissionsInput
    upsert?: EncounterUpsertWithoutAdmissionsInput
    disconnect?: EncounterWhereInput | boolean
    delete?: EncounterWhereInput | boolean
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutAdmissionsInput, EncounterUpdateWithoutAdmissionsInput>, EncounterUncheckedUpdateWithoutAdmissionsInput>
  }

  export type PatientUpdateOneRequiredWithoutAdmissionNestedInput = {
    create?: XOR<PatientCreateWithoutAdmissionInput, PatientUncheckedCreateWithoutAdmissionInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAdmissionInput
    upsert?: PatientUpsertWithoutAdmissionInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAdmissionInput, PatientUpdateWithoutAdmissionInput>, PatientUncheckedUpdateWithoutAdmissionInput>
  }

  export type BedUpdateOneWithoutAdmissionsNestedInput = {
    create?: XOR<BedCreateWithoutAdmissionsInput, BedUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: BedCreateOrConnectWithoutAdmissionsInput
    upsert?: BedUpsertWithoutAdmissionsInput
    disconnect?: BedWhereInput | boolean
    delete?: BedWhereInput | boolean
    connect?: BedWhereUniqueInput
    update?: XOR<XOR<BedUpdateToOneWithWhereWithoutAdmissionsInput, BedUpdateWithoutAdmissionsInput>, BedUncheckedUpdateWithoutAdmissionsInput>
  }

  export type BranchCreateNestedOneWithoutOTsInput = {
    create?: XOR<BranchCreateWithoutOTsInput, BranchUncheckedCreateWithoutOTsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutOTsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutOTsNestedInput = {
    create?: XOR<BranchCreateWithoutOTsInput, BranchUncheckedCreateWithoutOTsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutOTsInput
    upsert?: BranchUpsertWithoutOTsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutOTsInput, BranchUpdateWithoutOTsInput>, BranchUncheckedUpdateWithoutOTsInput>
  }

  export type BranchCreateNestedOneWithoutAssetsInput = {
    create?: XOR<BranchCreateWithoutAssetsInput, BranchUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAssetsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<BranchCreateWithoutAssetsInput, BranchUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAssetsInput
    upsert?: BranchUpsertWithoutAssetsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAssetsInput, BranchUpdateWithoutAssetsInput>, BranchUncheckedUpdateWithoutAssetsInput>
  }

  export type BranchCreateNestedOneWithoutTariffPlansInput = {
    create?: XOR<BranchCreateWithoutTariffPlansInput, BranchUncheckedCreateWithoutTariffPlansInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTariffPlansInput
    connect?: BranchWhereUniqueInput
  }

  export type TariffRateCreateNestedManyWithoutTariffPlanInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
  }

  export type TariffRateUncheckedCreateNestedManyWithoutTariffPlanInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutTariffPlansNestedInput = {
    create?: XOR<BranchCreateWithoutTariffPlansInput, BranchUncheckedCreateWithoutTariffPlansInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTariffPlansInput
    upsert?: BranchUpsertWithoutTariffPlansInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutTariffPlansInput, BranchUpdateWithoutTariffPlansInput>, BranchUncheckedUpdateWithoutTariffPlansInput>
  }

  export type TariffRateUpdateManyWithoutTariffPlanNestedInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    upsert?: TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput | TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    set?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    disconnect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    delete?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    update?: TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput | TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput[]
    updateMany?: TariffRateUpdateManyWithWhereWithoutTariffPlanInput | TariffRateUpdateManyWithWhereWithoutTariffPlanInput[]
    deleteMany?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
  }

  export type TariffRateUncheckedUpdateManyWithoutTariffPlanNestedInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    upsert?: TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput | TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    set?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    disconnect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    delete?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    update?: TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput | TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput[]
    updateMany?: TariffRateUpdateManyWithWhereWithoutTariffPlanInput | TariffRateUpdateManyWithWhereWithoutTariffPlanInput[]
    deleteMany?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
  }

  export type TariffPlanCreateNestedOneWithoutRatesInput = {
    create?: XOR<TariffPlanCreateWithoutRatesInput, TariffPlanUncheckedCreateWithoutRatesInput>
    connectOrCreate?: TariffPlanCreateOrConnectWithoutRatesInput
    connect?: TariffPlanWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TariffPlanUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<TariffPlanCreateWithoutRatesInput, TariffPlanUncheckedCreateWithoutRatesInput>
    connectOrCreate?: TariffPlanCreateOrConnectWithoutRatesInput
    upsert?: TariffPlanUpsertWithoutRatesInput
    connect?: TariffPlanWhereUniqueInput
    update?: XOR<XOR<TariffPlanUpdateToOneWithWhereWithoutRatesInput, TariffPlanUpdateWithoutRatesInput>, TariffPlanUncheckedUpdateWithoutRatesInput>
  }

  export type PatientCreateNestedOneWithoutConsentRecordsInput = {
    create?: XOR<PatientCreateWithoutConsentRecordsInput, PatientUncheckedCreateWithoutConsentRecordsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsentRecordsInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumConsentScopeFieldUpdateOperationsInput = {
    set?: $Enums.ConsentScope
  }

  export type EnumConsentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConsentStatus
  }

  export type PatientUpdateOneRequiredWithoutConsentRecordsNestedInput = {
    create?: XOR<PatientCreateWithoutConsentRecordsInput, PatientUncheckedCreateWithoutConsentRecordsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsentRecordsInput
    upsert?: PatientUpsertWithoutConsentRecordsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutConsentRecordsInput, PatientUpdateWithoutConsentRecordsInput>, PatientUncheckedUpdateWithoutConsentRecordsInput>
  }

  export type PatientCreateNestedOneWithoutRtbfRequestsInput = {
    create?: XOR<PatientCreateWithoutRtbfRequestsInput, PatientUncheckedCreateWithoutRtbfRequestsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRtbfRequestsInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumRtbfStatusFieldUpdateOperationsInput = {
    set?: $Enums.RtbfStatus
  }

  export type PatientUpdateOneRequiredWithoutRtbfRequestsNestedInput = {
    create?: XOR<PatientCreateWithoutRtbfRequestsInput, PatientUncheckedCreateWithoutRtbfRequestsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRtbfRequestsInput
    upsert?: PatientUpsertWithoutRtbfRequestsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutRtbfRequestsInput, PatientUpdateWithoutRtbfRequestsInput>, PatientUncheckedUpdateWithoutRtbfRequestsInput>
  }

  export type BranchCreateNestedOneWithoutStatutoryCasesInput = {
    create?: XOR<BranchCreateWithoutStatutoryCasesInput, BranchUncheckedCreateWithoutStatutoryCasesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStatutoryCasesInput
    connect?: BranchWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutStatutoryCasesInput = {
    create?: XOR<PatientCreateWithoutStatutoryCasesInput, PatientUncheckedCreateWithoutStatutoryCasesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutStatutoryCasesInput
    connect?: PatientWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutStatutoryCasesNestedInput = {
    create?: XOR<BranchCreateWithoutStatutoryCasesInput, BranchUncheckedCreateWithoutStatutoryCasesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStatutoryCasesInput
    upsert?: BranchUpsertWithoutStatutoryCasesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutStatutoryCasesInput, BranchUpdateWithoutStatutoryCasesInput>, BranchUncheckedUpdateWithoutStatutoryCasesInput>
  }

  export type PatientUpdateOneRequiredWithoutStatutoryCasesNestedInput = {
    create?: XOR<PatientCreateWithoutStatutoryCasesInput, PatientUncheckedCreateWithoutStatutoryCasesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutStatutoryCasesInput
    upsert?: PatientUpsertWithoutStatutoryCasesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutStatutoryCasesInput, PatientUpdateWithoutStatutoryCasesInput>, PatientUncheckedUpdateWithoutStatutoryCasesInput>
  }

  export type BranchCreateNestedOneWithoutAuditEventsInput = {
    create?: XOR<BranchCreateWithoutAuditEventsInput, BranchUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAuditEventsInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditEventsAsActorInput = {
    create?: XOR<UserCreateWithoutAuditEventsAsActorInput, UserUncheckedCreateWithoutAuditEventsAsActorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditEventsAsActorInput
    connect?: UserWhereUniqueInput
  }

  export type BranchUpdateOneWithoutAuditEventsNestedInput = {
    create?: XOR<BranchCreateWithoutAuditEventsInput, BranchUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAuditEventsInput
    upsert?: BranchUpsertWithoutAuditEventsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAuditEventsInput, BranchUpdateWithoutAuditEventsInput>, BranchUncheckedUpdateWithoutAuditEventsInput>
  }

  export type UserUpdateOneWithoutAuditEventsAsActorNestedInput = {
    create?: XOR<UserCreateWithoutAuditEventsAsActorInput, UserUncheckedCreateWithoutAuditEventsAsActorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditEventsAsActorInput
    upsert?: UserUpsertWithoutAuditEventsAsActorInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditEventsAsActorInput, UserUpdateWithoutAuditEventsAsActorInput>, UserUncheckedUpdateWithoutAuditEventsAsActorInput>
  }

  export type EnumOutboxStatusFieldUpdateOperationsInput = {
    set?: $Enums.OutboxStatus
  }

  export type RoleTemplatePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput> | RoleTemplatePermissionCreateWithoutPermissionInput[] | RoleTemplatePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutPermissionInput | RoleTemplatePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RoleTemplatePermissionCreateManyPermissionInputEnvelope
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
  }

  export type RoleTemplatePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput> | RoleTemplatePermissionCreateWithoutPermissionInput[] | RoleTemplatePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutPermissionInput | RoleTemplatePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RoleTemplatePermissionCreateManyPermissionInputEnvelope
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
  }

  export type RoleTemplatePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput> | RoleTemplatePermissionCreateWithoutPermissionInput[] | RoleTemplatePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutPermissionInput | RoleTemplatePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RoleTemplatePermissionUpsertWithWhereUniqueWithoutPermissionInput | RoleTemplatePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RoleTemplatePermissionCreateManyPermissionInputEnvelope
    set?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    disconnect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    delete?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    update?: RoleTemplatePermissionUpdateWithWhereUniqueWithoutPermissionInput | RoleTemplatePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RoleTemplatePermissionUpdateManyWithWhereWithoutPermissionInput | RoleTemplatePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
  }

  export type RoleTemplatePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput> | RoleTemplatePermissionCreateWithoutPermissionInput[] | RoleTemplatePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutPermissionInput | RoleTemplatePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RoleTemplatePermissionUpsertWithWhereUniqueWithoutPermissionInput | RoleTemplatePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RoleTemplatePermissionCreateManyPermissionInputEnvelope
    set?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    disconnect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    delete?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    update?: RoleTemplatePermissionUpdateWithWhereUniqueWithoutPermissionInput | RoleTemplatePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RoleTemplatePermissionUpdateManyWithWhereWithoutPermissionInput | RoleTemplatePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
  }

  export type RoleTemplateVersionCreateNestedManyWithoutRoleTemplateInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput> | RoleTemplateVersionCreateWithoutRoleTemplateInput[] | RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput | RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput[]
    createMany?: RoleTemplateVersionCreateManyRoleTemplateInputEnvelope
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
  }

  export type RoleTemplateVersionUncheckedCreateNestedManyWithoutRoleTemplateInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput> | RoleTemplateVersionCreateWithoutRoleTemplateInput[] | RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput | RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput[]
    createMany?: RoleTemplateVersionCreateManyRoleTemplateInputEnvelope
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
  }

  export type EnumRoleScopeFieldUpdateOperationsInput = {
    set?: $Enums.RoleScope
  }

  export type RoleTemplateVersionUpdateManyWithoutRoleTemplateNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput> | RoleTemplateVersionCreateWithoutRoleTemplateInput[] | RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput | RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput[]
    upsert?: RoleTemplateVersionUpsertWithWhereUniqueWithoutRoleTemplateInput | RoleTemplateVersionUpsertWithWhereUniqueWithoutRoleTemplateInput[]
    createMany?: RoleTemplateVersionCreateManyRoleTemplateInputEnvelope
    set?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    disconnect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    delete?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    update?: RoleTemplateVersionUpdateWithWhereUniqueWithoutRoleTemplateInput | RoleTemplateVersionUpdateWithWhereUniqueWithoutRoleTemplateInput[]
    updateMany?: RoleTemplateVersionUpdateManyWithWhereWithoutRoleTemplateInput | RoleTemplateVersionUpdateManyWithWhereWithoutRoleTemplateInput[]
    deleteMany?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
  }

  export type RoleTemplateVersionUncheckedUpdateManyWithoutRoleTemplateNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput> | RoleTemplateVersionCreateWithoutRoleTemplateInput[] | RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput | RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput[]
    upsert?: RoleTemplateVersionUpsertWithWhereUniqueWithoutRoleTemplateInput | RoleTemplateVersionUpsertWithWhereUniqueWithoutRoleTemplateInput[]
    createMany?: RoleTemplateVersionCreateManyRoleTemplateInputEnvelope
    set?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    disconnect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    delete?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    update?: RoleTemplateVersionUpdateWithWhereUniqueWithoutRoleTemplateInput | RoleTemplateVersionUpdateWithWhereUniqueWithoutRoleTemplateInput[]
    updateMany?: RoleTemplateVersionUpdateManyWithWhereWithoutRoleTemplateInput | RoleTemplateVersionUpdateManyWithWhereWithoutRoleTemplateInput[]
    deleteMany?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
  }

  export type RoleTemplateCreateNestedOneWithoutVersionsInput = {
    create?: XOR<RoleTemplateCreateWithoutVersionsInput, RoleTemplateUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: RoleTemplateCreateOrConnectWithoutVersionsInput
    connect?: RoleTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedRoleVersionsInput = {
    create?: XOR<UserCreateWithoutCreatedRoleVersionsInput, UserUncheckedCreateWithoutCreatedRoleVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRoleVersionsInput
    connect?: UserWhereUniqueInput
  }

  export type RoleTemplatePermissionCreateNestedManyWithoutRoleVersionInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput> | RoleTemplatePermissionCreateWithoutRoleVersionInput[] | RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput | RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput[]
    createMany?: RoleTemplatePermissionCreateManyRoleVersionInputEnvelope
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRoleVersionInput = {
    create?: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput> | UserCreateWithoutRoleVersionInput[] | UserUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleVersionInput | UserCreateOrConnectWithoutRoleVersionInput[]
    createMany?: UserCreateManyRoleVersionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleTemplatePermissionUncheckedCreateNestedManyWithoutRoleVersionInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput> | RoleTemplatePermissionCreateWithoutRoleVersionInput[] | RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput | RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput[]
    createMany?: RoleTemplatePermissionCreateManyRoleVersionInputEnvelope
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleVersionInput = {
    create?: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput> | UserCreateWithoutRoleVersionInput[] | UserUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleVersionInput | UserCreateOrConnectWithoutRoleVersionInput[]
    createMany?: UserCreateManyRoleVersionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EnumRoleVersionStatusFieldUpdateOperationsInput = {
    set?: $Enums.RoleVersionStatus
  }

  export type RoleTemplateUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<RoleTemplateCreateWithoutVersionsInput, RoleTemplateUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: RoleTemplateCreateOrConnectWithoutVersionsInput
    upsert?: RoleTemplateUpsertWithoutVersionsInput
    connect?: RoleTemplateWhereUniqueInput
    update?: XOR<XOR<RoleTemplateUpdateToOneWithWhereWithoutVersionsInput, RoleTemplateUpdateWithoutVersionsInput>, RoleTemplateUncheckedUpdateWithoutVersionsInput>
  }

  export type UserUpdateOneWithoutCreatedRoleVersionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedRoleVersionsInput, UserUncheckedCreateWithoutCreatedRoleVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRoleVersionsInput
    upsert?: UserUpsertWithoutCreatedRoleVersionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedRoleVersionsInput, UserUpdateWithoutCreatedRoleVersionsInput>, UserUncheckedUpdateWithoutCreatedRoleVersionsInput>
  }

  export type RoleTemplatePermissionUpdateManyWithoutRoleVersionNestedInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput> | RoleTemplatePermissionCreateWithoutRoleVersionInput[] | RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput | RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput[]
    upsert?: RoleTemplatePermissionUpsertWithWhereUniqueWithoutRoleVersionInput | RoleTemplatePermissionUpsertWithWhereUniqueWithoutRoleVersionInput[]
    createMany?: RoleTemplatePermissionCreateManyRoleVersionInputEnvelope
    set?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    disconnect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    delete?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    update?: RoleTemplatePermissionUpdateWithWhereUniqueWithoutRoleVersionInput | RoleTemplatePermissionUpdateWithWhereUniqueWithoutRoleVersionInput[]
    updateMany?: RoleTemplatePermissionUpdateManyWithWhereWithoutRoleVersionInput | RoleTemplatePermissionUpdateManyWithWhereWithoutRoleVersionInput[]
    deleteMany?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRoleVersionNestedInput = {
    create?: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput> | UserCreateWithoutRoleVersionInput[] | UserUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleVersionInput | UserCreateOrConnectWithoutRoleVersionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleVersionInput | UserUpsertWithWhereUniqueWithoutRoleVersionInput[]
    createMany?: UserCreateManyRoleVersionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleVersionInput | UserUpdateWithWhereUniqueWithoutRoleVersionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleVersionInput | UserUpdateManyWithWhereWithoutRoleVersionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionNestedInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput> | RoleTemplatePermissionCreateWithoutRoleVersionInput[] | RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput | RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput[]
    upsert?: RoleTemplatePermissionUpsertWithWhereUniqueWithoutRoleVersionInput | RoleTemplatePermissionUpsertWithWhereUniqueWithoutRoleVersionInput[]
    createMany?: RoleTemplatePermissionCreateManyRoleVersionInputEnvelope
    set?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    disconnect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    delete?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    update?: RoleTemplatePermissionUpdateWithWhereUniqueWithoutRoleVersionInput | RoleTemplatePermissionUpdateWithWhereUniqueWithoutRoleVersionInput[]
    updateMany?: RoleTemplatePermissionUpdateManyWithWhereWithoutRoleVersionInput | RoleTemplatePermissionUpdateManyWithWhereWithoutRoleVersionInput[]
    deleteMany?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleVersionNestedInput = {
    create?: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput> | UserCreateWithoutRoleVersionInput[] | UserUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleVersionInput | UserCreateOrConnectWithoutRoleVersionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleVersionInput | UserUpsertWithWhereUniqueWithoutRoleVersionInput[]
    createMany?: UserCreateManyRoleVersionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleVersionInput | UserUpdateWithWhereUniqueWithoutRoleVersionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleVersionInput | UserUpdateManyWithWhereWithoutRoleVersionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleTemplateVersionCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutPermissionsInput, RoleTemplateVersionUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutPermissionsInput
    connect?: RoleTemplateVersionWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRoleGrantsInput = {
    create?: XOR<PermissionCreateWithoutRoleGrantsInput, PermissionUncheckedCreateWithoutRoleGrantsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleGrantsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleTemplateVersionUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutPermissionsInput, RoleTemplateVersionUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutPermissionsInput
    upsert?: RoleTemplateVersionUpsertWithoutPermissionsInput
    connect?: RoleTemplateVersionWhereUniqueInput
    update?: XOR<XOR<RoleTemplateVersionUpdateToOneWithWhereWithoutPermissionsInput, RoleTemplateVersionUpdateWithoutPermissionsInput>, RoleTemplateVersionUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRoleGrantsNestedInput = {
    create?: XOR<PermissionCreateWithoutRoleGrantsInput, PermissionUncheckedCreateWithoutRoleGrantsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleGrantsInput
    upsert?: PermissionUpsertWithoutRoleGrantsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRoleGrantsInput, PermissionUpdateWithoutRoleGrantsInput>, PermissionUncheckedUpdateWithoutRoleGrantsInput>
  }

  export type PolicyVersionCreateNestedManyWithoutPolicyInput = {
    create?: XOR<PolicyVersionCreateWithoutPolicyInput, PolicyVersionUncheckedCreateWithoutPolicyInput> | PolicyVersionCreateWithoutPolicyInput[] | PolicyVersionUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutPolicyInput | PolicyVersionCreateOrConnectWithoutPolicyInput[]
    createMany?: PolicyVersionCreateManyPolicyInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionUncheckedCreateNestedManyWithoutPolicyInput = {
    create?: XOR<PolicyVersionCreateWithoutPolicyInput, PolicyVersionUncheckedCreateWithoutPolicyInput> | PolicyVersionCreateWithoutPolicyInput[] | PolicyVersionUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutPolicyInput | PolicyVersionCreateOrConnectWithoutPolicyInput[]
    createMany?: PolicyVersionCreateManyPolicyInputEnvelope
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
  }

  export type PolicyVersionUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutPolicyInput, PolicyVersionUncheckedCreateWithoutPolicyInput> | PolicyVersionCreateWithoutPolicyInput[] | PolicyVersionUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutPolicyInput | PolicyVersionCreateOrConnectWithoutPolicyInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutPolicyInput | PolicyVersionUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: PolicyVersionCreateManyPolicyInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutPolicyInput | PolicyVersionUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutPolicyInput | PolicyVersionUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyVersionUncheckedUpdateManyWithoutPolicyNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutPolicyInput, PolicyVersionUncheckedCreateWithoutPolicyInput> | PolicyVersionCreateWithoutPolicyInput[] | PolicyVersionUncheckedCreateWithoutPolicyInput[]
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutPolicyInput | PolicyVersionCreateOrConnectWithoutPolicyInput[]
    upsert?: PolicyVersionUpsertWithWhereUniqueWithoutPolicyInput | PolicyVersionUpsertWithWhereUniqueWithoutPolicyInput[]
    createMany?: PolicyVersionCreateManyPolicyInputEnvelope
    set?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    disconnect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    delete?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    connect?: PolicyVersionWhereUniqueInput | PolicyVersionWhereUniqueInput[]
    update?: PolicyVersionUpdateWithWhereUniqueWithoutPolicyInput | PolicyVersionUpdateWithWhereUniqueWithoutPolicyInput[]
    updateMany?: PolicyVersionUpdateManyWithWhereWithoutPolicyInput | PolicyVersionUpdateManyWithWhereWithoutPolicyInput[]
    deleteMany?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
  }

  export type PolicyDefinitionCreateNestedOneWithoutVersionsInput = {
    create?: XOR<PolicyDefinitionCreateWithoutVersionsInput, PolicyDefinitionUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: PolicyDefinitionCreateOrConnectWithoutVersionsInput
    connect?: PolicyDefinitionWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutPolicyVersionsInput = {
    create?: XOR<BranchCreateWithoutPolicyVersionsInput, BranchUncheckedCreateWithoutPolicyVersionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPolicyVersionsInput
    connect?: BranchWhereUniqueInput
  }

  export type PolicyVersionBranchCreateNestedManyWithoutPolicyVersionInput = {
    create?: XOR<PolicyVersionBranchCreateWithoutPolicyVersionInput, PolicyVersionBranchUncheckedCreateWithoutPolicyVersionInput> | PolicyVersionBranchCreateWithoutPolicyVersionInput[] | PolicyVersionBranchUncheckedCreateWithoutPolicyVersionInput[]
    connectOrCreate?: PolicyVersionBranchCreateOrConnectWithoutPolicyVersionInput | PolicyVersionBranchCreateOrConnectWithoutPolicyVersionInput[]
    createMany?: PolicyVersionBranchCreateManyPolicyVersionInputEnvelope
    connect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPolicyVersionsCreatedByInput = {
    create?: XOR<UserCreateWithoutPolicyVersionsCreatedByInput, UserUncheckedCreateWithoutPolicyVersionsCreatedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutPolicyVersionsCreatedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPolicyVersionsSubmittedByInput = {
    create?: XOR<UserCreateWithoutPolicyVersionsSubmittedByInput, UserUncheckedCreateWithoutPolicyVersionsSubmittedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutPolicyVersionsSubmittedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPolicyVersionsApprovedByInput = {
    create?: XOR<UserCreateWithoutPolicyVersionsApprovedByInput, UserUncheckedCreateWithoutPolicyVersionsApprovedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutPolicyVersionsApprovedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPolicyVersionsRejectedByInput = {
    create?: XOR<UserCreateWithoutPolicyVersionsRejectedByInput, UserUncheckedCreateWithoutPolicyVersionsRejectedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutPolicyVersionsRejectedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPolicyVersionsRetiredByInput = {
    create?: XOR<UserCreateWithoutPolicyVersionsRetiredByInput, UserUncheckedCreateWithoutPolicyVersionsRetiredByInput>
    connectOrCreate?: UserCreateOrConnectWithoutPolicyVersionsRetiredByInput
    connect?: UserWhereUniqueInput
  }

  export type PolicyVersionBranchUncheckedCreateNestedManyWithoutPolicyVersionInput = {
    create?: XOR<PolicyVersionBranchCreateWithoutPolicyVersionInput, PolicyVersionBranchUncheckedCreateWithoutPolicyVersionInput> | PolicyVersionBranchCreateWithoutPolicyVersionInput[] | PolicyVersionBranchUncheckedCreateWithoutPolicyVersionInput[]
    connectOrCreate?: PolicyVersionBranchCreateOrConnectWithoutPolicyVersionInput | PolicyVersionBranchCreateOrConnectWithoutPolicyVersionInput[]
    createMany?: PolicyVersionBranchCreateManyPolicyVersionInputEnvelope
    connect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
  }

  export type EnumPolicyScopeFieldUpdateOperationsInput = {
    set?: $Enums.PolicyScope
  }

  export type EnumPolicyVersionStatusFieldUpdateOperationsInput = {
    set?: $Enums.PolicyVersionStatus
  }

  export type PolicyDefinitionUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<PolicyDefinitionCreateWithoutVersionsInput, PolicyDefinitionUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: PolicyDefinitionCreateOrConnectWithoutVersionsInput
    upsert?: PolicyDefinitionUpsertWithoutVersionsInput
    connect?: PolicyDefinitionWhereUniqueInput
    update?: XOR<XOR<PolicyDefinitionUpdateToOneWithWhereWithoutVersionsInput, PolicyDefinitionUpdateWithoutVersionsInput>, PolicyDefinitionUncheckedUpdateWithoutVersionsInput>
  }

  export type BranchUpdateOneWithoutPolicyVersionsNestedInput = {
    create?: XOR<BranchCreateWithoutPolicyVersionsInput, BranchUncheckedCreateWithoutPolicyVersionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPolicyVersionsInput
    upsert?: BranchUpsertWithoutPolicyVersionsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutPolicyVersionsInput, BranchUpdateWithoutPolicyVersionsInput>, BranchUncheckedUpdateWithoutPolicyVersionsInput>
  }

  export type PolicyVersionBranchUpdateManyWithoutPolicyVersionNestedInput = {
    create?: XOR<PolicyVersionBranchCreateWithoutPolicyVersionInput, PolicyVersionBranchUncheckedCreateWithoutPolicyVersionInput> | PolicyVersionBranchCreateWithoutPolicyVersionInput[] | PolicyVersionBranchUncheckedCreateWithoutPolicyVersionInput[]
    connectOrCreate?: PolicyVersionBranchCreateOrConnectWithoutPolicyVersionInput | PolicyVersionBranchCreateOrConnectWithoutPolicyVersionInput[]
    upsert?: PolicyVersionBranchUpsertWithWhereUniqueWithoutPolicyVersionInput | PolicyVersionBranchUpsertWithWhereUniqueWithoutPolicyVersionInput[]
    createMany?: PolicyVersionBranchCreateManyPolicyVersionInputEnvelope
    set?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    disconnect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    delete?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    connect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    update?: PolicyVersionBranchUpdateWithWhereUniqueWithoutPolicyVersionInput | PolicyVersionBranchUpdateWithWhereUniqueWithoutPolicyVersionInput[]
    updateMany?: PolicyVersionBranchUpdateManyWithWhereWithoutPolicyVersionInput | PolicyVersionBranchUpdateManyWithWhereWithoutPolicyVersionInput[]
    deleteMany?: PolicyVersionBranchScalarWhereInput | PolicyVersionBranchScalarWhereInput[]
  }

  export type UserUpdateOneWithoutPolicyVersionsCreatedByNestedInput = {
    create?: XOR<UserCreateWithoutPolicyVersionsCreatedByInput, UserUncheckedCreateWithoutPolicyVersionsCreatedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutPolicyVersionsCreatedByInput
    upsert?: UserUpsertWithoutPolicyVersionsCreatedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPolicyVersionsCreatedByInput, UserUpdateWithoutPolicyVersionsCreatedByInput>, UserUncheckedUpdateWithoutPolicyVersionsCreatedByInput>
  }

  export type UserUpdateOneWithoutPolicyVersionsSubmittedByNestedInput = {
    create?: XOR<UserCreateWithoutPolicyVersionsSubmittedByInput, UserUncheckedCreateWithoutPolicyVersionsSubmittedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutPolicyVersionsSubmittedByInput
    upsert?: UserUpsertWithoutPolicyVersionsSubmittedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPolicyVersionsSubmittedByInput, UserUpdateWithoutPolicyVersionsSubmittedByInput>, UserUncheckedUpdateWithoutPolicyVersionsSubmittedByInput>
  }

  export type UserUpdateOneWithoutPolicyVersionsApprovedByNestedInput = {
    create?: XOR<UserCreateWithoutPolicyVersionsApprovedByInput, UserUncheckedCreateWithoutPolicyVersionsApprovedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutPolicyVersionsApprovedByInput
    upsert?: UserUpsertWithoutPolicyVersionsApprovedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPolicyVersionsApprovedByInput, UserUpdateWithoutPolicyVersionsApprovedByInput>, UserUncheckedUpdateWithoutPolicyVersionsApprovedByInput>
  }

  export type UserUpdateOneWithoutPolicyVersionsRejectedByNestedInput = {
    create?: XOR<UserCreateWithoutPolicyVersionsRejectedByInput, UserUncheckedCreateWithoutPolicyVersionsRejectedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutPolicyVersionsRejectedByInput
    upsert?: UserUpsertWithoutPolicyVersionsRejectedByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPolicyVersionsRejectedByInput, UserUpdateWithoutPolicyVersionsRejectedByInput>, UserUncheckedUpdateWithoutPolicyVersionsRejectedByInput>
  }

  export type UserUpdateOneWithoutPolicyVersionsRetiredByNestedInput = {
    create?: XOR<UserCreateWithoutPolicyVersionsRetiredByInput, UserUncheckedCreateWithoutPolicyVersionsRetiredByInput>
    connectOrCreate?: UserCreateOrConnectWithoutPolicyVersionsRetiredByInput
    upsert?: UserUpsertWithoutPolicyVersionsRetiredByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPolicyVersionsRetiredByInput, UserUpdateWithoutPolicyVersionsRetiredByInput>, UserUncheckedUpdateWithoutPolicyVersionsRetiredByInput>
  }

  export type PolicyVersionBranchUncheckedUpdateManyWithoutPolicyVersionNestedInput = {
    create?: XOR<PolicyVersionBranchCreateWithoutPolicyVersionInput, PolicyVersionBranchUncheckedCreateWithoutPolicyVersionInput> | PolicyVersionBranchCreateWithoutPolicyVersionInput[] | PolicyVersionBranchUncheckedCreateWithoutPolicyVersionInput[]
    connectOrCreate?: PolicyVersionBranchCreateOrConnectWithoutPolicyVersionInput | PolicyVersionBranchCreateOrConnectWithoutPolicyVersionInput[]
    upsert?: PolicyVersionBranchUpsertWithWhereUniqueWithoutPolicyVersionInput | PolicyVersionBranchUpsertWithWhereUniqueWithoutPolicyVersionInput[]
    createMany?: PolicyVersionBranchCreateManyPolicyVersionInputEnvelope
    set?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    disconnect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    delete?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    connect?: PolicyVersionBranchWhereUniqueInput | PolicyVersionBranchWhereUniqueInput[]
    update?: PolicyVersionBranchUpdateWithWhereUniqueWithoutPolicyVersionInput | PolicyVersionBranchUpdateWithWhereUniqueWithoutPolicyVersionInput[]
    updateMany?: PolicyVersionBranchUpdateManyWithWhereWithoutPolicyVersionInput | PolicyVersionBranchUpdateManyWithWhereWithoutPolicyVersionInput[]
    deleteMany?: PolicyVersionBranchScalarWhereInput | PolicyVersionBranchScalarWhereInput[]
  }

  export type PolicyVersionCreateNestedOneWithoutBranchesInput = {
    create?: XOR<PolicyVersionCreateWithoutBranchesInput, PolicyVersionUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutBranchesInput
    connect?: PolicyVersionWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutPolicyVersionBranchesInput = {
    create?: XOR<BranchCreateWithoutPolicyVersionBranchesInput, BranchUncheckedCreateWithoutPolicyVersionBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPolicyVersionBranchesInput
    connect?: BranchWhereUniqueInput
  }

  export type PolicyVersionUpdateOneRequiredWithoutBranchesNestedInput = {
    create?: XOR<PolicyVersionCreateWithoutBranchesInput, PolicyVersionUncheckedCreateWithoutBranchesInput>
    connectOrCreate?: PolicyVersionCreateOrConnectWithoutBranchesInput
    upsert?: PolicyVersionUpsertWithoutBranchesInput
    connect?: PolicyVersionWhereUniqueInput
    update?: XOR<XOR<PolicyVersionUpdateToOneWithWhereWithoutBranchesInput, PolicyVersionUpdateWithoutBranchesInput>, PolicyVersionUncheckedUpdateWithoutBranchesInput>
  }

  export type BranchUpdateOneRequiredWithoutPolicyVersionBranchesNestedInput = {
    create?: XOR<BranchCreateWithoutPolicyVersionBranchesInput, BranchUncheckedCreateWithoutPolicyVersionBranchesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPolicyVersionBranchesInput
    upsert?: BranchUpsertWithoutPolicyVersionBranchesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutPolicyVersionBranchesInput, BranchUpdateWithoutPolicyVersionBranchesInput>, BranchUncheckedUpdateWithoutPolicyVersionBranchesInput>
  }

  export type BranchCreateNestedOneWithoutLocationNodesInput = {
    create?: XOR<BranchCreateWithoutLocationNodesInput, BranchUncheckedCreateWithoutLocationNodesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutLocationNodesInput
    connect?: BranchWhereUniqueInput
  }

  export type LocationNodeCreateNestedOneWithoutChildrenInput = {
    create?: XOR<LocationNodeCreateWithoutChildrenInput, LocationNodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: LocationNodeCreateOrConnectWithoutChildrenInput
    connect?: LocationNodeWhereUniqueInput
  }

  export type LocationNodeCreateNestedManyWithoutParentInput = {
    create?: XOR<LocationNodeCreateWithoutParentInput, LocationNodeUncheckedCreateWithoutParentInput> | LocationNodeCreateWithoutParentInput[] | LocationNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LocationNodeCreateOrConnectWithoutParentInput | LocationNodeCreateOrConnectWithoutParentInput[]
    createMany?: LocationNodeCreateManyParentInputEnvelope
    connect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
  }

  export type LocationNodeRevisionCreateNestedManyWithoutNodeInput = {
    create?: XOR<LocationNodeRevisionCreateWithoutNodeInput, LocationNodeRevisionUncheckedCreateWithoutNodeInput> | LocationNodeRevisionCreateWithoutNodeInput[] | LocationNodeRevisionUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: LocationNodeRevisionCreateOrConnectWithoutNodeInput | LocationNodeRevisionCreateOrConnectWithoutNodeInput[]
    createMany?: LocationNodeRevisionCreateManyNodeInputEnvelope
    connect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
  }

  export type EquipmentAssetCreateNestedManyWithoutLocationNodeInput = {
    create?: XOR<EquipmentAssetCreateWithoutLocationNodeInput, EquipmentAssetUncheckedCreateWithoutLocationNodeInput> | EquipmentAssetCreateWithoutLocationNodeInput[] | EquipmentAssetUncheckedCreateWithoutLocationNodeInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutLocationNodeInput | EquipmentAssetCreateOrConnectWithoutLocationNodeInput[]
    createMany?: EquipmentAssetCreateManyLocationNodeInputEnvelope
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
  }

  export type LocationNodeUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<LocationNodeCreateWithoutParentInput, LocationNodeUncheckedCreateWithoutParentInput> | LocationNodeCreateWithoutParentInput[] | LocationNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LocationNodeCreateOrConnectWithoutParentInput | LocationNodeCreateOrConnectWithoutParentInput[]
    createMany?: LocationNodeCreateManyParentInputEnvelope
    connect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
  }

  export type LocationNodeRevisionUncheckedCreateNestedManyWithoutNodeInput = {
    create?: XOR<LocationNodeRevisionCreateWithoutNodeInput, LocationNodeRevisionUncheckedCreateWithoutNodeInput> | LocationNodeRevisionCreateWithoutNodeInput[] | LocationNodeRevisionUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: LocationNodeRevisionCreateOrConnectWithoutNodeInput | LocationNodeRevisionCreateOrConnectWithoutNodeInput[]
    createMany?: LocationNodeRevisionCreateManyNodeInputEnvelope
    connect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
  }

  export type EquipmentAssetUncheckedCreateNestedManyWithoutLocationNodeInput = {
    create?: XOR<EquipmentAssetCreateWithoutLocationNodeInput, EquipmentAssetUncheckedCreateWithoutLocationNodeInput> | EquipmentAssetCreateWithoutLocationNodeInput[] | EquipmentAssetUncheckedCreateWithoutLocationNodeInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutLocationNodeInput | EquipmentAssetCreateOrConnectWithoutLocationNodeInput[]
    createMany?: EquipmentAssetCreateManyLocationNodeInputEnvelope
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
  }

  export type EnumLocationKindFieldUpdateOperationsInput = {
    set?: $Enums.LocationKind
  }

  export type BranchUpdateOneRequiredWithoutLocationNodesNestedInput = {
    create?: XOR<BranchCreateWithoutLocationNodesInput, BranchUncheckedCreateWithoutLocationNodesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutLocationNodesInput
    upsert?: BranchUpsertWithoutLocationNodesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutLocationNodesInput, BranchUpdateWithoutLocationNodesInput>, BranchUncheckedUpdateWithoutLocationNodesInput>
  }

  export type LocationNodeUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<LocationNodeCreateWithoutChildrenInput, LocationNodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: LocationNodeCreateOrConnectWithoutChildrenInput
    upsert?: LocationNodeUpsertWithoutChildrenInput
    disconnect?: LocationNodeWhereInput | boolean
    delete?: LocationNodeWhereInput | boolean
    connect?: LocationNodeWhereUniqueInput
    update?: XOR<XOR<LocationNodeUpdateToOneWithWhereWithoutChildrenInput, LocationNodeUpdateWithoutChildrenInput>, LocationNodeUncheckedUpdateWithoutChildrenInput>
  }

  export type LocationNodeUpdateManyWithoutParentNestedInput = {
    create?: XOR<LocationNodeCreateWithoutParentInput, LocationNodeUncheckedCreateWithoutParentInput> | LocationNodeCreateWithoutParentInput[] | LocationNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LocationNodeCreateOrConnectWithoutParentInput | LocationNodeCreateOrConnectWithoutParentInput[]
    upsert?: LocationNodeUpsertWithWhereUniqueWithoutParentInput | LocationNodeUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LocationNodeCreateManyParentInputEnvelope
    set?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    disconnect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    delete?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    connect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    update?: LocationNodeUpdateWithWhereUniqueWithoutParentInput | LocationNodeUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LocationNodeUpdateManyWithWhereWithoutParentInput | LocationNodeUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LocationNodeScalarWhereInput | LocationNodeScalarWhereInput[]
  }

  export type LocationNodeRevisionUpdateManyWithoutNodeNestedInput = {
    create?: XOR<LocationNodeRevisionCreateWithoutNodeInput, LocationNodeRevisionUncheckedCreateWithoutNodeInput> | LocationNodeRevisionCreateWithoutNodeInput[] | LocationNodeRevisionUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: LocationNodeRevisionCreateOrConnectWithoutNodeInput | LocationNodeRevisionCreateOrConnectWithoutNodeInput[]
    upsert?: LocationNodeRevisionUpsertWithWhereUniqueWithoutNodeInput | LocationNodeRevisionUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: LocationNodeRevisionCreateManyNodeInputEnvelope
    set?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    disconnect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    delete?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    connect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    update?: LocationNodeRevisionUpdateWithWhereUniqueWithoutNodeInput | LocationNodeRevisionUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: LocationNodeRevisionUpdateManyWithWhereWithoutNodeInput | LocationNodeRevisionUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: LocationNodeRevisionScalarWhereInput | LocationNodeRevisionScalarWhereInput[]
  }

  export type EquipmentAssetUpdateManyWithoutLocationNodeNestedInput = {
    create?: XOR<EquipmentAssetCreateWithoutLocationNodeInput, EquipmentAssetUncheckedCreateWithoutLocationNodeInput> | EquipmentAssetCreateWithoutLocationNodeInput[] | EquipmentAssetUncheckedCreateWithoutLocationNodeInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutLocationNodeInput | EquipmentAssetCreateOrConnectWithoutLocationNodeInput[]
    upsert?: EquipmentAssetUpsertWithWhereUniqueWithoutLocationNodeInput | EquipmentAssetUpsertWithWhereUniqueWithoutLocationNodeInput[]
    createMany?: EquipmentAssetCreateManyLocationNodeInputEnvelope
    set?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    disconnect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    delete?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    update?: EquipmentAssetUpdateWithWhereUniqueWithoutLocationNodeInput | EquipmentAssetUpdateWithWhereUniqueWithoutLocationNodeInput[]
    updateMany?: EquipmentAssetUpdateManyWithWhereWithoutLocationNodeInput | EquipmentAssetUpdateManyWithWhereWithoutLocationNodeInput[]
    deleteMany?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
  }

  export type LocationNodeUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<LocationNodeCreateWithoutParentInput, LocationNodeUncheckedCreateWithoutParentInput> | LocationNodeCreateWithoutParentInput[] | LocationNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LocationNodeCreateOrConnectWithoutParentInput | LocationNodeCreateOrConnectWithoutParentInput[]
    upsert?: LocationNodeUpsertWithWhereUniqueWithoutParentInput | LocationNodeUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LocationNodeCreateManyParentInputEnvelope
    set?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    disconnect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    delete?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    connect?: LocationNodeWhereUniqueInput | LocationNodeWhereUniqueInput[]
    update?: LocationNodeUpdateWithWhereUniqueWithoutParentInput | LocationNodeUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LocationNodeUpdateManyWithWhereWithoutParentInput | LocationNodeUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LocationNodeScalarWhereInput | LocationNodeScalarWhereInput[]
  }

  export type LocationNodeRevisionUncheckedUpdateManyWithoutNodeNestedInput = {
    create?: XOR<LocationNodeRevisionCreateWithoutNodeInput, LocationNodeRevisionUncheckedCreateWithoutNodeInput> | LocationNodeRevisionCreateWithoutNodeInput[] | LocationNodeRevisionUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: LocationNodeRevisionCreateOrConnectWithoutNodeInput | LocationNodeRevisionCreateOrConnectWithoutNodeInput[]
    upsert?: LocationNodeRevisionUpsertWithWhereUniqueWithoutNodeInput | LocationNodeRevisionUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: LocationNodeRevisionCreateManyNodeInputEnvelope
    set?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    disconnect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    delete?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    connect?: LocationNodeRevisionWhereUniqueInput | LocationNodeRevisionWhereUniqueInput[]
    update?: LocationNodeRevisionUpdateWithWhereUniqueWithoutNodeInput | LocationNodeRevisionUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: LocationNodeRevisionUpdateManyWithWhereWithoutNodeInput | LocationNodeRevisionUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: LocationNodeRevisionScalarWhereInput | LocationNodeRevisionScalarWhereInput[]
  }

  export type EquipmentAssetUncheckedUpdateManyWithoutLocationNodeNestedInput = {
    create?: XOR<EquipmentAssetCreateWithoutLocationNodeInput, EquipmentAssetUncheckedCreateWithoutLocationNodeInput> | EquipmentAssetCreateWithoutLocationNodeInput[] | EquipmentAssetUncheckedCreateWithoutLocationNodeInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutLocationNodeInput | EquipmentAssetCreateOrConnectWithoutLocationNodeInput[]
    upsert?: EquipmentAssetUpsertWithWhereUniqueWithoutLocationNodeInput | EquipmentAssetUpsertWithWhereUniqueWithoutLocationNodeInput[]
    createMany?: EquipmentAssetCreateManyLocationNodeInputEnvelope
    set?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    disconnect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    delete?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    update?: EquipmentAssetUpdateWithWhereUniqueWithoutLocationNodeInput | EquipmentAssetUpdateWithWhereUniqueWithoutLocationNodeInput[]
    updateMany?: EquipmentAssetUpdateManyWithWhereWithoutLocationNodeInput | EquipmentAssetUpdateManyWithWhereWithoutLocationNodeInput[]
    deleteMany?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
  }

  export type LocationNodeCreateNestedOneWithoutRevisionsInput = {
    create?: XOR<LocationNodeCreateWithoutRevisionsInput, LocationNodeUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: LocationNodeCreateOrConnectWithoutRevisionsInput
    connect?: LocationNodeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedLocationRevisionsInput = {
    create?: XOR<UserCreateWithoutCreatedLocationRevisionsInput, UserUncheckedCreateWithoutCreatedLocationRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLocationRevisionsInput
    connect?: UserWhereUniqueInput
  }

  export type LocationNodeUpdateOneRequiredWithoutRevisionsNestedInput = {
    create?: XOR<LocationNodeCreateWithoutRevisionsInput, LocationNodeUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: LocationNodeCreateOrConnectWithoutRevisionsInput
    upsert?: LocationNodeUpsertWithoutRevisionsInput
    connect?: LocationNodeWhereUniqueInput
    update?: XOR<XOR<LocationNodeUpdateToOneWithWhereWithoutRevisionsInput, LocationNodeUpdateWithoutRevisionsInput>, LocationNodeUncheckedUpdateWithoutRevisionsInput>
  }

  export type UserUpdateOneWithoutCreatedLocationRevisionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedLocationRevisionsInput, UserUncheckedCreateWithoutCreatedLocationRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLocationRevisionsInput
    upsert?: UserUpsertWithoutCreatedLocationRevisionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedLocationRevisionsInput, UserUpdateWithoutCreatedLocationRevisionsInput>, UserUncheckedUpdateWithoutCreatedLocationRevisionsInput>
  }

  export type BranchUnitTypeCreateNestedManyWithoutUnitTypeInput = {
    create?: XOR<BranchUnitTypeCreateWithoutUnitTypeInput, BranchUnitTypeUncheckedCreateWithoutUnitTypeInput> | BranchUnitTypeCreateWithoutUnitTypeInput[] | BranchUnitTypeUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: BranchUnitTypeCreateOrConnectWithoutUnitTypeInput | BranchUnitTypeCreateOrConnectWithoutUnitTypeInput[]
    createMany?: BranchUnitTypeCreateManyUnitTypeInputEnvelope
    connect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutUnitTypeInput = {
    create?: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput> | UnitCreateWithoutUnitTypeInput[] | UnitUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutUnitTypeInput | UnitCreateOrConnectWithoutUnitTypeInput[]
    createMany?: UnitCreateManyUnitTypeInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type BranchUnitTypeUncheckedCreateNestedManyWithoutUnitTypeInput = {
    create?: XOR<BranchUnitTypeCreateWithoutUnitTypeInput, BranchUnitTypeUncheckedCreateWithoutUnitTypeInput> | BranchUnitTypeCreateWithoutUnitTypeInput[] | BranchUnitTypeUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: BranchUnitTypeCreateOrConnectWithoutUnitTypeInput | BranchUnitTypeCreateOrConnectWithoutUnitTypeInput[]
    createMany?: BranchUnitTypeCreateManyUnitTypeInputEnvelope
    connect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutUnitTypeInput = {
    create?: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput> | UnitCreateWithoutUnitTypeInput[] | UnitUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutUnitTypeInput | UnitCreateOrConnectWithoutUnitTypeInput[]
    createMany?: UnitCreateManyUnitTypeInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type BranchUnitTypeUpdateManyWithoutUnitTypeNestedInput = {
    create?: XOR<BranchUnitTypeCreateWithoutUnitTypeInput, BranchUnitTypeUncheckedCreateWithoutUnitTypeInput> | BranchUnitTypeCreateWithoutUnitTypeInput[] | BranchUnitTypeUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: BranchUnitTypeCreateOrConnectWithoutUnitTypeInput | BranchUnitTypeCreateOrConnectWithoutUnitTypeInput[]
    upsert?: BranchUnitTypeUpsertWithWhereUniqueWithoutUnitTypeInput | BranchUnitTypeUpsertWithWhereUniqueWithoutUnitTypeInput[]
    createMany?: BranchUnitTypeCreateManyUnitTypeInputEnvelope
    set?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    disconnect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    delete?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    connect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    update?: BranchUnitTypeUpdateWithWhereUniqueWithoutUnitTypeInput | BranchUnitTypeUpdateWithWhereUniqueWithoutUnitTypeInput[]
    updateMany?: BranchUnitTypeUpdateManyWithWhereWithoutUnitTypeInput | BranchUnitTypeUpdateManyWithWhereWithoutUnitTypeInput[]
    deleteMany?: BranchUnitTypeScalarWhereInput | BranchUnitTypeScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutUnitTypeNestedInput = {
    create?: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput> | UnitCreateWithoutUnitTypeInput[] | UnitUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutUnitTypeInput | UnitCreateOrConnectWithoutUnitTypeInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutUnitTypeInput | UnitUpsertWithWhereUniqueWithoutUnitTypeInput[]
    createMany?: UnitCreateManyUnitTypeInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutUnitTypeInput | UnitUpdateWithWhereUniqueWithoutUnitTypeInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutUnitTypeInput | UnitUpdateManyWithWhereWithoutUnitTypeInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type BranchUnitTypeUncheckedUpdateManyWithoutUnitTypeNestedInput = {
    create?: XOR<BranchUnitTypeCreateWithoutUnitTypeInput, BranchUnitTypeUncheckedCreateWithoutUnitTypeInput> | BranchUnitTypeCreateWithoutUnitTypeInput[] | BranchUnitTypeUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: BranchUnitTypeCreateOrConnectWithoutUnitTypeInput | BranchUnitTypeCreateOrConnectWithoutUnitTypeInput[]
    upsert?: BranchUnitTypeUpsertWithWhereUniqueWithoutUnitTypeInput | BranchUnitTypeUpsertWithWhereUniqueWithoutUnitTypeInput[]
    createMany?: BranchUnitTypeCreateManyUnitTypeInputEnvelope
    set?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    disconnect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    delete?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    connect?: BranchUnitTypeWhereUniqueInput | BranchUnitTypeWhereUniqueInput[]
    update?: BranchUnitTypeUpdateWithWhereUniqueWithoutUnitTypeInput | BranchUnitTypeUpdateWithWhereUniqueWithoutUnitTypeInput[]
    updateMany?: BranchUnitTypeUpdateManyWithWhereWithoutUnitTypeInput | BranchUnitTypeUpdateManyWithWhereWithoutUnitTypeInput[]
    deleteMany?: BranchUnitTypeScalarWhereInput | BranchUnitTypeScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutUnitTypeNestedInput = {
    create?: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput> | UnitCreateWithoutUnitTypeInput[] | UnitUncheckedCreateWithoutUnitTypeInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutUnitTypeInput | UnitCreateOrConnectWithoutUnitTypeInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutUnitTypeInput | UnitUpsertWithWhereUniqueWithoutUnitTypeInput[]
    createMany?: UnitCreateManyUnitTypeInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutUnitTypeInput | UnitUpdateWithWhereUniqueWithoutUnitTypeInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutUnitTypeInput | UnitUpdateManyWithWhereWithoutUnitTypeInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutUnitTypesEnabledInput = {
    create?: XOR<BranchCreateWithoutUnitTypesEnabledInput, BranchUncheckedCreateWithoutUnitTypesEnabledInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUnitTypesEnabledInput
    connect?: BranchWhereUniqueInput
  }

  export type UnitTypeCatalogCreateNestedOneWithoutBranchLinksInput = {
    create?: XOR<UnitTypeCatalogCreateWithoutBranchLinksInput, UnitTypeCatalogUncheckedCreateWithoutBranchLinksInput>
    connectOrCreate?: UnitTypeCatalogCreateOrConnectWithoutBranchLinksInput
    connect?: UnitTypeCatalogWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutUnitTypesEnabledNestedInput = {
    create?: XOR<BranchCreateWithoutUnitTypesEnabledInput, BranchUncheckedCreateWithoutUnitTypesEnabledInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUnitTypesEnabledInput
    upsert?: BranchUpsertWithoutUnitTypesEnabledInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUnitTypesEnabledInput, BranchUpdateWithoutUnitTypesEnabledInput>, BranchUncheckedUpdateWithoutUnitTypesEnabledInput>
  }

  export type UnitTypeCatalogUpdateOneRequiredWithoutBranchLinksNestedInput = {
    create?: XOR<UnitTypeCatalogCreateWithoutBranchLinksInput, UnitTypeCatalogUncheckedCreateWithoutBranchLinksInput>
    connectOrCreate?: UnitTypeCatalogCreateOrConnectWithoutBranchLinksInput
    upsert?: UnitTypeCatalogUpsertWithoutBranchLinksInput
    connect?: UnitTypeCatalogWhereUniqueInput
    update?: XOR<XOR<UnitTypeCatalogUpdateToOneWithWhereWithoutBranchLinksInput, UnitTypeCatalogUpdateWithoutBranchLinksInput>, UnitTypeCatalogUncheckedUpdateWithoutBranchLinksInput>
  }

  export type BranchCreateNestedOneWithoutUnitsInput = {
    create?: XOR<BranchCreateWithoutUnitsInput, BranchUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUnitsInput
    connect?: BranchWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutUnitsInput = {
    create?: XOR<DepartmentCreateWithoutUnitsInput, DepartmentUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUnitsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UnitTypeCatalogCreateNestedOneWithoutUnitsInput = {
    create?: XOR<UnitTypeCatalogCreateWithoutUnitsInput, UnitTypeCatalogUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: UnitTypeCatalogCreateOrConnectWithoutUnitsInput
    connect?: UnitTypeCatalogWhereUniqueInput
  }

  export type UnitRoomCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitRoomCreateWithoutUnitInput, UnitRoomUncheckedCreateWithoutUnitInput> | UnitRoomCreateWithoutUnitInput[] | UnitRoomUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitRoomCreateOrConnectWithoutUnitInput | UnitRoomCreateOrConnectWithoutUnitInput[]
    createMany?: UnitRoomCreateManyUnitInputEnvelope
    connect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
  }

  export type UnitResourceCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitResourceCreateWithoutUnitInput, UnitResourceUncheckedCreateWithoutUnitInput> | UnitResourceCreateWithoutUnitInput[] | UnitResourceUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutUnitInput | UnitResourceCreateOrConnectWithoutUnitInput[]
    createMany?: UnitResourceCreateManyUnitInputEnvelope
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
  }

  export type EquipmentAssetCreateNestedManyWithoutUnitInput = {
    create?: XOR<EquipmentAssetCreateWithoutUnitInput, EquipmentAssetUncheckedCreateWithoutUnitInput> | EquipmentAssetCreateWithoutUnitInput[] | EquipmentAssetUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutUnitInput | EquipmentAssetCreateOrConnectWithoutUnitInput[]
    createMany?: EquipmentAssetCreateManyUnitInputEnvelope
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
  }

  export type ProcedureBookingCreateNestedManyWithoutUnitInput = {
    create?: XOR<ProcedureBookingCreateWithoutUnitInput, ProcedureBookingUncheckedCreateWithoutUnitInput> | ProcedureBookingCreateWithoutUnitInput[] | ProcedureBookingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutUnitInput | ProcedureBookingCreateOrConnectWithoutUnitInput[]
    createMany?: ProcedureBookingCreateManyUnitInputEnvelope
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
  }

  export type UnitRoomUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitRoomCreateWithoutUnitInput, UnitRoomUncheckedCreateWithoutUnitInput> | UnitRoomCreateWithoutUnitInput[] | UnitRoomUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitRoomCreateOrConnectWithoutUnitInput | UnitRoomCreateOrConnectWithoutUnitInput[]
    createMany?: UnitRoomCreateManyUnitInputEnvelope
    connect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
  }

  export type UnitResourceUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitResourceCreateWithoutUnitInput, UnitResourceUncheckedCreateWithoutUnitInput> | UnitResourceCreateWithoutUnitInput[] | UnitResourceUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutUnitInput | UnitResourceCreateOrConnectWithoutUnitInput[]
    createMany?: UnitResourceCreateManyUnitInputEnvelope
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
  }

  export type EquipmentAssetUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<EquipmentAssetCreateWithoutUnitInput, EquipmentAssetUncheckedCreateWithoutUnitInput> | EquipmentAssetCreateWithoutUnitInput[] | EquipmentAssetUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutUnitInput | EquipmentAssetCreateOrConnectWithoutUnitInput[]
    createMany?: EquipmentAssetCreateManyUnitInputEnvelope
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
  }

  export type ProcedureBookingUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ProcedureBookingCreateWithoutUnitInput, ProcedureBookingUncheckedCreateWithoutUnitInput> | ProcedureBookingCreateWithoutUnitInput[] | ProcedureBookingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutUnitInput | ProcedureBookingCreateOrConnectWithoutUnitInput[]
    createMany?: ProcedureBookingCreateManyUnitInputEnvelope
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<BranchCreateWithoutUnitsInput, BranchUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUnitsInput
    upsert?: BranchUpsertWithoutUnitsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUnitsInput, BranchUpdateWithoutUnitsInput>, BranchUncheckedUpdateWithoutUnitsInput>
  }

  export type DepartmentUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<DepartmentCreateWithoutUnitsInput, DepartmentUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUnitsInput
    upsert?: DepartmentUpsertWithoutUnitsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutUnitsInput, DepartmentUpdateWithoutUnitsInput>, DepartmentUncheckedUpdateWithoutUnitsInput>
  }

  export type UnitTypeCatalogUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<UnitTypeCatalogCreateWithoutUnitsInput, UnitTypeCatalogUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: UnitTypeCatalogCreateOrConnectWithoutUnitsInput
    upsert?: UnitTypeCatalogUpsertWithoutUnitsInput
    connect?: UnitTypeCatalogWhereUniqueInput
    update?: XOR<XOR<UnitTypeCatalogUpdateToOneWithWhereWithoutUnitsInput, UnitTypeCatalogUpdateWithoutUnitsInput>, UnitTypeCatalogUncheckedUpdateWithoutUnitsInput>
  }

  export type UnitRoomUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitRoomCreateWithoutUnitInput, UnitRoomUncheckedCreateWithoutUnitInput> | UnitRoomCreateWithoutUnitInput[] | UnitRoomUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitRoomCreateOrConnectWithoutUnitInput | UnitRoomCreateOrConnectWithoutUnitInput[]
    upsert?: UnitRoomUpsertWithWhereUniqueWithoutUnitInput | UnitRoomUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitRoomCreateManyUnitInputEnvelope
    set?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    disconnect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    delete?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    connect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    update?: UnitRoomUpdateWithWhereUniqueWithoutUnitInput | UnitRoomUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitRoomUpdateManyWithWhereWithoutUnitInput | UnitRoomUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitRoomScalarWhereInput | UnitRoomScalarWhereInput[]
  }

  export type UnitResourceUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitResourceCreateWithoutUnitInput, UnitResourceUncheckedCreateWithoutUnitInput> | UnitResourceCreateWithoutUnitInput[] | UnitResourceUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutUnitInput | UnitResourceCreateOrConnectWithoutUnitInput[]
    upsert?: UnitResourceUpsertWithWhereUniqueWithoutUnitInput | UnitResourceUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitResourceCreateManyUnitInputEnvelope
    set?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    disconnect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    delete?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    update?: UnitResourceUpdateWithWhereUniqueWithoutUnitInput | UnitResourceUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitResourceUpdateManyWithWhereWithoutUnitInput | UnitResourceUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitResourceScalarWhereInput | UnitResourceScalarWhereInput[]
  }

  export type EquipmentAssetUpdateManyWithoutUnitNestedInput = {
    create?: XOR<EquipmentAssetCreateWithoutUnitInput, EquipmentAssetUncheckedCreateWithoutUnitInput> | EquipmentAssetCreateWithoutUnitInput[] | EquipmentAssetUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutUnitInput | EquipmentAssetCreateOrConnectWithoutUnitInput[]
    upsert?: EquipmentAssetUpsertWithWhereUniqueWithoutUnitInput | EquipmentAssetUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: EquipmentAssetCreateManyUnitInputEnvelope
    set?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    disconnect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    delete?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    update?: EquipmentAssetUpdateWithWhereUniqueWithoutUnitInput | EquipmentAssetUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: EquipmentAssetUpdateManyWithWhereWithoutUnitInput | EquipmentAssetUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
  }

  export type ProcedureBookingUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ProcedureBookingCreateWithoutUnitInput, ProcedureBookingUncheckedCreateWithoutUnitInput> | ProcedureBookingCreateWithoutUnitInput[] | ProcedureBookingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutUnitInput | ProcedureBookingCreateOrConnectWithoutUnitInput[]
    upsert?: ProcedureBookingUpsertWithWhereUniqueWithoutUnitInput | ProcedureBookingUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ProcedureBookingCreateManyUnitInputEnvelope
    set?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    disconnect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    delete?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    update?: ProcedureBookingUpdateWithWhereUniqueWithoutUnitInput | ProcedureBookingUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ProcedureBookingUpdateManyWithWhereWithoutUnitInput | ProcedureBookingUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ProcedureBookingScalarWhereInput | ProcedureBookingScalarWhereInput[]
  }

  export type UnitRoomUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitRoomCreateWithoutUnitInput, UnitRoomUncheckedCreateWithoutUnitInput> | UnitRoomCreateWithoutUnitInput[] | UnitRoomUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitRoomCreateOrConnectWithoutUnitInput | UnitRoomCreateOrConnectWithoutUnitInput[]
    upsert?: UnitRoomUpsertWithWhereUniqueWithoutUnitInput | UnitRoomUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitRoomCreateManyUnitInputEnvelope
    set?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    disconnect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    delete?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    connect?: UnitRoomWhereUniqueInput | UnitRoomWhereUniqueInput[]
    update?: UnitRoomUpdateWithWhereUniqueWithoutUnitInput | UnitRoomUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitRoomUpdateManyWithWhereWithoutUnitInput | UnitRoomUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitRoomScalarWhereInput | UnitRoomScalarWhereInput[]
  }

  export type UnitResourceUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitResourceCreateWithoutUnitInput, UnitResourceUncheckedCreateWithoutUnitInput> | UnitResourceCreateWithoutUnitInput[] | UnitResourceUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutUnitInput | UnitResourceCreateOrConnectWithoutUnitInput[]
    upsert?: UnitResourceUpsertWithWhereUniqueWithoutUnitInput | UnitResourceUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitResourceCreateManyUnitInputEnvelope
    set?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    disconnect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    delete?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    update?: UnitResourceUpdateWithWhereUniqueWithoutUnitInput | UnitResourceUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitResourceUpdateManyWithWhereWithoutUnitInput | UnitResourceUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitResourceScalarWhereInput | UnitResourceScalarWhereInput[]
  }

  export type EquipmentAssetUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<EquipmentAssetCreateWithoutUnitInput, EquipmentAssetUncheckedCreateWithoutUnitInput> | EquipmentAssetCreateWithoutUnitInput[] | EquipmentAssetUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutUnitInput | EquipmentAssetCreateOrConnectWithoutUnitInput[]
    upsert?: EquipmentAssetUpsertWithWhereUniqueWithoutUnitInput | EquipmentAssetUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: EquipmentAssetCreateManyUnitInputEnvelope
    set?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    disconnect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    delete?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    update?: EquipmentAssetUpdateWithWhereUniqueWithoutUnitInput | EquipmentAssetUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: EquipmentAssetUpdateManyWithWhereWithoutUnitInput | EquipmentAssetUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
  }

  export type ProcedureBookingUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ProcedureBookingCreateWithoutUnitInput, ProcedureBookingUncheckedCreateWithoutUnitInput> | ProcedureBookingCreateWithoutUnitInput[] | ProcedureBookingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutUnitInput | ProcedureBookingCreateOrConnectWithoutUnitInput[]
    upsert?: ProcedureBookingUpsertWithWhereUniqueWithoutUnitInput | ProcedureBookingUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ProcedureBookingCreateManyUnitInputEnvelope
    set?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    disconnect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    delete?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    update?: ProcedureBookingUpdateWithWhereUniqueWithoutUnitInput | ProcedureBookingUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ProcedureBookingUpdateManyWithWhereWithoutUnitInput | ProcedureBookingUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ProcedureBookingScalarWhereInput | ProcedureBookingScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutRoomsInput = {
    create?: XOR<UnitCreateWithoutRoomsInput, UnitUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutRoomsInput
    connect?: UnitWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutUnitRoomsInput = {
    create?: XOR<BranchCreateWithoutUnitRoomsInput, BranchUncheckedCreateWithoutUnitRoomsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUnitRoomsInput
    connect?: BranchWhereUniqueInput
  }

  export type UnitResourceCreateNestedManyWithoutRoomInput = {
    create?: XOR<UnitResourceCreateWithoutRoomInput, UnitResourceUncheckedCreateWithoutRoomInput> | UnitResourceCreateWithoutRoomInput[] | UnitResourceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutRoomInput | UnitResourceCreateOrConnectWithoutRoomInput[]
    createMany?: UnitResourceCreateManyRoomInputEnvelope
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
  }

  export type EquipmentAssetCreateNestedManyWithoutRoomInput = {
    create?: XOR<EquipmentAssetCreateWithoutRoomInput, EquipmentAssetUncheckedCreateWithoutRoomInput> | EquipmentAssetCreateWithoutRoomInput[] | EquipmentAssetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutRoomInput | EquipmentAssetCreateOrConnectWithoutRoomInput[]
    createMany?: EquipmentAssetCreateManyRoomInputEnvelope
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
  }

  export type UnitResourceUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<UnitResourceCreateWithoutRoomInput, UnitResourceUncheckedCreateWithoutRoomInput> | UnitResourceCreateWithoutRoomInput[] | UnitResourceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutRoomInput | UnitResourceCreateOrConnectWithoutRoomInput[]
    createMany?: UnitResourceCreateManyRoomInputEnvelope
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
  }

  export type EquipmentAssetUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<EquipmentAssetCreateWithoutRoomInput, EquipmentAssetUncheckedCreateWithoutRoomInput> | EquipmentAssetCreateWithoutRoomInput[] | EquipmentAssetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutRoomInput | EquipmentAssetCreateOrConnectWithoutRoomInput[]
    createMany?: EquipmentAssetCreateManyRoomInputEnvelope
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
  }

  export type UnitUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<UnitCreateWithoutRoomsInput, UnitUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutRoomsInput
    upsert?: UnitUpsertWithoutRoomsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutRoomsInput, UnitUpdateWithoutRoomsInput>, UnitUncheckedUpdateWithoutRoomsInput>
  }

  export type BranchUpdateOneRequiredWithoutUnitRoomsNestedInput = {
    create?: XOR<BranchCreateWithoutUnitRoomsInput, BranchUncheckedCreateWithoutUnitRoomsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUnitRoomsInput
    upsert?: BranchUpsertWithoutUnitRoomsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUnitRoomsInput, BranchUpdateWithoutUnitRoomsInput>, BranchUncheckedUpdateWithoutUnitRoomsInput>
  }

  export type UnitResourceUpdateManyWithoutRoomNestedInput = {
    create?: XOR<UnitResourceCreateWithoutRoomInput, UnitResourceUncheckedCreateWithoutRoomInput> | UnitResourceCreateWithoutRoomInput[] | UnitResourceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutRoomInput | UnitResourceCreateOrConnectWithoutRoomInput[]
    upsert?: UnitResourceUpsertWithWhereUniqueWithoutRoomInput | UnitResourceUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: UnitResourceCreateManyRoomInputEnvelope
    set?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    disconnect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    delete?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    update?: UnitResourceUpdateWithWhereUniqueWithoutRoomInput | UnitResourceUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: UnitResourceUpdateManyWithWhereWithoutRoomInput | UnitResourceUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: UnitResourceScalarWhereInput | UnitResourceScalarWhereInput[]
  }

  export type EquipmentAssetUpdateManyWithoutRoomNestedInput = {
    create?: XOR<EquipmentAssetCreateWithoutRoomInput, EquipmentAssetUncheckedCreateWithoutRoomInput> | EquipmentAssetCreateWithoutRoomInput[] | EquipmentAssetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutRoomInput | EquipmentAssetCreateOrConnectWithoutRoomInput[]
    upsert?: EquipmentAssetUpsertWithWhereUniqueWithoutRoomInput | EquipmentAssetUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: EquipmentAssetCreateManyRoomInputEnvelope
    set?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    disconnect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    delete?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    update?: EquipmentAssetUpdateWithWhereUniqueWithoutRoomInput | EquipmentAssetUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: EquipmentAssetUpdateManyWithWhereWithoutRoomInput | EquipmentAssetUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
  }

  export type UnitResourceUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<UnitResourceCreateWithoutRoomInput, UnitResourceUncheckedCreateWithoutRoomInput> | UnitResourceCreateWithoutRoomInput[] | UnitResourceUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: UnitResourceCreateOrConnectWithoutRoomInput | UnitResourceCreateOrConnectWithoutRoomInput[]
    upsert?: UnitResourceUpsertWithWhereUniqueWithoutRoomInput | UnitResourceUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: UnitResourceCreateManyRoomInputEnvelope
    set?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    disconnect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    delete?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    connect?: UnitResourceWhereUniqueInput | UnitResourceWhereUniqueInput[]
    update?: UnitResourceUpdateWithWhereUniqueWithoutRoomInput | UnitResourceUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: UnitResourceUpdateManyWithWhereWithoutRoomInput | UnitResourceUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: UnitResourceScalarWhereInput | UnitResourceScalarWhereInput[]
  }

  export type EquipmentAssetUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<EquipmentAssetCreateWithoutRoomInput, EquipmentAssetUncheckedCreateWithoutRoomInput> | EquipmentAssetCreateWithoutRoomInput[] | EquipmentAssetUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutRoomInput | EquipmentAssetCreateOrConnectWithoutRoomInput[]
    upsert?: EquipmentAssetUpsertWithWhereUniqueWithoutRoomInput | EquipmentAssetUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: EquipmentAssetCreateManyRoomInputEnvelope
    set?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    disconnect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    delete?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    connect?: EquipmentAssetWhereUniqueInput | EquipmentAssetWhereUniqueInput[]
    update?: EquipmentAssetUpdateWithWhereUniqueWithoutRoomInput | EquipmentAssetUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: EquipmentAssetUpdateManyWithWhereWithoutRoomInput | EquipmentAssetUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutUnitResourcesInput = {
    create?: XOR<BranchCreateWithoutUnitResourcesInput, BranchUncheckedCreateWithoutUnitResourcesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUnitResourcesInput
    connect?: BranchWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutResourcesInput = {
    create?: XOR<UnitCreateWithoutResourcesInput, UnitUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutResourcesInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitRoomCreateNestedOneWithoutResourcesInput = {
    create?: XOR<UnitRoomCreateWithoutResourcesInput, UnitRoomUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UnitRoomCreateOrConnectWithoutResourcesInput
    connect?: UnitRoomWhereUniqueInput
  }

  export type ProcedureBookingCreateNestedManyWithoutResourceInput = {
    create?: XOR<ProcedureBookingCreateWithoutResourceInput, ProcedureBookingUncheckedCreateWithoutResourceInput> | ProcedureBookingCreateWithoutResourceInput[] | ProcedureBookingUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutResourceInput | ProcedureBookingCreateOrConnectWithoutResourceInput[]
    createMany?: ProcedureBookingCreateManyResourceInputEnvelope
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
  }

  export type ProcedureBookingUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<ProcedureBookingCreateWithoutResourceInput, ProcedureBookingUncheckedCreateWithoutResourceInput> | ProcedureBookingCreateWithoutResourceInput[] | ProcedureBookingUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutResourceInput | ProcedureBookingCreateOrConnectWithoutResourceInput[]
    createMany?: ProcedureBookingCreateManyResourceInputEnvelope
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
  }

  export type EnumUnitResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.UnitResourceType
  }

  export type EnumUnitResourceStateFieldUpdateOperationsInput = {
    set?: $Enums.UnitResourceState
  }

  export type BranchUpdateOneRequiredWithoutUnitResourcesNestedInput = {
    create?: XOR<BranchCreateWithoutUnitResourcesInput, BranchUncheckedCreateWithoutUnitResourcesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUnitResourcesInput
    upsert?: BranchUpsertWithoutUnitResourcesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUnitResourcesInput, BranchUpdateWithoutUnitResourcesInput>, BranchUncheckedUpdateWithoutUnitResourcesInput>
  }

  export type UnitUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<UnitCreateWithoutResourcesInput, UnitUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutResourcesInput
    upsert?: UnitUpsertWithoutResourcesInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutResourcesInput, UnitUpdateWithoutResourcesInput>, UnitUncheckedUpdateWithoutResourcesInput>
  }

  export type UnitRoomUpdateOneWithoutResourcesNestedInput = {
    create?: XOR<UnitRoomCreateWithoutResourcesInput, UnitRoomUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: UnitRoomCreateOrConnectWithoutResourcesInput
    upsert?: UnitRoomUpsertWithoutResourcesInput
    disconnect?: UnitRoomWhereInput | boolean
    delete?: UnitRoomWhereInput | boolean
    connect?: UnitRoomWhereUniqueInput
    update?: XOR<XOR<UnitRoomUpdateToOneWithWhereWithoutResourcesInput, UnitRoomUpdateWithoutResourcesInput>, UnitRoomUncheckedUpdateWithoutResourcesInput>
  }

  export type ProcedureBookingUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ProcedureBookingCreateWithoutResourceInput, ProcedureBookingUncheckedCreateWithoutResourceInput> | ProcedureBookingCreateWithoutResourceInput[] | ProcedureBookingUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutResourceInput | ProcedureBookingCreateOrConnectWithoutResourceInput[]
    upsert?: ProcedureBookingUpsertWithWhereUniqueWithoutResourceInput | ProcedureBookingUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ProcedureBookingCreateManyResourceInputEnvelope
    set?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    disconnect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    delete?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    update?: ProcedureBookingUpdateWithWhereUniqueWithoutResourceInput | ProcedureBookingUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ProcedureBookingUpdateManyWithWhereWithoutResourceInput | ProcedureBookingUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ProcedureBookingScalarWhereInput | ProcedureBookingScalarWhereInput[]
  }

  export type ProcedureBookingUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ProcedureBookingCreateWithoutResourceInput, ProcedureBookingUncheckedCreateWithoutResourceInput> | ProcedureBookingCreateWithoutResourceInput[] | ProcedureBookingUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ProcedureBookingCreateOrConnectWithoutResourceInput | ProcedureBookingCreateOrConnectWithoutResourceInput[]
    upsert?: ProcedureBookingUpsertWithWhereUniqueWithoutResourceInput | ProcedureBookingUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ProcedureBookingCreateManyResourceInputEnvelope
    set?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    disconnect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    delete?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    connect?: ProcedureBookingWhereUniqueInput | ProcedureBookingWhereUniqueInput[]
    update?: ProcedureBookingUpdateWithWhereUniqueWithoutResourceInput | ProcedureBookingUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ProcedureBookingUpdateManyWithWhereWithoutResourceInput | ProcedureBookingUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ProcedureBookingScalarWhereInput | ProcedureBookingScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutEquipmentAssetsInput = {
    create?: XOR<BranchCreateWithoutEquipmentAssetsInput, BranchUncheckedCreateWithoutEquipmentAssetsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEquipmentAssetsInput
    connect?: BranchWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutEquipmentOwnedInput = {
    create?: XOR<DepartmentCreateWithoutEquipmentOwnedInput, DepartmentUncheckedCreateWithoutEquipmentOwnedInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEquipmentOwnedInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<UnitCreateWithoutEquipmentInput, UnitUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: UnitCreateOrConnectWithoutEquipmentInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitRoomCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<UnitRoomCreateWithoutEquipmentInput, UnitRoomUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: UnitRoomCreateOrConnectWithoutEquipmentInput
    connect?: UnitRoomWhereUniqueInput
  }

  export type LocationNodeCreateNestedOneWithoutEquipmentAssetInput = {
    create?: XOR<LocationNodeCreateWithoutEquipmentAssetInput, LocationNodeUncheckedCreateWithoutEquipmentAssetInput>
    connectOrCreate?: LocationNodeCreateOrConnectWithoutEquipmentAssetInput
    connect?: LocationNodeWhereUniqueInput
  }

  export type DowntimeTicketCreateNestedManyWithoutAssetInput = {
    create?: XOR<DowntimeTicketCreateWithoutAssetInput, DowntimeTicketUncheckedCreateWithoutAssetInput> | DowntimeTicketCreateWithoutAssetInput[] | DowntimeTicketUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: DowntimeTicketCreateOrConnectWithoutAssetInput | DowntimeTicketCreateOrConnectWithoutAssetInput[]
    createMany?: DowntimeTicketCreateManyAssetInputEnvelope
    connect?: DowntimeTicketWhereUniqueInput | DowntimeTicketWhereUniqueInput[]
  }

  export type DowntimeTicketUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<DowntimeTicketCreateWithoutAssetInput, DowntimeTicketUncheckedCreateWithoutAssetInput> | DowntimeTicketCreateWithoutAssetInput[] | DowntimeTicketUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: DowntimeTicketCreateOrConnectWithoutAssetInput | DowntimeTicketCreateOrConnectWithoutAssetInput[]
    createMany?: DowntimeTicketCreateManyAssetInputEnvelope
    connect?: DowntimeTicketWhereUniqueInput | DowntimeTicketWhereUniqueInput[]
  }

  export type EnumEquipmentComplianceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentComplianceCategory
  }

  export type EnumEquipmentOperationalStatusFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentOperationalStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BranchUpdateOneRequiredWithoutEquipmentAssetsNestedInput = {
    create?: XOR<BranchCreateWithoutEquipmentAssetsInput, BranchUncheckedCreateWithoutEquipmentAssetsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEquipmentAssetsInput
    upsert?: BranchUpsertWithoutEquipmentAssetsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutEquipmentAssetsInput, BranchUpdateWithoutEquipmentAssetsInput>, BranchUncheckedUpdateWithoutEquipmentAssetsInput>
  }

  export type DepartmentUpdateOneWithoutEquipmentOwnedNestedInput = {
    create?: XOR<DepartmentCreateWithoutEquipmentOwnedInput, DepartmentUncheckedCreateWithoutEquipmentOwnedInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEquipmentOwnedInput
    upsert?: DepartmentUpsertWithoutEquipmentOwnedInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutEquipmentOwnedInput, DepartmentUpdateWithoutEquipmentOwnedInput>, DepartmentUncheckedUpdateWithoutEquipmentOwnedInput>
  }

  export type UnitUpdateOneWithoutEquipmentNestedInput = {
    create?: XOR<UnitCreateWithoutEquipmentInput, UnitUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: UnitCreateOrConnectWithoutEquipmentInput
    upsert?: UnitUpsertWithoutEquipmentInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutEquipmentInput, UnitUpdateWithoutEquipmentInput>, UnitUncheckedUpdateWithoutEquipmentInput>
  }

  export type UnitRoomUpdateOneWithoutEquipmentNestedInput = {
    create?: XOR<UnitRoomCreateWithoutEquipmentInput, UnitRoomUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: UnitRoomCreateOrConnectWithoutEquipmentInput
    upsert?: UnitRoomUpsertWithoutEquipmentInput
    disconnect?: UnitRoomWhereInput | boolean
    delete?: UnitRoomWhereInput | boolean
    connect?: UnitRoomWhereUniqueInput
    update?: XOR<XOR<UnitRoomUpdateToOneWithWhereWithoutEquipmentInput, UnitRoomUpdateWithoutEquipmentInput>, UnitRoomUncheckedUpdateWithoutEquipmentInput>
  }

  export type LocationNodeUpdateOneWithoutEquipmentAssetNestedInput = {
    create?: XOR<LocationNodeCreateWithoutEquipmentAssetInput, LocationNodeUncheckedCreateWithoutEquipmentAssetInput>
    connectOrCreate?: LocationNodeCreateOrConnectWithoutEquipmentAssetInput
    upsert?: LocationNodeUpsertWithoutEquipmentAssetInput
    disconnect?: LocationNodeWhereInput | boolean
    delete?: LocationNodeWhereInput | boolean
    connect?: LocationNodeWhereUniqueInput
    update?: XOR<XOR<LocationNodeUpdateToOneWithWhereWithoutEquipmentAssetInput, LocationNodeUpdateWithoutEquipmentAssetInput>, LocationNodeUncheckedUpdateWithoutEquipmentAssetInput>
  }

  export type DowntimeTicketUpdateManyWithoutAssetNestedInput = {
    create?: XOR<DowntimeTicketCreateWithoutAssetInput, DowntimeTicketUncheckedCreateWithoutAssetInput> | DowntimeTicketCreateWithoutAssetInput[] | DowntimeTicketUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: DowntimeTicketCreateOrConnectWithoutAssetInput | DowntimeTicketCreateOrConnectWithoutAssetInput[]
    upsert?: DowntimeTicketUpsertWithWhereUniqueWithoutAssetInput | DowntimeTicketUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: DowntimeTicketCreateManyAssetInputEnvelope
    set?: DowntimeTicketWhereUniqueInput | DowntimeTicketWhereUniqueInput[]
    disconnect?: DowntimeTicketWhereUniqueInput | DowntimeTicketWhereUniqueInput[]
    delete?: DowntimeTicketWhereUniqueInput | DowntimeTicketWhereUniqueInput[]
    connect?: DowntimeTicketWhereUniqueInput | DowntimeTicketWhereUniqueInput[]
    update?: DowntimeTicketUpdateWithWhereUniqueWithoutAssetInput | DowntimeTicketUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: DowntimeTicketUpdateManyWithWhereWithoutAssetInput | DowntimeTicketUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: DowntimeTicketScalarWhereInput | DowntimeTicketScalarWhereInput[]
  }

  export type DowntimeTicketUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<DowntimeTicketCreateWithoutAssetInput, DowntimeTicketUncheckedCreateWithoutAssetInput> | DowntimeTicketCreateWithoutAssetInput[] | DowntimeTicketUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: DowntimeTicketCreateOrConnectWithoutAssetInput | DowntimeTicketCreateOrConnectWithoutAssetInput[]
    upsert?: DowntimeTicketUpsertWithWhereUniqueWithoutAssetInput | DowntimeTicketUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: DowntimeTicketCreateManyAssetInputEnvelope
    set?: DowntimeTicketWhereUniqueInput | DowntimeTicketWhereUniqueInput[]
    disconnect?: DowntimeTicketWhereUniqueInput | DowntimeTicketWhereUniqueInput[]
    delete?: DowntimeTicketWhereUniqueInput | DowntimeTicketWhereUniqueInput[]
    connect?: DowntimeTicketWhereUniqueInput | DowntimeTicketWhereUniqueInput[]
    update?: DowntimeTicketUpdateWithWhereUniqueWithoutAssetInput | DowntimeTicketUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: DowntimeTicketUpdateManyWithWhereWithoutAssetInput | DowntimeTicketUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: DowntimeTicketScalarWhereInput | DowntimeTicketScalarWhereInput[]
  }

  export type EquipmentAssetCreateNestedOneWithoutDowntimeTicketsInput = {
    create?: XOR<EquipmentAssetCreateWithoutDowntimeTicketsInput, EquipmentAssetUncheckedCreateWithoutDowntimeTicketsInput>
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutDowntimeTicketsInput
    connect?: EquipmentAssetWhereUniqueInput
  }

  export type EnumDowntimeStatusFieldUpdateOperationsInput = {
    set?: $Enums.DowntimeStatus
  }

  export type EquipmentAssetUpdateOneRequiredWithoutDowntimeTicketsNestedInput = {
    create?: XOR<EquipmentAssetCreateWithoutDowntimeTicketsInput, EquipmentAssetUncheckedCreateWithoutDowntimeTicketsInput>
    connectOrCreate?: EquipmentAssetCreateOrConnectWithoutDowntimeTicketsInput
    upsert?: EquipmentAssetUpsertWithoutDowntimeTicketsInput
    connect?: EquipmentAssetWhereUniqueInput
    update?: XOR<XOR<EquipmentAssetUpdateToOneWithWhereWithoutDowntimeTicketsInput, EquipmentAssetUpdateWithoutDowntimeTicketsInput>, EquipmentAssetUncheckedUpdateWithoutDowntimeTicketsInput>
  }

  export type BranchCreateNestedOneWithoutChargeMasterItemsInput = {
    create?: XOR<BranchCreateWithoutChargeMasterItemsInput, BranchUncheckedCreateWithoutChargeMasterItemsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutChargeMasterItemsInput
    connect?: BranchWhereUniqueInput
  }

  export type ServiceChargeMappingCreateNestedManyWithoutChargeMasterItemInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutChargeMasterItemInput, ServiceChargeMappingUncheckedCreateWithoutChargeMasterItemInput> | ServiceChargeMappingCreateWithoutChargeMasterItemInput[] | ServiceChargeMappingUncheckedCreateWithoutChargeMasterItemInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutChargeMasterItemInput | ServiceChargeMappingCreateOrConnectWithoutChargeMasterItemInput[]
    createMany?: ServiceChargeMappingCreateManyChargeMasterItemInputEnvelope
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
  }

  export type ServiceChargeMappingUncheckedCreateNestedManyWithoutChargeMasterItemInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutChargeMasterItemInput, ServiceChargeMappingUncheckedCreateWithoutChargeMasterItemInput> | ServiceChargeMappingCreateWithoutChargeMasterItemInput[] | ServiceChargeMappingUncheckedCreateWithoutChargeMasterItemInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutChargeMasterItemInput | ServiceChargeMappingCreateOrConnectWithoutChargeMasterItemInput[]
    createMany?: ServiceChargeMappingCreateManyChargeMasterItemInputEnvelope
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutChargeMasterItemsNestedInput = {
    create?: XOR<BranchCreateWithoutChargeMasterItemsInput, BranchUncheckedCreateWithoutChargeMasterItemsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutChargeMasterItemsInput
    upsert?: BranchUpsertWithoutChargeMasterItemsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutChargeMasterItemsInput, BranchUpdateWithoutChargeMasterItemsInput>, BranchUncheckedUpdateWithoutChargeMasterItemsInput>
  }

  export type ServiceChargeMappingUpdateManyWithoutChargeMasterItemNestedInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutChargeMasterItemInput, ServiceChargeMappingUncheckedCreateWithoutChargeMasterItemInput> | ServiceChargeMappingCreateWithoutChargeMasterItemInput[] | ServiceChargeMappingUncheckedCreateWithoutChargeMasterItemInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutChargeMasterItemInput | ServiceChargeMappingCreateOrConnectWithoutChargeMasterItemInput[]
    upsert?: ServiceChargeMappingUpsertWithWhereUniqueWithoutChargeMasterItemInput | ServiceChargeMappingUpsertWithWhereUniqueWithoutChargeMasterItemInput[]
    createMany?: ServiceChargeMappingCreateManyChargeMasterItemInputEnvelope
    set?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    disconnect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    delete?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    update?: ServiceChargeMappingUpdateWithWhereUniqueWithoutChargeMasterItemInput | ServiceChargeMappingUpdateWithWhereUniqueWithoutChargeMasterItemInput[]
    updateMany?: ServiceChargeMappingUpdateManyWithWhereWithoutChargeMasterItemInput | ServiceChargeMappingUpdateManyWithWhereWithoutChargeMasterItemInput[]
    deleteMany?: ServiceChargeMappingScalarWhereInput | ServiceChargeMappingScalarWhereInput[]
  }

  export type ServiceChargeMappingUncheckedUpdateManyWithoutChargeMasterItemNestedInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutChargeMasterItemInput, ServiceChargeMappingUncheckedCreateWithoutChargeMasterItemInput> | ServiceChargeMappingCreateWithoutChargeMasterItemInput[] | ServiceChargeMappingUncheckedCreateWithoutChargeMasterItemInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutChargeMasterItemInput | ServiceChargeMappingCreateOrConnectWithoutChargeMasterItemInput[]
    upsert?: ServiceChargeMappingUpsertWithWhereUniqueWithoutChargeMasterItemInput | ServiceChargeMappingUpsertWithWhereUniqueWithoutChargeMasterItemInput[]
    createMany?: ServiceChargeMappingCreateManyChargeMasterItemInputEnvelope
    set?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    disconnect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    delete?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    update?: ServiceChargeMappingUpdateWithWhereUniqueWithoutChargeMasterItemInput | ServiceChargeMappingUpdateWithWhereUniqueWithoutChargeMasterItemInput[]
    updateMany?: ServiceChargeMappingUpdateManyWithWhereWithoutChargeMasterItemInput | ServiceChargeMappingUpdateManyWithWhereWithoutChargeMasterItemInput[]
    deleteMany?: ServiceChargeMappingScalarWhereInput | ServiceChargeMappingScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutServiceItemsInput = {
    create?: XOR<BranchCreateWithoutServiceItemsInput, BranchUncheckedCreateWithoutServiceItemsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServiceItemsInput
    connect?: BranchWhereUniqueInput
  }

  export type ServiceChargeMappingCreateNestedManyWithoutServiceItemInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutServiceItemInput, ServiceChargeMappingUncheckedCreateWithoutServiceItemInput> | ServiceChargeMappingCreateWithoutServiceItemInput[] | ServiceChargeMappingUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutServiceItemInput | ServiceChargeMappingCreateOrConnectWithoutServiceItemInput[]
    createMany?: ServiceChargeMappingCreateManyServiceItemInputEnvelope
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
  }

  export type FixItTaskCreateNestedManyWithoutServiceItemInput = {
    create?: XOR<FixItTaskCreateWithoutServiceItemInput, FixItTaskUncheckedCreateWithoutServiceItemInput> | FixItTaskCreateWithoutServiceItemInput[] | FixItTaskUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutServiceItemInput | FixItTaskCreateOrConnectWithoutServiceItemInput[]
    createMany?: FixItTaskCreateManyServiceItemInputEnvelope
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
  }

  export type ServiceChargeMappingUncheckedCreateNestedManyWithoutServiceItemInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutServiceItemInput, ServiceChargeMappingUncheckedCreateWithoutServiceItemInput> | ServiceChargeMappingCreateWithoutServiceItemInput[] | ServiceChargeMappingUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutServiceItemInput | ServiceChargeMappingCreateOrConnectWithoutServiceItemInput[]
    createMany?: ServiceChargeMappingCreateManyServiceItemInputEnvelope
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
  }

  export type FixItTaskUncheckedCreateNestedManyWithoutServiceItemInput = {
    create?: XOR<FixItTaskCreateWithoutServiceItemInput, FixItTaskUncheckedCreateWithoutServiceItemInput> | FixItTaskCreateWithoutServiceItemInput[] | FixItTaskUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutServiceItemInput | FixItTaskCreateOrConnectWithoutServiceItemInput[]
    createMany?: FixItTaskCreateManyServiceItemInputEnvelope
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutServiceItemsNestedInput = {
    create?: XOR<BranchCreateWithoutServiceItemsInput, BranchUncheckedCreateWithoutServiceItemsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServiceItemsInput
    upsert?: BranchUpsertWithoutServiceItemsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutServiceItemsInput, BranchUpdateWithoutServiceItemsInput>, BranchUncheckedUpdateWithoutServiceItemsInput>
  }

  export type ServiceChargeMappingUpdateManyWithoutServiceItemNestedInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutServiceItemInput, ServiceChargeMappingUncheckedCreateWithoutServiceItemInput> | ServiceChargeMappingCreateWithoutServiceItemInput[] | ServiceChargeMappingUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutServiceItemInput | ServiceChargeMappingCreateOrConnectWithoutServiceItemInput[]
    upsert?: ServiceChargeMappingUpsertWithWhereUniqueWithoutServiceItemInput | ServiceChargeMappingUpsertWithWhereUniqueWithoutServiceItemInput[]
    createMany?: ServiceChargeMappingCreateManyServiceItemInputEnvelope
    set?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    disconnect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    delete?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    update?: ServiceChargeMappingUpdateWithWhereUniqueWithoutServiceItemInput | ServiceChargeMappingUpdateWithWhereUniqueWithoutServiceItemInput[]
    updateMany?: ServiceChargeMappingUpdateManyWithWhereWithoutServiceItemInput | ServiceChargeMappingUpdateManyWithWhereWithoutServiceItemInput[]
    deleteMany?: ServiceChargeMappingScalarWhereInput | ServiceChargeMappingScalarWhereInput[]
  }

  export type FixItTaskUpdateManyWithoutServiceItemNestedInput = {
    create?: XOR<FixItTaskCreateWithoutServiceItemInput, FixItTaskUncheckedCreateWithoutServiceItemInput> | FixItTaskCreateWithoutServiceItemInput[] | FixItTaskUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutServiceItemInput | FixItTaskCreateOrConnectWithoutServiceItemInput[]
    upsert?: FixItTaskUpsertWithWhereUniqueWithoutServiceItemInput | FixItTaskUpsertWithWhereUniqueWithoutServiceItemInput[]
    createMany?: FixItTaskCreateManyServiceItemInputEnvelope
    set?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    disconnect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    delete?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    update?: FixItTaskUpdateWithWhereUniqueWithoutServiceItemInput | FixItTaskUpdateWithWhereUniqueWithoutServiceItemInput[]
    updateMany?: FixItTaskUpdateManyWithWhereWithoutServiceItemInput | FixItTaskUpdateManyWithWhereWithoutServiceItemInput[]
    deleteMany?: FixItTaskScalarWhereInput | FixItTaskScalarWhereInput[]
  }

  export type ServiceChargeMappingUncheckedUpdateManyWithoutServiceItemNestedInput = {
    create?: XOR<ServiceChargeMappingCreateWithoutServiceItemInput, ServiceChargeMappingUncheckedCreateWithoutServiceItemInput> | ServiceChargeMappingCreateWithoutServiceItemInput[] | ServiceChargeMappingUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: ServiceChargeMappingCreateOrConnectWithoutServiceItemInput | ServiceChargeMappingCreateOrConnectWithoutServiceItemInput[]
    upsert?: ServiceChargeMappingUpsertWithWhereUniqueWithoutServiceItemInput | ServiceChargeMappingUpsertWithWhereUniqueWithoutServiceItemInput[]
    createMany?: ServiceChargeMappingCreateManyServiceItemInputEnvelope
    set?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    disconnect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    delete?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    connect?: ServiceChargeMappingWhereUniqueInput | ServiceChargeMappingWhereUniqueInput[]
    update?: ServiceChargeMappingUpdateWithWhereUniqueWithoutServiceItemInput | ServiceChargeMappingUpdateWithWhereUniqueWithoutServiceItemInput[]
    updateMany?: ServiceChargeMappingUpdateManyWithWhereWithoutServiceItemInput | ServiceChargeMappingUpdateManyWithWhereWithoutServiceItemInput[]
    deleteMany?: ServiceChargeMappingScalarWhereInput | ServiceChargeMappingScalarWhereInput[]
  }

  export type FixItTaskUncheckedUpdateManyWithoutServiceItemNestedInput = {
    create?: XOR<FixItTaskCreateWithoutServiceItemInput, FixItTaskUncheckedCreateWithoutServiceItemInput> | FixItTaskCreateWithoutServiceItemInput[] | FixItTaskUncheckedCreateWithoutServiceItemInput[]
    connectOrCreate?: FixItTaskCreateOrConnectWithoutServiceItemInput | FixItTaskCreateOrConnectWithoutServiceItemInput[]
    upsert?: FixItTaskUpsertWithWhereUniqueWithoutServiceItemInput | FixItTaskUpsertWithWhereUniqueWithoutServiceItemInput[]
    createMany?: FixItTaskCreateManyServiceItemInputEnvelope
    set?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    disconnect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    delete?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    connect?: FixItTaskWhereUniqueInput | FixItTaskWhereUniqueInput[]
    update?: FixItTaskUpdateWithWhereUniqueWithoutServiceItemInput | FixItTaskUpdateWithWhereUniqueWithoutServiceItemInput[]
    updateMany?: FixItTaskUpdateManyWithWhereWithoutServiceItemInput | FixItTaskUpdateManyWithWhereWithoutServiceItemInput[]
    deleteMany?: FixItTaskScalarWhereInput | FixItTaskScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutServiceMappingsInput = {
    create?: XOR<BranchCreateWithoutServiceMappingsInput, BranchUncheckedCreateWithoutServiceMappingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServiceMappingsInput
    connect?: BranchWhereUniqueInput
  }

  export type ServiceItemCreateNestedOneWithoutMappingsInput = {
    create?: XOR<ServiceItemCreateWithoutMappingsInput, ServiceItemUncheckedCreateWithoutMappingsInput>
    connectOrCreate?: ServiceItemCreateOrConnectWithoutMappingsInput
    connect?: ServiceItemWhereUniqueInput
  }

  export type ChargeMasterItemCreateNestedOneWithoutMappingsInput = {
    create?: XOR<ChargeMasterItemCreateWithoutMappingsInput, ChargeMasterItemUncheckedCreateWithoutMappingsInput>
    connectOrCreate?: ChargeMasterItemCreateOrConnectWithoutMappingsInput
    connect?: ChargeMasterItemWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutServiceMappingsNestedInput = {
    create?: XOR<BranchCreateWithoutServiceMappingsInput, BranchUncheckedCreateWithoutServiceMappingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutServiceMappingsInput
    upsert?: BranchUpsertWithoutServiceMappingsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutServiceMappingsInput, BranchUpdateWithoutServiceMappingsInput>, BranchUncheckedUpdateWithoutServiceMappingsInput>
  }

  export type ServiceItemUpdateOneRequiredWithoutMappingsNestedInput = {
    create?: XOR<ServiceItemCreateWithoutMappingsInput, ServiceItemUncheckedCreateWithoutMappingsInput>
    connectOrCreate?: ServiceItemCreateOrConnectWithoutMappingsInput
    upsert?: ServiceItemUpsertWithoutMappingsInput
    connect?: ServiceItemWhereUniqueInput
    update?: XOR<XOR<ServiceItemUpdateToOneWithWhereWithoutMappingsInput, ServiceItemUpdateWithoutMappingsInput>, ServiceItemUncheckedUpdateWithoutMappingsInput>
  }

  export type ChargeMasterItemUpdateOneRequiredWithoutMappingsNestedInput = {
    create?: XOR<ChargeMasterItemCreateWithoutMappingsInput, ChargeMasterItemUncheckedCreateWithoutMappingsInput>
    connectOrCreate?: ChargeMasterItemCreateOrConnectWithoutMappingsInput
    upsert?: ChargeMasterItemUpsertWithoutMappingsInput
    connect?: ChargeMasterItemWhereUniqueInput
    update?: XOR<XOR<ChargeMasterItemUpdateToOneWithWhereWithoutMappingsInput, ChargeMasterItemUpdateWithoutMappingsInput>, ChargeMasterItemUncheckedUpdateWithoutMappingsInput>
  }

  export type BranchCreateNestedOneWithoutFixItTasksInput = {
    create?: XOR<BranchCreateWithoutFixItTasksInput, BranchUncheckedCreateWithoutFixItTasksInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFixItTasksInput
    connect?: BranchWhereUniqueInput
  }

  export type ServiceItemCreateNestedOneWithoutFixItsInput = {
    create?: XOR<ServiceItemCreateWithoutFixItsInput, ServiceItemUncheckedCreateWithoutFixItsInput>
    connectOrCreate?: ServiceItemCreateOrConnectWithoutFixItsInput
    connect?: ServiceItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedFixItsInput = {
    create?: XOR<UserCreateWithoutAssignedFixItsInput, UserUncheckedCreateWithoutAssignedFixItsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFixItsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFixItTypeFieldUpdateOperationsInput = {
    set?: $Enums.FixItType
  }

  export type EnumFixItStatusFieldUpdateOperationsInput = {
    set?: $Enums.FixItStatus
  }

  export type BranchUpdateOneRequiredWithoutFixItTasksNestedInput = {
    create?: XOR<BranchCreateWithoutFixItTasksInput, BranchUncheckedCreateWithoutFixItTasksInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFixItTasksInput
    upsert?: BranchUpsertWithoutFixItTasksInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutFixItTasksInput, BranchUpdateWithoutFixItTasksInput>, BranchUncheckedUpdateWithoutFixItTasksInput>
  }

  export type ServiceItemUpdateOneWithoutFixItsNestedInput = {
    create?: XOR<ServiceItemCreateWithoutFixItsInput, ServiceItemUncheckedCreateWithoutFixItsInput>
    connectOrCreate?: ServiceItemCreateOrConnectWithoutFixItsInput
    upsert?: ServiceItemUpsertWithoutFixItsInput
    disconnect?: ServiceItemWhereInput | boolean
    delete?: ServiceItemWhereInput | boolean
    connect?: ServiceItemWhereUniqueInput
    update?: XOR<XOR<ServiceItemUpdateToOneWithWhereWithoutFixItsInput, ServiceItemUpdateWithoutFixItsInput>, ServiceItemUncheckedUpdateWithoutFixItsInput>
  }

  export type UserUpdateOneWithoutAssignedFixItsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedFixItsInput, UserUncheckedCreateWithoutAssignedFixItsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedFixItsInput
    upsert?: UserUpsertWithoutAssignedFixItsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedFixItsInput, UserUpdateWithoutAssignedFixItsInput>, UserUncheckedUpdateWithoutAssignedFixItsInput>
  }

  export type BranchCreateNestedOneWithoutImportJobsInput = {
    create?: XOR<BranchCreateWithoutImportJobsInput, BranchUncheckedCreateWithoutImportJobsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutImportJobsInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedImportJobsInput = {
    create?: XOR<UserCreateWithoutCreatedImportJobsInput, UserUncheckedCreateWithoutCreatedImportJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedImportJobsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumImportEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ImportEntityType
  }

  export type EnumImportJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImportJobStatus
  }

  export type BranchUpdateOneRequiredWithoutImportJobsNestedInput = {
    create?: XOR<BranchCreateWithoutImportJobsInput, BranchUncheckedCreateWithoutImportJobsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutImportJobsInput
    upsert?: BranchUpsertWithoutImportJobsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutImportJobsInput, BranchUpdateWithoutImportJobsInput>, BranchUncheckedUpdateWithoutImportJobsInput>
  }

  export type UserUpdateOneWithoutCreatedImportJobsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedImportJobsInput, UserUncheckedCreateWithoutCreatedImportJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedImportJobsInput
    upsert?: UserUpsertWithoutCreatedImportJobsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedImportJobsInput, UserUpdateWithoutCreatedImportJobsInput>, UserUncheckedUpdateWithoutCreatedImportJobsInput>
  }

  export type BranchCreateNestedOneWithoutProcedureBookingsInput = {
    create?: XOR<BranchCreateWithoutProcedureBookingsInput, BranchUncheckedCreateWithoutProcedureBookingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProcedureBookingsInput
    connect?: BranchWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UnitCreateWithoutBookingsInput, UnitUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutBookingsInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitResourceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UnitResourceCreateWithoutBookingsInput, UnitResourceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UnitResourceCreateOrConnectWithoutBookingsInput
    connect?: UnitResourceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedBookingsInput = {
    create?: XOR<UserCreateWithoutCreatedBookingsInput, UserUncheckedCreateWithoutCreatedBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type BranchUpdateOneRequiredWithoutProcedureBookingsNestedInput = {
    create?: XOR<BranchCreateWithoutProcedureBookingsInput, BranchUncheckedCreateWithoutProcedureBookingsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutProcedureBookingsInput
    upsert?: BranchUpsertWithoutProcedureBookingsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutProcedureBookingsInput, BranchUpdateWithoutProcedureBookingsInput>, BranchUncheckedUpdateWithoutProcedureBookingsInput>
  }

  export type UnitUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UnitCreateWithoutBookingsInput, UnitUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutBookingsInput
    upsert?: UnitUpsertWithoutBookingsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutBookingsInput, UnitUpdateWithoutBookingsInput>, UnitUncheckedUpdateWithoutBookingsInput>
  }

  export type UnitResourceUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UnitResourceCreateWithoutBookingsInput, UnitResourceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UnitResourceCreateOrConnectWithoutBookingsInput
    upsert?: UnitResourceUpsertWithoutBookingsInput
    connect?: UnitResourceWhereUniqueInput
    update?: XOR<XOR<UnitResourceUpdateToOneWithWhereWithoutBookingsInput, UnitResourceUpdateWithoutBookingsInput>, UnitResourceUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneWithoutCreatedBookingsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedBookingsInput, UserUncheckedCreateWithoutCreatedBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBookingsInput
    upsert?: UserUpsertWithoutCreatedBookingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedBookingsInput, UserUpdateWithoutCreatedBookingsInput>, UserUncheckedUpdateWithoutCreatedBookingsInput>
  }

  export type BranchCreateNestedOneWithoutGoLiveReportsInput = {
    create?: XOR<BranchCreateWithoutGoLiveReportsInput, BranchUncheckedCreateWithoutGoLiveReportsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutGoLiveReportsInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedGoLiveReportsInput = {
    create?: XOR<UserCreateWithoutCreatedGoLiveReportsInput, UserUncheckedCreateWithoutCreatedGoLiveReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGoLiveReportsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutGoLiveReportsNestedInput = {
    create?: XOR<BranchCreateWithoutGoLiveReportsInput, BranchUncheckedCreateWithoutGoLiveReportsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutGoLiveReportsInput
    upsert?: BranchUpsertWithoutGoLiveReportsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutGoLiveReportsInput, BranchUpdateWithoutGoLiveReportsInput>, BranchUncheckedUpdateWithoutGoLiveReportsInput>
  }

  export type UserUpdateOneWithoutCreatedGoLiveReportsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedGoLiveReportsInput, UserUncheckedCreateWithoutCreatedGoLiveReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedGoLiveReportsInput
    upsert?: UserUpsertWithoutCreatedGoLiveReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedGoLiveReportsInput, UserUpdateWithoutCreatedGoLiveReportsInput>, UserUncheckedUpdateWithoutCreatedGoLiveReportsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumFacilityCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityCategory | EnumFacilityCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityCategory[] | ListEnumFacilityCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityCategory[] | ListEnumFacilityCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityCategoryFilter<$PrismaModel> | $Enums.FacilityCategory
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumFacilityCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FacilityCategory | EnumFacilityCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FacilityCategory[] | ListEnumFacilityCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FacilityCategory[] | ListEnumFacilityCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFacilityCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FacilityCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFacilityCategoryFilter<$PrismaModel>
    _max?: NestedEnumFacilityCategoryFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEncounterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterType | EnumEncounterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterTypeFilter<$PrismaModel> | $Enums.EncounterType
  }

  export type NestedEnumEncounterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterType | EnumEncounterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterTypeWithAggregatesFilter<$PrismaModel> | $Enums.EncounterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEncounterTypeFilter<$PrismaModel>
    _max?: NestedEnumEncounterTypeFilter<$PrismaModel>
  }

  export type NestedEnumBedStateFilter<$PrismaModel = never> = {
    equals?: $Enums.BedState | EnumBedStateFieldRefInput<$PrismaModel>
    in?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStateFilter<$PrismaModel> | $Enums.BedState
  }

  export type NestedEnumBedStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BedState | EnumBedStateFieldRefInput<$PrismaModel>
    in?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStateWithAggregatesFilter<$PrismaModel> | $Enums.BedState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBedStateFilter<$PrismaModel>
    _max?: NestedEnumBedStateFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumConsentScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentScope | EnumConsentScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentScopeFilter<$PrismaModel> | $Enums.ConsentScope
  }

  export type NestedEnumConsentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusFilter<$PrismaModel> | $Enums.ConsentStatus
  }

  export type NestedEnumConsentScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentScope | EnumConsentScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentScopeWithAggregatesFilter<$PrismaModel> | $Enums.ConsentScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentScopeFilter<$PrismaModel>
    _max?: NestedEnumConsentScopeFilter<$PrismaModel>
  }

  export type NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConsentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentStatusFilter<$PrismaModel>
    _max?: NestedEnumConsentStatusFilter<$PrismaModel>
  }

  export type NestedEnumRtbfStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RtbfStatus | EnumRtbfStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRtbfStatusFilter<$PrismaModel> | $Enums.RtbfStatus
  }

  export type NestedEnumRtbfStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RtbfStatus | EnumRtbfStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRtbfStatusWithAggregatesFilter<$PrismaModel> | $Enums.RtbfStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRtbfStatusFilter<$PrismaModel>
    _max?: NestedEnumRtbfStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumOutboxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusFilter<$PrismaModel> | $Enums.OutboxStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumOutboxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusWithAggregatesFilter<$PrismaModel> | $Enums.OutboxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOutboxStatusFilter<$PrismaModel>
    _max?: NestedEnumOutboxStatusFilter<$PrismaModel>
  }

  export type NestedEnumRoleScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleScope | EnumRoleScopeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleScopeFilter<$PrismaModel> | $Enums.RoleScope
  }

  export type NestedEnumRoleScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleScope | EnumRoleScopeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleScopeWithAggregatesFilter<$PrismaModel> | $Enums.RoleScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleScopeFilter<$PrismaModel>
    _max?: NestedEnumRoleScopeFilter<$PrismaModel>
  }

  export type NestedEnumRoleVersionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleVersionStatus | EnumRoleVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleVersionStatusFilter<$PrismaModel> | $Enums.RoleVersionStatus
  }

  export type NestedEnumRoleVersionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleVersionStatus | EnumRoleVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleVersionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoleVersionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleVersionStatusFilter<$PrismaModel>
    _max?: NestedEnumRoleVersionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPolicyScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyScope | EnumPolicyScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyScope[] | ListEnumPolicyScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyScope[] | ListEnumPolicyScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyScopeFilter<$PrismaModel> | $Enums.PolicyScope
  }

  export type NestedEnumPolicyVersionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyVersionStatus | EnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyVersionStatus[] | ListEnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyVersionStatus[] | ListEnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyVersionStatusFilter<$PrismaModel> | $Enums.PolicyVersionStatus
  }

  export type NestedEnumPolicyScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyScope | EnumPolicyScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyScope[] | ListEnumPolicyScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyScope[] | ListEnumPolicyScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyScopeWithAggregatesFilter<$PrismaModel> | $Enums.PolicyScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPolicyScopeFilter<$PrismaModel>
    _max?: NestedEnumPolicyScopeFilter<$PrismaModel>
  }

  export type NestedEnumPolicyVersionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PolicyVersionStatus | EnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PolicyVersionStatus[] | ListEnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PolicyVersionStatus[] | ListEnumPolicyVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPolicyVersionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PolicyVersionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPolicyVersionStatusFilter<$PrismaModel>
    _max?: NestedEnumPolicyVersionStatusFilter<$PrismaModel>
  }

  export type NestedEnumLocationKindFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationKind | EnumLocationKindFieldRefInput<$PrismaModel>
    in?: $Enums.LocationKind[] | ListEnumLocationKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationKind[] | ListEnumLocationKindFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationKindFilter<$PrismaModel> | $Enums.LocationKind
  }

  export type NestedEnumLocationKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationKind | EnumLocationKindFieldRefInput<$PrismaModel>
    in?: $Enums.LocationKind[] | ListEnumLocationKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationKind[] | ListEnumLocationKindFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationKindWithAggregatesFilter<$PrismaModel> | $Enums.LocationKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationKindFilter<$PrismaModel>
    _max?: NestedEnumLocationKindFilter<$PrismaModel>
  }

  export type NestedEnumUnitResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitResourceType | EnumUnitResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitResourceType[] | ListEnumUnitResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitResourceType[] | ListEnumUnitResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitResourceTypeFilter<$PrismaModel> | $Enums.UnitResourceType
  }

  export type NestedEnumUnitResourceStateFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitResourceState | EnumUnitResourceStateFieldRefInput<$PrismaModel>
    in?: $Enums.UnitResourceState[] | ListEnumUnitResourceStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitResourceState[] | ListEnumUnitResourceStateFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitResourceStateFilter<$PrismaModel> | $Enums.UnitResourceState
  }

  export type NestedEnumUnitResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitResourceType | EnumUnitResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitResourceType[] | ListEnumUnitResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitResourceType[] | ListEnumUnitResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.UnitResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumUnitResourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumUnitResourceStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitResourceState | EnumUnitResourceStateFieldRefInput<$PrismaModel>
    in?: $Enums.UnitResourceState[] | ListEnumUnitResourceStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitResourceState[] | ListEnumUnitResourceStateFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitResourceStateWithAggregatesFilter<$PrismaModel> | $Enums.UnitResourceState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitResourceStateFilter<$PrismaModel>
    _max?: NestedEnumUnitResourceStateFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentComplianceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentComplianceCategory | EnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentComplianceCategory[] | ListEnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentComplianceCategory[] | ListEnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentComplianceCategoryFilter<$PrismaModel> | $Enums.EquipmentComplianceCategory
  }

  export type NestedEnumEquipmentOperationalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentOperationalStatus | EnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentOperationalStatus[] | ListEnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentOperationalStatus[] | ListEnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentOperationalStatusFilter<$PrismaModel> | $Enums.EquipmentOperationalStatus
  }

  export type NestedEnumEquipmentComplianceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentComplianceCategory | EnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentComplianceCategory[] | ListEnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentComplianceCategory[] | ListEnumEquipmentComplianceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentComplianceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentComplianceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentComplianceCategoryFilter<$PrismaModel>
    _max?: NestedEnumEquipmentComplianceCategoryFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentOperationalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentOperationalStatus | EnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentOperationalStatus[] | ListEnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentOperationalStatus[] | ListEnumEquipmentOperationalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentOperationalStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentOperationalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentOperationalStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentOperationalStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDowntimeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DowntimeStatus | EnumDowntimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DowntimeStatus[] | ListEnumDowntimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DowntimeStatus[] | ListEnumDowntimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDowntimeStatusFilter<$PrismaModel> | $Enums.DowntimeStatus
  }

  export type NestedEnumDowntimeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DowntimeStatus | EnumDowntimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DowntimeStatus[] | ListEnumDowntimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DowntimeStatus[] | ListEnumDowntimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDowntimeStatusWithAggregatesFilter<$PrismaModel> | $Enums.DowntimeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDowntimeStatusFilter<$PrismaModel>
    _max?: NestedEnumDowntimeStatusFilter<$PrismaModel>
  }

  export type NestedEnumFixItTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FixItType | EnumFixItTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FixItType[] | ListEnumFixItTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FixItType[] | ListEnumFixItTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFixItTypeFilter<$PrismaModel> | $Enums.FixItType
  }

  export type NestedEnumFixItStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FixItStatus | EnumFixItStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FixItStatus[] | ListEnumFixItStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FixItStatus[] | ListEnumFixItStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFixItStatusFilter<$PrismaModel> | $Enums.FixItStatus
  }

  export type NestedEnumFixItTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FixItType | EnumFixItTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FixItType[] | ListEnumFixItTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FixItType[] | ListEnumFixItTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFixItTypeWithAggregatesFilter<$PrismaModel> | $Enums.FixItType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFixItTypeFilter<$PrismaModel>
    _max?: NestedEnumFixItTypeFilter<$PrismaModel>
  }

  export type NestedEnumFixItStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FixItStatus | EnumFixItStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FixItStatus[] | ListEnumFixItStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FixItStatus[] | ListEnumFixItStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFixItStatusWithAggregatesFilter<$PrismaModel> | $Enums.FixItStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFixItStatusFilter<$PrismaModel>
    _max?: NestedEnumFixItStatusFilter<$PrismaModel>
  }

  export type NestedEnumImportEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportEntityType | EnumImportEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportEntityTypeFilter<$PrismaModel> | $Enums.ImportEntityType
  }

  export type NestedEnumImportJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobStatus | EnumImportJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobStatusFilter<$PrismaModel> | $Enums.ImportJobStatus
  }

  export type NestedEnumImportEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportEntityType | EnumImportEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportEntityType[] | ListEnumImportEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImportEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumImportEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumImportJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportJobStatus | EnumImportJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportJobStatus[] | ListEnumImportJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportJobStatusFilter<$PrismaModel>
    _max?: NestedEnumImportJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type DepartmentCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    facility: FacilityCatalogCreateNestedOneWithoutDepartmentsInput
    headStaff?: StaffCreateNestedOneWithoutHeadedDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutDepartmentInput
    units?: UnitCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutBranchInput = {
    id?: string
    facilityId: string
    code: string
    name: string
    headStaffId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutDepartmentInput
    units?: UnitUncheckedCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetUncheckedCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutBranchInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput>
  }

  export type DepartmentCreateManyBranchInputEnvelope = {
    data: DepartmentCreateManyBranchInput | DepartmentCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBranchInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutBranchInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutBranchInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutBranchInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput>
  }

  export type PatientCreateManyBranchInputEnvelope = {
    data: PatientCreateManyBranchInput | PatientCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type WardCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomCreateNestedManyWithoutWardInput
  }

  export type WardUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardCreateOrConnectWithoutBranchInput = {
    where: WardWhereUniqueInput
    create: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput>
  }

  export type WardCreateManyBranchInputEnvelope = {
    data: WardCreateManyBranchInput | WardCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type OTCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTCreateOrConnectWithoutBranchInput = {
    where: OTWhereUniqueInput
    create: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput>
  }

  export type OTCreateManyBranchInputEnvelope = {
    data: OTCreateManyBranchInput | OTCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type TariffPlanCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rates?: TariffRateCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rates?: TariffRateUncheckedCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanCreateOrConnectWithoutBranchInput = {
    where: TariffPlanWhereUniqueInput
    create: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput>
  }

  export type TariffPlanCreateManyBranchInputEnvelope = {
    data: TariffPlanCreateManyBranchInput | TariffPlanCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateOrConnectWithoutBranchInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput>
  }

  export type AssetCreateManyBranchInputEnvelope = {
    data: AssetCreateManyBranchInput | AssetCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type SpecialtyCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedManyWithoutSpecialtyInput
    departmentLinks?: DepartmentSpecialtyCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutSpecialtyInput
    departmentLinks?: DepartmentSpecialtyUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutBranchInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput>
  }

  export type SpecialtyCreateManyBranchInputEnvelope = {
    data: SpecialtyCreateManyBranchInput | SpecialtyCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type StaffCreateWithoutBranchInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutStaffInput
    specialty?: SpecialtyCreateNestedOneWithoutStaffInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutStaffInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadStaffInput
    user?: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutBranchInput = {
    id?: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutStaffInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadStaffInput
    user?: UserUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutBranchInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput>
  }

  export type StaffCreateManyBranchInputEnvelope = {
    data: StaffCreateManyBranchInput | StaffCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutBranchInput = {
    id?: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEncountersInput
    admissions?: AdmissionCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutBranchInput = {
    id?: string
    patientId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutBranchInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput>
  }

  export type EncounterCreateManyBranchInputEnvelope = {
    data: EncounterCreateManyBranchInput | EncounterCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type BedCreateWithoutBranchInput = {
    id?: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutBedsInput
    admissions?: AdmissionCreateNestedManyWithoutBedInput
  }

  export type BedUncheckedCreateWithoutBranchInput = {
    id?: string
    roomId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutBedInput
  }

  export type BedCreateOrConnectWithoutBranchInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput>
  }

  export type BedCreateManyBranchInputEnvelope = {
    data: BedCreateManyBranchInput | BedCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionCreateWithoutBranchInput = {
    id?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter?: EncounterCreateNestedOneWithoutAdmissionsInput
    patient: PatientCreateNestedOneWithoutAdmissionInput
    bed?: BedCreateNestedOneWithoutAdmissionsInput
  }

  export type AdmissionUncheckedCreateWithoutBranchInput = {
    id?: string
    encounterId?: string | null
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateOrConnectWithoutBranchInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput>
  }

  export type AdmissionCreateManyBranchInputEnvelope = {
    data: AdmissionCreateManyBranchInput | AdmissionCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type BranchFacilityCreateWithoutBranchInput = {
    id?: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    facility: FacilityCatalogCreateNestedOneWithoutBranchLinksInput
  }

  export type BranchFacilityUncheckedCreateWithoutBranchInput = {
    id?: string
    facilityId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchFacilityCreateOrConnectWithoutBranchInput = {
    where: BranchFacilityWhereUniqueInput
    create: XOR<BranchFacilityCreateWithoutBranchInput, BranchFacilityUncheckedCreateWithoutBranchInput>
  }

  export type BranchFacilityCreateManyBranchInputEnvelope = {
    data: BranchFacilityCreateManyBranchInput | BranchFacilityCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    floor?: string | null
    type?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ward: WardCreateNestedOneWithoutRoomsInput
    beds?: BedCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutBranchInput = {
    id?: string
    wardId: string
    code: string
    name: string
    floor?: string | null
    type?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    beds?: BedUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutBranchInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutBranchInput, RoomUncheckedCreateWithoutBranchInput>
  }

  export type RoomCreateManyBranchInputEnvelope = {
    data: RoomCreateManyBranchInput | RoomCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type StatutoryCaseCreateWithoutBranchInput = {
    id?: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutStatutoryCasesInput
  }

  export type StatutoryCaseUncheckedCreateWithoutBranchInput = {
    id?: string
    patientId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseCreateOrConnectWithoutBranchInput = {
    where: StatutoryCaseWhereUniqueInput
    create: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput>
  }

  export type StatutoryCaseCreateManyBranchInputEnvelope = {
    data: StatutoryCaseCreateManyBranchInput | StatutoryCaseCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AuditEventCreateWithoutBranchInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actorUser?: UserCreateNestedOneWithoutAuditEventsAsActorInput
  }

  export type AuditEventUncheckedCreateWithoutBranchInput = {
    id?: string
    actorUserId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditEventCreateOrConnectWithoutBranchInput = {
    where: AuditEventWhereUniqueInput
    create: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput>
  }

  export type AuditEventCreateManyBranchInputEnvelope = {
    data: AuditEventCreateManyBranchInput | AuditEventCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type PolicyVersionCreateWithoutBranchInput = {
    id?: string
    scope?: $Enums.PolicyScope
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policy: PolicyDefinitionCreateNestedOneWithoutVersionsInput
    branches?: PolicyVersionBranchCreateNestedManyWithoutPolicyVersionInput
    createdByUser?: UserCreateNestedOneWithoutPolicyVersionsCreatedByInput
    submittedByUser?: UserCreateNestedOneWithoutPolicyVersionsSubmittedByInput
    approvedByUser?: UserCreateNestedOneWithoutPolicyVersionsApprovedByInput
    rejectedByUser?: UserCreateNestedOneWithoutPolicyVersionsRejectedByInput
    retiredByUser?: UserCreateNestedOneWithoutPolicyVersionsRetiredByInput
  }

  export type PolicyVersionUncheckedCreateWithoutBranchInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutPolicyVersionInput
  }

  export type PolicyVersionCreateOrConnectWithoutBranchInput = {
    where: PolicyVersionWhereUniqueInput
    create: XOR<PolicyVersionCreateWithoutBranchInput, PolicyVersionUncheckedCreateWithoutBranchInput>
  }

  export type PolicyVersionCreateManyBranchInputEnvelope = {
    data: PolicyVersionCreateManyBranchInput | PolicyVersionCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type PolicyVersionBranchCreateWithoutBranchInput = {
    id?: string
    createdAt?: Date | string
    policyVersion: PolicyVersionCreateNestedOneWithoutBranchesInput
  }

  export type PolicyVersionBranchUncheckedCreateWithoutBranchInput = {
    id?: string
    policyVersionId: string
    createdAt?: Date | string
  }

  export type PolicyVersionBranchCreateOrConnectWithoutBranchInput = {
    where: PolicyVersionBranchWhereUniqueInput
    create: XOR<PolicyVersionBranchCreateWithoutBranchInput, PolicyVersionBranchUncheckedCreateWithoutBranchInput>
  }

  export type PolicyVersionBranchCreateManyBranchInputEnvelope = {
    data: PolicyVersionBranchCreateManyBranchInput | PolicyVersionBranchCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type LocationNodeCreateWithoutBranchInput = {
    id?: string
    kind: $Enums.LocationKind
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: LocationNodeCreateNestedOneWithoutChildrenInput
    children?: LocationNodeCreateNestedManyWithoutParentInput
    revisions?: LocationNodeRevisionCreateNestedManyWithoutNodeInput
    EquipmentAsset?: EquipmentAssetCreateNestedManyWithoutLocationNodeInput
  }

  export type LocationNodeUncheckedCreateWithoutBranchInput = {
    id?: string
    kind: $Enums.LocationKind
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationNodeUncheckedCreateNestedManyWithoutParentInput
    revisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutNodeInput
    EquipmentAsset?: EquipmentAssetUncheckedCreateNestedManyWithoutLocationNodeInput
  }

  export type LocationNodeCreateOrConnectWithoutBranchInput = {
    where: LocationNodeWhereUniqueInput
    create: XOR<LocationNodeCreateWithoutBranchInput, LocationNodeUncheckedCreateWithoutBranchInput>
  }

  export type LocationNodeCreateManyBranchInputEnvelope = {
    data: LocationNodeCreateManyBranchInput | LocationNodeCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type BranchUnitTypeCreateWithoutBranchInput = {
    id?: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    unitType: UnitTypeCatalogCreateNestedOneWithoutBranchLinksInput
  }

  export type BranchUnitTypeUncheckedCreateWithoutBranchInput = {
    id?: string
    unitTypeId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUnitTypeCreateOrConnectWithoutBranchInput = {
    where: BranchUnitTypeWhereUniqueInput
    create: XOR<BranchUnitTypeCreateWithoutBranchInput, BranchUnitTypeUncheckedCreateWithoutBranchInput>
  }

  export type BranchUnitTypeCreateManyBranchInputEnvelope = {
    data: BranchUnitTypeCreateManyBranchInput | BranchUnitTypeCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutUnitsInput
    unitType: UnitTypeCatalogCreateNestedOneWithoutUnitsInput
    rooms?: UnitRoomCreateNestedManyWithoutUnitInput
    resources?: UnitResourceCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutBranchInput = {
    id?: string
    departmentId: string
    unitTypeId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: UnitRoomUncheckedCreateNestedManyWithoutUnitInput
    resources?: UnitResourceUncheckedCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetUncheckedCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutBranchInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutBranchInput, UnitUncheckedCreateWithoutBranchInput>
  }

  export type UnitCreateManyBranchInputEnvelope = {
    data: UnitCreateManyBranchInput | UnitCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UnitRoomCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutRoomsInput
    resources?: UnitResourceCreateNestedManyWithoutRoomInput
    equipment?: EquipmentAssetCreateNestedManyWithoutRoomInput
  }

  export type UnitRoomUncheckedCreateWithoutBranchInput = {
    id?: string
    unitId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: UnitResourceUncheckedCreateNestedManyWithoutRoomInput
    equipment?: EquipmentAssetUncheckedCreateNestedManyWithoutRoomInput
  }

  export type UnitRoomCreateOrConnectWithoutBranchInput = {
    where: UnitRoomWhereUniqueInput
    create: XOR<UnitRoomCreateWithoutBranchInput, UnitRoomUncheckedCreateWithoutBranchInput>
  }

  export type UnitRoomCreateManyBranchInputEnvelope = {
    data: UnitRoomCreateManyBranchInput | UnitRoomCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UnitResourceCreateWithoutBranchInput = {
    id?: string
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutResourcesInput
    room?: UnitRoomCreateNestedOneWithoutResourcesInput
    bookings?: ProcedureBookingCreateNestedManyWithoutResourceInput
  }

  export type UnitResourceUncheckedCreateWithoutBranchInput = {
    id?: string
    unitId: string
    roomId?: string | null
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ProcedureBookingUncheckedCreateNestedManyWithoutResourceInput
  }

  export type UnitResourceCreateOrConnectWithoutBranchInput = {
    where: UnitResourceWhereUniqueInput
    create: XOR<UnitResourceCreateWithoutBranchInput, UnitResourceUncheckedCreateWithoutBranchInput>
  }

  export type UnitResourceCreateManyBranchInputEnvelope = {
    data: UnitResourceCreateManyBranchInput | UnitResourceCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentAssetCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerDepartment?: DepartmentCreateNestedOneWithoutEquipmentOwnedInput
    unit?: UnitCreateNestedOneWithoutEquipmentInput
    room?: UnitRoomCreateNestedOneWithoutEquipmentInput
    locationNode?: LocationNodeCreateNestedOneWithoutEquipmentAssetInput
    downtimeTickets?: DowntimeTicketCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    ownerDepartmentId?: string | null
    unitId?: string | null
    roomId?: string | null
    locationNodeId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    downtimeTickets?: DowntimeTicketUncheckedCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetCreateOrConnectWithoutBranchInput = {
    where: EquipmentAssetWhereUniqueInput
    create: XOR<EquipmentAssetCreateWithoutBranchInput, EquipmentAssetUncheckedCreateWithoutBranchInput>
  }

  export type EquipmentAssetCreateManyBranchInputEnvelope = {
    data: EquipmentAssetCreateManyBranchInput | EquipmentAssetCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ServiceItemCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mappings?: ServiceChargeMappingCreateNestedManyWithoutServiceItemInput
    fixIts?: FixItTaskCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutServiceItemInput
    fixIts?: FixItTaskUncheckedCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemCreateOrConnectWithoutBranchInput = {
    where: ServiceItemWhereUniqueInput
    create: XOR<ServiceItemCreateWithoutBranchInput, ServiceItemUncheckedCreateWithoutBranchInput>
  }

  export type ServiceItemCreateManyBranchInputEnvelope = {
    data: ServiceItemCreateManyBranchInput | ServiceItemCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ChargeMasterItemCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    category?: string | null
    unit?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mappings?: ServiceChargeMappingCreateNestedManyWithoutChargeMasterItemInput
  }

  export type ChargeMasterItemUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    category?: string | null
    unit?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutChargeMasterItemInput
  }

  export type ChargeMasterItemCreateOrConnectWithoutBranchInput = {
    where: ChargeMasterItemWhereUniqueInput
    create: XOR<ChargeMasterItemCreateWithoutBranchInput, ChargeMasterItemUncheckedCreateWithoutBranchInput>
  }

  export type ChargeMasterItemCreateManyBranchInputEnvelope = {
    data: ChargeMasterItemCreateManyBranchInput | ChargeMasterItemCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ServiceChargeMappingCreateWithoutBranchInput = {
    id?: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceItem: ServiceItemCreateNestedOneWithoutMappingsInput
    chargeMasterItem: ChargeMasterItemCreateNestedOneWithoutMappingsInput
  }

  export type ServiceChargeMappingUncheckedCreateWithoutBranchInput = {
    id?: string
    serviceItemId: string
    chargeMasterItemId: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceChargeMappingCreateOrConnectWithoutBranchInput = {
    where: ServiceChargeMappingWhereUniqueInput
    create: XOR<ServiceChargeMappingCreateWithoutBranchInput, ServiceChargeMappingUncheckedCreateWithoutBranchInput>
  }

  export type ServiceChargeMappingCreateManyBranchInputEnvelope = {
    data: ServiceChargeMappingCreateManyBranchInput | ServiceChargeMappingCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type FixItTaskCreateWithoutBranchInput = {
    id?: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceItem?: ServiceItemCreateNestedOneWithoutFixItsInput
    assignedToUser?: UserCreateNestedOneWithoutAssignedFixItsInput
  }

  export type FixItTaskUncheckedCreateWithoutBranchInput = {
    id?: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: string | null
    assignedToUserId?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixItTaskCreateOrConnectWithoutBranchInput = {
    where: FixItTaskWhereUniqueInput
    create: XOR<FixItTaskCreateWithoutBranchInput, FixItTaskUncheckedCreateWithoutBranchInput>
  }

  export type FixItTaskCreateManyBranchInputEnvelope = {
    data: FixItTaskCreateManyBranchInput | FixItTaskCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type BulkImportJobCreateWithoutBranchInput = {
    id?: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: number
    validRows?: number
    invalidRows?: number
    committedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUser?: UserCreateNestedOneWithoutCreatedImportJobsInput
  }

  export type BulkImportJobUncheckedCreateWithoutBranchInput = {
    id?: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: number
    validRows?: number
    invalidRows?: number
    createdByUserId?: string | null
    committedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BulkImportJobCreateOrConnectWithoutBranchInput = {
    where: BulkImportJobWhereUniqueInput
    create: XOR<BulkImportJobCreateWithoutBranchInput, BulkImportJobUncheckedCreateWithoutBranchInput>
  }

  export type BulkImportJobCreateManyBranchInputEnvelope = {
    data: BulkImportJobCreateManyBranchInput | BulkImportJobCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type ProcedureBookingCreateWithoutBranchInput = {
    id?: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutBookingsInput
    resource: UnitResourceCreateNestedOneWithoutBookingsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedBookingsInput
  }

  export type ProcedureBookingUncheckedCreateWithoutBranchInput = {
    id?: string
    unitId: string
    resourceId: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureBookingCreateOrConnectWithoutBranchInput = {
    where: ProcedureBookingWhereUniqueInput
    create: XOR<ProcedureBookingCreateWithoutBranchInput, ProcedureBookingUncheckedCreateWithoutBranchInput>
  }

  export type ProcedureBookingCreateManyBranchInputEnvelope = {
    data: ProcedureBookingCreateManyBranchInput | ProcedureBookingCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type GoLiveReportCreateWithoutBranchInput = {
    id?: string
    score: number
    blockers: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    createdByUser?: UserCreateNestedOneWithoutCreatedGoLiveReportsInput
  }

  export type GoLiveReportUncheckedCreateWithoutBranchInput = {
    id?: string
    score: number
    blockers: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    snapshot: JsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type GoLiveReportCreateOrConnectWithoutBranchInput = {
    where: GoLiveReportWhereUniqueInput
    create: XOR<GoLiveReportCreateWithoutBranchInput, GoLiveReportUncheckedCreateWithoutBranchInput>
  }

  export type GoLiveReportCreateManyBranchInputEnvelope = {
    data: GoLiveReportCreateManyBranchInput | GoLiveReportCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithWhereUniqueWithoutBranchInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutBranchInput, DepartmentUncheckedUpdateWithoutBranchInput>
    create: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutBranchInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutBranchInput, DepartmentUncheckedUpdateWithoutBranchInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutBranchInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutBranchInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    branchId?: StringFilter<"Department"> | string
    facilityId?: StringFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    headStaffId?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    branchId?: StringNullableFilter<"User"> | string | null
    staffId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    passwordHash?: StringNullableFilter<"User"> | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    roleVersionId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type PatientUpsertWithWhereUniqueWithoutBranchInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutBranchInput, PatientUncheckedUpdateWithoutBranchInput>
    create: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutBranchInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutBranchInput, PatientUncheckedUpdateWithoutBranchInput>
  }

  export type PatientUpdateManyWithWhereWithoutBranchInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutBranchInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: StringFilter<"Patient"> | string
    branchId?: StringFilter<"Patient"> | string
    uhid?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    dob?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
  }

  export type WardUpsertWithWhereUniqueWithoutBranchInput = {
    where: WardWhereUniqueInput
    update: XOR<WardUpdateWithoutBranchInput, WardUncheckedUpdateWithoutBranchInput>
    create: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput>
  }

  export type WardUpdateWithWhereUniqueWithoutBranchInput = {
    where: WardWhereUniqueInput
    data: XOR<WardUpdateWithoutBranchInput, WardUncheckedUpdateWithoutBranchInput>
  }

  export type WardUpdateManyWithWhereWithoutBranchInput = {
    where: WardScalarWhereInput
    data: XOR<WardUpdateManyMutationInput, WardUncheckedUpdateManyWithoutBranchInput>
  }

  export type WardScalarWhereInput = {
    AND?: WardScalarWhereInput | WardScalarWhereInput[]
    OR?: WardScalarWhereInput[]
    NOT?: WardScalarWhereInput | WardScalarWhereInput[]
    id?: StringFilter<"Ward"> | string
    branchId?: StringFilter<"Ward"> | string
    code?: StringFilter<"Ward"> | string
    name?: StringFilter<"Ward"> | string
    specialty?: StringNullableFilter<"Ward"> | string | null
    isActive?: BoolFilter<"Ward"> | boolean
    createdAt?: DateTimeFilter<"Ward"> | Date | string
    updatedAt?: DateTimeFilter<"Ward"> | Date | string
  }

  export type OTUpsertWithWhereUniqueWithoutBranchInput = {
    where: OTWhereUniqueInput
    update: XOR<OTUpdateWithoutBranchInput, OTUncheckedUpdateWithoutBranchInput>
    create: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput>
  }

  export type OTUpdateWithWhereUniqueWithoutBranchInput = {
    where: OTWhereUniqueInput
    data: XOR<OTUpdateWithoutBranchInput, OTUncheckedUpdateWithoutBranchInput>
  }

  export type OTUpdateManyWithWhereWithoutBranchInput = {
    where: OTScalarWhereInput
    data: XOR<OTUpdateManyMutationInput, OTUncheckedUpdateManyWithoutBranchInput>
  }

  export type OTScalarWhereInput = {
    AND?: OTScalarWhereInput | OTScalarWhereInput[]
    OR?: OTScalarWhereInput[]
    NOT?: OTScalarWhereInput | OTScalarWhereInput[]
    id?: StringFilter<"OT"> | string
    branchId?: StringFilter<"OT"> | string
    code?: StringFilter<"OT"> | string
    name?: StringFilter<"OT"> | string
    isActive?: BoolFilter<"OT"> | boolean
    createdAt?: DateTimeFilter<"OT"> | Date | string
    updatedAt?: DateTimeFilter<"OT"> | Date | string
  }

  export type TariffPlanUpsertWithWhereUniqueWithoutBranchInput = {
    where: TariffPlanWhereUniqueInput
    update: XOR<TariffPlanUpdateWithoutBranchInput, TariffPlanUncheckedUpdateWithoutBranchInput>
    create: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput>
  }

  export type TariffPlanUpdateWithWhereUniqueWithoutBranchInput = {
    where: TariffPlanWhereUniqueInput
    data: XOR<TariffPlanUpdateWithoutBranchInput, TariffPlanUncheckedUpdateWithoutBranchInput>
  }

  export type TariffPlanUpdateManyWithWhereWithoutBranchInput = {
    where: TariffPlanScalarWhereInput
    data: XOR<TariffPlanUpdateManyMutationInput, TariffPlanUncheckedUpdateManyWithoutBranchInput>
  }

  export type TariffPlanScalarWhereInput = {
    AND?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
    OR?: TariffPlanScalarWhereInput[]
    NOT?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
    id?: StringFilter<"TariffPlan"> | string
    branchId?: StringFilter<"TariffPlan"> | string
    code?: StringFilter<"TariffPlan"> | string
    name?: StringFilter<"TariffPlan"> | string
    status?: StringFilter<"TariffPlan"> | string
    payerType?: StringFilter<"TariffPlan"> | string
    effectiveFrom?: DateTimeFilter<"TariffPlan"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TariffPlan"> | Date | string
  }

  export type AssetUpsertWithWhereUniqueWithoutBranchInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutBranchInput, AssetUncheckedUpdateWithoutBranchInput>
    create: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutBranchInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutBranchInput, AssetUncheckedUpdateWithoutBranchInput>
  }

  export type AssetUpdateManyWithWhereWithoutBranchInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutBranchInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: StringFilter<"Asset"> | string
    branchId?: StringFilter<"Asset"> | string
    code?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    category?: StringFilter<"Asset"> | string
    location?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
  }

  export type SpecialtyUpsertWithWhereUniqueWithoutBranchInput = {
    where: SpecialtyWhereUniqueInput
    update: XOR<SpecialtyUpdateWithoutBranchInput, SpecialtyUncheckedUpdateWithoutBranchInput>
    create: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput>
  }

  export type SpecialtyUpdateWithWhereUniqueWithoutBranchInput = {
    where: SpecialtyWhereUniqueInput
    data: XOR<SpecialtyUpdateWithoutBranchInput, SpecialtyUncheckedUpdateWithoutBranchInput>
  }

  export type SpecialtyUpdateManyWithWhereWithoutBranchInput = {
    where: SpecialtyScalarWhereInput
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyWithoutBranchInput>
  }

  export type SpecialtyScalarWhereInput = {
    AND?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
    OR?: SpecialtyScalarWhereInput[]
    NOT?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
    id?: StringFilter<"Specialty"> | string
    branchId?: StringFilter<"Specialty"> | string
    code?: StringFilter<"Specialty"> | string
    name?: StringFilter<"Specialty"> | string
    isActive?: BoolFilter<"Specialty"> | boolean
    createdAt?: DateTimeFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeFilter<"Specialty"> | Date | string
  }

  export type StaffUpsertWithWhereUniqueWithoutBranchInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutBranchInput, StaffUncheckedUpdateWithoutBranchInput>
    create: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutBranchInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutBranchInput, StaffUncheckedUpdateWithoutBranchInput>
  }

  export type StaffUpdateManyWithWhereWithoutBranchInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutBranchInput>
  }

  export type StaffScalarWhereInput = {
    AND?: StaffScalarWhereInput | StaffScalarWhereInput[]
    OR?: StaffScalarWhereInput[]
    NOT?: StaffScalarWhereInput | StaffScalarWhereInput[]
    id?: StringFilter<"Staff"> | string
    branchId?: StringFilter<"Staff"> | string
    departmentId?: StringNullableFilter<"Staff"> | string | null
    specialtyId?: StringNullableFilter<"Staff"> | string | null
    empCode?: StringFilter<"Staff"> | string
    name?: StringFilter<"Staff"> | string
    designation?: StringFilter<"Staff"> | string
    phone?: StringNullableFilter<"Staff"> | string | null
    email?: StringNullableFilter<"Staff"> | string | null
    isActive?: BoolFilter<"Staff"> | boolean
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
  }

  export type EncounterUpsertWithWhereUniqueWithoutBranchInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutBranchInput, EncounterUncheckedUpdateWithoutBranchInput>
    create: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutBranchInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutBranchInput, EncounterUncheckedUpdateWithoutBranchInput>
  }

  export type EncounterUpdateManyWithWhereWithoutBranchInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutBranchInput>
  }

  export type EncounterScalarWhereInput = {
    AND?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    OR?: EncounterScalarWhereInput[]
    NOT?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    id?: StringFilter<"Encounter"> | string
    branchId?: StringFilter<"Encounter"> | string
    patientId?: StringFilter<"Encounter"> | string
    type?: EnumEncounterTypeFilter<"Encounter"> | $Enums.EncounterType
    startedAt?: DateTimeFilter<"Encounter"> | Date | string
    endedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    status?: StringFilter<"Encounter"> | string
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
  }

  export type BedUpsertWithWhereUniqueWithoutBranchInput = {
    where: BedWhereUniqueInput
    update: XOR<BedUpdateWithoutBranchInput, BedUncheckedUpdateWithoutBranchInput>
    create: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput>
  }

  export type BedUpdateWithWhereUniqueWithoutBranchInput = {
    where: BedWhereUniqueInput
    data: XOR<BedUpdateWithoutBranchInput, BedUncheckedUpdateWithoutBranchInput>
  }

  export type BedUpdateManyWithWhereWithoutBranchInput = {
    where: BedScalarWhereInput
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyWithoutBranchInput>
  }

  export type BedScalarWhereInput = {
    AND?: BedScalarWhereInput | BedScalarWhereInput[]
    OR?: BedScalarWhereInput[]
    NOT?: BedScalarWhereInput | BedScalarWhereInput[]
    id?: StringFilter<"Bed"> | string
    branchId?: StringFilter<"Bed"> | string
    roomId?: StringFilter<"Bed"> | string
    code?: StringFilter<"Bed"> | string
    state?: EnumBedStateFilter<"Bed"> | $Enums.BedState
    isActive?: BoolFilter<"Bed"> | boolean
    createdAt?: DateTimeFilter<"Bed"> | Date | string
    updatedAt?: DateTimeFilter<"Bed"> | Date | string
  }

  export type AdmissionUpsertWithWhereUniqueWithoutBranchInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutBranchInput, AdmissionUncheckedUpdateWithoutBranchInput>
    create: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutBranchInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutBranchInput, AdmissionUncheckedUpdateWithoutBranchInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutBranchInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutBranchInput>
  }

  export type AdmissionScalarWhereInput = {
    AND?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    OR?: AdmissionScalarWhereInput[]
    NOT?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    id?: StringFilter<"Admission"> | string
    branchId?: StringFilter<"Admission"> | string
    encounterId?: StringNullableFilter<"Admission"> | string | null
    patientId?: StringFilter<"Admission"> | string
    bedId?: StringNullableFilter<"Admission"> | string | null
    admittedAt?: DateTimeFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"Admission"> | Date | string | null
    status?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
  }

  export type BranchFacilityUpsertWithWhereUniqueWithoutBranchInput = {
    where: BranchFacilityWhereUniqueInput
    update: XOR<BranchFacilityUpdateWithoutBranchInput, BranchFacilityUncheckedUpdateWithoutBranchInput>
    create: XOR<BranchFacilityCreateWithoutBranchInput, BranchFacilityUncheckedCreateWithoutBranchInput>
  }

  export type BranchFacilityUpdateWithWhereUniqueWithoutBranchInput = {
    where: BranchFacilityWhereUniqueInput
    data: XOR<BranchFacilityUpdateWithoutBranchInput, BranchFacilityUncheckedUpdateWithoutBranchInput>
  }

  export type BranchFacilityUpdateManyWithWhereWithoutBranchInput = {
    where: BranchFacilityScalarWhereInput
    data: XOR<BranchFacilityUpdateManyMutationInput, BranchFacilityUncheckedUpdateManyWithoutBranchInput>
  }

  export type BranchFacilityScalarWhereInput = {
    AND?: BranchFacilityScalarWhereInput | BranchFacilityScalarWhereInput[]
    OR?: BranchFacilityScalarWhereInput[]
    NOT?: BranchFacilityScalarWhereInput | BranchFacilityScalarWhereInput[]
    id?: StringFilter<"BranchFacility"> | string
    branchId?: StringFilter<"BranchFacility"> | string
    facilityId?: StringFilter<"BranchFacility"> | string
    isEnabled?: BoolFilter<"BranchFacility"> | boolean
    enabledAt?: DateTimeFilter<"BranchFacility"> | Date | string
    createdAt?: DateTimeFilter<"BranchFacility"> | Date | string
    updatedAt?: DateTimeFilter<"BranchFacility"> | Date | string
  }

  export type RoomUpsertWithWhereUniqueWithoutBranchInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutBranchInput, RoomUncheckedUpdateWithoutBranchInput>
    create: XOR<RoomCreateWithoutBranchInput, RoomUncheckedCreateWithoutBranchInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutBranchInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutBranchInput, RoomUncheckedUpdateWithoutBranchInput>
  }

  export type RoomUpdateManyWithWhereWithoutBranchInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutBranchInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: StringFilter<"Room"> | string
    branchId?: StringFilter<"Room"> | string
    wardId?: StringFilter<"Room"> | string
    code?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    floor?: StringNullableFilter<"Room"> | string | null
    type?: StringNullableFilter<"Room"> | string | null
    isActive?: BoolFilter<"Room"> | boolean
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
  }

  export type StatutoryCaseUpsertWithWhereUniqueWithoutBranchInput = {
    where: StatutoryCaseWhereUniqueInput
    update: XOR<StatutoryCaseUpdateWithoutBranchInput, StatutoryCaseUncheckedUpdateWithoutBranchInput>
    create: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput>
  }

  export type StatutoryCaseUpdateWithWhereUniqueWithoutBranchInput = {
    where: StatutoryCaseWhereUniqueInput
    data: XOR<StatutoryCaseUpdateWithoutBranchInput, StatutoryCaseUncheckedUpdateWithoutBranchInput>
  }

  export type StatutoryCaseUpdateManyWithWhereWithoutBranchInput = {
    where: StatutoryCaseScalarWhereInput
    data: XOR<StatutoryCaseUpdateManyMutationInput, StatutoryCaseUncheckedUpdateManyWithoutBranchInput>
  }

  export type StatutoryCaseScalarWhereInput = {
    AND?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
    OR?: StatutoryCaseScalarWhereInput[]
    NOT?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
    id?: StringFilter<"StatutoryCase"> | string
    branchId?: StringFilter<"StatutoryCase"> | string
    patientId?: StringFilter<"StatutoryCase"> | string
    program?: StringFilter<"StatutoryCase"> | string
    disease?: StringFilter<"StatutoryCase"> | string
    status?: StringFilter<"StatutoryCase"> | string
    createdAt?: DateTimeFilter<"StatutoryCase"> | Date | string
    updatedAt?: DateTimeFilter<"StatutoryCase"> | Date | string
  }

  export type AuditEventUpsertWithWhereUniqueWithoutBranchInput = {
    where: AuditEventWhereUniqueInput
    update: XOR<AuditEventUpdateWithoutBranchInput, AuditEventUncheckedUpdateWithoutBranchInput>
    create: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput>
  }

  export type AuditEventUpdateWithWhereUniqueWithoutBranchInput = {
    where: AuditEventWhereUniqueInput
    data: XOR<AuditEventUpdateWithoutBranchInput, AuditEventUncheckedUpdateWithoutBranchInput>
  }

  export type AuditEventUpdateManyWithWhereWithoutBranchInput = {
    where: AuditEventScalarWhereInput
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyWithoutBranchInput>
  }

  export type AuditEventScalarWhereInput = {
    AND?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
    OR?: AuditEventScalarWhereInput[]
    NOT?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
    id?: StringFilter<"AuditEvent"> | string
    branchId?: StringNullableFilter<"AuditEvent"> | string | null
    actorUserId?: StringNullableFilter<"AuditEvent"> | string | null
    action?: StringFilter<"AuditEvent"> | string
    entity?: StringFilter<"AuditEvent"> | string
    entityId?: StringNullableFilter<"AuditEvent"> | string | null
    meta?: JsonNullableFilter<"AuditEvent">
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
  }

  export type PolicyVersionUpsertWithWhereUniqueWithoutBranchInput = {
    where: PolicyVersionWhereUniqueInput
    update: XOR<PolicyVersionUpdateWithoutBranchInput, PolicyVersionUncheckedUpdateWithoutBranchInput>
    create: XOR<PolicyVersionCreateWithoutBranchInput, PolicyVersionUncheckedCreateWithoutBranchInput>
  }

  export type PolicyVersionUpdateWithWhereUniqueWithoutBranchInput = {
    where: PolicyVersionWhereUniqueInput
    data: XOR<PolicyVersionUpdateWithoutBranchInput, PolicyVersionUncheckedUpdateWithoutBranchInput>
  }

  export type PolicyVersionUpdateManyWithWhereWithoutBranchInput = {
    where: PolicyVersionScalarWhereInput
    data: XOR<PolicyVersionUpdateManyMutationInput, PolicyVersionUncheckedUpdateManyWithoutBranchInput>
  }

  export type PolicyVersionScalarWhereInput = {
    AND?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
    OR?: PolicyVersionScalarWhereInput[]
    NOT?: PolicyVersionScalarWhereInput | PolicyVersionScalarWhereInput[]
    id?: StringFilter<"PolicyVersion"> | string
    policyId?: StringFilter<"PolicyVersion"> | string
    scope?: EnumPolicyScopeFilter<"PolicyVersion"> | $Enums.PolicyScope
    branchId?: StringNullableFilter<"PolicyVersion"> | string | null
    version?: IntFilter<"PolicyVersion"> | number
    status?: EnumPolicyVersionStatusFilter<"PolicyVersion"> | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFilter<"PolicyVersion"> | Date | string
    notes?: StringNullableFilter<"PolicyVersion"> | string | null
    payload?: JsonFilter<"PolicyVersion">
    applyToAllBranches?: BoolFilter<"PolicyVersion"> | boolean
    createdByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    submittedAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    submittedByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    approvedAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    approvedByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    approvalNote?: StringNullableFilter<"PolicyVersion"> | string | null
    rejectedAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    rejectedByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    rejectionReason?: StringNullableFilter<"PolicyVersion"> | string | null
    retiredAt?: DateTimeNullableFilter<"PolicyVersion"> | Date | string | null
    retiredByUserId?: StringNullableFilter<"PolicyVersion"> | string | null
    createdAt?: DateTimeFilter<"PolicyVersion"> | Date | string
    updatedAt?: DateTimeFilter<"PolicyVersion"> | Date | string
  }

  export type PolicyVersionBranchUpsertWithWhereUniqueWithoutBranchInput = {
    where: PolicyVersionBranchWhereUniqueInput
    update: XOR<PolicyVersionBranchUpdateWithoutBranchInput, PolicyVersionBranchUncheckedUpdateWithoutBranchInput>
    create: XOR<PolicyVersionBranchCreateWithoutBranchInput, PolicyVersionBranchUncheckedCreateWithoutBranchInput>
  }

  export type PolicyVersionBranchUpdateWithWhereUniqueWithoutBranchInput = {
    where: PolicyVersionBranchWhereUniqueInput
    data: XOR<PolicyVersionBranchUpdateWithoutBranchInput, PolicyVersionBranchUncheckedUpdateWithoutBranchInput>
  }

  export type PolicyVersionBranchUpdateManyWithWhereWithoutBranchInput = {
    where: PolicyVersionBranchScalarWhereInput
    data: XOR<PolicyVersionBranchUpdateManyMutationInput, PolicyVersionBranchUncheckedUpdateManyWithoutBranchInput>
  }

  export type PolicyVersionBranchScalarWhereInput = {
    AND?: PolicyVersionBranchScalarWhereInput | PolicyVersionBranchScalarWhereInput[]
    OR?: PolicyVersionBranchScalarWhereInput[]
    NOT?: PolicyVersionBranchScalarWhereInput | PolicyVersionBranchScalarWhereInput[]
    id?: StringFilter<"PolicyVersionBranch"> | string
    policyVersionId?: StringFilter<"PolicyVersionBranch"> | string
    branchId?: StringFilter<"PolicyVersionBranch"> | string
    createdAt?: DateTimeFilter<"PolicyVersionBranch"> | Date | string
  }

  export type LocationNodeUpsertWithWhereUniqueWithoutBranchInput = {
    where: LocationNodeWhereUniqueInput
    update: XOR<LocationNodeUpdateWithoutBranchInput, LocationNodeUncheckedUpdateWithoutBranchInput>
    create: XOR<LocationNodeCreateWithoutBranchInput, LocationNodeUncheckedCreateWithoutBranchInput>
  }

  export type LocationNodeUpdateWithWhereUniqueWithoutBranchInput = {
    where: LocationNodeWhereUniqueInput
    data: XOR<LocationNodeUpdateWithoutBranchInput, LocationNodeUncheckedUpdateWithoutBranchInput>
  }

  export type LocationNodeUpdateManyWithWhereWithoutBranchInput = {
    where: LocationNodeScalarWhereInput
    data: XOR<LocationNodeUpdateManyMutationInput, LocationNodeUncheckedUpdateManyWithoutBranchInput>
  }

  export type LocationNodeScalarWhereInput = {
    AND?: LocationNodeScalarWhereInput | LocationNodeScalarWhereInput[]
    OR?: LocationNodeScalarWhereInput[]
    NOT?: LocationNodeScalarWhereInput | LocationNodeScalarWhereInput[]
    id?: StringFilter<"LocationNode"> | string
    branchId?: StringFilter<"LocationNode"> | string
    kind?: EnumLocationKindFilter<"LocationNode"> | $Enums.LocationKind
    parentId?: StringNullableFilter<"LocationNode"> | string | null
    createdAt?: DateTimeFilter<"LocationNode"> | Date | string
    updatedAt?: DateTimeFilter<"LocationNode"> | Date | string
  }

  export type BranchUnitTypeUpsertWithWhereUniqueWithoutBranchInput = {
    where: BranchUnitTypeWhereUniqueInput
    update: XOR<BranchUnitTypeUpdateWithoutBranchInput, BranchUnitTypeUncheckedUpdateWithoutBranchInput>
    create: XOR<BranchUnitTypeCreateWithoutBranchInput, BranchUnitTypeUncheckedCreateWithoutBranchInput>
  }

  export type BranchUnitTypeUpdateWithWhereUniqueWithoutBranchInput = {
    where: BranchUnitTypeWhereUniqueInput
    data: XOR<BranchUnitTypeUpdateWithoutBranchInput, BranchUnitTypeUncheckedUpdateWithoutBranchInput>
  }

  export type BranchUnitTypeUpdateManyWithWhereWithoutBranchInput = {
    where: BranchUnitTypeScalarWhereInput
    data: XOR<BranchUnitTypeUpdateManyMutationInput, BranchUnitTypeUncheckedUpdateManyWithoutBranchInput>
  }

  export type BranchUnitTypeScalarWhereInput = {
    AND?: BranchUnitTypeScalarWhereInput | BranchUnitTypeScalarWhereInput[]
    OR?: BranchUnitTypeScalarWhereInput[]
    NOT?: BranchUnitTypeScalarWhereInput | BranchUnitTypeScalarWhereInput[]
    id?: StringFilter<"BranchUnitType"> | string
    branchId?: StringFilter<"BranchUnitType"> | string
    unitTypeId?: StringFilter<"BranchUnitType"> | string
    isEnabled?: BoolFilter<"BranchUnitType"> | boolean
    enabledAt?: DateTimeFilter<"BranchUnitType"> | Date | string
    createdAt?: DateTimeFilter<"BranchUnitType"> | Date | string
    updatedAt?: DateTimeFilter<"BranchUnitType"> | Date | string
  }

  export type UnitUpsertWithWhereUniqueWithoutBranchInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutBranchInput, UnitUncheckedUpdateWithoutBranchInput>
    create: XOR<UnitCreateWithoutBranchInput, UnitUncheckedCreateWithoutBranchInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutBranchInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutBranchInput, UnitUncheckedUpdateWithoutBranchInput>
  }

  export type UnitUpdateManyWithWhereWithoutBranchInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutBranchInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: StringFilter<"Unit"> | string
    branchId?: StringFilter<"Unit"> | string
    departmentId?: StringFilter<"Unit"> | string
    unitTypeId?: StringFilter<"Unit"> | string
    code?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    usesRooms?: BoolFilter<"Unit"> | boolean
    isActive?: BoolFilter<"Unit"> | boolean
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
  }

  export type UnitRoomUpsertWithWhereUniqueWithoutBranchInput = {
    where: UnitRoomWhereUniqueInput
    update: XOR<UnitRoomUpdateWithoutBranchInput, UnitRoomUncheckedUpdateWithoutBranchInput>
    create: XOR<UnitRoomCreateWithoutBranchInput, UnitRoomUncheckedCreateWithoutBranchInput>
  }

  export type UnitRoomUpdateWithWhereUniqueWithoutBranchInput = {
    where: UnitRoomWhereUniqueInput
    data: XOR<UnitRoomUpdateWithoutBranchInput, UnitRoomUncheckedUpdateWithoutBranchInput>
  }

  export type UnitRoomUpdateManyWithWhereWithoutBranchInput = {
    where: UnitRoomScalarWhereInput
    data: XOR<UnitRoomUpdateManyMutationInput, UnitRoomUncheckedUpdateManyWithoutBranchInput>
  }

  export type UnitRoomScalarWhereInput = {
    AND?: UnitRoomScalarWhereInput | UnitRoomScalarWhereInput[]
    OR?: UnitRoomScalarWhereInput[]
    NOT?: UnitRoomScalarWhereInput | UnitRoomScalarWhereInput[]
    id?: StringFilter<"UnitRoom"> | string
    unitId?: StringFilter<"UnitRoom"> | string
    branchId?: StringFilter<"UnitRoom"> | string
    code?: StringFilter<"UnitRoom"> | string
    name?: StringFilter<"UnitRoom"> | string
    isActive?: BoolFilter<"UnitRoom"> | boolean
    createdAt?: DateTimeFilter<"UnitRoom"> | Date | string
    updatedAt?: DateTimeFilter<"UnitRoom"> | Date | string
  }

  export type UnitResourceUpsertWithWhereUniqueWithoutBranchInput = {
    where: UnitResourceWhereUniqueInput
    update: XOR<UnitResourceUpdateWithoutBranchInput, UnitResourceUncheckedUpdateWithoutBranchInput>
    create: XOR<UnitResourceCreateWithoutBranchInput, UnitResourceUncheckedCreateWithoutBranchInput>
  }

  export type UnitResourceUpdateWithWhereUniqueWithoutBranchInput = {
    where: UnitResourceWhereUniqueInput
    data: XOR<UnitResourceUpdateWithoutBranchInput, UnitResourceUncheckedUpdateWithoutBranchInput>
  }

  export type UnitResourceUpdateManyWithWhereWithoutBranchInput = {
    where: UnitResourceScalarWhereInput
    data: XOR<UnitResourceUpdateManyMutationInput, UnitResourceUncheckedUpdateManyWithoutBranchInput>
  }

  export type UnitResourceScalarWhereInput = {
    AND?: UnitResourceScalarWhereInput | UnitResourceScalarWhereInput[]
    OR?: UnitResourceScalarWhereInput[]
    NOT?: UnitResourceScalarWhereInput | UnitResourceScalarWhereInput[]
    id?: StringFilter<"UnitResource"> | string
    branchId?: StringFilter<"UnitResource"> | string
    unitId?: StringFilter<"UnitResource"> | string
    roomId?: StringNullableFilter<"UnitResource"> | string | null
    resourceType?: EnumUnitResourceTypeFilter<"UnitResource"> | $Enums.UnitResourceType
    code?: StringFilter<"UnitResource"> | string
    name?: StringFilter<"UnitResource"> | string
    state?: EnumUnitResourceStateFilter<"UnitResource"> | $Enums.UnitResourceState
    isActive?: BoolFilter<"UnitResource"> | boolean
    isSchedulable?: BoolFilter<"UnitResource"> | boolean
    createdAt?: DateTimeFilter<"UnitResource"> | Date | string
    updatedAt?: DateTimeFilter<"UnitResource"> | Date | string
  }

  export type EquipmentAssetUpsertWithWhereUniqueWithoutBranchInput = {
    where: EquipmentAssetWhereUniqueInput
    update: XOR<EquipmentAssetUpdateWithoutBranchInput, EquipmentAssetUncheckedUpdateWithoutBranchInput>
    create: XOR<EquipmentAssetCreateWithoutBranchInput, EquipmentAssetUncheckedCreateWithoutBranchInput>
  }

  export type EquipmentAssetUpdateWithWhereUniqueWithoutBranchInput = {
    where: EquipmentAssetWhereUniqueInput
    data: XOR<EquipmentAssetUpdateWithoutBranchInput, EquipmentAssetUncheckedUpdateWithoutBranchInput>
  }

  export type EquipmentAssetUpdateManyWithWhereWithoutBranchInput = {
    where: EquipmentAssetScalarWhereInput
    data: XOR<EquipmentAssetUpdateManyMutationInput, EquipmentAssetUncheckedUpdateManyWithoutBranchInput>
  }

  export type EquipmentAssetScalarWhereInput = {
    AND?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
    OR?: EquipmentAssetScalarWhereInput[]
    NOT?: EquipmentAssetScalarWhereInput | EquipmentAssetScalarWhereInput[]
    id?: StringFilter<"EquipmentAsset"> | string
    branchId?: StringFilter<"EquipmentAsset"> | string
    code?: StringFilter<"EquipmentAsset"> | string
    name?: StringFilter<"EquipmentAsset"> | string
    category?: EnumEquipmentComplianceCategoryFilter<"EquipmentAsset"> | $Enums.EquipmentComplianceCategory
    make?: StringNullableFilter<"EquipmentAsset"> | string | null
    model?: StringNullableFilter<"EquipmentAsset"> | string | null
    serial?: StringNullableFilter<"EquipmentAsset"> | string | null
    ownerDepartmentId?: StringNullableFilter<"EquipmentAsset"> | string | null
    unitId?: StringNullableFilter<"EquipmentAsset"> | string | null
    roomId?: StringNullableFilter<"EquipmentAsset"> | string | null
    locationNodeId?: StringNullableFilter<"EquipmentAsset"> | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFilter<"EquipmentAsset"> | $Enums.EquipmentOperationalStatus
    amcVendor?: StringNullableFilter<"EquipmentAsset"> | string | null
    amcValidFrom?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    amcValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    warrantyValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    pmFrequencyDays?: IntNullableFilter<"EquipmentAsset"> | number | null
    nextPmDueAt?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    aerbLicenseNo?: StringNullableFilter<"EquipmentAsset"> | string | null
    aerbValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    pcpndtRegNo?: StringNullableFilter<"EquipmentAsset"> | string | null
    pcpndtValidTo?: DateTimeNullableFilter<"EquipmentAsset"> | Date | string | null
    isSchedulable?: BoolFilter<"EquipmentAsset"> | boolean
    createdAt?: DateTimeFilter<"EquipmentAsset"> | Date | string
    updatedAt?: DateTimeFilter<"EquipmentAsset"> | Date | string
  }

  export type ServiceItemUpsertWithWhereUniqueWithoutBranchInput = {
    where: ServiceItemWhereUniqueInput
    update: XOR<ServiceItemUpdateWithoutBranchInput, ServiceItemUncheckedUpdateWithoutBranchInput>
    create: XOR<ServiceItemCreateWithoutBranchInput, ServiceItemUncheckedCreateWithoutBranchInput>
  }

  export type ServiceItemUpdateWithWhereUniqueWithoutBranchInput = {
    where: ServiceItemWhereUniqueInput
    data: XOR<ServiceItemUpdateWithoutBranchInput, ServiceItemUncheckedUpdateWithoutBranchInput>
  }

  export type ServiceItemUpdateManyWithWhereWithoutBranchInput = {
    where: ServiceItemScalarWhereInput
    data: XOR<ServiceItemUpdateManyMutationInput, ServiceItemUncheckedUpdateManyWithoutBranchInput>
  }

  export type ServiceItemScalarWhereInput = {
    AND?: ServiceItemScalarWhereInput | ServiceItemScalarWhereInput[]
    OR?: ServiceItemScalarWhereInput[]
    NOT?: ServiceItemScalarWhereInput | ServiceItemScalarWhereInput[]
    id?: StringFilter<"ServiceItem"> | string
    branchId?: StringFilter<"ServiceItem"> | string
    code?: StringFilter<"ServiceItem"> | string
    name?: StringFilter<"ServiceItem"> | string
    category?: StringFilter<"ServiceItem"> | string
    unit?: StringNullableFilter<"ServiceItem"> | string | null
    isOrderable?: BoolFilter<"ServiceItem"> | boolean
    isActive?: BoolFilter<"ServiceItem"> | boolean
    createdAt?: DateTimeFilter<"ServiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceItem"> | Date | string
  }

  export type ChargeMasterItemUpsertWithWhereUniqueWithoutBranchInput = {
    where: ChargeMasterItemWhereUniqueInput
    update: XOR<ChargeMasterItemUpdateWithoutBranchInput, ChargeMasterItemUncheckedUpdateWithoutBranchInput>
    create: XOR<ChargeMasterItemCreateWithoutBranchInput, ChargeMasterItemUncheckedCreateWithoutBranchInput>
  }

  export type ChargeMasterItemUpdateWithWhereUniqueWithoutBranchInput = {
    where: ChargeMasterItemWhereUniqueInput
    data: XOR<ChargeMasterItemUpdateWithoutBranchInput, ChargeMasterItemUncheckedUpdateWithoutBranchInput>
  }

  export type ChargeMasterItemUpdateManyWithWhereWithoutBranchInput = {
    where: ChargeMasterItemScalarWhereInput
    data: XOR<ChargeMasterItemUpdateManyMutationInput, ChargeMasterItemUncheckedUpdateManyWithoutBranchInput>
  }

  export type ChargeMasterItemScalarWhereInput = {
    AND?: ChargeMasterItemScalarWhereInput | ChargeMasterItemScalarWhereInput[]
    OR?: ChargeMasterItemScalarWhereInput[]
    NOT?: ChargeMasterItemScalarWhereInput | ChargeMasterItemScalarWhereInput[]
    id?: StringFilter<"ChargeMasterItem"> | string
    branchId?: StringFilter<"ChargeMasterItem"> | string
    code?: StringFilter<"ChargeMasterItem"> | string
    name?: StringFilter<"ChargeMasterItem"> | string
    category?: StringNullableFilter<"ChargeMasterItem"> | string | null
    unit?: StringNullableFilter<"ChargeMasterItem"> | string | null
    isActive?: BoolFilter<"ChargeMasterItem"> | boolean
    createdAt?: DateTimeFilter<"ChargeMasterItem"> | Date | string
    updatedAt?: DateTimeFilter<"ChargeMasterItem"> | Date | string
  }

  export type ServiceChargeMappingUpsertWithWhereUniqueWithoutBranchInput = {
    where: ServiceChargeMappingWhereUniqueInput
    update: XOR<ServiceChargeMappingUpdateWithoutBranchInput, ServiceChargeMappingUncheckedUpdateWithoutBranchInput>
    create: XOR<ServiceChargeMappingCreateWithoutBranchInput, ServiceChargeMappingUncheckedCreateWithoutBranchInput>
  }

  export type ServiceChargeMappingUpdateWithWhereUniqueWithoutBranchInput = {
    where: ServiceChargeMappingWhereUniqueInput
    data: XOR<ServiceChargeMappingUpdateWithoutBranchInput, ServiceChargeMappingUncheckedUpdateWithoutBranchInput>
  }

  export type ServiceChargeMappingUpdateManyWithWhereWithoutBranchInput = {
    where: ServiceChargeMappingScalarWhereInput
    data: XOR<ServiceChargeMappingUpdateManyMutationInput, ServiceChargeMappingUncheckedUpdateManyWithoutBranchInput>
  }

  export type ServiceChargeMappingScalarWhereInput = {
    AND?: ServiceChargeMappingScalarWhereInput | ServiceChargeMappingScalarWhereInput[]
    OR?: ServiceChargeMappingScalarWhereInput[]
    NOT?: ServiceChargeMappingScalarWhereInput | ServiceChargeMappingScalarWhereInput[]
    id?: StringFilter<"ServiceChargeMapping"> | string
    branchId?: StringFilter<"ServiceChargeMapping"> | string
    serviceItemId?: StringFilter<"ServiceChargeMapping"> | string
    chargeMasterItemId?: StringFilter<"ServiceChargeMapping"> | string
    effectiveFrom?: DateTimeFilter<"ServiceChargeMapping"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"ServiceChargeMapping"> | Date | string | null
    version?: IntFilter<"ServiceChargeMapping"> | number
    createdAt?: DateTimeFilter<"ServiceChargeMapping"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceChargeMapping"> | Date | string
  }

  export type FixItTaskUpsertWithWhereUniqueWithoutBranchInput = {
    where: FixItTaskWhereUniqueInput
    update: XOR<FixItTaskUpdateWithoutBranchInput, FixItTaskUncheckedUpdateWithoutBranchInput>
    create: XOR<FixItTaskCreateWithoutBranchInput, FixItTaskUncheckedCreateWithoutBranchInput>
  }

  export type FixItTaskUpdateWithWhereUniqueWithoutBranchInput = {
    where: FixItTaskWhereUniqueInput
    data: XOR<FixItTaskUpdateWithoutBranchInput, FixItTaskUncheckedUpdateWithoutBranchInput>
  }

  export type FixItTaskUpdateManyWithWhereWithoutBranchInput = {
    where: FixItTaskScalarWhereInput
    data: XOR<FixItTaskUpdateManyMutationInput, FixItTaskUncheckedUpdateManyWithoutBranchInput>
  }

  export type FixItTaskScalarWhereInput = {
    AND?: FixItTaskScalarWhereInput | FixItTaskScalarWhereInput[]
    OR?: FixItTaskScalarWhereInput[]
    NOT?: FixItTaskScalarWhereInput | FixItTaskScalarWhereInput[]
    id?: StringFilter<"FixItTask"> | string
    branchId?: StringFilter<"FixItTask"> | string
    type?: EnumFixItTypeFilter<"FixItTask"> | $Enums.FixItType
    status?: EnumFixItStatusFilter<"FixItTask"> | $Enums.FixItStatus
    title?: StringFilter<"FixItTask"> | string
    details?: JsonNullableFilter<"FixItTask">
    serviceItemId?: StringNullableFilter<"FixItTask"> | string | null
    assignedToUserId?: StringNullableFilter<"FixItTask"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FixItTask"> | Date | string | null
    createdAt?: DateTimeFilter<"FixItTask"> | Date | string
    updatedAt?: DateTimeFilter<"FixItTask"> | Date | string
  }

  export type BulkImportJobUpsertWithWhereUniqueWithoutBranchInput = {
    where: BulkImportJobWhereUniqueInput
    update: XOR<BulkImportJobUpdateWithoutBranchInput, BulkImportJobUncheckedUpdateWithoutBranchInput>
    create: XOR<BulkImportJobCreateWithoutBranchInput, BulkImportJobUncheckedCreateWithoutBranchInput>
  }

  export type BulkImportJobUpdateWithWhereUniqueWithoutBranchInput = {
    where: BulkImportJobWhereUniqueInput
    data: XOR<BulkImportJobUpdateWithoutBranchInput, BulkImportJobUncheckedUpdateWithoutBranchInput>
  }

  export type BulkImportJobUpdateManyWithWhereWithoutBranchInput = {
    where: BulkImportJobScalarWhereInput
    data: XOR<BulkImportJobUpdateManyMutationInput, BulkImportJobUncheckedUpdateManyWithoutBranchInput>
  }

  export type BulkImportJobScalarWhereInput = {
    AND?: BulkImportJobScalarWhereInput | BulkImportJobScalarWhereInput[]
    OR?: BulkImportJobScalarWhereInput[]
    NOT?: BulkImportJobScalarWhereInput | BulkImportJobScalarWhereInput[]
    id?: StringFilter<"BulkImportJob"> | string
    branchId?: StringFilter<"BulkImportJob"> | string
    entityType?: EnumImportEntityTypeFilter<"BulkImportJob"> | $Enums.ImportEntityType
    status?: EnumImportJobStatusFilter<"BulkImportJob"> | $Enums.ImportJobStatus
    fileName?: StringNullableFilter<"BulkImportJob"> | string | null
    payload?: JsonNullableFilter<"BulkImportJob">
    errors?: JsonNullableFilter<"BulkImportJob">
    totalRows?: IntFilter<"BulkImportJob"> | number
    validRows?: IntFilter<"BulkImportJob"> | number
    invalidRows?: IntFilter<"BulkImportJob"> | number
    createdByUserId?: StringNullableFilter<"BulkImportJob"> | string | null
    committedAt?: DateTimeNullableFilter<"BulkImportJob"> | Date | string | null
    createdAt?: DateTimeFilter<"BulkImportJob"> | Date | string
    updatedAt?: DateTimeFilter<"BulkImportJob"> | Date | string
  }

  export type ProcedureBookingUpsertWithWhereUniqueWithoutBranchInput = {
    where: ProcedureBookingWhereUniqueInput
    update: XOR<ProcedureBookingUpdateWithoutBranchInput, ProcedureBookingUncheckedUpdateWithoutBranchInput>
    create: XOR<ProcedureBookingCreateWithoutBranchInput, ProcedureBookingUncheckedCreateWithoutBranchInput>
  }

  export type ProcedureBookingUpdateWithWhereUniqueWithoutBranchInput = {
    where: ProcedureBookingWhereUniqueInput
    data: XOR<ProcedureBookingUpdateWithoutBranchInput, ProcedureBookingUncheckedUpdateWithoutBranchInput>
  }

  export type ProcedureBookingUpdateManyWithWhereWithoutBranchInput = {
    where: ProcedureBookingScalarWhereInput
    data: XOR<ProcedureBookingUpdateManyMutationInput, ProcedureBookingUncheckedUpdateManyWithoutBranchInput>
  }

  export type ProcedureBookingScalarWhereInput = {
    AND?: ProcedureBookingScalarWhereInput | ProcedureBookingScalarWhereInput[]
    OR?: ProcedureBookingScalarWhereInput[]
    NOT?: ProcedureBookingScalarWhereInput | ProcedureBookingScalarWhereInput[]
    id?: StringFilter<"ProcedureBooking"> | string
    branchId?: StringFilter<"ProcedureBooking"> | string
    unitId?: StringFilter<"ProcedureBooking"> | string
    resourceId?: StringFilter<"ProcedureBooking"> | string
    patientId?: StringNullableFilter<"ProcedureBooking"> | string | null
    departmentId?: StringNullableFilter<"ProcedureBooking"> | string | null
    startAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
    endAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
    status?: EnumBookingStatusFilter<"ProcedureBooking"> | $Enums.BookingStatus
    consentOk?: BoolFilter<"ProcedureBooking"> | boolean
    anesthesiaOk?: BoolFilter<"ProcedureBooking"> | boolean
    checklistOk?: BoolFilter<"ProcedureBooking"> | boolean
    createdByUserId?: StringNullableFilter<"ProcedureBooking"> | string | null
    createdAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ProcedureBooking"> | Date | string
  }

  export type GoLiveReportUpsertWithWhereUniqueWithoutBranchInput = {
    where: GoLiveReportWhereUniqueInput
    update: XOR<GoLiveReportUpdateWithoutBranchInput, GoLiveReportUncheckedUpdateWithoutBranchInput>
    create: XOR<GoLiveReportCreateWithoutBranchInput, GoLiveReportUncheckedCreateWithoutBranchInput>
  }

  export type GoLiveReportUpdateWithWhereUniqueWithoutBranchInput = {
    where: GoLiveReportWhereUniqueInput
    data: XOR<GoLiveReportUpdateWithoutBranchInput, GoLiveReportUncheckedUpdateWithoutBranchInput>
  }

  export type GoLiveReportUpdateManyWithWhereWithoutBranchInput = {
    where: GoLiveReportScalarWhereInput
    data: XOR<GoLiveReportUpdateManyMutationInput, GoLiveReportUncheckedUpdateManyWithoutBranchInput>
  }

  export type GoLiveReportScalarWhereInput = {
    AND?: GoLiveReportScalarWhereInput | GoLiveReportScalarWhereInput[]
    OR?: GoLiveReportScalarWhereInput[]
    NOT?: GoLiveReportScalarWhereInput | GoLiveReportScalarWhereInput[]
    id?: StringFilter<"GoLiveReport"> | string
    branchId?: StringFilter<"GoLiveReport"> | string
    score?: IntFilter<"GoLiveReport"> | number
    blockers?: JsonFilter<"GoLiveReport">
    warnings?: JsonFilter<"GoLiveReport">
    snapshot?: JsonFilter<"GoLiveReport">
    createdByUserId?: StringNullableFilter<"GoLiveReport"> | string | null
    createdAt?: DateTimeFilter<"GoLiveReport"> | Date | string
  }

  export type BranchFacilityCreateWithoutFacilityInput = {
    id?: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBranchFacilitiesInput
  }

  export type BranchFacilityUncheckedCreateWithoutFacilityInput = {
    id?: string
    branchId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchFacilityCreateOrConnectWithoutFacilityInput = {
    where: BranchFacilityWhereUniqueInput
    create: XOR<BranchFacilityCreateWithoutFacilityInput, BranchFacilityUncheckedCreateWithoutFacilityInput>
  }

  export type BranchFacilityCreateManyFacilityInputEnvelope = {
    data: BranchFacilityCreateManyFacilityInput | BranchFacilityCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutFacilityInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDepartmentsInput
    headStaff?: StaffCreateNestedOneWithoutHeadedDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutDepartmentInput
    units?: UnitCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutFacilityInput = {
    id?: string
    branchId: string
    code: string
    name: string
    headStaffId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutDepartmentInput
    units?: UnitUncheckedCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetUncheckedCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutFacilityInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutFacilityInput, DepartmentUncheckedCreateWithoutFacilityInput>
  }

  export type DepartmentCreateManyFacilityInputEnvelope = {
    data: DepartmentCreateManyFacilityInput | DepartmentCreateManyFacilityInput[]
    skipDuplicates?: boolean
  }

  export type BranchFacilityUpsertWithWhereUniqueWithoutFacilityInput = {
    where: BranchFacilityWhereUniqueInput
    update: XOR<BranchFacilityUpdateWithoutFacilityInput, BranchFacilityUncheckedUpdateWithoutFacilityInput>
    create: XOR<BranchFacilityCreateWithoutFacilityInput, BranchFacilityUncheckedCreateWithoutFacilityInput>
  }

  export type BranchFacilityUpdateWithWhereUniqueWithoutFacilityInput = {
    where: BranchFacilityWhereUniqueInput
    data: XOR<BranchFacilityUpdateWithoutFacilityInput, BranchFacilityUncheckedUpdateWithoutFacilityInput>
  }

  export type BranchFacilityUpdateManyWithWhereWithoutFacilityInput = {
    where: BranchFacilityScalarWhereInput
    data: XOR<BranchFacilityUpdateManyMutationInput, BranchFacilityUncheckedUpdateManyWithoutFacilityInput>
  }

  export type DepartmentUpsertWithWhereUniqueWithoutFacilityInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutFacilityInput, DepartmentUncheckedUpdateWithoutFacilityInput>
    create: XOR<DepartmentCreateWithoutFacilityInput, DepartmentUncheckedCreateWithoutFacilityInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutFacilityInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutFacilityInput, DepartmentUncheckedUpdateWithoutFacilityInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutFacilityInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutFacilityInput>
  }

  export type BranchCreateWithoutBranchFacilitiesInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutBranchFacilitiesInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutBranchFacilitiesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutBranchFacilitiesInput, BranchUncheckedCreateWithoutBranchFacilitiesInput>
  }

  export type FacilityCatalogCreateWithoutBranchLinksInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FacilityCategory
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCatalogUncheckedCreateWithoutBranchLinksInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FacilityCategory
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCatalogCreateOrConnectWithoutBranchLinksInput = {
    where: FacilityCatalogWhereUniqueInput
    create: XOR<FacilityCatalogCreateWithoutBranchLinksInput, FacilityCatalogUncheckedCreateWithoutBranchLinksInput>
  }

  export type BranchUpsertWithoutBranchFacilitiesInput = {
    update: XOR<BranchUpdateWithoutBranchFacilitiesInput, BranchUncheckedUpdateWithoutBranchFacilitiesInput>
    create: XOR<BranchCreateWithoutBranchFacilitiesInput, BranchUncheckedCreateWithoutBranchFacilitiesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutBranchFacilitiesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutBranchFacilitiesInput, BranchUncheckedUpdateWithoutBranchFacilitiesInput>
  }

  export type BranchUpdateWithoutBranchFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutBranchFacilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type FacilityCatalogUpsertWithoutBranchLinksInput = {
    update: XOR<FacilityCatalogUpdateWithoutBranchLinksInput, FacilityCatalogUncheckedUpdateWithoutBranchLinksInput>
    create: XOR<FacilityCatalogCreateWithoutBranchLinksInput, FacilityCatalogUncheckedCreateWithoutBranchLinksInput>
    where?: FacilityCatalogWhereInput
  }

  export type FacilityCatalogUpdateToOneWithWhereWithoutBranchLinksInput = {
    where?: FacilityCatalogWhereInput
    data: XOR<FacilityCatalogUpdateWithoutBranchLinksInput, FacilityCatalogUncheckedUpdateWithoutBranchLinksInput>
  }

  export type FacilityCatalogUpdateWithoutBranchLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFacilityCategoryFieldUpdateOperationsInput | $Enums.FacilityCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityCatalogUncheckedUpdateWithoutBranchLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFacilityCategoryFieldUpdateOperationsInput | $Enums.FacilityCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type BranchCreateWithoutDepartmentsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutDepartmentsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
  }

  export type FacilityCatalogCreateWithoutDepartmentsInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FacilityCategory
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branchLinks?: BranchFacilityCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCatalogUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    code: string
    name: string
    category: $Enums.FacilityCategory
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branchLinks?: BranchFacilityUncheckedCreateNestedManyWithoutFacilityInput
  }

  export type FacilityCatalogCreateOrConnectWithoutDepartmentsInput = {
    where: FacilityCatalogWhereUniqueInput
    create: XOR<FacilityCatalogCreateWithoutDepartmentsInput, FacilityCatalogUncheckedCreateWithoutDepartmentsInput>
  }

  export type StaffCreateWithoutHeadedDepartmentsInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    specialty?: SpecialtyCreateNestedOneWithoutStaffInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutStaffInput
    user?: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutHeadedDepartmentsInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutStaffInput
    user?: UserUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutHeadedDepartmentsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutHeadedDepartmentsInput, StaffUncheckedCreateWithoutHeadedDepartmentsInput>
  }

  export type StaffCreateWithoutDepartmentInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStaffInput
    specialty?: SpecialtyCreateNestedOneWithoutStaffInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutStaffInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadStaffInput
    user?: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutDepartmentInput = {
    id?: string
    branchId: string
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutStaffInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadStaffInput
    user?: UserUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffCreateManyDepartmentInputEnvelope = {
    data: StaffCreateManyDepartmentInput | StaffCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentSpecialtyCreateWithoutDepartmentInput = {
    id?: string
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    specialty: SpecialtyCreateNestedOneWithoutDepartmentLinksInput
  }

  export type DepartmentSpecialtyUncheckedCreateWithoutDepartmentInput = {
    id?: string
    specialtyId: string
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentSpecialtyCreateOrConnectWithoutDepartmentInput = {
    where: DepartmentSpecialtyWhereUniqueInput
    create: XOR<DepartmentSpecialtyCreateWithoutDepartmentInput, DepartmentSpecialtyUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentSpecialtyCreateManyDepartmentInputEnvelope = {
    data: DepartmentSpecialtyCreateManyDepartmentInput | DepartmentSpecialtyCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentDoctorCreateWithoutDepartmentInput = {
    id?: string
    isPrimary?: boolean
    assignedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutDoctorAssignmentsInput
  }

  export type DepartmentDoctorUncheckedCreateWithoutDepartmentInput = {
    id?: string
    staffId: string
    isPrimary?: boolean
    assignedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentDoctorCreateOrConnectWithoutDepartmentInput = {
    where: DepartmentDoctorWhereUniqueInput
    create: XOR<DepartmentDoctorCreateWithoutDepartmentInput, DepartmentDoctorUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentDoctorCreateManyDepartmentInputEnvelope = {
    data: DepartmentDoctorCreateManyDepartmentInput | DepartmentDoctorCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutDepartmentInput = {
    id?: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitsInput
    unitType: UnitTypeCatalogCreateNestedOneWithoutUnitsInput
    rooms?: UnitRoomCreateNestedManyWithoutUnitInput
    resources?: UnitResourceCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutDepartmentInput = {
    id?: string
    branchId: string
    unitTypeId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: UnitRoomUncheckedCreateNestedManyWithoutUnitInput
    resources?: UnitResourceUncheckedCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetUncheckedCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutDepartmentInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput>
  }

  export type UnitCreateManyDepartmentInputEnvelope = {
    data: UnitCreateManyDepartmentInput | UnitCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentAssetCreateWithoutOwnerDepartmentInput = {
    id?: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEquipmentAssetsInput
    unit?: UnitCreateNestedOneWithoutEquipmentInput
    room?: UnitRoomCreateNestedOneWithoutEquipmentInput
    locationNode?: LocationNodeCreateNestedOneWithoutEquipmentAssetInput
    downtimeTickets?: DowntimeTicketCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetUncheckedCreateWithoutOwnerDepartmentInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    unitId?: string | null
    roomId?: string | null
    locationNodeId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    downtimeTickets?: DowntimeTicketUncheckedCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetCreateOrConnectWithoutOwnerDepartmentInput = {
    where: EquipmentAssetWhereUniqueInput
    create: XOR<EquipmentAssetCreateWithoutOwnerDepartmentInput, EquipmentAssetUncheckedCreateWithoutOwnerDepartmentInput>
  }

  export type EquipmentAssetCreateManyOwnerDepartmentInputEnvelope = {
    data: EquipmentAssetCreateManyOwnerDepartmentInput | EquipmentAssetCreateManyOwnerDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutDepartmentsInput = {
    update: XOR<BranchUpdateWithoutDepartmentsInput, BranchUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutDepartmentsInput, BranchUncheckedUpdateWithoutDepartmentsInput>
  }

  export type BranchUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type FacilityCatalogUpsertWithoutDepartmentsInput = {
    update: XOR<FacilityCatalogUpdateWithoutDepartmentsInput, FacilityCatalogUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<FacilityCatalogCreateWithoutDepartmentsInput, FacilityCatalogUncheckedCreateWithoutDepartmentsInput>
    where?: FacilityCatalogWhereInput
  }

  export type FacilityCatalogUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: FacilityCatalogWhereInput
    data: XOR<FacilityCatalogUpdateWithoutDepartmentsInput, FacilityCatalogUncheckedUpdateWithoutDepartmentsInput>
  }

  export type FacilityCatalogUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFacilityCategoryFieldUpdateOperationsInput | $Enums.FacilityCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchLinks?: BranchFacilityUpdateManyWithoutFacilityNestedInput
  }

  export type FacilityCatalogUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumFacilityCategoryFieldUpdateOperationsInput | $Enums.FacilityCategory
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchLinks?: BranchFacilityUncheckedUpdateManyWithoutFacilityNestedInput
  }

  export type StaffUpsertWithoutHeadedDepartmentsInput = {
    update: XOR<StaffUpdateWithoutHeadedDepartmentsInput, StaffUncheckedUpdateWithoutHeadedDepartmentsInput>
    create: XOR<StaffCreateWithoutHeadedDepartmentsInput, StaffUncheckedCreateWithoutHeadedDepartmentsInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutHeadedDepartmentsInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutHeadedDepartmentsInput, StaffUncheckedUpdateWithoutHeadedDepartmentsInput>
  }

  export type StaffUpdateWithoutHeadedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    specialty?: SpecialtyUpdateOneWithoutStaffNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutStaffNestedInput
    user?: UserUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutHeadedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutStaffNestedInput
    user?: UserUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutDepartmentInput, StaffUncheckedUpdateWithoutDepartmentInput>
    create: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutDepartmentInput, StaffUncheckedUpdateWithoutDepartmentInput>
  }

  export type StaffUpdateManyWithWhereWithoutDepartmentInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentSpecialtyUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentSpecialtyWhereUniqueInput
    update: XOR<DepartmentSpecialtyUpdateWithoutDepartmentInput, DepartmentSpecialtyUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DepartmentSpecialtyCreateWithoutDepartmentInput, DepartmentSpecialtyUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentSpecialtyUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentSpecialtyWhereUniqueInput
    data: XOR<DepartmentSpecialtyUpdateWithoutDepartmentInput, DepartmentSpecialtyUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentSpecialtyUpdateManyWithWhereWithoutDepartmentInput = {
    where: DepartmentSpecialtyScalarWhereInput
    data: XOR<DepartmentSpecialtyUpdateManyMutationInput, DepartmentSpecialtyUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentSpecialtyScalarWhereInput = {
    AND?: DepartmentSpecialtyScalarWhereInput | DepartmentSpecialtyScalarWhereInput[]
    OR?: DepartmentSpecialtyScalarWhereInput[]
    NOT?: DepartmentSpecialtyScalarWhereInput | DepartmentSpecialtyScalarWhereInput[]
    id?: StringFilter<"DepartmentSpecialty"> | string
    departmentId?: StringFilter<"DepartmentSpecialty"> | string
    specialtyId?: StringFilter<"DepartmentSpecialty"> | string
    isPrimary?: BoolFilter<"DepartmentSpecialty"> | boolean
    isActive?: BoolFilter<"DepartmentSpecialty"> | boolean
    createdAt?: DateTimeFilter<"DepartmentSpecialty"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentSpecialty"> | Date | string
  }

  export type DepartmentDoctorUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentDoctorWhereUniqueInput
    update: XOR<DepartmentDoctorUpdateWithoutDepartmentInput, DepartmentDoctorUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DepartmentDoctorCreateWithoutDepartmentInput, DepartmentDoctorUncheckedCreateWithoutDepartmentInput>
  }

  export type DepartmentDoctorUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DepartmentDoctorWhereUniqueInput
    data: XOR<DepartmentDoctorUpdateWithoutDepartmentInput, DepartmentDoctorUncheckedUpdateWithoutDepartmentInput>
  }

  export type DepartmentDoctorUpdateManyWithWhereWithoutDepartmentInput = {
    where: DepartmentDoctorScalarWhereInput
    data: XOR<DepartmentDoctorUpdateManyMutationInput, DepartmentDoctorUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentDoctorScalarWhereInput = {
    AND?: DepartmentDoctorScalarWhereInput | DepartmentDoctorScalarWhereInput[]
    OR?: DepartmentDoctorScalarWhereInput[]
    NOT?: DepartmentDoctorScalarWhereInput | DepartmentDoctorScalarWhereInput[]
    id?: StringFilter<"DepartmentDoctor"> | string
    departmentId?: StringFilter<"DepartmentDoctor"> | string
    staffId?: StringFilter<"DepartmentDoctor"> | string
    isPrimary?: BoolFilter<"DepartmentDoctor"> | boolean
    assignedAt?: DateTimeFilter<"DepartmentDoctor"> | Date | string
    createdAt?: DateTimeFilter<"DepartmentDoctor"> | Date | string
    updatedAt?: DateTimeFilter<"DepartmentDoctor"> | Date | string
  }

  export type UnitUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutDepartmentInput, UnitUncheckedUpdateWithoutDepartmentInput>
    create: XOR<UnitCreateWithoutDepartmentInput, UnitUncheckedCreateWithoutDepartmentInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutDepartmentInput, UnitUncheckedUpdateWithoutDepartmentInput>
  }

  export type UnitUpdateManyWithWhereWithoutDepartmentInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type EquipmentAssetUpsertWithWhereUniqueWithoutOwnerDepartmentInput = {
    where: EquipmentAssetWhereUniqueInput
    update: XOR<EquipmentAssetUpdateWithoutOwnerDepartmentInput, EquipmentAssetUncheckedUpdateWithoutOwnerDepartmentInput>
    create: XOR<EquipmentAssetCreateWithoutOwnerDepartmentInput, EquipmentAssetUncheckedCreateWithoutOwnerDepartmentInput>
  }

  export type EquipmentAssetUpdateWithWhereUniqueWithoutOwnerDepartmentInput = {
    where: EquipmentAssetWhereUniqueInput
    data: XOR<EquipmentAssetUpdateWithoutOwnerDepartmentInput, EquipmentAssetUncheckedUpdateWithoutOwnerDepartmentInput>
  }

  export type EquipmentAssetUpdateManyWithWhereWithoutOwnerDepartmentInput = {
    where: EquipmentAssetScalarWhereInput
    data: XOR<EquipmentAssetUpdateManyMutationInput, EquipmentAssetUncheckedUpdateManyWithoutOwnerDepartmentInput>
  }

  export type DepartmentCreateWithoutDoctorAssignmentsInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDepartmentsInput
    facility: FacilityCatalogCreateNestedOneWithoutDepartmentsInput
    headStaff?: StaffCreateNestedOneWithoutHeadedDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyCreateNestedManyWithoutDepartmentInput
    units?: UnitCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutDoctorAssignmentsInput = {
    id?: string
    branchId: string
    facilityId: string
    code: string
    name: string
    headStaffId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedCreateNestedManyWithoutDepartmentInput
    units?: UnitUncheckedCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetUncheckedCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutDoctorAssignmentsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutDoctorAssignmentsInput, DepartmentUncheckedCreateWithoutDoctorAssignmentsInput>
  }

  export type StaffCreateWithoutDoctorAssignmentsInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    specialty?: SpecialtyCreateNestedOneWithoutStaffInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadStaffInput
    user?: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutDoctorAssignmentsInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadStaffInput
    user?: UserUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutDoctorAssignmentsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutDoctorAssignmentsInput, StaffUncheckedCreateWithoutDoctorAssignmentsInput>
  }

  export type DepartmentUpsertWithoutDoctorAssignmentsInput = {
    update: XOR<DepartmentUpdateWithoutDoctorAssignmentsInput, DepartmentUncheckedUpdateWithoutDoctorAssignmentsInput>
    create: XOR<DepartmentCreateWithoutDoctorAssignmentsInput, DepartmentUncheckedCreateWithoutDoctorAssignmentsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutDoctorAssignmentsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutDoctorAssignmentsInput, DepartmentUncheckedUpdateWithoutDoctorAssignmentsInput>
  }

  export type DepartmentUpdateWithoutDoctorAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDepartmentsNestedInput
    facility?: FacilityCatalogUpdateOneRequiredWithoutDepartmentsNestedInput
    headStaff?: StaffUpdateOneWithoutHeadedDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUpdateManyWithoutDepartmentNestedInput
    units?: UnitUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutDoctorAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    headStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput
    units?: UnitUncheckedUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUncheckedUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type StaffUpsertWithoutDoctorAssignmentsInput = {
    update: XOR<StaffUpdateWithoutDoctorAssignmentsInput, StaffUncheckedUpdateWithoutDoctorAssignmentsInput>
    create: XOR<StaffCreateWithoutDoctorAssignmentsInput, StaffUncheckedCreateWithoutDoctorAssignmentsInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutDoctorAssignmentsInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutDoctorAssignmentsInput, StaffUncheckedUpdateWithoutDoctorAssignmentsInput>
  }

  export type StaffUpdateWithoutDoctorAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    specialty?: SpecialtyUpdateOneWithoutStaffNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadStaffNestedInput
    user?: UserUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutDoctorAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadStaffNestedInput
    user?: UserUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type BranchCreateWithoutSpecialtyInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSpecialtyInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSpecialtyInput, BranchUncheckedCreateWithoutSpecialtyInput>
  }

  export type StaffCreateWithoutSpecialtyInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutStaffInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadStaffInput
    user?: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutStaffInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadStaffInput
    user?: UserUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutSpecialtyInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput>
  }

  export type StaffCreateManySpecialtyInputEnvelope = {
    data: StaffCreateManySpecialtyInput | StaffCreateManySpecialtyInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentSpecialtyCreateWithoutSpecialtyInput = {
    id?: string
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutDepartmentSpecialtiesInput
  }

  export type DepartmentSpecialtyUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    departmentId: string
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentSpecialtyCreateOrConnectWithoutSpecialtyInput = {
    where: DepartmentSpecialtyWhereUniqueInput
    create: XOR<DepartmentSpecialtyCreateWithoutSpecialtyInput, DepartmentSpecialtyUncheckedCreateWithoutSpecialtyInput>
  }

  export type DepartmentSpecialtyCreateManySpecialtyInputEnvelope = {
    data: DepartmentSpecialtyCreateManySpecialtyInput | DepartmentSpecialtyCreateManySpecialtyInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutSpecialtyInput = {
    update: XOR<BranchUpdateWithoutSpecialtyInput, BranchUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<BranchCreateWithoutSpecialtyInput, BranchUncheckedCreateWithoutSpecialtyInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSpecialtyInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSpecialtyInput, BranchUncheckedUpdateWithoutSpecialtyInput>
  }

  export type BranchUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type StaffUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutSpecialtyInput, StaffUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutSpecialtyInput, StaffUncheckedUpdateWithoutSpecialtyInput>
  }

  export type StaffUpdateManyWithWhereWithoutSpecialtyInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutSpecialtyInput>
  }

  export type DepartmentSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: DepartmentSpecialtyWhereUniqueInput
    update: XOR<DepartmentSpecialtyUpdateWithoutSpecialtyInput, DepartmentSpecialtyUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<DepartmentSpecialtyCreateWithoutSpecialtyInput, DepartmentSpecialtyUncheckedCreateWithoutSpecialtyInput>
  }

  export type DepartmentSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: DepartmentSpecialtyWhereUniqueInput
    data: XOR<DepartmentSpecialtyUpdateWithoutSpecialtyInput, DepartmentSpecialtyUncheckedUpdateWithoutSpecialtyInput>
  }

  export type DepartmentSpecialtyUpdateManyWithWhereWithoutSpecialtyInput = {
    where: DepartmentSpecialtyScalarWhereInput
    data: XOR<DepartmentSpecialtyUpdateManyMutationInput, DepartmentSpecialtyUncheckedUpdateManyWithoutSpecialtyInput>
  }

  export type DepartmentCreateWithoutDepartmentSpecialtiesInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDepartmentsInput
    facility: FacilityCatalogCreateNestedOneWithoutDepartmentsInput
    headStaff?: StaffCreateNestedOneWithoutHeadedDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutDepartmentInput
    units?: UnitCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutDepartmentSpecialtiesInput = {
    id?: string
    branchId: string
    facilityId: string
    code: string
    name: string
    headStaffId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutDepartmentInput
    units?: UnitUncheckedCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetUncheckedCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutDepartmentSpecialtiesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutDepartmentSpecialtiesInput, DepartmentUncheckedCreateWithoutDepartmentSpecialtiesInput>
  }

  export type SpecialtyCreateWithoutDepartmentLinksInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSpecialtyInput
    staff?: StaffCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutDepartmentLinksInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutDepartmentLinksInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutDepartmentLinksInput, SpecialtyUncheckedCreateWithoutDepartmentLinksInput>
  }

  export type DepartmentUpsertWithoutDepartmentSpecialtiesInput = {
    update: XOR<DepartmentUpdateWithoutDepartmentSpecialtiesInput, DepartmentUncheckedUpdateWithoutDepartmentSpecialtiesInput>
    create: XOR<DepartmentCreateWithoutDepartmentSpecialtiesInput, DepartmentUncheckedCreateWithoutDepartmentSpecialtiesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutDepartmentSpecialtiesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutDepartmentSpecialtiesInput, DepartmentUncheckedUpdateWithoutDepartmentSpecialtiesInput>
  }

  export type DepartmentUpdateWithoutDepartmentSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDepartmentsNestedInput
    facility?: FacilityCatalogUpdateOneRequiredWithoutDepartmentsNestedInput
    headStaff?: StaffUpdateOneWithoutHeadedDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutDepartmentNestedInput
    units?: UnitUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutDepartmentSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    headStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutDepartmentNestedInput
    units?: UnitUncheckedUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUncheckedUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type SpecialtyUpsertWithoutDepartmentLinksInput = {
    update: XOR<SpecialtyUpdateWithoutDepartmentLinksInput, SpecialtyUncheckedUpdateWithoutDepartmentLinksInput>
    create: XOR<SpecialtyCreateWithoutDepartmentLinksInput, SpecialtyUncheckedCreateWithoutDepartmentLinksInput>
    where?: SpecialtyWhereInput
  }

  export type SpecialtyUpdateToOneWithWhereWithoutDepartmentLinksInput = {
    where?: SpecialtyWhereInput
    data: XOR<SpecialtyUpdateWithoutDepartmentLinksInput, SpecialtyUncheckedUpdateWithoutDepartmentLinksInput>
  }

  export type SpecialtyUpdateWithoutDepartmentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSpecialtyNestedInput
    staff?: StaffUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutDepartmentLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type BranchCreateWithoutStaffInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutStaffInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutStaffInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutStaffInput, BranchUncheckedCreateWithoutStaffInput>
  }

  export type DepartmentCreateWithoutStaffInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDepartmentsInput
    facility: FacilityCatalogCreateNestedOneWithoutDepartmentsInput
    headStaff?: StaffCreateNestedOneWithoutHeadedDepartmentsInput
    departmentSpecialties?: DepartmentSpecialtyCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutDepartmentInput
    units?: UnitCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutStaffInput = {
    id?: string
    branchId: string
    facilityId: string
    code: string
    name: string
    headStaffId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentSpecialties?: DepartmentSpecialtyUncheckedCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutDepartmentInput
    units?: UnitUncheckedCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetUncheckedCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutStaffInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
  }

  export type SpecialtyCreateWithoutStaffInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSpecialtyInput
    departmentLinks?: DepartmentSpecialtyCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutStaffInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentLinks?: DepartmentSpecialtyUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutStaffInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutStaffInput, SpecialtyUncheckedCreateWithoutStaffInput>
  }

  export type DepartmentDoctorCreateWithoutStaffInput = {
    id?: string
    isPrimary?: boolean
    assignedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutDoctorAssignmentsInput
  }

  export type DepartmentDoctorUncheckedCreateWithoutStaffInput = {
    id?: string
    departmentId: string
    isPrimary?: boolean
    assignedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentDoctorCreateOrConnectWithoutStaffInput = {
    where: DepartmentDoctorWhereUniqueInput
    create: XOR<DepartmentDoctorCreateWithoutStaffInput, DepartmentDoctorUncheckedCreateWithoutStaffInput>
  }

  export type DepartmentDoctorCreateManyStaffInputEnvelope = {
    data: DepartmentDoctorCreateManyStaffInput | DepartmentDoctorCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutHeadStaffInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDepartmentsInput
    facility: FacilityCatalogCreateNestedOneWithoutDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutDepartmentInput
    units?: UnitCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutHeadStaffInput = {
    id?: string
    branchId: string
    facilityId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutDepartmentInput
    units?: UnitUncheckedCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetUncheckedCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutHeadStaffInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutHeadStaffInput, DepartmentUncheckedCreateWithoutHeadStaffInput>
  }

  export type DepartmentCreateManyHeadStaffInputEnvelope = {
    data: DepartmentCreateManyHeadStaffInput | DepartmentCreateManyHeadStaffInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutStaffInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutStaffInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
  }

  export type BranchUpsertWithoutStaffInput = {
    update: XOR<BranchUpdateWithoutStaffInput, BranchUncheckedUpdateWithoutStaffInput>
    create: XOR<BranchCreateWithoutStaffInput, BranchUncheckedCreateWithoutStaffInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutStaffInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutStaffInput, BranchUncheckedUpdateWithoutStaffInput>
  }

  export type BranchUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type DepartmentUpsertWithoutStaffInput = {
    update: XOR<DepartmentUpdateWithoutStaffInput, DepartmentUncheckedUpdateWithoutStaffInput>
    create: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutStaffInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutStaffInput, DepartmentUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDepartmentsNestedInput
    facility?: FacilityCatalogUpdateOneRequiredWithoutDepartmentsNestedInput
    headStaff?: StaffUpdateOneWithoutHeadedDepartmentsNestedInput
    departmentSpecialties?: DepartmentSpecialtyUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutDepartmentNestedInput
    units?: UnitUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    headStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentSpecialties?: DepartmentSpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutDepartmentNestedInput
    units?: UnitUncheckedUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUncheckedUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type SpecialtyUpsertWithoutStaffInput = {
    update: XOR<SpecialtyUpdateWithoutStaffInput, SpecialtyUncheckedUpdateWithoutStaffInput>
    create: XOR<SpecialtyCreateWithoutStaffInput, SpecialtyUncheckedCreateWithoutStaffInput>
    where?: SpecialtyWhereInput
  }

  export type SpecialtyUpdateToOneWithWhereWithoutStaffInput = {
    where?: SpecialtyWhereInput
    data: XOR<SpecialtyUpdateWithoutStaffInput, SpecialtyUncheckedUpdateWithoutStaffInput>
  }

  export type SpecialtyUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSpecialtyNestedInput
    departmentLinks?: DepartmentSpecialtyUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentLinks?: DepartmentSpecialtyUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type DepartmentDoctorUpsertWithWhereUniqueWithoutStaffInput = {
    where: DepartmentDoctorWhereUniqueInput
    update: XOR<DepartmentDoctorUpdateWithoutStaffInput, DepartmentDoctorUncheckedUpdateWithoutStaffInput>
    create: XOR<DepartmentDoctorCreateWithoutStaffInput, DepartmentDoctorUncheckedCreateWithoutStaffInput>
  }

  export type DepartmentDoctorUpdateWithWhereUniqueWithoutStaffInput = {
    where: DepartmentDoctorWhereUniqueInput
    data: XOR<DepartmentDoctorUpdateWithoutStaffInput, DepartmentDoctorUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentDoctorUpdateManyWithWhereWithoutStaffInput = {
    where: DepartmentDoctorScalarWhereInput
    data: XOR<DepartmentDoctorUpdateManyMutationInput, DepartmentDoctorUncheckedUpdateManyWithoutStaffInput>
  }

  export type DepartmentUpsertWithWhereUniqueWithoutHeadStaffInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutHeadStaffInput, DepartmentUncheckedUpdateWithoutHeadStaffInput>
    create: XOR<DepartmentCreateWithoutHeadStaffInput, DepartmentUncheckedCreateWithoutHeadStaffInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutHeadStaffInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutHeadStaffInput, DepartmentUncheckedUpdateWithoutHeadStaffInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutHeadStaffInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutHeadStaffInput>
  }

  export type UserUpsertWithoutStaffInput = {
    update: XOR<UserUpdateWithoutStaffInput, UserUncheckedUpdateWithoutStaffInput>
    create: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffInput, UserUncheckedUpdateWithoutStaffInput>
  }

  export type UserUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type BranchCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type StaffCreateWithoutUserInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    specialty?: SpecialtyCreateNestedOneWithoutStaffInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutStaffInput
    headedDepartments?: DepartmentCreateNestedManyWithoutHeadStaffInput
  }

  export type StaffUncheckedCreateWithoutUserInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutStaffInput
    headedDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadStaffInput
  }

  export type StaffCreateOrConnectWithoutUserInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
  }

  export type RoleTemplateVersionCreateWithoutUsersInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleTemplate: RoleTemplateCreateNestedOneWithoutVersionsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedRoleVersionsInput
    permissions?: RoleTemplatePermissionCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUncheckedCreateWithoutUsersInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RoleTemplatePermissionUncheckedCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionCreateOrConnectWithoutUsersInput = {
    where: RoleTemplateVersionWhereUniqueInput
    create: XOR<RoleTemplateVersionCreateWithoutUsersInput, RoleTemplateVersionUncheckedCreateWithoutUsersInput>
  }

  export type RoleTemplateVersionCreateWithoutCreatedByUserInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleTemplate: RoleTemplateCreateNestedOneWithoutVersionsInput
    permissions?: RoleTemplatePermissionCreateNestedManyWithoutRoleVersionInput
    users?: UserCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RoleTemplatePermissionUncheckedCreateNestedManyWithoutRoleVersionInput
    users?: UserUncheckedCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput = {
    where: RoleTemplateVersionWhereUniqueInput
    create: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput>
  }

  export type RoleTemplateVersionCreateManyCreatedByUserInputEnvelope = {
    data: RoleTemplateVersionCreateManyCreatedByUserInput | RoleTemplateVersionCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditEventCreateWithoutActorUserInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutAuditEventsInput
  }

  export type AuditEventUncheckedCreateWithoutActorUserInput = {
    id?: string
    branchId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditEventCreateOrConnectWithoutActorUserInput = {
    where: AuditEventWhereUniqueInput
    create: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput>
  }

  export type AuditEventCreateManyActorUserInputEnvelope = {
    data: AuditEventCreateManyActorUserInput | AuditEventCreateManyActorUserInput[]
    skipDuplicates?: boolean
  }

  export type PolicyVersionCreateWithoutCreatedByUserInput = {
    id?: string
    scope?: $Enums.PolicyScope
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policy: PolicyDefinitionCreateNestedOneWithoutVersionsInput
    branch?: BranchCreateNestedOneWithoutPolicyVersionsInput
    branches?: PolicyVersionBranchCreateNestedManyWithoutPolicyVersionInput
    submittedByUser?: UserCreateNestedOneWithoutPolicyVersionsSubmittedByInput
    approvedByUser?: UserCreateNestedOneWithoutPolicyVersionsApprovedByInput
    rejectedByUser?: UserCreateNestedOneWithoutPolicyVersionsRejectedByInput
    retiredByUser?: UserCreateNestedOneWithoutPolicyVersionsRetiredByInput
  }

  export type PolicyVersionUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutPolicyVersionInput
  }

  export type PolicyVersionCreateOrConnectWithoutCreatedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    create: XOR<PolicyVersionCreateWithoutCreatedByUserInput, PolicyVersionUncheckedCreateWithoutCreatedByUserInput>
  }

  export type PolicyVersionCreateManyCreatedByUserInputEnvelope = {
    data: PolicyVersionCreateManyCreatedByUserInput | PolicyVersionCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PolicyVersionCreateWithoutSubmittedByUserInput = {
    id?: string
    scope?: $Enums.PolicyScope
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policy: PolicyDefinitionCreateNestedOneWithoutVersionsInput
    branch?: BranchCreateNestedOneWithoutPolicyVersionsInput
    branches?: PolicyVersionBranchCreateNestedManyWithoutPolicyVersionInput
    createdByUser?: UserCreateNestedOneWithoutPolicyVersionsCreatedByInput
    approvedByUser?: UserCreateNestedOneWithoutPolicyVersionsApprovedByInput
    rejectedByUser?: UserCreateNestedOneWithoutPolicyVersionsRejectedByInput
    retiredByUser?: UserCreateNestedOneWithoutPolicyVersionsRetiredByInput
  }

  export type PolicyVersionUncheckedCreateWithoutSubmittedByUserInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutPolicyVersionInput
  }

  export type PolicyVersionCreateOrConnectWithoutSubmittedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    create: XOR<PolicyVersionCreateWithoutSubmittedByUserInput, PolicyVersionUncheckedCreateWithoutSubmittedByUserInput>
  }

  export type PolicyVersionCreateManySubmittedByUserInputEnvelope = {
    data: PolicyVersionCreateManySubmittedByUserInput | PolicyVersionCreateManySubmittedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PolicyVersionCreateWithoutApprovedByUserInput = {
    id?: string
    scope?: $Enums.PolicyScope
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policy: PolicyDefinitionCreateNestedOneWithoutVersionsInput
    branch?: BranchCreateNestedOneWithoutPolicyVersionsInput
    branches?: PolicyVersionBranchCreateNestedManyWithoutPolicyVersionInput
    createdByUser?: UserCreateNestedOneWithoutPolicyVersionsCreatedByInput
    submittedByUser?: UserCreateNestedOneWithoutPolicyVersionsSubmittedByInput
    rejectedByUser?: UserCreateNestedOneWithoutPolicyVersionsRejectedByInput
    retiredByUser?: UserCreateNestedOneWithoutPolicyVersionsRetiredByInput
  }

  export type PolicyVersionUncheckedCreateWithoutApprovedByUserInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutPolicyVersionInput
  }

  export type PolicyVersionCreateOrConnectWithoutApprovedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    create: XOR<PolicyVersionCreateWithoutApprovedByUserInput, PolicyVersionUncheckedCreateWithoutApprovedByUserInput>
  }

  export type PolicyVersionCreateManyApprovedByUserInputEnvelope = {
    data: PolicyVersionCreateManyApprovedByUserInput | PolicyVersionCreateManyApprovedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PolicyVersionCreateWithoutRejectedByUserInput = {
    id?: string
    scope?: $Enums.PolicyScope
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policy: PolicyDefinitionCreateNestedOneWithoutVersionsInput
    branch?: BranchCreateNestedOneWithoutPolicyVersionsInput
    branches?: PolicyVersionBranchCreateNestedManyWithoutPolicyVersionInput
    createdByUser?: UserCreateNestedOneWithoutPolicyVersionsCreatedByInput
    submittedByUser?: UserCreateNestedOneWithoutPolicyVersionsSubmittedByInput
    approvedByUser?: UserCreateNestedOneWithoutPolicyVersionsApprovedByInput
    retiredByUser?: UserCreateNestedOneWithoutPolicyVersionsRetiredByInput
  }

  export type PolicyVersionUncheckedCreateWithoutRejectedByUserInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutPolicyVersionInput
  }

  export type PolicyVersionCreateOrConnectWithoutRejectedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    create: XOR<PolicyVersionCreateWithoutRejectedByUserInput, PolicyVersionUncheckedCreateWithoutRejectedByUserInput>
  }

  export type PolicyVersionCreateManyRejectedByUserInputEnvelope = {
    data: PolicyVersionCreateManyRejectedByUserInput | PolicyVersionCreateManyRejectedByUserInput[]
    skipDuplicates?: boolean
  }

  export type PolicyVersionCreateWithoutRetiredByUserInput = {
    id?: string
    scope?: $Enums.PolicyScope
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policy: PolicyDefinitionCreateNestedOneWithoutVersionsInput
    branch?: BranchCreateNestedOneWithoutPolicyVersionsInput
    branches?: PolicyVersionBranchCreateNestedManyWithoutPolicyVersionInput
    createdByUser?: UserCreateNestedOneWithoutPolicyVersionsCreatedByInput
    submittedByUser?: UserCreateNestedOneWithoutPolicyVersionsSubmittedByInput
    approvedByUser?: UserCreateNestedOneWithoutPolicyVersionsApprovedByInput
    rejectedByUser?: UserCreateNestedOneWithoutPolicyVersionsRejectedByInput
  }

  export type PolicyVersionUncheckedCreateWithoutRetiredByUserInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutPolicyVersionInput
  }

  export type PolicyVersionCreateOrConnectWithoutRetiredByUserInput = {
    where: PolicyVersionWhereUniqueInput
    create: XOR<PolicyVersionCreateWithoutRetiredByUserInput, PolicyVersionUncheckedCreateWithoutRetiredByUserInput>
  }

  export type PolicyVersionCreateManyRetiredByUserInputEnvelope = {
    data: PolicyVersionCreateManyRetiredByUserInput | PolicyVersionCreateManyRetiredByUserInput[]
    skipDuplicates?: boolean
  }

  export type LocationNodeRevisionCreateWithoutCreatedByUserInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    node: LocationNodeCreateNestedOneWithoutRevisionsInput
  }

  export type LocationNodeRevisionUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    nodeId: string
    code: string
    name: string
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
  }

  export type LocationNodeRevisionCreateOrConnectWithoutCreatedByUserInput = {
    where: LocationNodeRevisionWhereUniqueInput
    create: XOR<LocationNodeRevisionCreateWithoutCreatedByUserInput, LocationNodeRevisionUncheckedCreateWithoutCreatedByUserInput>
  }

  export type LocationNodeRevisionCreateManyCreatedByUserInputEnvelope = {
    data: LocationNodeRevisionCreateManyCreatedByUserInput | LocationNodeRevisionCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type BulkImportJobCreateWithoutCreatedByUserInput = {
    id?: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: number
    validRows?: number
    invalidRows?: number
    committedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutImportJobsInput
  }

  export type BulkImportJobUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    branchId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: number
    validRows?: number
    invalidRows?: number
    committedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BulkImportJobCreateOrConnectWithoutCreatedByUserInput = {
    where: BulkImportJobWhereUniqueInput
    create: XOR<BulkImportJobCreateWithoutCreatedByUserInput, BulkImportJobUncheckedCreateWithoutCreatedByUserInput>
  }

  export type BulkImportJobCreateManyCreatedByUserInputEnvelope = {
    data: BulkImportJobCreateManyCreatedByUserInput | BulkImportJobCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type FixItTaskCreateWithoutAssignedToUserInput = {
    id?: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutFixItTasksInput
    serviceItem?: ServiceItemCreateNestedOneWithoutFixItsInput
  }

  export type FixItTaskUncheckedCreateWithoutAssignedToUserInput = {
    id?: string
    branchId: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixItTaskCreateOrConnectWithoutAssignedToUserInput = {
    where: FixItTaskWhereUniqueInput
    create: XOR<FixItTaskCreateWithoutAssignedToUserInput, FixItTaskUncheckedCreateWithoutAssignedToUserInput>
  }

  export type FixItTaskCreateManyAssignedToUserInputEnvelope = {
    data: FixItTaskCreateManyAssignedToUserInput | FixItTaskCreateManyAssignedToUserInput[]
    skipDuplicates?: boolean
  }

  export type ProcedureBookingCreateWithoutCreatedByUserInput = {
    id?: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProcedureBookingsInput
    unit: UnitCreateNestedOneWithoutBookingsInput
    resource: UnitResourceCreateNestedOneWithoutBookingsInput
  }

  export type ProcedureBookingUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    branchId: string
    unitId: string
    resourceId: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureBookingCreateOrConnectWithoutCreatedByUserInput = {
    where: ProcedureBookingWhereUniqueInput
    create: XOR<ProcedureBookingCreateWithoutCreatedByUserInput, ProcedureBookingUncheckedCreateWithoutCreatedByUserInput>
  }

  export type ProcedureBookingCreateManyCreatedByUserInputEnvelope = {
    data: ProcedureBookingCreateManyCreatedByUserInput | ProcedureBookingCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type GoLiveReportCreateWithoutCreatedByUserInput = {
    id?: string
    score: number
    blockers: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutGoLiveReportsInput
  }

  export type GoLiveReportUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    branchId: string
    score: number
    blockers: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GoLiveReportCreateOrConnectWithoutCreatedByUserInput = {
    where: GoLiveReportWhereUniqueInput
    create: XOR<GoLiveReportCreateWithoutCreatedByUserInput, GoLiveReportUncheckedCreateWithoutCreatedByUserInput>
  }

  export type GoLiveReportCreateManyCreatedByUserInputEnvelope = {
    data: GoLiveReportCreateManyCreatedByUserInput | GoLiveReportCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type StaffUpsertWithoutUserInput = {
    update: XOR<StaffUpdateWithoutUserInput, StaffUncheckedUpdateWithoutUserInput>
    create: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutUserInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutUserInput, StaffUncheckedUpdateWithoutUserInput>
  }

  export type StaffUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    specialty?: SpecialtyUpdateOneWithoutStaffNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutStaffNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutStaffNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadStaffNestedInput
  }

  export type RoleTemplateVersionUpsertWithoutUsersInput = {
    update: XOR<RoleTemplateVersionUpdateWithoutUsersInput, RoleTemplateVersionUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleTemplateVersionCreateWithoutUsersInput, RoleTemplateVersionUncheckedCreateWithoutUsersInput>
    where?: RoleTemplateVersionWhereInput
  }

  export type RoleTemplateVersionUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleTemplateVersionWhereInput
    data: XOR<RoleTemplateVersionUpdateWithoutUsersInput, RoleTemplateVersionUncheckedUpdateWithoutUsersInput>
  }

  export type RoleTemplateVersionUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleTemplate?: RoleTemplateUpdateOneRequiredWithoutVersionsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedRoleVersionsNestedInput
    permissions?: RoleTemplatePermissionUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: RoleTemplateVersionWhereUniqueInput
    update: XOR<RoleTemplateVersionUpdateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput>
  }

  export type RoleTemplateVersionUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: RoleTemplateVersionWhereUniqueInput
    data: XOR<RoleTemplateVersionUpdateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type RoleTemplateVersionUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: RoleTemplateVersionScalarWhereInput
    data: XOR<RoleTemplateVersionUpdateManyMutationInput, RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type RoleTemplateVersionScalarWhereInput = {
    AND?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
    OR?: RoleTemplateVersionScalarWhereInput[]
    NOT?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
    id?: StringFilter<"RoleTemplateVersion"> | string
    roleTemplateId?: StringFilter<"RoleTemplateVersion"> | string
    version?: IntFilter<"RoleTemplateVersion"> | number
    status?: EnumRoleVersionStatusFilter<"RoleTemplateVersion"> | $Enums.RoleVersionStatus
    notes?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdByUserId?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
  }

  export type AuditEventUpsertWithWhereUniqueWithoutActorUserInput = {
    where: AuditEventWhereUniqueInput
    update: XOR<AuditEventUpdateWithoutActorUserInput, AuditEventUncheckedUpdateWithoutActorUserInput>
    create: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput>
  }

  export type AuditEventUpdateWithWhereUniqueWithoutActorUserInput = {
    where: AuditEventWhereUniqueInput
    data: XOR<AuditEventUpdateWithoutActorUserInput, AuditEventUncheckedUpdateWithoutActorUserInput>
  }

  export type AuditEventUpdateManyWithWhereWithoutActorUserInput = {
    where: AuditEventScalarWhereInput
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyWithoutActorUserInput>
  }

  export type PolicyVersionUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    update: XOR<PolicyVersionUpdateWithoutCreatedByUserInput, PolicyVersionUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<PolicyVersionCreateWithoutCreatedByUserInput, PolicyVersionUncheckedCreateWithoutCreatedByUserInput>
  }

  export type PolicyVersionUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    data: XOR<PolicyVersionUpdateWithoutCreatedByUserInput, PolicyVersionUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type PolicyVersionUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: PolicyVersionScalarWhereInput
    data: XOR<PolicyVersionUpdateManyMutationInput, PolicyVersionUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type PolicyVersionUpsertWithWhereUniqueWithoutSubmittedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    update: XOR<PolicyVersionUpdateWithoutSubmittedByUserInput, PolicyVersionUncheckedUpdateWithoutSubmittedByUserInput>
    create: XOR<PolicyVersionCreateWithoutSubmittedByUserInput, PolicyVersionUncheckedCreateWithoutSubmittedByUserInput>
  }

  export type PolicyVersionUpdateWithWhereUniqueWithoutSubmittedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    data: XOR<PolicyVersionUpdateWithoutSubmittedByUserInput, PolicyVersionUncheckedUpdateWithoutSubmittedByUserInput>
  }

  export type PolicyVersionUpdateManyWithWhereWithoutSubmittedByUserInput = {
    where: PolicyVersionScalarWhereInput
    data: XOR<PolicyVersionUpdateManyMutationInput, PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserInput>
  }

  export type PolicyVersionUpsertWithWhereUniqueWithoutApprovedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    update: XOR<PolicyVersionUpdateWithoutApprovedByUserInput, PolicyVersionUncheckedUpdateWithoutApprovedByUserInput>
    create: XOR<PolicyVersionCreateWithoutApprovedByUserInput, PolicyVersionUncheckedCreateWithoutApprovedByUserInput>
  }

  export type PolicyVersionUpdateWithWhereUniqueWithoutApprovedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    data: XOR<PolicyVersionUpdateWithoutApprovedByUserInput, PolicyVersionUncheckedUpdateWithoutApprovedByUserInput>
  }

  export type PolicyVersionUpdateManyWithWhereWithoutApprovedByUserInput = {
    where: PolicyVersionScalarWhereInput
    data: XOR<PolicyVersionUpdateManyMutationInput, PolicyVersionUncheckedUpdateManyWithoutApprovedByUserInput>
  }

  export type PolicyVersionUpsertWithWhereUniqueWithoutRejectedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    update: XOR<PolicyVersionUpdateWithoutRejectedByUserInput, PolicyVersionUncheckedUpdateWithoutRejectedByUserInput>
    create: XOR<PolicyVersionCreateWithoutRejectedByUserInput, PolicyVersionUncheckedCreateWithoutRejectedByUserInput>
  }

  export type PolicyVersionUpdateWithWhereUniqueWithoutRejectedByUserInput = {
    where: PolicyVersionWhereUniqueInput
    data: XOR<PolicyVersionUpdateWithoutRejectedByUserInput, PolicyVersionUncheckedUpdateWithoutRejectedByUserInput>
  }

  export type PolicyVersionUpdateManyWithWhereWithoutRejectedByUserInput = {
    where: PolicyVersionScalarWhereInput
    data: XOR<PolicyVersionUpdateManyMutationInput, PolicyVersionUncheckedUpdateManyWithoutRejectedByUserInput>
  }

  export type PolicyVersionUpsertWithWhereUniqueWithoutRetiredByUserInput = {
    where: PolicyVersionWhereUniqueInput
    update: XOR<PolicyVersionUpdateWithoutRetiredByUserInput, PolicyVersionUncheckedUpdateWithoutRetiredByUserInput>
    create: XOR<PolicyVersionCreateWithoutRetiredByUserInput, PolicyVersionUncheckedCreateWithoutRetiredByUserInput>
  }

  export type PolicyVersionUpdateWithWhereUniqueWithoutRetiredByUserInput = {
    where: PolicyVersionWhereUniqueInput
    data: XOR<PolicyVersionUpdateWithoutRetiredByUserInput, PolicyVersionUncheckedUpdateWithoutRetiredByUserInput>
  }

  export type PolicyVersionUpdateManyWithWhereWithoutRetiredByUserInput = {
    where: PolicyVersionScalarWhereInput
    data: XOR<PolicyVersionUpdateManyMutationInput, PolicyVersionUncheckedUpdateManyWithoutRetiredByUserInput>
  }

  export type LocationNodeRevisionUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: LocationNodeRevisionWhereUniqueInput
    update: XOR<LocationNodeRevisionUpdateWithoutCreatedByUserInput, LocationNodeRevisionUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<LocationNodeRevisionCreateWithoutCreatedByUserInput, LocationNodeRevisionUncheckedCreateWithoutCreatedByUserInput>
  }

  export type LocationNodeRevisionUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: LocationNodeRevisionWhereUniqueInput
    data: XOR<LocationNodeRevisionUpdateWithoutCreatedByUserInput, LocationNodeRevisionUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type LocationNodeRevisionUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: LocationNodeRevisionScalarWhereInput
    data: XOR<LocationNodeRevisionUpdateManyMutationInput, LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type LocationNodeRevisionScalarWhereInput = {
    AND?: LocationNodeRevisionScalarWhereInput | LocationNodeRevisionScalarWhereInput[]
    OR?: LocationNodeRevisionScalarWhereInput[]
    NOT?: LocationNodeRevisionScalarWhereInput | LocationNodeRevisionScalarWhereInput[]
    id?: StringFilter<"LocationNodeRevision"> | string
    nodeId?: StringFilter<"LocationNodeRevision"> | string
    code?: StringFilter<"LocationNodeRevision"> | string
    name?: StringFilter<"LocationNodeRevision"> | string
    isActive?: BoolFilter<"LocationNodeRevision"> | boolean
    effectiveFrom?: DateTimeFilter<"LocationNodeRevision"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"LocationNodeRevision"> | Date | string | null
    createdByUserId?: StringNullableFilter<"LocationNodeRevision"> | string | null
    createdAt?: DateTimeFilter<"LocationNodeRevision"> | Date | string
  }

  export type BulkImportJobUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: BulkImportJobWhereUniqueInput
    update: XOR<BulkImportJobUpdateWithoutCreatedByUserInput, BulkImportJobUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<BulkImportJobCreateWithoutCreatedByUserInput, BulkImportJobUncheckedCreateWithoutCreatedByUserInput>
  }

  export type BulkImportJobUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: BulkImportJobWhereUniqueInput
    data: XOR<BulkImportJobUpdateWithoutCreatedByUserInput, BulkImportJobUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type BulkImportJobUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: BulkImportJobScalarWhereInput
    data: XOR<BulkImportJobUpdateManyMutationInput, BulkImportJobUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type FixItTaskUpsertWithWhereUniqueWithoutAssignedToUserInput = {
    where: FixItTaskWhereUniqueInput
    update: XOR<FixItTaskUpdateWithoutAssignedToUserInput, FixItTaskUncheckedUpdateWithoutAssignedToUserInput>
    create: XOR<FixItTaskCreateWithoutAssignedToUserInput, FixItTaskUncheckedCreateWithoutAssignedToUserInput>
  }

  export type FixItTaskUpdateWithWhereUniqueWithoutAssignedToUserInput = {
    where: FixItTaskWhereUniqueInput
    data: XOR<FixItTaskUpdateWithoutAssignedToUserInput, FixItTaskUncheckedUpdateWithoutAssignedToUserInput>
  }

  export type FixItTaskUpdateManyWithWhereWithoutAssignedToUserInput = {
    where: FixItTaskScalarWhereInput
    data: XOR<FixItTaskUpdateManyMutationInput, FixItTaskUncheckedUpdateManyWithoutAssignedToUserInput>
  }

  export type ProcedureBookingUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: ProcedureBookingWhereUniqueInput
    update: XOR<ProcedureBookingUpdateWithoutCreatedByUserInput, ProcedureBookingUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<ProcedureBookingCreateWithoutCreatedByUserInput, ProcedureBookingUncheckedCreateWithoutCreatedByUserInput>
  }

  export type ProcedureBookingUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: ProcedureBookingWhereUniqueInput
    data: XOR<ProcedureBookingUpdateWithoutCreatedByUserInput, ProcedureBookingUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type ProcedureBookingUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: ProcedureBookingScalarWhereInput
    data: XOR<ProcedureBookingUpdateManyMutationInput, ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type GoLiveReportUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: GoLiveReportWhereUniqueInput
    update: XOR<GoLiveReportUpdateWithoutCreatedByUserInput, GoLiveReportUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<GoLiveReportCreateWithoutCreatedByUserInput, GoLiveReportUncheckedCreateWithoutCreatedByUserInput>
  }

  export type GoLiveReportUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: GoLiveReportWhereUniqueInput
    data: XOR<GoLiveReportUpdateWithoutCreatedByUserInput, GoLiveReportUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type GoLiveReportUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: GoLiveReportScalarWhereInput
    data: XOR<GoLiveReportUpdateManyMutationInput, GoLiveReportUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type BranchCreateWithoutPatientsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutPatientsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutPatientsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
  }

  export type EncounterCreateWithoutPatientInput = {
    id?: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEncounterInput
    admissions?: AdmissionCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutPatientInput = {
    id?: string
    branchId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput>
  }

  export type EncounterCreateManyPatientInputEnvelope = {
    data: EncounterCreateManyPatientInput | EncounterCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionCreateWithoutPatientInput = {
    id?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutAdmissionInput
    encounter?: EncounterCreateNestedOneWithoutAdmissionsInput
    bed?: BedCreateNestedOneWithoutAdmissionsInput
  }

  export type AdmissionUncheckedCreateWithoutPatientInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateOrConnectWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput>
  }

  export type AdmissionCreateManyPatientInputEnvelope = {
    data: AdmissionCreateManyPatientInput | AdmissionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ConsentRecordCreateWithoutPatientInput = {
    id?: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
  }

  export type ConsentRecordUncheckedCreateWithoutPatientInput = {
    id?: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
  }

  export type ConsentRecordCreateOrConnectWithoutPatientInput = {
    where: ConsentRecordWhereUniqueInput
    create: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput>
  }

  export type ConsentRecordCreateManyPatientInputEnvelope = {
    data: ConsentRecordCreateManyPatientInput | ConsentRecordCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type RtbfRequestCreateWithoutPatientInput = {
    id?: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RtbfRequestUncheckedCreateWithoutPatientInput = {
    id?: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RtbfRequestCreateOrConnectWithoutPatientInput = {
    where: RtbfRequestWhereUniqueInput
    create: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput>
  }

  export type RtbfRequestCreateManyPatientInputEnvelope = {
    data: RtbfRequestCreateManyPatientInput | RtbfRequestCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type StatutoryCaseCreateWithoutPatientInput = {
    id?: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStatutoryCasesInput
  }

  export type StatutoryCaseUncheckedCreateWithoutPatientInput = {
    id?: string
    branchId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseCreateOrConnectWithoutPatientInput = {
    where: StatutoryCaseWhereUniqueInput
    create: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput>
  }

  export type StatutoryCaseCreateManyPatientInputEnvelope = {
    data: StatutoryCaseCreateManyPatientInput | StatutoryCaseCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutPatientsInput = {
    update: XOR<BranchUpdateWithoutPatientsInput, BranchUncheckedUpdateWithoutPatientsInput>
    create: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutPatientsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutPatientsInput, BranchUncheckedUpdateWithoutPatientsInput>
  }

  export type BranchUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutPatientInput, EncounterUncheckedUpdateWithoutPatientInput>
    create: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutPatientInput, EncounterUncheckedUpdateWithoutPatientInput>
  }

  export type EncounterUpdateManyWithWhereWithoutPatientInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutPatientInput>
  }

  export type AdmissionUpsertWithWhereUniqueWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutPatientInput, AdmissionUncheckedUpdateWithoutPatientInput>
    create: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutPatientInput, AdmissionUncheckedUpdateWithoutPatientInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutPatientInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutPatientInput>
  }

  export type ConsentRecordUpsertWithWhereUniqueWithoutPatientInput = {
    where: ConsentRecordWhereUniqueInput
    update: XOR<ConsentRecordUpdateWithoutPatientInput, ConsentRecordUncheckedUpdateWithoutPatientInput>
    create: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput>
  }

  export type ConsentRecordUpdateWithWhereUniqueWithoutPatientInput = {
    where: ConsentRecordWhereUniqueInput
    data: XOR<ConsentRecordUpdateWithoutPatientInput, ConsentRecordUncheckedUpdateWithoutPatientInput>
  }

  export type ConsentRecordUpdateManyWithWhereWithoutPatientInput = {
    where: ConsentRecordScalarWhereInput
    data: XOR<ConsentRecordUpdateManyMutationInput, ConsentRecordUncheckedUpdateManyWithoutPatientInput>
  }

  export type ConsentRecordScalarWhereInput = {
    AND?: ConsentRecordScalarWhereInput | ConsentRecordScalarWhereInput[]
    OR?: ConsentRecordScalarWhereInput[]
    NOT?: ConsentRecordScalarWhereInput | ConsentRecordScalarWhereInput[]
    id?: StringFilter<"ConsentRecord"> | string
    patientId?: StringFilter<"ConsentRecord"> | string
    scope?: EnumConsentScopeFilter<"ConsentRecord"> | $Enums.ConsentScope
    purpose?: StringFilter<"ConsentRecord"> | string
    status?: EnumConsentStatusFilter<"ConsentRecord"> | $Enums.ConsentStatus
    createdAt?: DateTimeFilter<"ConsentRecord"> | Date | string
  }

  export type RtbfRequestUpsertWithWhereUniqueWithoutPatientInput = {
    where: RtbfRequestWhereUniqueInput
    update: XOR<RtbfRequestUpdateWithoutPatientInput, RtbfRequestUncheckedUpdateWithoutPatientInput>
    create: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput>
  }

  export type RtbfRequestUpdateWithWhereUniqueWithoutPatientInput = {
    where: RtbfRequestWhereUniqueInput
    data: XOR<RtbfRequestUpdateWithoutPatientInput, RtbfRequestUncheckedUpdateWithoutPatientInput>
  }

  export type RtbfRequestUpdateManyWithWhereWithoutPatientInput = {
    where: RtbfRequestScalarWhereInput
    data: XOR<RtbfRequestUpdateManyMutationInput, RtbfRequestUncheckedUpdateManyWithoutPatientInput>
  }

  export type RtbfRequestScalarWhereInput = {
    AND?: RtbfRequestScalarWhereInput | RtbfRequestScalarWhereInput[]
    OR?: RtbfRequestScalarWhereInput[]
    NOT?: RtbfRequestScalarWhereInput | RtbfRequestScalarWhereInput[]
    id?: StringFilter<"RtbfRequest"> | string
    patientId?: StringFilter<"RtbfRequest"> | string
    reason?: StringFilter<"RtbfRequest"> | string
    status?: EnumRtbfStatusFilter<"RtbfRequest"> | $Enums.RtbfStatus
    createdAt?: DateTimeFilter<"RtbfRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RtbfRequest"> | Date | string
  }

  export type StatutoryCaseUpsertWithWhereUniqueWithoutPatientInput = {
    where: StatutoryCaseWhereUniqueInput
    update: XOR<StatutoryCaseUpdateWithoutPatientInput, StatutoryCaseUncheckedUpdateWithoutPatientInput>
    create: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput>
  }

  export type StatutoryCaseUpdateWithWhereUniqueWithoutPatientInput = {
    where: StatutoryCaseWhereUniqueInput
    data: XOR<StatutoryCaseUpdateWithoutPatientInput, StatutoryCaseUncheckedUpdateWithoutPatientInput>
  }

  export type StatutoryCaseUpdateManyWithWhereWithoutPatientInput = {
    where: StatutoryCaseScalarWhereInput
    data: XOR<StatutoryCaseUpdateManyMutationInput, StatutoryCaseUncheckedUpdateManyWithoutPatientInput>
  }

  export type BranchCreateWithoutEncounterInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutEncounterInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutEncounterInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutEncounterInput, BranchUncheckedCreateWithoutEncounterInput>
  }

  export type PatientCreateWithoutEncountersInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutEncountersInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutEncountersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
  }

  export type AdmissionCreateWithoutEncounterInput = {
    id?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutAdmissionInput
    patient: PatientCreateNestedOneWithoutAdmissionInput
    bed?: BedCreateNestedOneWithoutAdmissionsInput
  }

  export type AdmissionUncheckedCreateWithoutEncounterInput = {
    id?: string
    branchId: string
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateOrConnectWithoutEncounterInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput>
  }

  export type AdmissionCreateManyEncounterInputEnvelope = {
    data: AdmissionCreateManyEncounterInput | AdmissionCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutEncounterInput = {
    update: XOR<BranchUpdateWithoutEncounterInput, BranchUncheckedUpdateWithoutEncounterInput>
    create: XOR<BranchCreateWithoutEncounterInput, BranchUncheckedCreateWithoutEncounterInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutEncounterInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutEncounterInput, BranchUncheckedUpdateWithoutEncounterInput>
  }

  export type BranchUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PatientUpsertWithoutEncountersInput = {
    update: XOR<PatientUpdateWithoutEncountersInput, PatientUncheckedUpdateWithoutEncountersInput>
    create: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutEncountersInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutEncountersInput, PatientUncheckedUpdateWithoutEncountersInput>
  }

  export type PatientUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type AdmissionUpsertWithWhereUniqueWithoutEncounterInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutEncounterInput, AdmissionUncheckedUpdateWithoutEncounterInput>
    create: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutEncounterInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutEncounterInput, AdmissionUncheckedUpdateWithoutEncounterInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutEncounterInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutEncounterInput>
  }

  export type BranchCreateWithoutWardsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutWardsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutWardsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutWardsInput, BranchUncheckedCreateWithoutWardsInput>
  }

  export type RoomCreateWithoutWardInput = {
    id?: string
    code: string
    name: string
    floor?: string | null
    type?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutRoomsInput
    beds?: BedCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutWardInput = {
    id?: string
    branchId: string
    code: string
    name: string
    floor?: string | null
    type?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    beds?: BedUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutWardInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutWardInput, RoomUncheckedCreateWithoutWardInput>
  }

  export type RoomCreateManyWardInputEnvelope = {
    data: RoomCreateManyWardInput | RoomCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutWardsInput = {
    update: XOR<BranchUpdateWithoutWardsInput, BranchUncheckedUpdateWithoutWardsInput>
    create: XOR<BranchCreateWithoutWardsInput, BranchUncheckedCreateWithoutWardsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutWardsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutWardsInput, BranchUncheckedUpdateWithoutWardsInput>
  }

  export type BranchUpdateWithoutWardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutWardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type RoomUpsertWithWhereUniqueWithoutWardInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutWardInput, RoomUncheckedUpdateWithoutWardInput>
    create: XOR<RoomCreateWithoutWardInput, RoomUncheckedCreateWithoutWardInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutWardInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutWardInput, RoomUncheckedUpdateWithoutWardInput>
  }

  export type RoomUpdateManyWithWhereWithoutWardInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutWardInput>
  }

  export type BranchCreateWithoutRoomsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutRoomsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutRoomsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutRoomsInput, BranchUncheckedCreateWithoutRoomsInput>
  }

  export type WardCreateWithoutRoomsInput = {
    id?: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutWardsInput
  }

  export type WardUncheckedCreateWithoutRoomsInput = {
    id?: string
    branchId: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardCreateOrConnectWithoutRoomsInput = {
    where: WardWhereUniqueInput
    create: XOR<WardCreateWithoutRoomsInput, WardUncheckedCreateWithoutRoomsInput>
  }

  export type BedCreateWithoutRoomInput = {
    id?: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBedInput
    admissions?: AdmissionCreateNestedManyWithoutBedInput
  }

  export type BedUncheckedCreateWithoutRoomInput = {
    id?: string
    branchId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutBedInput
  }

  export type BedCreateOrConnectWithoutRoomInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput>
  }

  export type BedCreateManyRoomInputEnvelope = {
    data: BedCreateManyRoomInput | BedCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutRoomsInput = {
    update: XOR<BranchUpdateWithoutRoomsInput, BranchUncheckedUpdateWithoutRoomsInput>
    create: XOR<BranchCreateWithoutRoomsInput, BranchUncheckedCreateWithoutRoomsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutRoomsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutRoomsInput, BranchUncheckedUpdateWithoutRoomsInput>
  }

  export type BranchUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type WardUpsertWithoutRoomsInput = {
    update: XOR<WardUpdateWithoutRoomsInput, WardUncheckedUpdateWithoutRoomsInput>
    create: XOR<WardCreateWithoutRoomsInput, WardUncheckedCreateWithoutRoomsInput>
    where?: WardWhereInput
  }

  export type WardUpdateToOneWithWhereWithoutRoomsInput = {
    where?: WardWhereInput
    data: XOR<WardUpdateWithoutRoomsInput, WardUncheckedUpdateWithoutRoomsInput>
  }

  export type WardUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutWardsNestedInput
  }

  export type WardUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedUpsertWithWhereUniqueWithoutRoomInput = {
    where: BedWhereUniqueInput
    update: XOR<BedUpdateWithoutRoomInput, BedUncheckedUpdateWithoutRoomInput>
    create: XOR<BedCreateWithoutRoomInput, BedUncheckedCreateWithoutRoomInput>
  }

  export type BedUpdateWithWhereUniqueWithoutRoomInput = {
    where: BedWhereUniqueInput
    data: XOR<BedUpdateWithoutRoomInput, BedUncheckedUpdateWithoutRoomInput>
  }

  export type BedUpdateManyWithWhereWithoutRoomInput = {
    where: BedScalarWhereInput
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyWithoutRoomInput>
  }

  export type BranchCreateWithoutBedInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutBedInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutBedInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutBedInput, BranchUncheckedCreateWithoutBedInput>
  }

  export type RoomCreateWithoutBedsInput = {
    id?: string
    code: string
    name: string
    floor?: string | null
    type?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutRoomsInput
    ward: WardCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutBedsInput = {
    id?: string
    branchId: string
    wardId: string
    code: string
    name: string
    floor?: string | null
    type?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomCreateOrConnectWithoutBedsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutBedsInput, RoomUncheckedCreateWithoutBedsInput>
  }

  export type AdmissionCreateWithoutBedInput = {
    id?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutAdmissionInput
    encounter?: EncounterCreateNestedOneWithoutAdmissionsInput
    patient: PatientCreateNestedOneWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutBedInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    patientId: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateOrConnectWithoutBedInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput>
  }

  export type AdmissionCreateManyBedInputEnvelope = {
    data: AdmissionCreateManyBedInput | AdmissionCreateManyBedInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutBedInput = {
    update: XOR<BranchUpdateWithoutBedInput, BranchUncheckedUpdateWithoutBedInput>
    create: XOR<BranchCreateWithoutBedInput, BranchUncheckedCreateWithoutBedInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutBedInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutBedInput, BranchUncheckedUpdateWithoutBedInput>
  }

  export type BranchUpdateWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type RoomUpsertWithoutBedsInput = {
    update: XOR<RoomUpdateWithoutBedsInput, RoomUncheckedUpdateWithoutBedsInput>
    create: XOR<RoomCreateWithoutBedsInput, RoomUncheckedCreateWithoutBedsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutBedsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutBedsInput, RoomUncheckedUpdateWithoutBedsInput>
  }

  export type RoomUpdateWithoutBedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutRoomsNestedInput
    ward?: WardUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutBedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUpsertWithWhereUniqueWithoutBedInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutBedInput, AdmissionUncheckedUpdateWithoutBedInput>
    create: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutBedInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutBedInput, AdmissionUncheckedUpdateWithoutBedInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutBedInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutBedInput>
  }

  export type BranchCreateWithoutAdmissionInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAdmissionInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAdmissionInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAdmissionInput, BranchUncheckedCreateWithoutAdmissionInput>
  }

  export type EncounterCreateWithoutAdmissionsInput = {
    id?: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
  }

  export type EncounterUncheckedCreateWithoutAdmissionsInput = {
    id?: string
    branchId: string
    patientId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterCreateOrConnectWithoutAdmissionsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutAdmissionsInput, EncounterUncheckedCreateWithoutAdmissionsInput>
  }

  export type PatientCreateWithoutAdmissionInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAdmissionInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAdmissionInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAdmissionInput, PatientUncheckedCreateWithoutAdmissionInput>
  }

  export type BedCreateWithoutAdmissionsInput = {
    id?: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBedInput
    room: RoomCreateNestedOneWithoutBedsInput
  }

  export type BedUncheckedCreateWithoutAdmissionsInput = {
    id?: string
    branchId: string
    roomId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedCreateOrConnectWithoutAdmissionsInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutAdmissionsInput, BedUncheckedCreateWithoutAdmissionsInput>
  }

  export type BranchUpsertWithoutAdmissionInput = {
    update: XOR<BranchUpdateWithoutAdmissionInput, BranchUncheckedUpdateWithoutAdmissionInput>
    create: XOR<BranchCreateWithoutAdmissionInput, BranchUncheckedCreateWithoutAdmissionInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAdmissionInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAdmissionInput, BranchUncheckedUpdateWithoutAdmissionInput>
  }

  export type BranchUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterUpsertWithoutAdmissionsInput = {
    update: XOR<EncounterUpdateWithoutAdmissionsInput, EncounterUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<EncounterCreateWithoutAdmissionsInput, EncounterUncheckedCreateWithoutAdmissionsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutAdmissionsInput, EncounterUncheckedUpdateWithoutAdmissionsInput>
  }

  export type EncounterUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type EncounterUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpsertWithoutAdmissionInput = {
    update: XOR<PatientUpdateWithoutAdmissionInput, PatientUncheckedUpdateWithoutAdmissionInput>
    create: XOR<PatientCreateWithoutAdmissionInput, PatientUncheckedCreateWithoutAdmissionInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAdmissionInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAdmissionInput, PatientUncheckedUpdateWithoutAdmissionInput>
  }

  export type PatientUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type BedUpsertWithoutAdmissionsInput = {
    update: XOR<BedUpdateWithoutAdmissionsInput, BedUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<BedCreateWithoutAdmissionsInput, BedUncheckedCreateWithoutAdmissionsInput>
    where?: BedWhereInput
  }

  export type BedUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: BedWhereInput
    data: XOR<BedUpdateWithoutAdmissionsInput, BedUncheckedUpdateWithoutAdmissionsInput>
  }

  export type BedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBedNestedInput
    room?: RoomUpdateOneRequiredWithoutBedsNestedInput
  }

  export type BedUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateWithoutOTsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutOTsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutOTsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutOTsInput, BranchUncheckedCreateWithoutOTsInput>
  }

  export type BranchUpsertWithoutOTsInput = {
    update: XOR<BranchUpdateWithoutOTsInput, BranchUncheckedUpdateWithoutOTsInput>
    create: XOR<BranchCreateWithoutOTsInput, BranchUncheckedCreateWithoutOTsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutOTsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutOTsInput, BranchUncheckedUpdateWithoutOTsInput>
  }

  export type BranchUpdateWithoutOTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutOTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutAssetsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAssetsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAssetsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAssetsInput, BranchUncheckedCreateWithoutAssetsInput>
  }

  export type BranchUpsertWithoutAssetsInput = {
    update: XOR<BranchUpdateWithoutAssetsInput, BranchUncheckedUpdateWithoutAssetsInput>
    create: XOR<BranchCreateWithoutAssetsInput, BranchUncheckedCreateWithoutAssetsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAssetsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAssetsInput, BranchUncheckedUpdateWithoutAssetsInput>
  }

  export type BranchUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutTariffPlansInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutTariffPlansInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutTariffPlansInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutTariffPlansInput, BranchUncheckedCreateWithoutTariffPlansInput>
  }

  export type TariffRateCreateWithoutTariffPlanInput = {
    id?: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffRateUncheckedCreateWithoutTariffPlanInput = {
    id?: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffRateCreateOrConnectWithoutTariffPlanInput = {
    where: TariffRateWhereUniqueInput
    create: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput>
  }

  export type TariffRateCreateManyTariffPlanInputEnvelope = {
    data: TariffRateCreateManyTariffPlanInput | TariffRateCreateManyTariffPlanInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutTariffPlansInput = {
    update: XOR<BranchUpdateWithoutTariffPlansInput, BranchUncheckedUpdateWithoutTariffPlansInput>
    create: XOR<BranchCreateWithoutTariffPlansInput, BranchUncheckedCreateWithoutTariffPlansInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutTariffPlansInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutTariffPlansInput, BranchUncheckedUpdateWithoutTariffPlansInput>
  }

  export type BranchUpdateWithoutTariffPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutTariffPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput = {
    where: TariffRateWhereUniqueInput
    update: XOR<TariffRateUpdateWithoutTariffPlanInput, TariffRateUncheckedUpdateWithoutTariffPlanInput>
    create: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput>
  }

  export type TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput = {
    where: TariffRateWhereUniqueInput
    data: XOR<TariffRateUpdateWithoutTariffPlanInput, TariffRateUncheckedUpdateWithoutTariffPlanInput>
  }

  export type TariffRateUpdateManyWithWhereWithoutTariffPlanInput = {
    where: TariffRateScalarWhereInput
    data: XOR<TariffRateUpdateManyMutationInput, TariffRateUncheckedUpdateManyWithoutTariffPlanInput>
  }

  export type TariffRateScalarWhereInput = {
    AND?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
    OR?: TariffRateScalarWhereInput[]
    NOT?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
    id?: StringFilter<"TariffRate"> | string
    tariffPlanId?: StringFilter<"TariffRate"> | string
    serviceCode?: StringFilter<"TariffRate"> | string
    amount?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeFilter<"TariffRate"> | Date | string
  }

  export type TariffPlanCreateWithoutRatesInput = {
    id?: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutTariffPlansInput
  }

  export type TariffPlanUncheckedCreateWithoutRatesInput = {
    id?: string
    branchId: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffPlanCreateOrConnectWithoutRatesInput = {
    where: TariffPlanWhereUniqueInput
    create: XOR<TariffPlanCreateWithoutRatesInput, TariffPlanUncheckedCreateWithoutRatesInput>
  }

  export type TariffPlanUpsertWithoutRatesInput = {
    update: XOR<TariffPlanUpdateWithoutRatesInput, TariffPlanUncheckedUpdateWithoutRatesInput>
    create: XOR<TariffPlanCreateWithoutRatesInput, TariffPlanUncheckedCreateWithoutRatesInput>
    where?: TariffPlanWhereInput
  }

  export type TariffPlanUpdateToOneWithWhereWithoutRatesInput = {
    where?: TariffPlanWhereInput
    data: XOR<TariffPlanUpdateWithoutRatesInput, TariffPlanUncheckedUpdateWithoutRatesInput>
  }

  export type TariffPlanUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutTariffPlansNestedInput
  }

  export type TariffPlanUncheckedUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateWithoutConsentRecordsInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutConsentRecordsInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutConsentRecordsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutConsentRecordsInput, PatientUncheckedCreateWithoutConsentRecordsInput>
  }

  export type PatientUpsertWithoutConsentRecordsInput = {
    update: XOR<PatientUpdateWithoutConsentRecordsInput, PatientUncheckedUpdateWithoutConsentRecordsInput>
    create: XOR<PatientCreateWithoutConsentRecordsInput, PatientUncheckedCreateWithoutConsentRecordsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutConsentRecordsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutConsentRecordsInput, PatientUncheckedUpdateWithoutConsentRecordsInput>
  }

  export type PatientUpdateWithoutConsentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutConsentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutRtbfRequestsInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutRtbfRequestsInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutRtbfRequestsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutRtbfRequestsInput, PatientUncheckedCreateWithoutRtbfRequestsInput>
  }

  export type PatientUpsertWithoutRtbfRequestsInput = {
    update: XOR<PatientUpdateWithoutRtbfRequestsInput, PatientUncheckedUpdateWithoutRtbfRequestsInput>
    create: XOR<PatientCreateWithoutRtbfRequestsInput, PatientUncheckedCreateWithoutRtbfRequestsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutRtbfRequestsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutRtbfRequestsInput, PatientUncheckedUpdateWithoutRtbfRequestsInput>
  }

  export type PatientUpdateWithoutRtbfRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutRtbfRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type BranchCreateWithoutStatutoryCasesInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutStatutoryCasesInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutStatutoryCasesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutStatutoryCasesInput, BranchUncheckedCreateWithoutStatutoryCasesInput>
  }

  export type PatientCreateWithoutStatutoryCasesInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutStatutoryCasesInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutStatutoryCasesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutStatutoryCasesInput, PatientUncheckedCreateWithoutStatutoryCasesInput>
  }

  export type BranchUpsertWithoutStatutoryCasesInput = {
    update: XOR<BranchUpdateWithoutStatutoryCasesInput, BranchUncheckedUpdateWithoutStatutoryCasesInput>
    create: XOR<BranchCreateWithoutStatutoryCasesInput, BranchUncheckedCreateWithoutStatutoryCasesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutStatutoryCasesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutStatutoryCasesInput, BranchUncheckedUpdateWithoutStatutoryCasesInput>
  }

  export type BranchUpdateWithoutStatutoryCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutStatutoryCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PatientUpsertWithoutStatutoryCasesInput = {
    update: XOR<PatientUpdateWithoutStatutoryCasesInput, PatientUncheckedUpdateWithoutStatutoryCasesInput>
    create: XOR<PatientCreateWithoutStatutoryCasesInput, PatientUncheckedCreateWithoutStatutoryCasesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutStatutoryCasesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutStatutoryCasesInput, PatientUncheckedUpdateWithoutStatutoryCasesInput>
  }

  export type PatientUpdateWithoutStatutoryCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutStatutoryCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type BranchCreateWithoutAuditEventsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAuditEventsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAuditEventsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAuditEventsInput, BranchUncheckedCreateWithoutAuditEventsInput>
  }

  export type UserCreateWithoutAuditEventsAsActorInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutAuditEventsAsActorInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutAuditEventsAsActorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditEventsAsActorInput, UserUncheckedCreateWithoutAuditEventsAsActorInput>
  }

  export type BranchUpsertWithoutAuditEventsInput = {
    update: XOR<BranchUpdateWithoutAuditEventsInput, BranchUncheckedUpdateWithoutAuditEventsInput>
    create: XOR<BranchCreateWithoutAuditEventsInput, BranchUncheckedCreateWithoutAuditEventsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAuditEventsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAuditEventsInput, BranchUncheckedUpdateWithoutAuditEventsInput>
  }

  export type BranchUpdateWithoutAuditEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAuditEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserUpsertWithoutAuditEventsAsActorInput = {
    update: XOR<UserUpdateWithoutAuditEventsAsActorInput, UserUncheckedUpdateWithoutAuditEventsAsActorInput>
    create: XOR<UserCreateWithoutAuditEventsAsActorInput, UserUncheckedCreateWithoutAuditEventsAsActorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditEventsAsActorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditEventsAsActorInput, UserUncheckedUpdateWithoutAuditEventsAsActorInput>
  }

  export type UserUpdateWithoutAuditEventsAsActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditEventsAsActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type RoleTemplatePermissionCreateWithoutPermissionInput = {
    id?: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roleVersion: RoleTemplateVersionCreateNestedOneWithoutPermissionsInput
  }

  export type RoleTemplatePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleVersionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionCreateOrConnectWithoutPermissionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    create: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RoleTemplatePermissionCreateManyPermissionInputEnvelope = {
    data: RoleTemplatePermissionCreateManyPermissionInput | RoleTemplatePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RoleTemplatePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    update: XOR<RoleTemplatePermissionUpdateWithoutPermissionInput, RoleTemplatePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RoleTemplatePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    data: XOR<RoleTemplatePermissionUpdateWithoutPermissionInput, RoleTemplatePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RoleTemplatePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RoleTemplatePermissionScalarWhereInput
    data: XOR<RoleTemplatePermissionUpdateManyMutationInput, RoleTemplatePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleTemplatePermissionScalarWhereInput = {
    AND?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
    OR?: RoleTemplatePermissionScalarWhereInput[]
    NOT?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
    id?: StringFilter<"RoleTemplatePermission"> | string
    roleVersionId?: StringFilter<"RoleTemplatePermission"> | string
    permissionId?: StringFilter<"RoleTemplatePermission"> | string
    allowed?: BoolFilter<"RoleTemplatePermission"> | boolean
    createdAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
  }

  export type RoleTemplateVersionCreateWithoutRoleTemplateInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUser?: UserCreateNestedOneWithoutCreatedRoleVersionsInput
    permissions?: RoleTemplatePermissionCreateNestedManyWithoutRoleVersionInput
    users?: UserCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RoleTemplatePermissionUncheckedCreateNestedManyWithoutRoleVersionInput
    users?: UserUncheckedCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput = {
    where: RoleTemplateVersionWhereUniqueInput
    create: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput>
  }

  export type RoleTemplateVersionCreateManyRoleTemplateInputEnvelope = {
    data: RoleTemplateVersionCreateManyRoleTemplateInput | RoleTemplateVersionCreateManyRoleTemplateInput[]
    skipDuplicates?: boolean
  }

  export type RoleTemplateVersionUpsertWithWhereUniqueWithoutRoleTemplateInput = {
    where: RoleTemplateVersionWhereUniqueInput
    update: XOR<RoleTemplateVersionUpdateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedUpdateWithoutRoleTemplateInput>
    create: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput>
  }

  export type RoleTemplateVersionUpdateWithWhereUniqueWithoutRoleTemplateInput = {
    where: RoleTemplateVersionWhereUniqueInput
    data: XOR<RoleTemplateVersionUpdateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedUpdateWithoutRoleTemplateInput>
  }

  export type RoleTemplateVersionUpdateManyWithWhereWithoutRoleTemplateInput = {
    where: RoleTemplateVersionScalarWhereInput
    data: XOR<RoleTemplateVersionUpdateManyMutationInput, RoleTemplateVersionUncheckedUpdateManyWithoutRoleTemplateInput>
  }

  export type RoleTemplateCreateWithoutVersionsInput = {
    id?: string
    code: string
    name: string
    scope?: $Enums.RoleScope
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateUncheckedCreateWithoutVersionsInput = {
    id?: string
    code: string
    name: string
    scope?: $Enums.RoleScope
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateCreateOrConnectWithoutVersionsInput = {
    where: RoleTemplateWhereUniqueInput
    create: XOR<RoleTemplateCreateWithoutVersionsInput, RoleTemplateUncheckedCreateWithoutVersionsInput>
  }

  export type UserCreateWithoutCreatedRoleVersionsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutCreatedRoleVersionsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutCreatedRoleVersionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedRoleVersionsInput, UserUncheckedCreateWithoutCreatedRoleVersionsInput>
  }

  export type RoleTemplatePermissionCreateWithoutRoleVersionInput = {
    id?: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRoleGrantsInput
  }

  export type RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput = {
    id?: string
    permissionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    create: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput>
  }

  export type RoleTemplatePermissionCreateManyRoleVersionInputEnvelope = {
    data: RoleTemplatePermissionCreateManyRoleVersionInput | RoleTemplatePermissionCreateManyRoleVersionInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRoleVersionInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutRoleVersionInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutRoleVersionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput>
  }

  export type UserCreateManyRoleVersionInputEnvelope = {
    data: UserCreateManyRoleVersionInput | UserCreateManyRoleVersionInput[]
    skipDuplicates?: boolean
  }

  export type RoleTemplateUpsertWithoutVersionsInput = {
    update: XOR<RoleTemplateUpdateWithoutVersionsInput, RoleTemplateUncheckedUpdateWithoutVersionsInput>
    create: XOR<RoleTemplateCreateWithoutVersionsInput, RoleTemplateUncheckedCreateWithoutVersionsInput>
    where?: RoleTemplateWhereInput
  }

  export type RoleTemplateUpdateToOneWithWhereWithoutVersionsInput = {
    where?: RoleTemplateWhereInput
    data: XOR<RoleTemplateUpdateWithoutVersionsInput, RoleTemplateUncheckedUpdateWithoutVersionsInput>
  }

  export type RoleTemplateUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedRoleVersionsInput = {
    update: XOR<UserUpdateWithoutCreatedRoleVersionsInput, UserUncheckedUpdateWithoutCreatedRoleVersionsInput>
    create: XOR<UserCreateWithoutCreatedRoleVersionsInput, UserUncheckedCreateWithoutCreatedRoleVersionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedRoleVersionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedRoleVersionsInput, UserUncheckedUpdateWithoutCreatedRoleVersionsInput>
  }

  export type UserUpdateWithoutCreatedRoleVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedRoleVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type RoleTemplatePermissionUpsertWithWhereUniqueWithoutRoleVersionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    update: XOR<RoleTemplatePermissionUpdateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedUpdateWithoutRoleVersionInput>
    create: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput>
  }

  export type RoleTemplatePermissionUpdateWithWhereUniqueWithoutRoleVersionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    data: XOR<RoleTemplatePermissionUpdateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedUpdateWithoutRoleVersionInput>
  }

  export type RoleTemplatePermissionUpdateManyWithWhereWithoutRoleVersionInput = {
    where: RoleTemplatePermissionScalarWhereInput
    data: XOR<RoleTemplatePermissionUpdateManyMutationInput, RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRoleVersionInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleVersionInput, UserUncheckedUpdateWithoutRoleVersionInput>
    create: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleVersionInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleVersionInput, UserUncheckedUpdateWithoutRoleVersionInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleVersionInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleVersionInput>
  }

  export type RoleTemplateVersionCreateWithoutPermissionsInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleTemplate: RoleTemplateCreateNestedOneWithoutVersionsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedRoleVersionsInput
    users?: UserCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUncheckedCreateWithoutPermissionsInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionCreateOrConnectWithoutPermissionsInput = {
    where: RoleTemplateVersionWhereUniqueInput
    create: XOR<RoleTemplateVersionCreateWithoutPermissionsInput, RoleTemplateVersionUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRoleGrantsInput = {
    id?: string
    code: string
    name: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRoleGrantsInput = {
    id?: string
    code: string
    name: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRoleGrantsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRoleGrantsInput, PermissionUncheckedCreateWithoutRoleGrantsInput>
  }

  export type RoleTemplateVersionUpsertWithoutPermissionsInput = {
    update: XOR<RoleTemplateVersionUpdateWithoutPermissionsInput, RoleTemplateVersionUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleTemplateVersionCreateWithoutPermissionsInput, RoleTemplateVersionUncheckedCreateWithoutPermissionsInput>
    where?: RoleTemplateVersionWhereInput
  }

  export type RoleTemplateVersionUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleTemplateVersionWhereInput
    data: XOR<RoleTemplateVersionUpdateWithoutPermissionsInput, RoleTemplateVersionUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleTemplateVersionUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleTemplate?: RoleTemplateUpdateOneRequiredWithoutVersionsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedRoleVersionsNestedInput
    users?: UserUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleVersionNestedInput
  }

  export type PermissionUpsertWithoutRoleGrantsInput = {
    update: XOR<PermissionUpdateWithoutRoleGrantsInput, PermissionUncheckedUpdateWithoutRoleGrantsInput>
    create: XOR<PermissionCreateWithoutRoleGrantsInput, PermissionUncheckedCreateWithoutRoleGrantsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRoleGrantsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRoleGrantsInput, PermissionUncheckedUpdateWithoutRoleGrantsInput>
  }

  export type PermissionUpdateWithoutRoleGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRoleGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionCreateWithoutPolicyInput = {
    id?: string
    scope?: $Enums.PolicyScope
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutPolicyVersionsInput
    branches?: PolicyVersionBranchCreateNestedManyWithoutPolicyVersionInput
    createdByUser?: UserCreateNestedOneWithoutPolicyVersionsCreatedByInput
    submittedByUser?: UserCreateNestedOneWithoutPolicyVersionsSubmittedByInput
    approvedByUser?: UserCreateNestedOneWithoutPolicyVersionsApprovedByInput
    rejectedByUser?: UserCreateNestedOneWithoutPolicyVersionsRejectedByInput
    retiredByUser?: UserCreateNestedOneWithoutPolicyVersionsRetiredByInput
  }

  export type PolicyVersionUncheckedCreateWithoutPolicyInput = {
    id?: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutPolicyVersionInput
  }

  export type PolicyVersionCreateOrConnectWithoutPolicyInput = {
    where: PolicyVersionWhereUniqueInput
    create: XOR<PolicyVersionCreateWithoutPolicyInput, PolicyVersionUncheckedCreateWithoutPolicyInput>
  }

  export type PolicyVersionCreateManyPolicyInputEnvelope = {
    data: PolicyVersionCreateManyPolicyInput | PolicyVersionCreateManyPolicyInput[]
    skipDuplicates?: boolean
  }

  export type PolicyVersionUpsertWithWhereUniqueWithoutPolicyInput = {
    where: PolicyVersionWhereUniqueInput
    update: XOR<PolicyVersionUpdateWithoutPolicyInput, PolicyVersionUncheckedUpdateWithoutPolicyInput>
    create: XOR<PolicyVersionCreateWithoutPolicyInput, PolicyVersionUncheckedCreateWithoutPolicyInput>
  }

  export type PolicyVersionUpdateWithWhereUniqueWithoutPolicyInput = {
    where: PolicyVersionWhereUniqueInput
    data: XOR<PolicyVersionUpdateWithoutPolicyInput, PolicyVersionUncheckedUpdateWithoutPolicyInput>
  }

  export type PolicyVersionUpdateManyWithWhereWithoutPolicyInput = {
    where: PolicyVersionScalarWhereInput
    data: XOR<PolicyVersionUpdateManyMutationInput, PolicyVersionUncheckedUpdateManyWithoutPolicyInput>
  }

  export type PolicyDefinitionCreateWithoutVersionsInput = {
    id?: string
    code: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyDefinitionUncheckedCreateWithoutVersionsInput = {
    id?: string
    code: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyDefinitionCreateOrConnectWithoutVersionsInput = {
    where: PolicyDefinitionWhereUniqueInput
    create: XOR<PolicyDefinitionCreateWithoutVersionsInput, PolicyDefinitionUncheckedCreateWithoutVersionsInput>
  }

  export type BranchCreateWithoutPolicyVersionsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutPolicyVersionsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutPolicyVersionsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutPolicyVersionsInput, BranchUncheckedCreateWithoutPolicyVersionsInput>
  }

  export type PolicyVersionBranchCreateWithoutPolicyVersionInput = {
    id?: string
    createdAt?: Date | string
    branch: BranchCreateNestedOneWithoutPolicyVersionBranchesInput
  }

  export type PolicyVersionBranchUncheckedCreateWithoutPolicyVersionInput = {
    id?: string
    branchId: string
    createdAt?: Date | string
  }

  export type PolicyVersionBranchCreateOrConnectWithoutPolicyVersionInput = {
    where: PolicyVersionBranchWhereUniqueInput
    create: XOR<PolicyVersionBranchCreateWithoutPolicyVersionInput, PolicyVersionBranchUncheckedCreateWithoutPolicyVersionInput>
  }

  export type PolicyVersionBranchCreateManyPolicyVersionInputEnvelope = {
    data: PolicyVersionBranchCreateManyPolicyVersionInput | PolicyVersionBranchCreateManyPolicyVersionInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPolicyVersionsCreatedByInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutPolicyVersionsCreatedByInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutPolicyVersionsCreatedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPolicyVersionsCreatedByInput, UserUncheckedCreateWithoutPolicyVersionsCreatedByInput>
  }

  export type UserCreateWithoutPolicyVersionsSubmittedByInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutPolicyVersionsSubmittedByInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutPolicyVersionsSubmittedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPolicyVersionsSubmittedByInput, UserUncheckedCreateWithoutPolicyVersionsSubmittedByInput>
  }

  export type UserCreateWithoutPolicyVersionsApprovedByInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutPolicyVersionsApprovedByInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutPolicyVersionsApprovedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPolicyVersionsApprovedByInput, UserUncheckedCreateWithoutPolicyVersionsApprovedByInput>
  }

  export type UserCreateWithoutPolicyVersionsRejectedByInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutPolicyVersionsRejectedByInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutPolicyVersionsRejectedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPolicyVersionsRejectedByInput, UserUncheckedCreateWithoutPolicyVersionsRejectedByInput>
  }

  export type UserCreateWithoutPolicyVersionsRetiredByInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutPolicyVersionsRetiredByInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutPolicyVersionsRetiredByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPolicyVersionsRetiredByInput, UserUncheckedCreateWithoutPolicyVersionsRetiredByInput>
  }

  export type PolicyDefinitionUpsertWithoutVersionsInput = {
    update: XOR<PolicyDefinitionUpdateWithoutVersionsInput, PolicyDefinitionUncheckedUpdateWithoutVersionsInput>
    create: XOR<PolicyDefinitionCreateWithoutVersionsInput, PolicyDefinitionUncheckedCreateWithoutVersionsInput>
    where?: PolicyDefinitionWhereInput
  }

  export type PolicyDefinitionUpdateToOneWithWhereWithoutVersionsInput = {
    where?: PolicyDefinitionWhereInput
    data: XOR<PolicyDefinitionUpdateWithoutVersionsInput, PolicyDefinitionUncheckedUpdateWithoutVersionsInput>
  }

  export type PolicyDefinitionUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyDefinitionUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUpsertWithoutPolicyVersionsInput = {
    update: XOR<BranchUpdateWithoutPolicyVersionsInput, BranchUncheckedUpdateWithoutPolicyVersionsInput>
    create: XOR<BranchCreateWithoutPolicyVersionsInput, BranchUncheckedCreateWithoutPolicyVersionsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutPolicyVersionsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutPolicyVersionsInput, BranchUncheckedUpdateWithoutPolicyVersionsInput>
  }

  export type BranchUpdateWithoutPolicyVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutPolicyVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PolicyVersionBranchUpsertWithWhereUniqueWithoutPolicyVersionInput = {
    where: PolicyVersionBranchWhereUniqueInput
    update: XOR<PolicyVersionBranchUpdateWithoutPolicyVersionInput, PolicyVersionBranchUncheckedUpdateWithoutPolicyVersionInput>
    create: XOR<PolicyVersionBranchCreateWithoutPolicyVersionInput, PolicyVersionBranchUncheckedCreateWithoutPolicyVersionInput>
  }

  export type PolicyVersionBranchUpdateWithWhereUniqueWithoutPolicyVersionInput = {
    where: PolicyVersionBranchWhereUniqueInput
    data: XOR<PolicyVersionBranchUpdateWithoutPolicyVersionInput, PolicyVersionBranchUncheckedUpdateWithoutPolicyVersionInput>
  }

  export type PolicyVersionBranchUpdateManyWithWhereWithoutPolicyVersionInput = {
    where: PolicyVersionBranchScalarWhereInput
    data: XOR<PolicyVersionBranchUpdateManyMutationInput, PolicyVersionBranchUncheckedUpdateManyWithoutPolicyVersionInput>
  }

  export type UserUpsertWithoutPolicyVersionsCreatedByInput = {
    update: XOR<UserUpdateWithoutPolicyVersionsCreatedByInput, UserUncheckedUpdateWithoutPolicyVersionsCreatedByInput>
    create: XOR<UserCreateWithoutPolicyVersionsCreatedByInput, UserUncheckedCreateWithoutPolicyVersionsCreatedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPolicyVersionsCreatedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPolicyVersionsCreatedByInput, UserUncheckedUpdateWithoutPolicyVersionsCreatedByInput>
  }

  export type UserUpdateWithoutPolicyVersionsCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPolicyVersionsCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUpsertWithoutPolicyVersionsSubmittedByInput = {
    update: XOR<UserUpdateWithoutPolicyVersionsSubmittedByInput, UserUncheckedUpdateWithoutPolicyVersionsSubmittedByInput>
    create: XOR<UserCreateWithoutPolicyVersionsSubmittedByInput, UserUncheckedCreateWithoutPolicyVersionsSubmittedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPolicyVersionsSubmittedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPolicyVersionsSubmittedByInput, UserUncheckedUpdateWithoutPolicyVersionsSubmittedByInput>
  }

  export type UserUpdateWithoutPolicyVersionsSubmittedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPolicyVersionsSubmittedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUpsertWithoutPolicyVersionsApprovedByInput = {
    update: XOR<UserUpdateWithoutPolicyVersionsApprovedByInput, UserUncheckedUpdateWithoutPolicyVersionsApprovedByInput>
    create: XOR<UserCreateWithoutPolicyVersionsApprovedByInput, UserUncheckedCreateWithoutPolicyVersionsApprovedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPolicyVersionsApprovedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPolicyVersionsApprovedByInput, UserUncheckedUpdateWithoutPolicyVersionsApprovedByInput>
  }

  export type UserUpdateWithoutPolicyVersionsApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPolicyVersionsApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUpsertWithoutPolicyVersionsRejectedByInput = {
    update: XOR<UserUpdateWithoutPolicyVersionsRejectedByInput, UserUncheckedUpdateWithoutPolicyVersionsRejectedByInput>
    create: XOR<UserCreateWithoutPolicyVersionsRejectedByInput, UserUncheckedCreateWithoutPolicyVersionsRejectedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPolicyVersionsRejectedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPolicyVersionsRejectedByInput, UserUncheckedUpdateWithoutPolicyVersionsRejectedByInput>
  }

  export type UserUpdateWithoutPolicyVersionsRejectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPolicyVersionsRejectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUpsertWithoutPolicyVersionsRetiredByInput = {
    update: XOR<UserUpdateWithoutPolicyVersionsRetiredByInput, UserUncheckedUpdateWithoutPolicyVersionsRetiredByInput>
    create: XOR<UserCreateWithoutPolicyVersionsRetiredByInput, UserUncheckedCreateWithoutPolicyVersionsRetiredByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPolicyVersionsRetiredByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPolicyVersionsRetiredByInput, UserUncheckedUpdateWithoutPolicyVersionsRetiredByInput>
  }

  export type UserUpdateWithoutPolicyVersionsRetiredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPolicyVersionsRetiredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type PolicyVersionCreateWithoutBranchesInput = {
    id?: string
    scope?: $Enums.PolicyScope
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    policy: PolicyDefinitionCreateNestedOneWithoutVersionsInput
    branch?: BranchCreateNestedOneWithoutPolicyVersionsInput
    createdByUser?: UserCreateNestedOneWithoutPolicyVersionsCreatedByInput
    submittedByUser?: UserCreateNestedOneWithoutPolicyVersionsSubmittedByInput
    approvedByUser?: UserCreateNestedOneWithoutPolicyVersionsApprovedByInput
    rejectedByUser?: UserCreateNestedOneWithoutPolicyVersionsRejectedByInput
    retiredByUser?: UserCreateNestedOneWithoutPolicyVersionsRetiredByInput
  }

  export type PolicyVersionUncheckedCreateWithoutBranchesInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyVersionCreateOrConnectWithoutBranchesInput = {
    where: PolicyVersionWhereUniqueInput
    create: XOR<PolicyVersionCreateWithoutBranchesInput, PolicyVersionUncheckedCreateWithoutBranchesInput>
  }

  export type BranchCreateWithoutPolicyVersionBranchesInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutPolicyVersionBranchesInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutPolicyVersionBranchesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutPolicyVersionBranchesInput, BranchUncheckedCreateWithoutPolicyVersionBranchesInput>
  }

  export type PolicyVersionUpsertWithoutBranchesInput = {
    update: XOR<PolicyVersionUpdateWithoutBranchesInput, PolicyVersionUncheckedUpdateWithoutBranchesInput>
    create: XOR<PolicyVersionCreateWithoutBranchesInput, PolicyVersionUncheckedCreateWithoutBranchesInput>
    where?: PolicyVersionWhereInput
  }

  export type PolicyVersionUpdateToOneWithWhereWithoutBranchesInput = {
    where?: PolicyVersionWhereInput
    data: XOR<PolicyVersionUpdateWithoutBranchesInput, PolicyVersionUncheckedUpdateWithoutBranchesInput>
  }

  export type PolicyVersionUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policy?: PolicyDefinitionUpdateOneRequiredWithoutVersionsNestedInput
    branch?: BranchUpdateOneWithoutPolicyVersionsNestedInput
    createdByUser?: UserUpdateOneWithoutPolicyVersionsCreatedByNestedInput
    submittedByUser?: UserUpdateOneWithoutPolicyVersionsSubmittedByNestedInput
    approvedByUser?: UserUpdateOneWithoutPolicyVersionsApprovedByNestedInput
    rejectedByUser?: UserUpdateOneWithoutPolicyVersionsRejectedByNestedInput
    retiredByUser?: UserUpdateOneWithoutPolicyVersionsRetiredByNestedInput
  }

  export type PolicyVersionUncheckedUpdateWithoutBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUpsertWithoutPolicyVersionBranchesInput = {
    update: XOR<BranchUpdateWithoutPolicyVersionBranchesInput, BranchUncheckedUpdateWithoutPolicyVersionBranchesInput>
    create: XOR<BranchCreateWithoutPolicyVersionBranchesInput, BranchUncheckedCreateWithoutPolicyVersionBranchesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutPolicyVersionBranchesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutPolicyVersionBranchesInput, BranchUncheckedUpdateWithoutPolicyVersionBranchesInput>
  }

  export type BranchUpdateWithoutPolicyVersionBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutPolicyVersionBranchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutLocationNodesInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutLocationNodesInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutLocationNodesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutLocationNodesInput, BranchUncheckedCreateWithoutLocationNodesInput>
  }

  export type LocationNodeCreateWithoutChildrenInput = {
    id?: string
    kind: $Enums.LocationKind
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutLocationNodesInput
    parent?: LocationNodeCreateNestedOneWithoutChildrenInput
    revisions?: LocationNodeRevisionCreateNestedManyWithoutNodeInput
    EquipmentAsset?: EquipmentAssetCreateNestedManyWithoutLocationNodeInput
  }

  export type LocationNodeUncheckedCreateWithoutChildrenInput = {
    id?: string
    branchId: string
    kind: $Enums.LocationKind
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    revisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutNodeInput
    EquipmentAsset?: EquipmentAssetUncheckedCreateNestedManyWithoutLocationNodeInput
  }

  export type LocationNodeCreateOrConnectWithoutChildrenInput = {
    where: LocationNodeWhereUniqueInput
    create: XOR<LocationNodeCreateWithoutChildrenInput, LocationNodeUncheckedCreateWithoutChildrenInput>
  }

  export type LocationNodeCreateWithoutParentInput = {
    id?: string
    kind: $Enums.LocationKind
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutLocationNodesInput
    children?: LocationNodeCreateNestedManyWithoutParentInput
    revisions?: LocationNodeRevisionCreateNestedManyWithoutNodeInput
    EquipmentAsset?: EquipmentAssetCreateNestedManyWithoutLocationNodeInput
  }

  export type LocationNodeUncheckedCreateWithoutParentInput = {
    id?: string
    branchId: string
    kind: $Enums.LocationKind
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationNodeUncheckedCreateNestedManyWithoutParentInput
    revisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutNodeInput
    EquipmentAsset?: EquipmentAssetUncheckedCreateNestedManyWithoutLocationNodeInput
  }

  export type LocationNodeCreateOrConnectWithoutParentInput = {
    where: LocationNodeWhereUniqueInput
    create: XOR<LocationNodeCreateWithoutParentInput, LocationNodeUncheckedCreateWithoutParentInput>
  }

  export type LocationNodeCreateManyParentInputEnvelope = {
    data: LocationNodeCreateManyParentInput | LocationNodeCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type LocationNodeRevisionCreateWithoutNodeInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    createdByUser?: UserCreateNestedOneWithoutCreatedLocationRevisionsInput
  }

  export type LocationNodeRevisionUncheckedCreateWithoutNodeInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type LocationNodeRevisionCreateOrConnectWithoutNodeInput = {
    where: LocationNodeRevisionWhereUniqueInput
    create: XOR<LocationNodeRevisionCreateWithoutNodeInput, LocationNodeRevisionUncheckedCreateWithoutNodeInput>
  }

  export type LocationNodeRevisionCreateManyNodeInputEnvelope = {
    data: LocationNodeRevisionCreateManyNodeInput | LocationNodeRevisionCreateManyNodeInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentAssetCreateWithoutLocationNodeInput = {
    id?: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEquipmentAssetsInput
    ownerDepartment?: DepartmentCreateNestedOneWithoutEquipmentOwnedInput
    unit?: UnitCreateNestedOneWithoutEquipmentInput
    room?: UnitRoomCreateNestedOneWithoutEquipmentInput
    downtimeTickets?: DowntimeTicketCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetUncheckedCreateWithoutLocationNodeInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    ownerDepartmentId?: string | null
    unitId?: string | null
    roomId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    downtimeTickets?: DowntimeTicketUncheckedCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetCreateOrConnectWithoutLocationNodeInput = {
    where: EquipmentAssetWhereUniqueInput
    create: XOR<EquipmentAssetCreateWithoutLocationNodeInput, EquipmentAssetUncheckedCreateWithoutLocationNodeInput>
  }

  export type EquipmentAssetCreateManyLocationNodeInputEnvelope = {
    data: EquipmentAssetCreateManyLocationNodeInput | EquipmentAssetCreateManyLocationNodeInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutLocationNodesInput = {
    update: XOR<BranchUpdateWithoutLocationNodesInput, BranchUncheckedUpdateWithoutLocationNodesInput>
    create: XOR<BranchCreateWithoutLocationNodesInput, BranchUncheckedCreateWithoutLocationNodesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutLocationNodesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutLocationNodesInput, BranchUncheckedUpdateWithoutLocationNodesInput>
  }

  export type BranchUpdateWithoutLocationNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutLocationNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type LocationNodeUpsertWithoutChildrenInput = {
    update: XOR<LocationNodeUpdateWithoutChildrenInput, LocationNodeUncheckedUpdateWithoutChildrenInput>
    create: XOR<LocationNodeCreateWithoutChildrenInput, LocationNodeUncheckedCreateWithoutChildrenInput>
    where?: LocationNodeWhereInput
  }

  export type LocationNodeUpdateToOneWithWhereWithoutChildrenInput = {
    where?: LocationNodeWhereInput
    data: XOR<LocationNodeUpdateWithoutChildrenInput, LocationNodeUncheckedUpdateWithoutChildrenInput>
  }

  export type LocationNodeUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLocationNodesNestedInput
    parent?: LocationNodeUpdateOneWithoutChildrenNestedInput
    revisions?: LocationNodeRevisionUpdateManyWithoutNodeNestedInput
    EquipmentAsset?: EquipmentAssetUpdateManyWithoutLocationNodeNestedInput
  }

  export type LocationNodeUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revisions?: LocationNodeRevisionUncheckedUpdateManyWithoutNodeNestedInput
    EquipmentAsset?: EquipmentAssetUncheckedUpdateManyWithoutLocationNodeNestedInput
  }

  export type LocationNodeUpsertWithWhereUniqueWithoutParentInput = {
    where: LocationNodeWhereUniqueInput
    update: XOR<LocationNodeUpdateWithoutParentInput, LocationNodeUncheckedUpdateWithoutParentInput>
    create: XOR<LocationNodeCreateWithoutParentInput, LocationNodeUncheckedCreateWithoutParentInput>
  }

  export type LocationNodeUpdateWithWhereUniqueWithoutParentInput = {
    where: LocationNodeWhereUniqueInput
    data: XOR<LocationNodeUpdateWithoutParentInput, LocationNodeUncheckedUpdateWithoutParentInput>
  }

  export type LocationNodeUpdateManyWithWhereWithoutParentInput = {
    where: LocationNodeScalarWhereInput
    data: XOR<LocationNodeUpdateManyMutationInput, LocationNodeUncheckedUpdateManyWithoutParentInput>
  }

  export type LocationNodeRevisionUpsertWithWhereUniqueWithoutNodeInput = {
    where: LocationNodeRevisionWhereUniqueInput
    update: XOR<LocationNodeRevisionUpdateWithoutNodeInput, LocationNodeRevisionUncheckedUpdateWithoutNodeInput>
    create: XOR<LocationNodeRevisionCreateWithoutNodeInput, LocationNodeRevisionUncheckedCreateWithoutNodeInput>
  }

  export type LocationNodeRevisionUpdateWithWhereUniqueWithoutNodeInput = {
    where: LocationNodeRevisionWhereUniqueInput
    data: XOR<LocationNodeRevisionUpdateWithoutNodeInput, LocationNodeRevisionUncheckedUpdateWithoutNodeInput>
  }

  export type LocationNodeRevisionUpdateManyWithWhereWithoutNodeInput = {
    where: LocationNodeRevisionScalarWhereInput
    data: XOR<LocationNodeRevisionUpdateManyMutationInput, LocationNodeRevisionUncheckedUpdateManyWithoutNodeInput>
  }

  export type EquipmentAssetUpsertWithWhereUniqueWithoutLocationNodeInput = {
    where: EquipmentAssetWhereUniqueInput
    update: XOR<EquipmentAssetUpdateWithoutLocationNodeInput, EquipmentAssetUncheckedUpdateWithoutLocationNodeInput>
    create: XOR<EquipmentAssetCreateWithoutLocationNodeInput, EquipmentAssetUncheckedCreateWithoutLocationNodeInput>
  }

  export type EquipmentAssetUpdateWithWhereUniqueWithoutLocationNodeInput = {
    where: EquipmentAssetWhereUniqueInput
    data: XOR<EquipmentAssetUpdateWithoutLocationNodeInput, EquipmentAssetUncheckedUpdateWithoutLocationNodeInput>
  }

  export type EquipmentAssetUpdateManyWithWhereWithoutLocationNodeInput = {
    where: EquipmentAssetScalarWhereInput
    data: XOR<EquipmentAssetUpdateManyMutationInput, EquipmentAssetUncheckedUpdateManyWithoutLocationNodeInput>
  }

  export type LocationNodeCreateWithoutRevisionsInput = {
    id?: string
    kind: $Enums.LocationKind
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutLocationNodesInput
    parent?: LocationNodeCreateNestedOneWithoutChildrenInput
    children?: LocationNodeCreateNestedManyWithoutParentInput
    EquipmentAsset?: EquipmentAssetCreateNestedManyWithoutLocationNodeInput
  }

  export type LocationNodeUncheckedCreateWithoutRevisionsInput = {
    id?: string
    branchId: string
    kind: $Enums.LocationKind
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationNodeUncheckedCreateNestedManyWithoutParentInput
    EquipmentAsset?: EquipmentAssetUncheckedCreateNestedManyWithoutLocationNodeInput
  }

  export type LocationNodeCreateOrConnectWithoutRevisionsInput = {
    where: LocationNodeWhereUniqueInput
    create: XOR<LocationNodeCreateWithoutRevisionsInput, LocationNodeUncheckedCreateWithoutRevisionsInput>
  }

  export type UserCreateWithoutCreatedLocationRevisionsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutCreatedLocationRevisionsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutCreatedLocationRevisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedLocationRevisionsInput, UserUncheckedCreateWithoutCreatedLocationRevisionsInput>
  }

  export type LocationNodeUpsertWithoutRevisionsInput = {
    update: XOR<LocationNodeUpdateWithoutRevisionsInput, LocationNodeUncheckedUpdateWithoutRevisionsInput>
    create: XOR<LocationNodeCreateWithoutRevisionsInput, LocationNodeUncheckedCreateWithoutRevisionsInput>
    where?: LocationNodeWhereInput
  }

  export type LocationNodeUpdateToOneWithWhereWithoutRevisionsInput = {
    where?: LocationNodeWhereInput
    data: XOR<LocationNodeUpdateWithoutRevisionsInput, LocationNodeUncheckedUpdateWithoutRevisionsInput>
  }

  export type LocationNodeUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLocationNodesNestedInput
    parent?: LocationNodeUpdateOneWithoutChildrenNestedInput
    children?: LocationNodeUpdateManyWithoutParentNestedInput
    EquipmentAsset?: EquipmentAssetUpdateManyWithoutLocationNodeNestedInput
  }

  export type LocationNodeUncheckedUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationNodeUncheckedUpdateManyWithoutParentNestedInput
    EquipmentAsset?: EquipmentAssetUncheckedUpdateManyWithoutLocationNodeNestedInput
  }

  export type UserUpsertWithoutCreatedLocationRevisionsInput = {
    update: XOR<UserUpdateWithoutCreatedLocationRevisionsInput, UserUncheckedUpdateWithoutCreatedLocationRevisionsInput>
    create: XOR<UserCreateWithoutCreatedLocationRevisionsInput, UserUncheckedCreateWithoutCreatedLocationRevisionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedLocationRevisionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedLocationRevisionsInput, UserUncheckedUpdateWithoutCreatedLocationRevisionsInput>
  }

  export type UserUpdateWithoutCreatedLocationRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedLocationRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type BranchUnitTypeCreateWithoutUnitTypeInput = {
    id?: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitTypesEnabledInput
  }

  export type BranchUnitTypeUncheckedCreateWithoutUnitTypeInput = {
    id?: string
    branchId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUnitTypeCreateOrConnectWithoutUnitTypeInput = {
    where: BranchUnitTypeWhereUniqueInput
    create: XOR<BranchUnitTypeCreateWithoutUnitTypeInput, BranchUnitTypeUncheckedCreateWithoutUnitTypeInput>
  }

  export type BranchUnitTypeCreateManyUnitTypeInputEnvelope = {
    data: BranchUnitTypeCreateManyUnitTypeInput | BranchUnitTypeCreateManyUnitTypeInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutUnitTypeInput = {
    id?: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitsInput
    department: DepartmentCreateNestedOneWithoutUnitsInput
    rooms?: UnitRoomCreateNestedManyWithoutUnitInput
    resources?: UnitResourceCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutUnitTypeInput = {
    id?: string
    branchId: string
    departmentId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: UnitRoomUncheckedCreateNestedManyWithoutUnitInput
    resources?: UnitResourceUncheckedCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetUncheckedCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutUnitTypeInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput>
  }

  export type UnitCreateManyUnitTypeInputEnvelope = {
    data: UnitCreateManyUnitTypeInput | UnitCreateManyUnitTypeInput[]
    skipDuplicates?: boolean
  }

  export type BranchUnitTypeUpsertWithWhereUniqueWithoutUnitTypeInput = {
    where: BranchUnitTypeWhereUniqueInput
    update: XOR<BranchUnitTypeUpdateWithoutUnitTypeInput, BranchUnitTypeUncheckedUpdateWithoutUnitTypeInput>
    create: XOR<BranchUnitTypeCreateWithoutUnitTypeInput, BranchUnitTypeUncheckedCreateWithoutUnitTypeInput>
  }

  export type BranchUnitTypeUpdateWithWhereUniqueWithoutUnitTypeInput = {
    where: BranchUnitTypeWhereUniqueInput
    data: XOR<BranchUnitTypeUpdateWithoutUnitTypeInput, BranchUnitTypeUncheckedUpdateWithoutUnitTypeInput>
  }

  export type BranchUnitTypeUpdateManyWithWhereWithoutUnitTypeInput = {
    where: BranchUnitTypeScalarWhereInput
    data: XOR<BranchUnitTypeUpdateManyMutationInput, BranchUnitTypeUncheckedUpdateManyWithoutUnitTypeInput>
  }

  export type UnitUpsertWithWhereUniqueWithoutUnitTypeInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutUnitTypeInput, UnitUncheckedUpdateWithoutUnitTypeInput>
    create: XOR<UnitCreateWithoutUnitTypeInput, UnitUncheckedCreateWithoutUnitTypeInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutUnitTypeInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutUnitTypeInput, UnitUncheckedUpdateWithoutUnitTypeInput>
  }

  export type UnitUpdateManyWithWhereWithoutUnitTypeInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutUnitTypeInput>
  }

  export type BranchCreateWithoutUnitTypesEnabledInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUnitTypesEnabledInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUnitTypesEnabledInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUnitTypesEnabledInput, BranchUncheckedCreateWithoutUnitTypesEnabledInput>
  }

  export type UnitTypeCatalogCreateWithoutBranchLinksInput = {
    id?: string
    code: string
    name: string
    usesRoomsDefault?: boolean
    schedulableByDefault?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: UnitCreateNestedManyWithoutUnitTypeInput
  }

  export type UnitTypeCatalogUncheckedCreateWithoutBranchLinksInput = {
    id?: string
    code: string
    name: string
    usesRoomsDefault?: boolean
    schedulableByDefault?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    units?: UnitUncheckedCreateNestedManyWithoutUnitTypeInput
  }

  export type UnitTypeCatalogCreateOrConnectWithoutBranchLinksInput = {
    where: UnitTypeCatalogWhereUniqueInput
    create: XOR<UnitTypeCatalogCreateWithoutBranchLinksInput, UnitTypeCatalogUncheckedCreateWithoutBranchLinksInput>
  }

  export type BranchUpsertWithoutUnitTypesEnabledInput = {
    update: XOR<BranchUpdateWithoutUnitTypesEnabledInput, BranchUncheckedUpdateWithoutUnitTypesEnabledInput>
    create: XOR<BranchCreateWithoutUnitTypesEnabledInput, BranchUncheckedCreateWithoutUnitTypesEnabledInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUnitTypesEnabledInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUnitTypesEnabledInput, BranchUncheckedUpdateWithoutUnitTypesEnabledInput>
  }

  export type BranchUpdateWithoutUnitTypesEnabledInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUnitTypesEnabledInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UnitTypeCatalogUpsertWithoutBranchLinksInput = {
    update: XOR<UnitTypeCatalogUpdateWithoutBranchLinksInput, UnitTypeCatalogUncheckedUpdateWithoutBranchLinksInput>
    create: XOR<UnitTypeCatalogCreateWithoutBranchLinksInput, UnitTypeCatalogUncheckedCreateWithoutBranchLinksInput>
    where?: UnitTypeCatalogWhereInput
  }

  export type UnitTypeCatalogUpdateToOneWithWhereWithoutBranchLinksInput = {
    where?: UnitTypeCatalogWhereInput
    data: XOR<UnitTypeCatalogUpdateWithoutBranchLinksInput, UnitTypeCatalogUncheckedUpdateWithoutBranchLinksInput>
  }

  export type UnitTypeCatalogUpdateWithoutBranchLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRoomsDefault?: BoolFieldUpdateOperationsInput | boolean
    schedulableByDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUpdateManyWithoutUnitTypeNestedInput
  }

  export type UnitTypeCatalogUncheckedUpdateWithoutBranchLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRoomsDefault?: BoolFieldUpdateOperationsInput | boolean
    schedulableByDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUncheckedUpdateManyWithoutUnitTypeNestedInput
  }

  export type BranchCreateWithoutUnitsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUnitsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUnitsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUnitsInput, BranchUncheckedCreateWithoutUnitsInput>
  }

  export type DepartmentCreateWithoutUnitsInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDepartmentsInput
    facility: FacilityCatalogCreateNestedOneWithoutDepartmentsInput
    headStaff?: StaffCreateNestedOneWithoutHeadedDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutUnitsInput = {
    id?: string
    branchId: string
    facilityId: string
    code: string
    name: string
    headStaffId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutDepartmentInput
    equipmentOwned?: EquipmentAssetUncheckedCreateNestedManyWithoutOwnerDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutUnitsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutUnitsInput, DepartmentUncheckedCreateWithoutUnitsInput>
  }

  export type UnitTypeCatalogCreateWithoutUnitsInput = {
    id?: string
    code: string
    name: string
    usesRoomsDefault?: boolean
    schedulableByDefault?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branchLinks?: BranchUnitTypeCreateNestedManyWithoutUnitTypeInput
  }

  export type UnitTypeCatalogUncheckedCreateWithoutUnitsInput = {
    id?: string
    code: string
    name: string
    usesRoomsDefault?: boolean
    schedulableByDefault?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branchLinks?: BranchUnitTypeUncheckedCreateNestedManyWithoutUnitTypeInput
  }

  export type UnitTypeCatalogCreateOrConnectWithoutUnitsInput = {
    where: UnitTypeCatalogWhereUniqueInput
    create: XOR<UnitTypeCatalogCreateWithoutUnitsInput, UnitTypeCatalogUncheckedCreateWithoutUnitsInput>
  }

  export type UnitRoomCreateWithoutUnitInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitRoomsInput
    resources?: UnitResourceCreateNestedManyWithoutRoomInput
    equipment?: EquipmentAssetCreateNestedManyWithoutRoomInput
  }

  export type UnitRoomUncheckedCreateWithoutUnitInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: UnitResourceUncheckedCreateNestedManyWithoutRoomInput
    equipment?: EquipmentAssetUncheckedCreateNestedManyWithoutRoomInput
  }

  export type UnitRoomCreateOrConnectWithoutUnitInput = {
    where: UnitRoomWhereUniqueInput
    create: XOR<UnitRoomCreateWithoutUnitInput, UnitRoomUncheckedCreateWithoutUnitInput>
  }

  export type UnitRoomCreateManyUnitInputEnvelope = {
    data: UnitRoomCreateManyUnitInput | UnitRoomCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitResourceCreateWithoutUnitInput = {
    id?: string
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitResourcesInput
    room?: UnitRoomCreateNestedOneWithoutResourcesInput
    bookings?: ProcedureBookingCreateNestedManyWithoutResourceInput
  }

  export type UnitResourceUncheckedCreateWithoutUnitInput = {
    id?: string
    branchId: string
    roomId?: string | null
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ProcedureBookingUncheckedCreateNestedManyWithoutResourceInput
  }

  export type UnitResourceCreateOrConnectWithoutUnitInput = {
    where: UnitResourceWhereUniqueInput
    create: XOR<UnitResourceCreateWithoutUnitInput, UnitResourceUncheckedCreateWithoutUnitInput>
  }

  export type UnitResourceCreateManyUnitInputEnvelope = {
    data: UnitResourceCreateManyUnitInput | UnitResourceCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentAssetCreateWithoutUnitInput = {
    id?: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEquipmentAssetsInput
    ownerDepartment?: DepartmentCreateNestedOneWithoutEquipmentOwnedInput
    room?: UnitRoomCreateNestedOneWithoutEquipmentInput
    locationNode?: LocationNodeCreateNestedOneWithoutEquipmentAssetInput
    downtimeTickets?: DowntimeTicketCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetUncheckedCreateWithoutUnitInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    ownerDepartmentId?: string | null
    roomId?: string | null
    locationNodeId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    downtimeTickets?: DowntimeTicketUncheckedCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetCreateOrConnectWithoutUnitInput = {
    where: EquipmentAssetWhereUniqueInput
    create: XOR<EquipmentAssetCreateWithoutUnitInput, EquipmentAssetUncheckedCreateWithoutUnitInput>
  }

  export type EquipmentAssetCreateManyUnitInputEnvelope = {
    data: EquipmentAssetCreateManyUnitInput | EquipmentAssetCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ProcedureBookingCreateWithoutUnitInput = {
    id?: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProcedureBookingsInput
    resource: UnitResourceCreateNestedOneWithoutBookingsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedBookingsInput
  }

  export type ProcedureBookingUncheckedCreateWithoutUnitInput = {
    id?: string
    branchId: string
    resourceId: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureBookingCreateOrConnectWithoutUnitInput = {
    where: ProcedureBookingWhereUniqueInput
    create: XOR<ProcedureBookingCreateWithoutUnitInput, ProcedureBookingUncheckedCreateWithoutUnitInput>
  }

  export type ProcedureBookingCreateManyUnitInputEnvelope = {
    data: ProcedureBookingCreateManyUnitInput | ProcedureBookingCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutUnitsInput = {
    update: XOR<BranchUpdateWithoutUnitsInput, BranchUncheckedUpdateWithoutUnitsInput>
    create: XOR<BranchCreateWithoutUnitsInput, BranchUncheckedCreateWithoutUnitsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUnitsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUnitsInput, BranchUncheckedUpdateWithoutUnitsInput>
  }

  export type BranchUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type DepartmentUpsertWithoutUnitsInput = {
    update: XOR<DepartmentUpdateWithoutUnitsInput, DepartmentUncheckedUpdateWithoutUnitsInput>
    create: XOR<DepartmentCreateWithoutUnitsInput, DepartmentUncheckedCreateWithoutUnitsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutUnitsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutUnitsInput, DepartmentUncheckedUpdateWithoutUnitsInput>
  }

  export type DepartmentUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDepartmentsNestedInput
    facility?: FacilityCatalogUpdateOneRequiredWithoutDepartmentsNestedInput
    headStaff?: StaffUpdateOneWithoutHeadedDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    headStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUncheckedUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type UnitTypeCatalogUpsertWithoutUnitsInput = {
    update: XOR<UnitTypeCatalogUpdateWithoutUnitsInput, UnitTypeCatalogUncheckedUpdateWithoutUnitsInput>
    create: XOR<UnitTypeCatalogCreateWithoutUnitsInput, UnitTypeCatalogUncheckedCreateWithoutUnitsInput>
    where?: UnitTypeCatalogWhereInput
  }

  export type UnitTypeCatalogUpdateToOneWithWhereWithoutUnitsInput = {
    where?: UnitTypeCatalogWhereInput
    data: XOR<UnitTypeCatalogUpdateWithoutUnitsInput, UnitTypeCatalogUncheckedUpdateWithoutUnitsInput>
  }

  export type UnitTypeCatalogUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRoomsDefault?: BoolFieldUpdateOperationsInput | boolean
    schedulableByDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchLinks?: BranchUnitTypeUpdateManyWithoutUnitTypeNestedInput
  }

  export type UnitTypeCatalogUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRoomsDefault?: BoolFieldUpdateOperationsInput | boolean
    schedulableByDefault?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branchLinks?: BranchUnitTypeUncheckedUpdateManyWithoutUnitTypeNestedInput
  }

  export type UnitRoomUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitRoomWhereUniqueInput
    update: XOR<UnitRoomUpdateWithoutUnitInput, UnitRoomUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitRoomCreateWithoutUnitInput, UnitRoomUncheckedCreateWithoutUnitInput>
  }

  export type UnitRoomUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitRoomWhereUniqueInput
    data: XOR<UnitRoomUpdateWithoutUnitInput, UnitRoomUncheckedUpdateWithoutUnitInput>
  }

  export type UnitRoomUpdateManyWithWhereWithoutUnitInput = {
    where: UnitRoomScalarWhereInput
    data: XOR<UnitRoomUpdateManyMutationInput, UnitRoomUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitResourceUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitResourceWhereUniqueInput
    update: XOR<UnitResourceUpdateWithoutUnitInput, UnitResourceUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitResourceCreateWithoutUnitInput, UnitResourceUncheckedCreateWithoutUnitInput>
  }

  export type UnitResourceUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitResourceWhereUniqueInput
    data: XOR<UnitResourceUpdateWithoutUnitInput, UnitResourceUncheckedUpdateWithoutUnitInput>
  }

  export type UnitResourceUpdateManyWithWhereWithoutUnitInput = {
    where: UnitResourceScalarWhereInput
    data: XOR<UnitResourceUpdateManyMutationInput, UnitResourceUncheckedUpdateManyWithoutUnitInput>
  }

  export type EquipmentAssetUpsertWithWhereUniqueWithoutUnitInput = {
    where: EquipmentAssetWhereUniqueInput
    update: XOR<EquipmentAssetUpdateWithoutUnitInput, EquipmentAssetUncheckedUpdateWithoutUnitInput>
    create: XOR<EquipmentAssetCreateWithoutUnitInput, EquipmentAssetUncheckedCreateWithoutUnitInput>
  }

  export type EquipmentAssetUpdateWithWhereUniqueWithoutUnitInput = {
    where: EquipmentAssetWhereUniqueInput
    data: XOR<EquipmentAssetUpdateWithoutUnitInput, EquipmentAssetUncheckedUpdateWithoutUnitInput>
  }

  export type EquipmentAssetUpdateManyWithWhereWithoutUnitInput = {
    where: EquipmentAssetScalarWhereInput
    data: XOR<EquipmentAssetUpdateManyMutationInput, EquipmentAssetUncheckedUpdateManyWithoutUnitInput>
  }

  export type ProcedureBookingUpsertWithWhereUniqueWithoutUnitInput = {
    where: ProcedureBookingWhereUniqueInput
    update: XOR<ProcedureBookingUpdateWithoutUnitInput, ProcedureBookingUncheckedUpdateWithoutUnitInput>
    create: XOR<ProcedureBookingCreateWithoutUnitInput, ProcedureBookingUncheckedCreateWithoutUnitInput>
  }

  export type ProcedureBookingUpdateWithWhereUniqueWithoutUnitInput = {
    where: ProcedureBookingWhereUniqueInput
    data: XOR<ProcedureBookingUpdateWithoutUnitInput, ProcedureBookingUncheckedUpdateWithoutUnitInput>
  }

  export type ProcedureBookingUpdateManyWithWhereWithoutUnitInput = {
    where: ProcedureBookingScalarWhereInput
    data: XOR<ProcedureBookingUpdateManyMutationInput, ProcedureBookingUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitCreateWithoutRoomsInput = {
    id?: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitsInput
    department: DepartmentCreateNestedOneWithoutUnitsInput
    unitType: UnitTypeCatalogCreateNestedOneWithoutUnitsInput
    resources?: UnitResourceCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutRoomsInput = {
    id?: string
    branchId: string
    departmentId: string
    unitTypeId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: UnitResourceUncheckedCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetUncheckedCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutRoomsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutRoomsInput, UnitUncheckedCreateWithoutRoomsInput>
  }

  export type BranchCreateWithoutUnitRoomsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUnitRoomsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUnitRoomsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUnitRoomsInput, BranchUncheckedCreateWithoutUnitRoomsInput>
  }

  export type UnitResourceCreateWithoutRoomInput = {
    id?: string
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitResourcesInput
    unit: UnitCreateNestedOneWithoutResourcesInput
    bookings?: ProcedureBookingCreateNestedManyWithoutResourceInput
  }

  export type UnitResourceUncheckedCreateWithoutRoomInput = {
    id?: string
    branchId: string
    unitId: string
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ProcedureBookingUncheckedCreateNestedManyWithoutResourceInput
  }

  export type UnitResourceCreateOrConnectWithoutRoomInput = {
    where: UnitResourceWhereUniqueInput
    create: XOR<UnitResourceCreateWithoutRoomInput, UnitResourceUncheckedCreateWithoutRoomInput>
  }

  export type UnitResourceCreateManyRoomInputEnvelope = {
    data: UnitResourceCreateManyRoomInput | UnitResourceCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentAssetCreateWithoutRoomInput = {
    id?: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEquipmentAssetsInput
    ownerDepartment?: DepartmentCreateNestedOneWithoutEquipmentOwnedInput
    unit?: UnitCreateNestedOneWithoutEquipmentInput
    locationNode?: LocationNodeCreateNestedOneWithoutEquipmentAssetInput
    downtimeTickets?: DowntimeTicketCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetUncheckedCreateWithoutRoomInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    ownerDepartmentId?: string | null
    unitId?: string | null
    locationNodeId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    downtimeTickets?: DowntimeTicketUncheckedCreateNestedManyWithoutAssetInput
  }

  export type EquipmentAssetCreateOrConnectWithoutRoomInput = {
    where: EquipmentAssetWhereUniqueInput
    create: XOR<EquipmentAssetCreateWithoutRoomInput, EquipmentAssetUncheckedCreateWithoutRoomInput>
  }

  export type EquipmentAssetCreateManyRoomInputEnvelope = {
    data: EquipmentAssetCreateManyRoomInput | EquipmentAssetCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithoutRoomsInput = {
    update: XOR<UnitUpdateWithoutRoomsInput, UnitUncheckedUpdateWithoutRoomsInput>
    create: XOR<UnitCreateWithoutRoomsInput, UnitUncheckedCreateWithoutRoomsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutRoomsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutRoomsInput, UnitUncheckedUpdateWithoutRoomsInput>
  }

  export type UnitUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeCatalogUpdateOneRequiredWithoutUnitsNestedInput
    resources?: UnitResourceUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: UnitResourceUncheckedUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUncheckedUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type BranchUpsertWithoutUnitRoomsInput = {
    update: XOR<BranchUpdateWithoutUnitRoomsInput, BranchUncheckedUpdateWithoutUnitRoomsInput>
    create: XOR<BranchCreateWithoutUnitRoomsInput, BranchUncheckedCreateWithoutUnitRoomsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUnitRoomsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUnitRoomsInput, BranchUncheckedUpdateWithoutUnitRoomsInput>
  }

  export type BranchUpdateWithoutUnitRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUnitRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UnitResourceUpsertWithWhereUniqueWithoutRoomInput = {
    where: UnitResourceWhereUniqueInput
    update: XOR<UnitResourceUpdateWithoutRoomInput, UnitResourceUncheckedUpdateWithoutRoomInput>
    create: XOR<UnitResourceCreateWithoutRoomInput, UnitResourceUncheckedCreateWithoutRoomInput>
  }

  export type UnitResourceUpdateWithWhereUniqueWithoutRoomInput = {
    where: UnitResourceWhereUniqueInput
    data: XOR<UnitResourceUpdateWithoutRoomInput, UnitResourceUncheckedUpdateWithoutRoomInput>
  }

  export type UnitResourceUpdateManyWithWhereWithoutRoomInput = {
    where: UnitResourceScalarWhereInput
    data: XOR<UnitResourceUpdateManyMutationInput, UnitResourceUncheckedUpdateManyWithoutRoomInput>
  }

  export type EquipmentAssetUpsertWithWhereUniqueWithoutRoomInput = {
    where: EquipmentAssetWhereUniqueInput
    update: XOR<EquipmentAssetUpdateWithoutRoomInput, EquipmentAssetUncheckedUpdateWithoutRoomInput>
    create: XOR<EquipmentAssetCreateWithoutRoomInput, EquipmentAssetUncheckedCreateWithoutRoomInput>
  }

  export type EquipmentAssetUpdateWithWhereUniqueWithoutRoomInput = {
    where: EquipmentAssetWhereUniqueInput
    data: XOR<EquipmentAssetUpdateWithoutRoomInput, EquipmentAssetUncheckedUpdateWithoutRoomInput>
  }

  export type EquipmentAssetUpdateManyWithWhereWithoutRoomInput = {
    where: EquipmentAssetScalarWhereInput
    data: XOR<EquipmentAssetUpdateManyMutationInput, EquipmentAssetUncheckedUpdateManyWithoutRoomInput>
  }

  export type BranchCreateWithoutUnitResourcesInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUnitResourcesInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUnitResourcesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUnitResourcesInput, BranchUncheckedCreateWithoutUnitResourcesInput>
  }

  export type UnitCreateWithoutResourcesInput = {
    id?: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitsInput
    department: DepartmentCreateNestedOneWithoutUnitsInput
    unitType: UnitTypeCatalogCreateNestedOneWithoutUnitsInput
    rooms?: UnitRoomCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutResourcesInput = {
    id?: string
    branchId: string
    departmentId: string
    unitTypeId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: UnitRoomUncheckedCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetUncheckedCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutResourcesInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutResourcesInput, UnitUncheckedCreateWithoutResourcesInput>
  }

  export type UnitRoomCreateWithoutResourcesInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutRoomsInput
    branch: BranchCreateNestedOneWithoutUnitRoomsInput
    equipment?: EquipmentAssetCreateNestedManyWithoutRoomInput
  }

  export type UnitRoomUncheckedCreateWithoutResourcesInput = {
    id?: string
    unitId: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    equipment?: EquipmentAssetUncheckedCreateNestedManyWithoutRoomInput
  }

  export type UnitRoomCreateOrConnectWithoutResourcesInput = {
    where: UnitRoomWhereUniqueInput
    create: XOR<UnitRoomCreateWithoutResourcesInput, UnitRoomUncheckedCreateWithoutResourcesInput>
  }

  export type ProcedureBookingCreateWithoutResourceInput = {
    id?: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutProcedureBookingsInput
    unit: UnitCreateNestedOneWithoutBookingsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedBookingsInput
  }

  export type ProcedureBookingUncheckedCreateWithoutResourceInput = {
    id?: string
    branchId: string
    unitId: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureBookingCreateOrConnectWithoutResourceInput = {
    where: ProcedureBookingWhereUniqueInput
    create: XOR<ProcedureBookingCreateWithoutResourceInput, ProcedureBookingUncheckedCreateWithoutResourceInput>
  }

  export type ProcedureBookingCreateManyResourceInputEnvelope = {
    data: ProcedureBookingCreateManyResourceInput | ProcedureBookingCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutUnitResourcesInput = {
    update: XOR<BranchUpdateWithoutUnitResourcesInput, BranchUncheckedUpdateWithoutUnitResourcesInput>
    create: XOR<BranchCreateWithoutUnitResourcesInput, BranchUncheckedCreateWithoutUnitResourcesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUnitResourcesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUnitResourcesInput, BranchUncheckedUpdateWithoutUnitResourcesInput>
  }

  export type BranchUpdateWithoutUnitResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUnitResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UnitUpsertWithoutResourcesInput = {
    update: XOR<UnitUpdateWithoutResourcesInput, UnitUncheckedUpdateWithoutResourcesInput>
    create: XOR<UnitCreateWithoutResourcesInput, UnitUncheckedCreateWithoutResourcesInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutResourcesInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutResourcesInput, UnitUncheckedUpdateWithoutResourcesInput>
  }

  export type UnitUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeCatalogUpdateOneRequiredWithoutUnitsNestedInput
    rooms?: UnitRoomUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: UnitRoomUncheckedUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUncheckedUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitRoomUpsertWithoutResourcesInput = {
    update: XOR<UnitRoomUpdateWithoutResourcesInput, UnitRoomUncheckedUpdateWithoutResourcesInput>
    create: XOR<UnitRoomCreateWithoutResourcesInput, UnitRoomUncheckedCreateWithoutResourcesInput>
    where?: UnitRoomWhereInput
  }

  export type UnitRoomUpdateToOneWithWhereWithoutResourcesInput = {
    where?: UnitRoomWhereInput
    data: XOR<UnitRoomUpdateWithoutResourcesInput, UnitRoomUncheckedUpdateWithoutResourcesInput>
  }

  export type UnitRoomUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutRoomsNestedInput
    branch?: BranchUpdateOneRequiredWithoutUnitRoomsNestedInput
    equipment?: EquipmentAssetUpdateManyWithoutRoomNestedInput
  }

  export type UnitRoomUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: EquipmentAssetUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ProcedureBookingUpsertWithWhereUniqueWithoutResourceInput = {
    where: ProcedureBookingWhereUniqueInput
    update: XOR<ProcedureBookingUpdateWithoutResourceInput, ProcedureBookingUncheckedUpdateWithoutResourceInput>
    create: XOR<ProcedureBookingCreateWithoutResourceInput, ProcedureBookingUncheckedCreateWithoutResourceInput>
  }

  export type ProcedureBookingUpdateWithWhereUniqueWithoutResourceInput = {
    where: ProcedureBookingWhereUniqueInput
    data: XOR<ProcedureBookingUpdateWithoutResourceInput, ProcedureBookingUncheckedUpdateWithoutResourceInput>
  }

  export type ProcedureBookingUpdateManyWithWhereWithoutResourceInput = {
    where: ProcedureBookingScalarWhereInput
    data: XOR<ProcedureBookingUpdateManyMutationInput, ProcedureBookingUncheckedUpdateManyWithoutResourceInput>
  }

  export type BranchCreateWithoutEquipmentAssetsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutEquipmentAssetsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutEquipmentAssetsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutEquipmentAssetsInput, BranchUncheckedCreateWithoutEquipmentAssetsInput>
  }

  export type DepartmentCreateWithoutEquipmentOwnedInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDepartmentsInput
    facility: FacilityCatalogCreateNestedOneWithoutDepartmentsInput
    headStaff?: StaffCreateNestedOneWithoutHeadedDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorCreateNestedManyWithoutDepartmentInput
    units?: UnitCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutEquipmentOwnedInput = {
    id?: string
    branchId: string
    facilityId: string
    code: string
    name: string
    headStaffId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedCreateNestedManyWithoutDepartmentInput
    doctorAssignments?: DepartmentDoctorUncheckedCreateNestedManyWithoutDepartmentInput
    units?: UnitUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutEquipmentOwnedInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutEquipmentOwnedInput, DepartmentUncheckedCreateWithoutEquipmentOwnedInput>
  }

  export type UnitCreateWithoutEquipmentInput = {
    id?: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitsInput
    department: DepartmentCreateNestedOneWithoutUnitsInput
    unitType: UnitTypeCatalogCreateNestedOneWithoutUnitsInput
    rooms?: UnitRoomCreateNestedManyWithoutUnitInput
    resources?: UnitResourceCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutEquipmentInput = {
    id?: string
    branchId: string
    departmentId: string
    unitTypeId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: UnitRoomUncheckedCreateNestedManyWithoutUnitInput
    resources?: UnitResourceUncheckedCreateNestedManyWithoutUnitInput
    bookings?: ProcedureBookingUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutEquipmentInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutEquipmentInput, UnitUncheckedCreateWithoutEquipmentInput>
  }

  export type UnitRoomCreateWithoutEquipmentInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutRoomsInput
    branch: BranchCreateNestedOneWithoutUnitRoomsInput
    resources?: UnitResourceCreateNestedManyWithoutRoomInput
  }

  export type UnitRoomUncheckedCreateWithoutEquipmentInput = {
    id?: string
    unitId: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    resources?: UnitResourceUncheckedCreateNestedManyWithoutRoomInput
  }

  export type UnitRoomCreateOrConnectWithoutEquipmentInput = {
    where: UnitRoomWhereUniqueInput
    create: XOR<UnitRoomCreateWithoutEquipmentInput, UnitRoomUncheckedCreateWithoutEquipmentInput>
  }

  export type LocationNodeCreateWithoutEquipmentAssetInput = {
    id?: string
    kind: $Enums.LocationKind
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutLocationNodesInput
    parent?: LocationNodeCreateNestedOneWithoutChildrenInput
    children?: LocationNodeCreateNestedManyWithoutParentInput
    revisions?: LocationNodeRevisionCreateNestedManyWithoutNodeInput
  }

  export type LocationNodeUncheckedCreateWithoutEquipmentAssetInput = {
    id?: string
    branchId: string
    kind: $Enums.LocationKind
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: LocationNodeUncheckedCreateNestedManyWithoutParentInput
    revisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutNodeInput
  }

  export type LocationNodeCreateOrConnectWithoutEquipmentAssetInput = {
    where: LocationNodeWhereUniqueInput
    create: XOR<LocationNodeCreateWithoutEquipmentAssetInput, LocationNodeUncheckedCreateWithoutEquipmentAssetInput>
  }

  export type DowntimeTicketCreateWithoutAssetInput = {
    id?: string
    status?: $Enums.DowntimeStatus
    reason: string
    notes?: string | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DowntimeTicketUncheckedCreateWithoutAssetInput = {
    id?: string
    status?: $Enums.DowntimeStatus
    reason: string
    notes?: string | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DowntimeTicketCreateOrConnectWithoutAssetInput = {
    where: DowntimeTicketWhereUniqueInput
    create: XOR<DowntimeTicketCreateWithoutAssetInput, DowntimeTicketUncheckedCreateWithoutAssetInput>
  }

  export type DowntimeTicketCreateManyAssetInputEnvelope = {
    data: DowntimeTicketCreateManyAssetInput | DowntimeTicketCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutEquipmentAssetsInput = {
    update: XOR<BranchUpdateWithoutEquipmentAssetsInput, BranchUncheckedUpdateWithoutEquipmentAssetsInput>
    create: XOR<BranchCreateWithoutEquipmentAssetsInput, BranchUncheckedCreateWithoutEquipmentAssetsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutEquipmentAssetsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutEquipmentAssetsInput, BranchUncheckedUpdateWithoutEquipmentAssetsInput>
  }

  export type BranchUpdateWithoutEquipmentAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutEquipmentAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type DepartmentUpsertWithoutEquipmentOwnedInput = {
    update: XOR<DepartmentUpdateWithoutEquipmentOwnedInput, DepartmentUncheckedUpdateWithoutEquipmentOwnedInput>
    create: XOR<DepartmentCreateWithoutEquipmentOwnedInput, DepartmentUncheckedCreateWithoutEquipmentOwnedInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutEquipmentOwnedInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutEquipmentOwnedInput, DepartmentUncheckedUpdateWithoutEquipmentOwnedInput>
  }

  export type DepartmentUpdateWithoutEquipmentOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDepartmentsNestedInput
    facility?: FacilityCatalogUpdateOneRequiredWithoutDepartmentsNestedInput
    headStaff?: StaffUpdateOneWithoutHeadedDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutDepartmentNestedInput
    units?: UnitUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutEquipmentOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    headStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutDepartmentNestedInput
    units?: UnitUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UnitUpsertWithoutEquipmentInput = {
    update: XOR<UnitUpdateWithoutEquipmentInput, UnitUncheckedUpdateWithoutEquipmentInput>
    create: XOR<UnitCreateWithoutEquipmentInput, UnitUncheckedCreateWithoutEquipmentInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutEquipmentInput, UnitUncheckedUpdateWithoutEquipmentInput>
  }

  export type UnitUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeCatalogUpdateOneRequiredWithoutUnitsNestedInput
    rooms?: UnitRoomUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: UnitRoomUncheckedUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUncheckedUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitRoomUpsertWithoutEquipmentInput = {
    update: XOR<UnitRoomUpdateWithoutEquipmentInput, UnitRoomUncheckedUpdateWithoutEquipmentInput>
    create: XOR<UnitRoomCreateWithoutEquipmentInput, UnitRoomUncheckedCreateWithoutEquipmentInput>
    where?: UnitRoomWhereInput
  }

  export type UnitRoomUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: UnitRoomWhereInput
    data: XOR<UnitRoomUpdateWithoutEquipmentInput, UnitRoomUncheckedUpdateWithoutEquipmentInput>
  }

  export type UnitRoomUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutRoomsNestedInput
    branch?: BranchUpdateOneRequiredWithoutUnitRoomsNestedInput
    resources?: UnitResourceUpdateManyWithoutRoomNestedInput
  }

  export type UnitRoomUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: UnitResourceUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type LocationNodeUpsertWithoutEquipmentAssetInput = {
    update: XOR<LocationNodeUpdateWithoutEquipmentAssetInput, LocationNodeUncheckedUpdateWithoutEquipmentAssetInput>
    create: XOR<LocationNodeCreateWithoutEquipmentAssetInput, LocationNodeUncheckedCreateWithoutEquipmentAssetInput>
    where?: LocationNodeWhereInput
  }

  export type LocationNodeUpdateToOneWithWhereWithoutEquipmentAssetInput = {
    where?: LocationNodeWhereInput
    data: XOR<LocationNodeUpdateWithoutEquipmentAssetInput, LocationNodeUncheckedUpdateWithoutEquipmentAssetInput>
  }

  export type LocationNodeUpdateWithoutEquipmentAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLocationNodesNestedInput
    parent?: LocationNodeUpdateOneWithoutChildrenNestedInput
    children?: LocationNodeUpdateManyWithoutParentNestedInput
    revisions?: LocationNodeRevisionUpdateManyWithoutNodeNestedInput
  }

  export type LocationNodeUncheckedUpdateWithoutEquipmentAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationNodeUncheckedUpdateManyWithoutParentNestedInput
    revisions?: LocationNodeRevisionUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type DowntimeTicketUpsertWithWhereUniqueWithoutAssetInput = {
    where: DowntimeTicketWhereUniqueInput
    update: XOR<DowntimeTicketUpdateWithoutAssetInput, DowntimeTicketUncheckedUpdateWithoutAssetInput>
    create: XOR<DowntimeTicketCreateWithoutAssetInput, DowntimeTicketUncheckedCreateWithoutAssetInput>
  }

  export type DowntimeTicketUpdateWithWhereUniqueWithoutAssetInput = {
    where: DowntimeTicketWhereUniqueInput
    data: XOR<DowntimeTicketUpdateWithoutAssetInput, DowntimeTicketUncheckedUpdateWithoutAssetInput>
  }

  export type DowntimeTicketUpdateManyWithWhereWithoutAssetInput = {
    where: DowntimeTicketScalarWhereInput
    data: XOR<DowntimeTicketUpdateManyMutationInput, DowntimeTicketUncheckedUpdateManyWithoutAssetInput>
  }

  export type DowntimeTicketScalarWhereInput = {
    AND?: DowntimeTicketScalarWhereInput | DowntimeTicketScalarWhereInput[]
    OR?: DowntimeTicketScalarWhereInput[]
    NOT?: DowntimeTicketScalarWhereInput | DowntimeTicketScalarWhereInput[]
    id?: StringFilter<"DowntimeTicket"> | string
    assetId?: StringFilter<"DowntimeTicket"> | string
    status?: EnumDowntimeStatusFilter<"DowntimeTicket"> | $Enums.DowntimeStatus
    reason?: StringFilter<"DowntimeTicket"> | string
    notes?: StringNullableFilter<"DowntimeTicket"> | string | null
    openedAt?: DateTimeFilter<"DowntimeTicket"> | Date | string
    closedAt?: DateTimeNullableFilter<"DowntimeTicket"> | Date | string | null
    createdAt?: DateTimeFilter<"DowntimeTicket"> | Date | string
    updatedAt?: DateTimeFilter<"DowntimeTicket"> | Date | string
  }

  export type EquipmentAssetCreateWithoutDowntimeTicketsInput = {
    id?: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEquipmentAssetsInput
    ownerDepartment?: DepartmentCreateNestedOneWithoutEquipmentOwnedInput
    unit?: UnitCreateNestedOneWithoutEquipmentInput
    room?: UnitRoomCreateNestedOneWithoutEquipmentInput
    locationNode?: LocationNodeCreateNestedOneWithoutEquipmentAssetInput
  }

  export type EquipmentAssetUncheckedCreateWithoutDowntimeTicketsInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    ownerDepartmentId?: string | null
    unitId?: string | null
    roomId?: string | null
    locationNodeId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentAssetCreateOrConnectWithoutDowntimeTicketsInput = {
    where: EquipmentAssetWhereUniqueInput
    create: XOR<EquipmentAssetCreateWithoutDowntimeTicketsInput, EquipmentAssetUncheckedCreateWithoutDowntimeTicketsInput>
  }

  export type EquipmentAssetUpsertWithoutDowntimeTicketsInput = {
    update: XOR<EquipmentAssetUpdateWithoutDowntimeTicketsInput, EquipmentAssetUncheckedUpdateWithoutDowntimeTicketsInput>
    create: XOR<EquipmentAssetCreateWithoutDowntimeTicketsInput, EquipmentAssetUncheckedCreateWithoutDowntimeTicketsInput>
    where?: EquipmentAssetWhereInput
  }

  export type EquipmentAssetUpdateToOneWithWhereWithoutDowntimeTicketsInput = {
    where?: EquipmentAssetWhereInput
    data: XOR<EquipmentAssetUpdateWithoutDowntimeTicketsInput, EquipmentAssetUncheckedUpdateWithoutDowntimeTicketsInput>
  }

  export type EquipmentAssetUpdateWithoutDowntimeTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEquipmentAssetsNestedInput
    ownerDepartment?: DepartmentUpdateOneWithoutEquipmentOwnedNestedInput
    unit?: UnitUpdateOneWithoutEquipmentNestedInput
    room?: UnitRoomUpdateOneWithoutEquipmentNestedInput
    locationNode?: LocationNodeUpdateOneWithoutEquipmentAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateWithoutDowntimeTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    locationNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateWithoutChargeMasterItemsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutChargeMasterItemsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutChargeMasterItemsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutChargeMasterItemsInput, BranchUncheckedCreateWithoutChargeMasterItemsInput>
  }

  export type ServiceChargeMappingCreateWithoutChargeMasterItemInput = {
    id?: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutServiceMappingsInput
    serviceItem: ServiceItemCreateNestedOneWithoutMappingsInput
  }

  export type ServiceChargeMappingUncheckedCreateWithoutChargeMasterItemInput = {
    id?: string
    branchId: string
    serviceItemId: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceChargeMappingCreateOrConnectWithoutChargeMasterItemInput = {
    where: ServiceChargeMappingWhereUniqueInput
    create: XOR<ServiceChargeMappingCreateWithoutChargeMasterItemInput, ServiceChargeMappingUncheckedCreateWithoutChargeMasterItemInput>
  }

  export type ServiceChargeMappingCreateManyChargeMasterItemInputEnvelope = {
    data: ServiceChargeMappingCreateManyChargeMasterItemInput | ServiceChargeMappingCreateManyChargeMasterItemInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutChargeMasterItemsInput = {
    update: XOR<BranchUpdateWithoutChargeMasterItemsInput, BranchUncheckedUpdateWithoutChargeMasterItemsInput>
    create: XOR<BranchCreateWithoutChargeMasterItemsInput, BranchUncheckedCreateWithoutChargeMasterItemsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutChargeMasterItemsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutChargeMasterItemsInput, BranchUncheckedUpdateWithoutChargeMasterItemsInput>
  }

  export type BranchUpdateWithoutChargeMasterItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutChargeMasterItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ServiceChargeMappingUpsertWithWhereUniqueWithoutChargeMasterItemInput = {
    where: ServiceChargeMappingWhereUniqueInput
    update: XOR<ServiceChargeMappingUpdateWithoutChargeMasterItemInput, ServiceChargeMappingUncheckedUpdateWithoutChargeMasterItemInput>
    create: XOR<ServiceChargeMappingCreateWithoutChargeMasterItemInput, ServiceChargeMappingUncheckedCreateWithoutChargeMasterItemInput>
  }

  export type ServiceChargeMappingUpdateWithWhereUniqueWithoutChargeMasterItemInput = {
    where: ServiceChargeMappingWhereUniqueInput
    data: XOR<ServiceChargeMappingUpdateWithoutChargeMasterItemInput, ServiceChargeMappingUncheckedUpdateWithoutChargeMasterItemInput>
  }

  export type ServiceChargeMappingUpdateManyWithWhereWithoutChargeMasterItemInput = {
    where: ServiceChargeMappingScalarWhereInput
    data: XOR<ServiceChargeMappingUpdateManyMutationInput, ServiceChargeMappingUncheckedUpdateManyWithoutChargeMasterItemInput>
  }

  export type BranchCreateWithoutServiceItemsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutServiceItemsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutServiceItemsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutServiceItemsInput, BranchUncheckedCreateWithoutServiceItemsInput>
  }

  export type ServiceChargeMappingCreateWithoutServiceItemInput = {
    id?: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutServiceMappingsInput
    chargeMasterItem: ChargeMasterItemCreateNestedOneWithoutMappingsInput
  }

  export type ServiceChargeMappingUncheckedCreateWithoutServiceItemInput = {
    id?: string
    branchId: string
    chargeMasterItemId: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceChargeMappingCreateOrConnectWithoutServiceItemInput = {
    where: ServiceChargeMappingWhereUniqueInput
    create: XOR<ServiceChargeMappingCreateWithoutServiceItemInput, ServiceChargeMappingUncheckedCreateWithoutServiceItemInput>
  }

  export type ServiceChargeMappingCreateManyServiceItemInputEnvelope = {
    data: ServiceChargeMappingCreateManyServiceItemInput | ServiceChargeMappingCreateManyServiceItemInput[]
    skipDuplicates?: boolean
  }

  export type FixItTaskCreateWithoutServiceItemInput = {
    id?: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutFixItTasksInput
    assignedToUser?: UserCreateNestedOneWithoutAssignedFixItsInput
  }

  export type FixItTaskUncheckedCreateWithoutServiceItemInput = {
    id?: string
    branchId: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    assignedToUserId?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixItTaskCreateOrConnectWithoutServiceItemInput = {
    where: FixItTaskWhereUniqueInput
    create: XOR<FixItTaskCreateWithoutServiceItemInput, FixItTaskUncheckedCreateWithoutServiceItemInput>
  }

  export type FixItTaskCreateManyServiceItemInputEnvelope = {
    data: FixItTaskCreateManyServiceItemInput | FixItTaskCreateManyServiceItemInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutServiceItemsInput = {
    update: XOR<BranchUpdateWithoutServiceItemsInput, BranchUncheckedUpdateWithoutServiceItemsInput>
    create: XOR<BranchCreateWithoutServiceItemsInput, BranchUncheckedCreateWithoutServiceItemsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutServiceItemsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutServiceItemsInput, BranchUncheckedUpdateWithoutServiceItemsInput>
  }

  export type BranchUpdateWithoutServiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutServiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ServiceChargeMappingUpsertWithWhereUniqueWithoutServiceItemInput = {
    where: ServiceChargeMappingWhereUniqueInput
    update: XOR<ServiceChargeMappingUpdateWithoutServiceItemInput, ServiceChargeMappingUncheckedUpdateWithoutServiceItemInput>
    create: XOR<ServiceChargeMappingCreateWithoutServiceItemInput, ServiceChargeMappingUncheckedCreateWithoutServiceItemInput>
  }

  export type ServiceChargeMappingUpdateWithWhereUniqueWithoutServiceItemInput = {
    where: ServiceChargeMappingWhereUniqueInput
    data: XOR<ServiceChargeMappingUpdateWithoutServiceItemInput, ServiceChargeMappingUncheckedUpdateWithoutServiceItemInput>
  }

  export type ServiceChargeMappingUpdateManyWithWhereWithoutServiceItemInput = {
    where: ServiceChargeMappingScalarWhereInput
    data: XOR<ServiceChargeMappingUpdateManyMutationInput, ServiceChargeMappingUncheckedUpdateManyWithoutServiceItemInput>
  }

  export type FixItTaskUpsertWithWhereUniqueWithoutServiceItemInput = {
    where: FixItTaskWhereUniqueInput
    update: XOR<FixItTaskUpdateWithoutServiceItemInput, FixItTaskUncheckedUpdateWithoutServiceItemInput>
    create: XOR<FixItTaskCreateWithoutServiceItemInput, FixItTaskUncheckedCreateWithoutServiceItemInput>
  }

  export type FixItTaskUpdateWithWhereUniqueWithoutServiceItemInput = {
    where: FixItTaskWhereUniqueInput
    data: XOR<FixItTaskUpdateWithoutServiceItemInput, FixItTaskUncheckedUpdateWithoutServiceItemInput>
  }

  export type FixItTaskUpdateManyWithWhereWithoutServiceItemInput = {
    where: FixItTaskScalarWhereInput
    data: XOR<FixItTaskUpdateManyMutationInput, FixItTaskUncheckedUpdateManyWithoutServiceItemInput>
  }

  export type BranchCreateWithoutServiceMappingsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutServiceMappingsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutServiceMappingsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutServiceMappingsInput, BranchUncheckedCreateWithoutServiceMappingsInput>
  }

  export type ServiceItemCreateWithoutMappingsInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutServiceItemsInput
    fixIts?: FixItTaskCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemUncheckedCreateWithoutMappingsInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category: string
    unit?: string | null
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fixIts?: FixItTaskUncheckedCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemCreateOrConnectWithoutMappingsInput = {
    where: ServiceItemWhereUniqueInput
    create: XOR<ServiceItemCreateWithoutMappingsInput, ServiceItemUncheckedCreateWithoutMappingsInput>
  }

  export type ChargeMasterItemCreateWithoutMappingsInput = {
    id?: string
    code: string
    name: string
    category?: string | null
    unit?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutChargeMasterItemsInput
  }

  export type ChargeMasterItemUncheckedCreateWithoutMappingsInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: string | null
    unit?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChargeMasterItemCreateOrConnectWithoutMappingsInput = {
    where: ChargeMasterItemWhereUniqueInput
    create: XOR<ChargeMasterItemCreateWithoutMappingsInput, ChargeMasterItemUncheckedCreateWithoutMappingsInput>
  }

  export type BranchUpsertWithoutServiceMappingsInput = {
    update: XOR<BranchUpdateWithoutServiceMappingsInput, BranchUncheckedUpdateWithoutServiceMappingsInput>
    create: XOR<BranchCreateWithoutServiceMappingsInput, BranchUncheckedCreateWithoutServiceMappingsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutServiceMappingsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutServiceMappingsInput, BranchUncheckedUpdateWithoutServiceMappingsInput>
  }

  export type BranchUpdateWithoutServiceMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutServiceMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ServiceItemUpsertWithoutMappingsInput = {
    update: XOR<ServiceItemUpdateWithoutMappingsInput, ServiceItemUncheckedUpdateWithoutMappingsInput>
    create: XOR<ServiceItemCreateWithoutMappingsInput, ServiceItemUncheckedCreateWithoutMappingsInput>
    where?: ServiceItemWhereInput
  }

  export type ServiceItemUpdateToOneWithWhereWithoutMappingsInput = {
    where?: ServiceItemWhereInput
    data: XOR<ServiceItemUpdateWithoutMappingsInput, ServiceItemUncheckedUpdateWithoutMappingsInput>
  }

  export type ServiceItemUpdateWithoutMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderable?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutServiceItemsNestedInput
    fixIts?: FixItTaskUpdateManyWithoutServiceItemNestedInput
  }

  export type ServiceItemUncheckedUpdateWithoutMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderable?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fixIts?: FixItTaskUncheckedUpdateManyWithoutServiceItemNestedInput
  }

  export type ChargeMasterItemUpsertWithoutMappingsInput = {
    update: XOR<ChargeMasterItemUpdateWithoutMappingsInput, ChargeMasterItemUncheckedUpdateWithoutMappingsInput>
    create: XOR<ChargeMasterItemCreateWithoutMappingsInput, ChargeMasterItemUncheckedCreateWithoutMappingsInput>
    where?: ChargeMasterItemWhereInput
  }

  export type ChargeMasterItemUpdateToOneWithWhereWithoutMappingsInput = {
    where?: ChargeMasterItemWhereInput
    data: XOR<ChargeMasterItemUpdateWithoutMappingsInput, ChargeMasterItemUncheckedUpdateWithoutMappingsInput>
  }

  export type ChargeMasterItemUpdateWithoutMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutChargeMasterItemsNestedInput
  }

  export type ChargeMasterItemUncheckedUpdateWithoutMappingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateWithoutFixItTasksInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutFixItTasksInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutFixItTasksInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutFixItTasksInput, BranchUncheckedCreateWithoutFixItTasksInput>
  }

  export type ServiceItemCreateWithoutFixItsInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutServiceItemsInput
    mappings?: ServiceChargeMappingCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemUncheckedCreateWithoutFixItsInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category: string
    unit?: string | null
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutServiceItemInput
  }

  export type ServiceItemCreateOrConnectWithoutFixItsInput = {
    where: ServiceItemWhereUniqueInput
    create: XOR<ServiceItemCreateWithoutFixItsInput, ServiceItemUncheckedCreateWithoutFixItsInput>
  }

  export type UserCreateWithoutAssignedFixItsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutAssignedFixItsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutAssignedFixItsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedFixItsInput, UserUncheckedCreateWithoutAssignedFixItsInput>
  }

  export type BranchUpsertWithoutFixItTasksInput = {
    update: XOR<BranchUpdateWithoutFixItTasksInput, BranchUncheckedUpdateWithoutFixItTasksInput>
    create: XOR<BranchCreateWithoutFixItTasksInput, BranchUncheckedCreateWithoutFixItTasksInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutFixItTasksInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutFixItTasksInput, BranchUncheckedUpdateWithoutFixItTasksInput>
  }

  export type BranchUpdateWithoutFixItTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutFixItTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ServiceItemUpsertWithoutFixItsInput = {
    update: XOR<ServiceItemUpdateWithoutFixItsInput, ServiceItemUncheckedUpdateWithoutFixItsInput>
    create: XOR<ServiceItemCreateWithoutFixItsInput, ServiceItemUncheckedCreateWithoutFixItsInput>
    where?: ServiceItemWhereInput
  }

  export type ServiceItemUpdateToOneWithWhereWithoutFixItsInput = {
    where?: ServiceItemWhereInput
    data: XOR<ServiceItemUpdateWithoutFixItsInput, ServiceItemUncheckedUpdateWithoutFixItsInput>
  }

  export type ServiceItemUpdateWithoutFixItsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderable?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutServiceItemsNestedInput
    mappings?: ServiceChargeMappingUpdateManyWithoutServiceItemNestedInput
  }

  export type ServiceItemUncheckedUpdateWithoutFixItsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderable?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mappings?: ServiceChargeMappingUncheckedUpdateManyWithoutServiceItemNestedInput
  }

  export type UserUpsertWithoutAssignedFixItsInput = {
    update: XOR<UserUpdateWithoutAssignedFixItsInput, UserUncheckedUpdateWithoutAssignedFixItsInput>
    create: XOR<UserCreateWithoutAssignedFixItsInput, UserUncheckedCreateWithoutAssignedFixItsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedFixItsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedFixItsInput, UserUncheckedUpdateWithoutAssignedFixItsInput>
  }

  export type UserUpdateWithoutAssignedFixItsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedFixItsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type BranchCreateWithoutImportJobsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutImportJobsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutImportJobsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutImportJobsInput, BranchUncheckedCreateWithoutImportJobsInput>
  }

  export type UserCreateWithoutCreatedImportJobsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutCreatedImportJobsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutCreatedImportJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedImportJobsInput, UserUncheckedCreateWithoutCreatedImportJobsInput>
  }

  export type BranchUpsertWithoutImportJobsInput = {
    update: XOR<BranchUpdateWithoutImportJobsInput, BranchUncheckedUpdateWithoutImportJobsInput>
    create: XOR<BranchCreateWithoutImportJobsInput, BranchUncheckedCreateWithoutImportJobsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutImportJobsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutImportJobsInput, BranchUncheckedUpdateWithoutImportJobsInput>
  }

  export type BranchUpdateWithoutImportJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutImportJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserUpsertWithoutCreatedImportJobsInput = {
    update: XOR<UserUpdateWithoutCreatedImportJobsInput, UserUncheckedUpdateWithoutCreatedImportJobsInput>
    create: XOR<UserCreateWithoutCreatedImportJobsInput, UserUncheckedCreateWithoutCreatedImportJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedImportJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedImportJobsInput, UserUncheckedUpdateWithoutCreatedImportJobsInput>
  }

  export type UserUpdateWithoutCreatedImportJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedImportJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type BranchCreateWithoutProcedureBookingsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutProcedureBookingsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    goLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutProcedureBookingsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutProcedureBookingsInput, BranchUncheckedCreateWithoutProcedureBookingsInput>
  }

  export type UnitCreateWithoutBookingsInput = {
    id?: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitsInput
    department: DepartmentCreateNestedOneWithoutUnitsInput
    unitType: UnitTypeCatalogCreateNestedOneWithoutUnitsInput
    rooms?: UnitRoomCreateNestedManyWithoutUnitInput
    resources?: UnitResourceCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutBookingsInput = {
    id?: string
    branchId: string
    departmentId: string
    unitTypeId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: UnitRoomUncheckedCreateNestedManyWithoutUnitInput
    resources?: UnitResourceUncheckedCreateNestedManyWithoutUnitInput
    equipment?: EquipmentAssetUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutBookingsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutBookingsInput, UnitUncheckedCreateWithoutBookingsInput>
  }

  export type UnitResourceCreateWithoutBookingsInput = {
    id?: string
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutUnitResourcesInput
    unit: UnitCreateNestedOneWithoutResourcesInput
    room?: UnitRoomCreateNestedOneWithoutResourcesInput
  }

  export type UnitResourceUncheckedCreateWithoutBookingsInput = {
    id?: string
    branchId: string
    unitId: string
    roomId?: string | null
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitResourceCreateOrConnectWithoutBookingsInput = {
    where: UnitResourceWhereUniqueInput
    create: XOR<UnitResourceCreateWithoutBookingsInput, UnitResourceUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutCreatedBookingsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdGoLiveReports?: GoLiveReportCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutCreatedBookingsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdGoLiveReports?: GoLiveReportUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutCreatedBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedBookingsInput, UserUncheckedCreateWithoutCreatedBookingsInput>
  }

  export type BranchUpsertWithoutProcedureBookingsInput = {
    update: XOR<BranchUpdateWithoutProcedureBookingsInput, BranchUncheckedUpdateWithoutProcedureBookingsInput>
    create: XOR<BranchCreateWithoutProcedureBookingsInput, BranchUncheckedCreateWithoutProcedureBookingsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutProcedureBookingsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutProcedureBookingsInput, BranchUncheckedUpdateWithoutProcedureBookingsInput>
  }

  export type BranchUpdateWithoutProcedureBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutProcedureBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    goLiveReports?: GoLiveReportUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UnitUpsertWithoutBookingsInput = {
    update: XOR<UnitUpdateWithoutBookingsInput, UnitUncheckedUpdateWithoutBookingsInput>
    create: XOR<UnitCreateWithoutBookingsInput, UnitUncheckedCreateWithoutBookingsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutBookingsInput, UnitUncheckedUpdateWithoutBookingsInput>
  }

  export type UnitUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeCatalogUpdateOneRequiredWithoutUnitsNestedInput
    rooms?: UnitRoomUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: UnitRoomUncheckedUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUncheckedUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitResourceUpsertWithoutBookingsInput = {
    update: XOR<UnitResourceUpdateWithoutBookingsInput, UnitResourceUncheckedUpdateWithoutBookingsInput>
    create: XOR<UnitResourceCreateWithoutBookingsInput, UnitResourceUncheckedCreateWithoutBookingsInput>
    where?: UnitResourceWhereInput
  }

  export type UnitResourceUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UnitResourceWhereInput
    data: XOR<UnitResourceUpdateWithoutBookingsInput, UnitResourceUncheckedUpdateWithoutBookingsInput>
  }

  export type UnitResourceUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitResourcesNestedInput
    unit?: UnitUpdateOneRequiredWithoutResourcesNestedInput
    room?: UnitRoomUpdateOneWithoutResourcesNestedInput
  }

  export type UnitResourceUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedBookingsInput = {
    update: XOR<UserUpdateWithoutCreatedBookingsInput, UserUncheckedUpdateWithoutCreatedBookingsInput>
    create: XOR<UserCreateWithoutCreatedBookingsInput, UserUncheckedCreateWithoutCreatedBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedBookingsInput, UserUncheckedUpdateWithoutCreatedBookingsInput>
  }

  export type UserUpdateWithoutCreatedBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type BranchCreateWithoutGoLiveReportsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityCreateNestedManyWithoutBranchInput
    rooms?: RoomCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeCreateNestedManyWithoutBranchInput
    units?: UnitCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutGoLiveReportsInput = {
    id?: string
    code: string
    name: string
    city: string
    gstNumber?: string | null
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    branchFacilities?: BranchFacilityUncheckedCreateNestedManyWithoutBranchInput
    rooms?: RoomUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
    policyVersions?: PolicyVersionUncheckedCreateNestedManyWithoutBranchInput
    policyVersionBranches?: PolicyVersionBranchUncheckedCreateNestedManyWithoutBranchInput
    locationNodes?: LocationNodeUncheckedCreateNestedManyWithoutBranchInput
    unitTypesEnabled?: BranchUnitTypeUncheckedCreateNestedManyWithoutBranchInput
    units?: UnitUncheckedCreateNestedManyWithoutBranchInput
    unitRooms?: UnitRoomUncheckedCreateNestedManyWithoutBranchInput
    unitResources?: UnitResourceUncheckedCreateNestedManyWithoutBranchInput
    equipmentAssets?: EquipmentAssetUncheckedCreateNestedManyWithoutBranchInput
    serviceItems?: ServiceItemUncheckedCreateNestedManyWithoutBranchInput
    chargeMasterItems?: ChargeMasterItemUncheckedCreateNestedManyWithoutBranchInput
    serviceMappings?: ServiceChargeMappingUncheckedCreateNestedManyWithoutBranchInput
    fixItTasks?: FixItTaskUncheckedCreateNestedManyWithoutBranchInput
    importJobs?: BulkImportJobUncheckedCreateNestedManyWithoutBranchInput
    procedureBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutGoLiveReportsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutGoLiveReportsInput, BranchUncheckedCreateWithoutGoLiveReportsInput>
  }

  export type UserCreateWithoutCreatedGoLiveReportsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutCreatedGoLiveReportsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedCreateNestedManyWithoutSubmittedByUserInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedCreateNestedManyWithoutApprovedByUserInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedCreateNestedManyWithoutRejectedByUserInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedCreateNestedManyWithoutRetiredByUserInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedCreateNestedManyWithoutCreatedByUserInput
    createdImportJobs?: BulkImportJobUncheckedCreateNestedManyWithoutCreatedByUserInput
    assignedFixIts?: FixItTaskUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdBookings?: ProcedureBookingUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutCreatedGoLiveReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedGoLiveReportsInput, UserUncheckedCreateWithoutCreatedGoLiveReportsInput>
  }

  export type BranchUpsertWithoutGoLiveReportsInput = {
    update: XOR<BranchUpdateWithoutGoLiveReportsInput, BranchUncheckedUpdateWithoutGoLiveReportsInput>
    create: XOR<BranchCreateWithoutGoLiveReportsInput, BranchUncheckedCreateWithoutGoLiveReportsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutGoLiveReportsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutGoLiveReportsInput, BranchUncheckedUpdateWithoutGoLiveReportsInput>
  }

  export type BranchUpdateWithoutGoLiveReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUpdateManyWithoutBranchNestedInput
    rooms?: RoomUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUpdateManyWithoutBranchNestedInput
    units?: UnitUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutGoLiveReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    gstNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    branchFacilities?: BranchFacilityUncheckedUpdateManyWithoutBranchNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
    policyVersions?: PolicyVersionUncheckedUpdateManyWithoutBranchNestedInput
    policyVersionBranches?: PolicyVersionBranchUncheckedUpdateManyWithoutBranchNestedInput
    locationNodes?: LocationNodeUncheckedUpdateManyWithoutBranchNestedInput
    unitTypesEnabled?: BranchUnitTypeUncheckedUpdateManyWithoutBranchNestedInput
    units?: UnitUncheckedUpdateManyWithoutBranchNestedInput
    unitRooms?: UnitRoomUncheckedUpdateManyWithoutBranchNestedInput
    unitResources?: UnitResourceUncheckedUpdateManyWithoutBranchNestedInput
    equipmentAssets?: EquipmentAssetUncheckedUpdateManyWithoutBranchNestedInput
    serviceItems?: ServiceItemUncheckedUpdateManyWithoutBranchNestedInput
    chargeMasterItems?: ChargeMasterItemUncheckedUpdateManyWithoutBranchNestedInput
    serviceMappings?: ServiceChargeMappingUncheckedUpdateManyWithoutBranchNestedInput
    fixItTasks?: FixItTaskUncheckedUpdateManyWithoutBranchNestedInput
    importJobs?: BulkImportJobUncheckedUpdateManyWithoutBranchNestedInput
    procedureBookings?: ProcedureBookingUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserUpsertWithoutCreatedGoLiveReportsInput = {
    update: XOR<UserUpdateWithoutCreatedGoLiveReportsInput, UserUncheckedUpdateWithoutCreatedGoLiveReportsInput>
    create: XOR<UserCreateWithoutCreatedGoLiveReportsInput, UserUncheckedCreateWithoutCreatedGoLiveReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedGoLiveReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedGoLiveReportsInput, UserUncheckedUpdateWithoutCreatedGoLiveReportsInput>
  }

  export type UserUpdateWithoutCreatedGoLiveReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedGoLiveReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type DepartmentCreateManyBranchInput = {
    id?: string
    facilityId: string
    code: string
    name: string
    headStaffId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyBranchInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientCreateManyBranchInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffPlanCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateManyBranchInput = {
    id?: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterCreateManyBranchInput = {
    id?: string
    patientId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedCreateManyBranchInput = {
    id?: string
    roomId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateManyBranchInput = {
    id?: string
    encounterId?: string | null
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchFacilityCreateManyBranchInput = {
    id?: string
    facilityId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomCreateManyBranchInput = {
    id?: string
    wardId: string
    code: string
    name: string
    floor?: string | null
    type?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseCreateManyBranchInput = {
    id?: string
    patientId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditEventCreateManyBranchInput = {
    id?: string
    actorUserId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PolicyVersionCreateManyBranchInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyVersionBranchCreateManyBranchInput = {
    id?: string
    policyVersionId: string
    createdAt?: Date | string
  }

  export type LocationNodeCreateManyBranchInput = {
    id?: string
    kind: $Enums.LocationKind
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUnitTypeCreateManyBranchInput = {
    id?: string
    unitTypeId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManyBranchInput = {
    id?: string
    departmentId: string
    unitTypeId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitRoomCreateManyBranchInput = {
    id?: string
    unitId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitResourceCreateManyBranchInput = {
    id?: string
    unitId: string
    roomId?: string | null
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentAssetCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    ownerDepartmentId?: string | null
    unitId?: string | null
    roomId?: string | null
    locationNodeId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceItemCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    isOrderable?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChargeMasterItemCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    category?: string | null
    unit?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceChargeMappingCreateManyBranchInput = {
    id?: string
    serviceItemId: string
    chargeMasterItemId: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixItTaskCreateManyBranchInput = {
    id?: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: string | null
    assignedToUserId?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BulkImportJobCreateManyBranchInput = {
    id?: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: number
    validRows?: number
    invalidRows?: number
    createdByUserId?: string | null
    committedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureBookingCreateManyBranchInput = {
    id?: string
    unitId: string
    resourceId: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoLiveReportCreateManyBranchInput = {
    id?: string
    score: number
    blockers: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    snapshot: JsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type DepartmentUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityCatalogUpdateOneRequiredWithoutDepartmentsNestedInput
    headStaff?: StaffUpdateOneWithoutHeadedDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutDepartmentNestedInput
    units?: UnitUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    headStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutDepartmentNestedInput
    units?: UnitUncheckedUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUncheckedUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    headStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffPlanUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rates?: TariffRateUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rates?: TariffRateUncheckedUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateManyWithoutSpecialtyNestedInput
    departmentLinks?: DepartmentSpecialtyUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutSpecialtyNestedInput
    departmentLinks?: DepartmentSpecialtyUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    specialty?: SpecialtyUpdateOneWithoutStaffNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutStaffNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadStaffNestedInput
    user?: UserUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutStaffNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadStaffNestedInput
    user?: UserUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    admissions?: AdmissionUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutBedsNestedInput
    admissions?: AdmissionUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneWithoutAdmissionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAdmissionNestedInput
    bed?: BedUpdateOneWithoutAdmissionsNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchFacilityUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facility?: FacilityCatalogUpdateOneRequiredWithoutBranchLinksNestedInput
  }

  export type BranchFacilityUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchFacilityUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ward?: WardUpdateOneRequiredWithoutRoomsNestedInput
    beds?: BedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beds?: BedUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutStatutoryCasesNestedInput
  }

  export type StatutoryCaseUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actorUser?: UserUpdateOneWithoutAuditEventsAsActorNestedInput
  }

  export type AuditEventUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policy?: PolicyDefinitionUpdateOneRequiredWithoutVersionsNestedInput
    branches?: PolicyVersionBranchUpdateManyWithoutPolicyVersionNestedInput
    createdByUser?: UserUpdateOneWithoutPolicyVersionsCreatedByNestedInput
    submittedByUser?: UserUpdateOneWithoutPolicyVersionsSubmittedByNestedInput
    approvedByUser?: UserUpdateOneWithoutPolicyVersionsApprovedByNestedInput
    rejectedByUser?: UserUpdateOneWithoutPolicyVersionsRejectedByNestedInput
    retiredByUser?: UserUpdateOneWithoutPolicyVersionsRetiredByNestedInput
  }

  export type PolicyVersionUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: PolicyVersionBranchUncheckedUpdateManyWithoutPolicyVersionNestedInput
  }

  export type PolicyVersionUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionBranchUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policyVersion?: PolicyVersionUpdateOneRequiredWithoutBranchesNestedInput
  }

  export type PolicyVersionBranchUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyVersionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionBranchUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyVersionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNodeUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: LocationNodeUpdateOneWithoutChildrenNestedInput
    children?: LocationNodeUpdateManyWithoutParentNestedInput
    revisions?: LocationNodeRevisionUpdateManyWithoutNodeNestedInput
    EquipmentAsset?: EquipmentAssetUpdateManyWithoutLocationNodeNestedInput
  }

  export type LocationNodeUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationNodeUncheckedUpdateManyWithoutParentNestedInput
    revisions?: LocationNodeRevisionUncheckedUpdateManyWithoutNodeNestedInput
    EquipmentAsset?: EquipmentAssetUncheckedUpdateManyWithoutLocationNodeNestedInput
  }

  export type LocationNodeUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUnitTypeUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unitType?: UnitTypeCatalogUpdateOneRequiredWithoutBranchLinksNestedInput
  }

  export type BranchUnitTypeUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUnitTypeUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeCatalogUpdateOneRequiredWithoutUnitsNestedInput
    rooms?: UnitRoomUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: UnitRoomUncheckedUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUncheckedUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUncheckedUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitRoomUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutRoomsNestedInput
    resources?: UnitResourceUpdateManyWithoutRoomNestedInput
    equipment?: EquipmentAssetUpdateManyWithoutRoomNestedInput
  }

  export type UnitRoomUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: UnitResourceUncheckedUpdateManyWithoutRoomNestedInput
    equipment?: EquipmentAssetUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type UnitRoomUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitResourceUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutResourcesNestedInput
    room?: UnitRoomUpdateOneWithoutResourcesNestedInput
    bookings?: ProcedureBookingUpdateManyWithoutResourceNestedInput
  }

  export type UnitResourceUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ProcedureBookingUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type UnitResourceUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssetUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerDepartment?: DepartmentUpdateOneWithoutEquipmentOwnedNestedInput
    unit?: UnitUpdateOneWithoutEquipmentNestedInput
    room?: UnitRoomUpdateOneWithoutEquipmentNestedInput
    locationNode?: LocationNodeUpdateOneWithoutEquipmentAssetNestedInput
    downtimeTickets?: DowntimeTicketUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    locationNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeTickets?: DowntimeTicketUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    locationNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceItemUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderable?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mappings?: ServiceChargeMappingUpdateManyWithoutServiceItemNestedInput
    fixIts?: FixItTaskUpdateManyWithoutServiceItemNestedInput
  }

  export type ServiceItemUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderable?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mappings?: ServiceChargeMappingUncheckedUpdateManyWithoutServiceItemNestedInput
    fixIts?: FixItTaskUncheckedUpdateManyWithoutServiceItemNestedInput
  }

  export type ServiceItemUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isOrderable?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChargeMasterItemUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mappings?: ServiceChargeMappingUpdateManyWithoutChargeMasterItemNestedInput
  }

  export type ChargeMasterItemUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mappings?: ServiceChargeMappingUncheckedUpdateManyWithoutChargeMasterItemNestedInput
  }

  export type ChargeMasterItemUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceChargeMappingUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceItem?: ServiceItemUpdateOneRequiredWithoutMappingsNestedInput
    chargeMasterItem?: ChargeMasterItemUpdateOneRequiredWithoutMappingsNestedInput
  }

  export type ServiceChargeMappingUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceItemId?: StringFieldUpdateOperationsInput | string
    chargeMasterItemId?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceChargeMappingUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceItemId?: StringFieldUpdateOperationsInput | string
    chargeMasterItemId?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixItTaskUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceItem?: ServiceItemUpdateOneWithoutFixItsNestedInput
    assignedToUser?: UserUpdateOneWithoutAssignedFixItsNestedInput
  }

  export type FixItTaskUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixItTaskUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkImportJobUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: IntFieldUpdateOperationsInput | number
    validRows?: IntFieldUpdateOperationsInput | number
    invalidRows?: IntFieldUpdateOperationsInput | number
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneWithoutCreatedImportJobsNestedInput
  }

  export type BulkImportJobUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: IntFieldUpdateOperationsInput | number
    validRows?: IntFieldUpdateOperationsInput | number
    invalidRows?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkImportJobUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: IntFieldUpdateOperationsInput | number
    validRows?: IntFieldUpdateOperationsInput | number
    invalidRows?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureBookingUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutBookingsNestedInput
    resource?: UnitResourceUpdateOneRequiredWithoutBookingsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedBookingsNestedInput
  }

  export type ProcedureBookingUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureBookingUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoLiveReportUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    blockers?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneWithoutCreatedGoLiveReportsNestedInput
  }

  export type GoLiveReportUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    blockers?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    snapshot?: JsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoLiveReportUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    blockers?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    snapshot?: JsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchFacilityCreateManyFacilityInput = {
    id?: string
    branchId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateManyFacilityInput = {
    id?: string
    branchId: string
    code: string
    name: string
    headStaffId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchFacilityUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBranchFacilitiesNestedInput
  }

  export type BranchFacilityUncheckedUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchFacilityUncheckedUpdateManyWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDepartmentsNestedInput
    headStaff?: StaffUpdateOneWithoutHeadedDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutDepartmentNestedInput
    units?: UnitUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    headStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutDepartmentNestedInput
    units?: UnitUncheckedUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUncheckedUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutFacilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    headStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateManyDepartmentInput = {
    id?: string
    branchId: string
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentSpecialtyCreateManyDepartmentInput = {
    id?: string
    specialtyId: string
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentDoctorCreateManyDepartmentInput = {
    id?: string
    staffId: string
    isPrimary?: boolean
    assignedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManyDepartmentInput = {
    id?: string
    branchId: string
    unitTypeId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentAssetCreateManyOwnerDepartmentInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    unitId?: string | null
    roomId?: string | null
    locationNodeId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStaffNestedInput
    specialty?: SpecialtyUpdateOneWithoutStaffNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutStaffNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadStaffNestedInput
    user?: UserUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutStaffNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadStaffNestedInput
    user?: UserUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentSpecialtyUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialty?: SpecialtyUpdateOneRequiredWithoutDepartmentLinksNestedInput
  }

  export type DepartmentSpecialtyUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentSpecialtyUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDoctorUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutDoctorAssignmentsNestedInput
  }

  export type DepartmentDoctorUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDoctorUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitsNestedInput
    unitType?: UnitTypeCatalogUpdateOneRequiredWithoutUnitsNestedInput
    rooms?: UnitRoomUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: UnitRoomUncheckedUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUncheckedUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUncheckedUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitTypeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssetUpdateWithoutOwnerDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEquipmentAssetsNestedInput
    unit?: UnitUpdateOneWithoutEquipmentNestedInput
    room?: UnitRoomUpdateOneWithoutEquipmentNestedInput
    locationNode?: LocationNodeUpdateOneWithoutEquipmentAssetNestedInput
    downtimeTickets?: DowntimeTicketUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateWithoutOwnerDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    locationNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeTickets?: DowntimeTicketUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateManyWithoutOwnerDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    locationNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateManySpecialtyInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentSpecialtyCreateManySpecialtyInput = {
    id?: string
    departmentId: string
    isPrimary?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutStaffNestedInput
    headedDepartments?: DepartmentUpdateManyWithoutHeadStaffNestedInput
    user?: UserUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutStaffNestedInput
    headedDepartments?: DepartmentUncheckedUpdateManyWithoutHeadStaffNestedInput
    user?: UserUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentSpecialtyUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutDepartmentSpecialtiesNestedInput
  }

  export type DepartmentSpecialtyUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentSpecialtyUncheckedUpdateManyWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDoctorCreateManyStaffInput = {
    id?: string
    departmentId: string
    isPrimary?: boolean
    assignedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateManyHeadStaffInput = {
    id?: string
    branchId: string
    facilityId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentDoctorUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutDoctorAssignmentsNestedInput
  }

  export type DepartmentDoctorUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentDoctorUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutHeadStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDepartmentsNestedInput
    facility?: FacilityCatalogUpdateOneRequiredWithoutDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUpdateManyWithoutDepartmentNestedInput
    units?: UnitUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutHeadStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    departmentSpecialties?: DepartmentSpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput
    doctorAssignments?: DepartmentDoctorUncheckedUpdateManyWithoutDepartmentNestedInput
    units?: UnitUncheckedUpdateManyWithoutDepartmentNestedInput
    equipmentOwned?: EquipmentAssetUncheckedUpdateManyWithoutOwnerDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutHeadStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    facilityId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateVersionCreateManyCreatedByUserInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditEventCreateManyActorUserInput = {
    id?: string
    branchId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PolicyVersionCreateManyCreatedByUserInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyVersionCreateManySubmittedByUserInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyVersionCreateManyApprovedByUserInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyVersionCreateManyRejectedByUserInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyVersionCreateManyRetiredByUserInput = {
    id?: string
    policyId: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationNodeRevisionCreateManyCreatedByUserInput = {
    id?: string
    nodeId: string
    code: string
    name: string
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
  }

  export type BulkImportJobCreateManyCreatedByUserInput = {
    id?: string
    branchId: string
    entityType: $Enums.ImportEntityType
    status?: $Enums.ImportJobStatus
    fileName?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: number
    validRows?: number
    invalidRows?: number
    committedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixItTaskCreateManyAssignedToUserInput = {
    id?: string
    branchId: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureBookingCreateManyCreatedByUserInput = {
    id?: string
    branchId: string
    unitId: string
    resourceId: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoLiveReportCreateManyCreatedByUserInput = {
    id?: string
    branchId: string
    score: number
    blockers: JsonNullValueInput | InputJsonValue
    warnings: JsonNullValueInput | InputJsonValue
    snapshot: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RoleTemplateVersionUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleTemplate?: RoleTemplateUpdateOneRequiredWithoutVersionsNestedInput
    permissions?: RoleTemplatePermissionUpdateManyWithoutRoleVersionNestedInput
    users?: UserUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUpdateWithoutActorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutAuditEventsNestedInput
  }

  export type AuditEventUncheckedUpdateWithoutActorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyWithoutActorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policy?: PolicyDefinitionUpdateOneRequiredWithoutVersionsNestedInput
    branch?: BranchUpdateOneWithoutPolicyVersionsNestedInput
    branches?: PolicyVersionBranchUpdateManyWithoutPolicyVersionNestedInput
    submittedByUser?: UserUpdateOneWithoutPolicyVersionsSubmittedByNestedInput
    approvedByUser?: UserUpdateOneWithoutPolicyVersionsApprovedByNestedInput
    rejectedByUser?: UserUpdateOneWithoutPolicyVersionsRejectedByNestedInput
    retiredByUser?: UserUpdateOneWithoutPolicyVersionsRetiredByNestedInput
  }

  export type PolicyVersionUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: PolicyVersionBranchUncheckedUpdateManyWithoutPolicyVersionNestedInput
  }

  export type PolicyVersionUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionUpdateWithoutSubmittedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policy?: PolicyDefinitionUpdateOneRequiredWithoutVersionsNestedInput
    branch?: BranchUpdateOneWithoutPolicyVersionsNestedInput
    branches?: PolicyVersionBranchUpdateManyWithoutPolicyVersionNestedInput
    createdByUser?: UserUpdateOneWithoutPolicyVersionsCreatedByNestedInput
    approvedByUser?: UserUpdateOneWithoutPolicyVersionsApprovedByNestedInput
    rejectedByUser?: UserUpdateOneWithoutPolicyVersionsRejectedByNestedInput
    retiredByUser?: UserUpdateOneWithoutPolicyVersionsRetiredByNestedInput
  }

  export type PolicyVersionUncheckedUpdateWithoutSubmittedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: PolicyVersionBranchUncheckedUpdateManyWithoutPolicyVersionNestedInput
  }

  export type PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionUpdateWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policy?: PolicyDefinitionUpdateOneRequiredWithoutVersionsNestedInput
    branch?: BranchUpdateOneWithoutPolicyVersionsNestedInput
    branches?: PolicyVersionBranchUpdateManyWithoutPolicyVersionNestedInput
    createdByUser?: UserUpdateOneWithoutPolicyVersionsCreatedByNestedInput
    submittedByUser?: UserUpdateOneWithoutPolicyVersionsSubmittedByNestedInput
    rejectedByUser?: UserUpdateOneWithoutPolicyVersionsRejectedByNestedInput
    retiredByUser?: UserUpdateOneWithoutPolicyVersionsRetiredByNestedInput
  }

  export type PolicyVersionUncheckedUpdateWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: PolicyVersionBranchUncheckedUpdateManyWithoutPolicyVersionNestedInput
  }

  export type PolicyVersionUncheckedUpdateManyWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionUpdateWithoutRejectedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policy?: PolicyDefinitionUpdateOneRequiredWithoutVersionsNestedInput
    branch?: BranchUpdateOneWithoutPolicyVersionsNestedInput
    branches?: PolicyVersionBranchUpdateManyWithoutPolicyVersionNestedInput
    createdByUser?: UserUpdateOneWithoutPolicyVersionsCreatedByNestedInput
    submittedByUser?: UserUpdateOneWithoutPolicyVersionsSubmittedByNestedInput
    approvedByUser?: UserUpdateOneWithoutPolicyVersionsApprovedByNestedInput
    retiredByUser?: UserUpdateOneWithoutPolicyVersionsRetiredByNestedInput
  }

  export type PolicyVersionUncheckedUpdateWithoutRejectedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: PolicyVersionBranchUncheckedUpdateManyWithoutPolicyVersionNestedInput
  }

  export type PolicyVersionUncheckedUpdateManyWithoutRejectedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionUpdateWithoutRetiredByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    policy?: PolicyDefinitionUpdateOneRequiredWithoutVersionsNestedInput
    branch?: BranchUpdateOneWithoutPolicyVersionsNestedInput
    branches?: PolicyVersionBranchUpdateManyWithoutPolicyVersionNestedInput
    createdByUser?: UserUpdateOneWithoutPolicyVersionsCreatedByNestedInput
    submittedByUser?: UserUpdateOneWithoutPolicyVersionsSubmittedByNestedInput
    approvedByUser?: UserUpdateOneWithoutPolicyVersionsApprovedByNestedInput
    rejectedByUser?: UserUpdateOneWithoutPolicyVersionsRejectedByNestedInput
  }

  export type PolicyVersionUncheckedUpdateWithoutRetiredByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: PolicyVersionBranchUncheckedUpdateManyWithoutPolicyVersionNestedInput
  }

  export type PolicyVersionUncheckedUpdateManyWithoutRetiredByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNodeRevisionUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: LocationNodeUpdateOneRequiredWithoutRevisionsNestedInput
  }

  export type LocationNodeRevisionUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkImportJobUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: IntFieldUpdateOperationsInput | number
    validRows?: IntFieldUpdateOperationsInput | number
    invalidRows?: IntFieldUpdateOperationsInput | number
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutImportJobsNestedInput
  }

  export type BulkImportJobUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: IntFieldUpdateOperationsInput | number
    validRows?: IntFieldUpdateOperationsInput | number
    invalidRows?: IntFieldUpdateOperationsInput | number
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulkImportJobUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumImportEntityTypeFieldUpdateOperationsInput | $Enums.ImportEntityType
    status?: EnumImportJobStatusFieldUpdateOperationsInput | $Enums.ImportJobStatus
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    errors?: NullableJsonNullValueInput | InputJsonValue
    totalRows?: IntFieldUpdateOperationsInput | number
    validRows?: IntFieldUpdateOperationsInput | number
    invalidRows?: IntFieldUpdateOperationsInput | number
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixItTaskUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutFixItTasksNestedInput
    serviceItem?: ServiceItemUpdateOneWithoutFixItsNestedInput
  }

  export type FixItTaskUncheckedUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixItTaskUncheckedUpdateManyWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    serviceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureBookingUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProcedureBookingsNestedInput
    unit?: UnitUpdateOneRequiredWithoutBookingsNestedInput
    resource?: UnitResourceUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type ProcedureBookingUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoLiveReportUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    blockers?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutGoLiveReportsNestedInput
  }

  export type GoLiveReportUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    blockers?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoLiveReportUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    blockers?: JsonNullValueInput | InputJsonValue
    warnings?: JsonNullValueInput | InputJsonValue
    snapshot?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateManyPatientInput = {
    id?: string
    branchId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateManyPatientInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsentRecordCreateManyPatientInput = {
    id?: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
  }

  export type RtbfRequestCreateManyPatientInput = {
    id?: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseCreateManyPatientInput = {
    id?: string
    branchId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEncounterNestedInput
    admissions?: AdmissionUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutAdmissionNestedInput
    encounter?: EncounterUpdateOneWithoutAdmissionsNestedInput
    bed?: BedUpdateOneWithoutAdmissionsNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStatutoryCasesNestedInput
  }

  export type StatutoryCaseUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionCreateManyEncounterInput = {
    id?: string
    branchId: string
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutAdmissionNestedInput
    patient?: PatientUpdateOneRequiredWithoutAdmissionNestedInput
    bed?: BedUpdateOneWithoutAdmissionsNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateManyWardInput = {
    id?: string
    branchId: string
    code: string
    name: string
    floor?: string | null
    type?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutRoomsNestedInput
    beds?: BedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beds?: BedUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedCreateManyRoomInput = {
    id?: string
    branchId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBedNestedInput
    admissions?: AdmissionUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionCreateManyBedInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    patientId: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionUpdateWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutAdmissionNestedInput
    encounter?: EncounterUpdateOneWithoutAdmissionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateCreateManyTariffPlanInput = {
    id?: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffRateUpdateWithoutTariffPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateUncheckedUpdateWithoutTariffPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateUncheckedUpdateManyWithoutTariffPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionCreateManyPermissionInput = {
    id?: string
    roleVersionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleVersion?: RoleTemplateVersionUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RoleTemplatePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleVersionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleVersionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateVersionCreateManyRoleTemplateInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateVersionUpdateWithoutRoleTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneWithoutCreatedRoleVersionsNestedInput
    permissions?: RoleTemplatePermissionUpdateManyWithoutRoleVersionNestedInput
    users?: UserUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateWithoutRoleTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateManyWithoutRoleTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionCreateManyRoleVersionInput = {
    id?: string
    permissionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyRoleVersionInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionUpdateWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRoleGrantsNestedInput
  }

  export type RoleTemplatePermissionUncheckedUpdateWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
    policyVersionsCreatedBy?: PolicyVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    policyVersionsSubmittedBy?: PolicyVersionUncheckedUpdateManyWithoutSubmittedByUserNestedInput
    policyVersionsApprovedBy?: PolicyVersionUncheckedUpdateManyWithoutApprovedByUserNestedInput
    policyVersionsRejectedBy?: PolicyVersionUncheckedUpdateManyWithoutRejectedByUserNestedInput
    policyVersionsRetiredBy?: PolicyVersionUncheckedUpdateManyWithoutRetiredByUserNestedInput
    createdLocationRevisions?: LocationNodeRevisionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdImportJobs?: BulkImportJobUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assignedFixIts?: FixItTaskUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdBookings?: ProcedureBookingUncheckedUpdateManyWithoutCreatedByUserNestedInput
    createdGoLiveReports?: GoLiveReportUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionCreateManyPolicyInput = {
    id?: string
    scope?: $Enums.PolicyScope
    branchId?: string | null
    version: number
    status?: $Enums.PolicyVersionStatus
    effectiveAt?: Date | string
    notes?: string | null
    payload: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: boolean
    createdByUserId?: string | null
    submittedAt?: Date | string | null
    submittedByUserId?: string | null
    approvedAt?: Date | string | null
    approvedByUserId?: string | null
    approvalNote?: string | null
    rejectedAt?: Date | string | null
    rejectedByUserId?: string | null
    rejectionReason?: string | null
    retiredAt?: Date | string | null
    retiredByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyVersionUpdateWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutPolicyVersionsNestedInput
    branches?: PolicyVersionBranchUpdateManyWithoutPolicyVersionNestedInput
    createdByUser?: UserUpdateOneWithoutPolicyVersionsCreatedByNestedInput
    submittedByUser?: UserUpdateOneWithoutPolicyVersionsSubmittedByNestedInput
    approvedByUser?: UserUpdateOneWithoutPolicyVersionsApprovedByNestedInput
    rejectedByUser?: UserUpdateOneWithoutPolicyVersionsRejectedByNestedInput
    retiredByUser?: UserUpdateOneWithoutPolicyVersionsRetiredByNestedInput
  }

  export type PolicyVersionUncheckedUpdateWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branches?: PolicyVersionBranchUncheckedUpdateManyWithoutPolicyVersionNestedInput
  }

  export type PolicyVersionUncheckedUpdateManyWithoutPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumPolicyScopeFieldUpdateOperationsInput | $Enums.PolicyScope
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumPolicyVersionStatusFieldUpdateOperationsInput | $Enums.PolicyVersionStatus
    effectiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    applyToAllBranches?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    retiredByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionBranchCreateManyPolicyVersionInput = {
    id?: string
    branchId: string
    createdAt?: Date | string
  }

  export type PolicyVersionBranchUpdateWithoutPolicyVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPolicyVersionBranchesNestedInput
  }

  export type PolicyVersionBranchUncheckedUpdateWithoutPolicyVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyVersionBranchUncheckedUpdateManyWithoutPolicyVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNodeCreateManyParentInput = {
    id?: string
    branchId: string
    kind: $Enums.LocationKind
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationNodeRevisionCreateManyNodeInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type EquipmentAssetCreateManyLocationNodeInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    ownerDepartmentId?: string | null
    unitId?: string | null
    roomId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationNodeUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutLocationNodesNestedInput
    children?: LocationNodeUpdateManyWithoutParentNestedInput
    revisions?: LocationNodeRevisionUpdateManyWithoutNodeNestedInput
    EquipmentAsset?: EquipmentAssetUpdateManyWithoutLocationNodeNestedInput
  }

  export type LocationNodeUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: LocationNodeUncheckedUpdateManyWithoutParentNestedInput
    revisions?: LocationNodeRevisionUncheckedUpdateManyWithoutNodeNestedInput
    EquipmentAsset?: EquipmentAssetUncheckedUpdateManyWithoutLocationNodeNestedInput
  }

  export type LocationNodeUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    kind?: EnumLocationKindFieldUpdateOperationsInput | $Enums.LocationKind
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNodeRevisionUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneWithoutCreatedLocationRevisionsNestedInput
  }

  export type LocationNodeRevisionUncheckedUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationNodeRevisionUncheckedUpdateManyWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssetUpdateWithoutLocationNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEquipmentAssetsNestedInput
    ownerDepartment?: DepartmentUpdateOneWithoutEquipmentOwnedNestedInput
    unit?: UnitUpdateOneWithoutEquipmentNestedInput
    room?: UnitRoomUpdateOneWithoutEquipmentNestedInput
    downtimeTickets?: DowntimeTicketUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateWithoutLocationNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeTickets?: DowntimeTicketUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateManyWithoutLocationNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUnitTypeCreateManyUnitTypeInput = {
    id?: string
    branchId: string
    isEnabled?: boolean
    enabledAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManyUnitTypeInput = {
    id?: string
    branchId: string
    departmentId: string
    code: string
    name: string
    usesRooms?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUnitTypeUpdateWithoutUnitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitTypesEnabledNestedInput
  }

  export type BranchUnitTypeUncheckedUpdateWithoutUnitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUnitTypeUncheckedUpdateManyWithoutUnitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    enabledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutUnitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutUnitsNestedInput
    rooms?: UnitRoomUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutUnitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: UnitRoomUncheckedUpdateManyWithoutUnitNestedInput
    resources?: UnitResourceUncheckedUpdateManyWithoutUnitNestedInput
    equipment?: EquipmentAssetUncheckedUpdateManyWithoutUnitNestedInput
    bookings?: ProcedureBookingUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutUnitTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    usesRooms?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitRoomCreateManyUnitInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitResourceCreateManyUnitInput = {
    id?: string
    branchId: string
    roomId?: string | null
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentAssetCreateManyUnitInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    ownerDepartmentId?: string | null
    roomId?: string | null
    locationNodeId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureBookingCreateManyUnitInput = {
    id?: string
    branchId: string
    resourceId: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitRoomUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitRoomsNestedInput
    resources?: UnitResourceUpdateManyWithoutRoomNestedInput
    equipment?: EquipmentAssetUpdateManyWithoutRoomNestedInput
  }

  export type UnitRoomUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resources?: UnitResourceUncheckedUpdateManyWithoutRoomNestedInput
    equipment?: EquipmentAssetUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type UnitRoomUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitResourceUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitResourcesNestedInput
    room?: UnitRoomUpdateOneWithoutResourcesNestedInput
    bookings?: ProcedureBookingUpdateManyWithoutResourceNestedInput
  }

  export type UnitResourceUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ProcedureBookingUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type UnitResourceUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssetUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEquipmentAssetsNestedInput
    ownerDepartment?: DepartmentUpdateOneWithoutEquipmentOwnedNestedInput
    room?: UnitRoomUpdateOneWithoutEquipmentNestedInput
    locationNode?: LocationNodeUpdateOneWithoutEquipmentAssetNestedInput
    downtimeTickets?: DowntimeTicketUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    locationNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeTickets?: DowntimeTicketUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    locationNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureBookingUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProcedureBookingsNestedInput
    resource?: UnitResourceUpdateOneRequiredWithoutBookingsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedBookingsNestedInput
  }

  export type ProcedureBookingUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureBookingUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitResourceCreateManyRoomInput = {
    id?: string
    branchId: string
    unitId: string
    resourceType: $Enums.UnitResourceType
    code: string
    name: string
    state?: $Enums.UnitResourceState
    isActive?: boolean
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentAssetCreateManyRoomInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category?: $Enums.EquipmentComplianceCategory
    make?: string | null
    model?: string | null
    serial?: string | null
    ownerDepartmentId?: string | null
    unitId?: string | null
    locationNodeId?: string | null
    operationalStatus?: $Enums.EquipmentOperationalStatus
    amcVendor?: string | null
    amcValidFrom?: Date | string | null
    amcValidTo?: Date | string | null
    warrantyValidTo?: Date | string | null
    pmFrequencyDays?: number | null
    nextPmDueAt?: Date | string | null
    aerbLicenseNo?: string | null
    aerbValidTo?: Date | string | null
    pcpndtRegNo?: string | null
    pcpndtValidTo?: Date | string | null
    isSchedulable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitResourceUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutUnitResourcesNestedInput
    unit?: UnitUpdateOneRequiredWithoutResourcesNestedInput
    bookings?: ProcedureBookingUpdateManyWithoutResourceNestedInput
  }

  export type UnitResourceUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ProcedureBookingUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type UnitResourceUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumUnitResourceTypeFieldUpdateOperationsInput | $Enums.UnitResourceType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: EnumUnitResourceStateFieldUpdateOperationsInput | $Enums.UnitResourceState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentAssetUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEquipmentAssetsNestedInput
    ownerDepartment?: DepartmentUpdateOneWithoutEquipmentOwnedNestedInput
    unit?: UnitUpdateOneWithoutEquipmentNestedInput
    locationNode?: LocationNodeUpdateOneWithoutEquipmentAssetNestedInput
    downtimeTickets?: DowntimeTicketUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    locationNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downtimeTickets?: DowntimeTicketUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type EquipmentAssetUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentComplianceCategoryFieldUpdateOperationsInput | $Enums.EquipmentComplianceCategory
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    serial?: NullableStringFieldUpdateOperationsInput | string | null
    ownerDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    locationNodeId?: NullableStringFieldUpdateOperationsInput | string | null
    operationalStatus?: EnumEquipmentOperationalStatusFieldUpdateOperationsInput | $Enums.EquipmentOperationalStatus
    amcVendor?: NullableStringFieldUpdateOperationsInput | string | null
    amcValidFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amcValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pmFrequencyDays?: NullableIntFieldUpdateOperationsInput | number | null
    nextPmDueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aerbLicenseNo?: NullableStringFieldUpdateOperationsInput | string | null
    aerbValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pcpndtRegNo?: NullableStringFieldUpdateOperationsInput | string | null
    pcpndtValidTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isSchedulable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureBookingCreateManyResourceInput = {
    id?: string
    branchId: string
    unitId: string
    patientId?: string | null
    departmentId?: string | null
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.BookingStatus
    consentOk?: boolean
    anesthesiaOk?: boolean
    checklistOk?: boolean
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProcedureBookingUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutProcedureBookingsNestedInput
    unit?: UnitUpdateOneRequiredWithoutBookingsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedBookingsNestedInput
  }

  export type ProcedureBookingUncheckedUpdateWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcedureBookingUncheckedUpdateManyWithoutResourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    consentOk?: BoolFieldUpdateOperationsInput | boolean
    anesthesiaOk?: BoolFieldUpdateOperationsInput | boolean
    checklistOk?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DowntimeTicketCreateManyAssetInput = {
    id?: string
    status?: $Enums.DowntimeStatus
    reason: string
    notes?: string | null
    openedAt?: Date | string
    closedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DowntimeTicketUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDowntimeStatusFieldUpdateOperationsInput | $Enums.DowntimeStatus
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DowntimeTicketUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDowntimeStatusFieldUpdateOperationsInput | $Enums.DowntimeStatus
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DowntimeTicketUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDowntimeStatusFieldUpdateOperationsInput | $Enums.DowntimeStatus
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceChargeMappingCreateManyChargeMasterItemInput = {
    id?: string
    branchId: string
    serviceItemId: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceChargeMappingUpdateWithoutChargeMasterItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutServiceMappingsNestedInput
    serviceItem?: ServiceItemUpdateOneRequiredWithoutMappingsNestedInput
  }

  export type ServiceChargeMappingUncheckedUpdateWithoutChargeMasterItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceItemId?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceChargeMappingUncheckedUpdateManyWithoutChargeMasterItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    serviceItemId?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceChargeMappingCreateManyServiceItemInput = {
    id?: string
    branchId: string
    chargeMasterItemId: string
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixItTaskCreateManyServiceItemInput = {
    id?: string
    branchId: string
    type: $Enums.FixItType
    status?: $Enums.FixItStatus
    title: string
    details?: NullableJsonNullValueInput | InputJsonValue
    assignedToUserId?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceChargeMappingUpdateWithoutServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutServiceMappingsNestedInput
    chargeMasterItem?: ChargeMasterItemUpdateOneRequiredWithoutMappingsNestedInput
  }

  export type ServiceChargeMappingUncheckedUpdateWithoutServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    chargeMasterItemId?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceChargeMappingUncheckedUpdateManyWithoutServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    chargeMasterItemId?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixItTaskUpdateWithoutServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutFixItTasksNestedInput
    assignedToUser?: UserUpdateOneWithoutAssignedFixItsNestedInput
  }

  export type FixItTaskUncheckedUpdateWithoutServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixItTaskUncheckedUpdateManyWithoutServiceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    type?: EnumFixItTypeFieldUpdateOperationsInput | $Enums.FixItType
    status?: EnumFixItStatusFieldUpdateOperationsInput | $Enums.FixItStatus
    title?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BranchCountOutputTypeDefaultArgs instead
     */
    export type BranchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityCatalogCountOutputTypeDefaultArgs instead
     */
    export type FacilityCatalogCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityCatalogCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCountOutputTypeDefaultArgs instead
     */
    export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpecialtyCountOutputTypeDefaultArgs instead
     */
    export type SpecialtyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecialtyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StaffCountOutputTypeDefaultArgs instead
     */
    export type StaffCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StaffCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientCountOutputTypeDefaultArgs instead
     */
    export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterCountOutputTypeDefaultArgs instead
     */
    export type EncounterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardCountOutputTypeDefaultArgs instead
     */
    export type WardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomCountOutputTypeDefaultArgs instead
     */
    export type RoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BedCountOutputTypeDefaultArgs instead
     */
    export type BedCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BedCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TariffPlanCountOutputTypeDefaultArgs instead
     */
    export type TariffPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TariffPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTemplateCountOutputTypeDefaultArgs instead
     */
    export type RoleTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTemplateVersionCountOutputTypeDefaultArgs instead
     */
    export type RoleTemplateVersionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTemplateVersionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PolicyDefinitionCountOutputTypeDefaultArgs instead
     */
    export type PolicyDefinitionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PolicyDefinitionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PolicyVersionCountOutputTypeDefaultArgs instead
     */
    export type PolicyVersionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PolicyVersionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationNodeCountOutputTypeDefaultArgs instead
     */
    export type LocationNodeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationNodeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitTypeCatalogCountOutputTypeDefaultArgs instead
     */
    export type UnitTypeCatalogCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitTypeCatalogCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitCountOutputTypeDefaultArgs instead
     */
    export type UnitCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitRoomCountOutputTypeDefaultArgs instead
     */
    export type UnitRoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitRoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitResourceCountOutputTypeDefaultArgs instead
     */
    export type UnitResourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitResourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentAssetCountOutputTypeDefaultArgs instead
     */
    export type EquipmentAssetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentAssetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChargeMasterItemCountOutputTypeDefaultArgs instead
     */
    export type ChargeMasterItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChargeMasterItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceItemCountOutputTypeDefaultArgs instead
     */
    export type ServiceItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDefaultArgs instead
     */
    export type BranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacilityCatalogDefaultArgs instead
     */
    export type FacilityCatalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacilityCatalogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchFacilityDefaultArgs instead
     */
    export type BranchFacilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchFacilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDefaultArgs instead
     */
    export type DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDoctorDefaultArgs instead
     */
    export type DepartmentDoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDoctorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpecialtyDefaultArgs instead
     */
    export type SpecialtyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecialtyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentSpecialtyDefaultArgs instead
     */
    export type DepartmentSpecialtyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentSpecialtyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StaffDefaultArgs instead
     */
    export type StaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StaffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientDefaultArgs instead
     */
    export type PatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterDefaultArgs instead
     */
    export type EncounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardDefaultArgs instead
     */
    export type WardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BedDefaultArgs instead
     */
    export type BedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionDefaultArgs instead
     */
    export type AdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OTDefaultArgs instead
     */
    export type OTArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OTDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDefaultArgs instead
     */
    export type AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TariffPlanDefaultArgs instead
     */
    export type TariffPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TariffPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCatalogItemDefaultArgs instead
     */
    export type ServiceCatalogItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCatalogItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TariffRateDefaultArgs instead
     */
    export type TariffRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TariffRateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsentRecordDefaultArgs instead
     */
    export type ConsentRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsentRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RtbfRequestDefaultArgs instead
     */
    export type RtbfRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RtbfRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatutoryCaseDefaultArgs instead
     */
    export type StatutoryCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatutoryCaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditEventDefaultArgs instead
     */
    export type AuditEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutboxEventDefaultArgs instead
     */
    export type OutboxEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OutboxEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTemplateDefaultArgs instead
     */
    export type RoleTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTemplateVersionDefaultArgs instead
     */
    export type RoleTemplateVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTemplateVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTemplatePermissionDefaultArgs instead
     */
    export type RoleTemplatePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTemplatePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PolicyDefinitionDefaultArgs instead
     */
    export type PolicyDefinitionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PolicyDefinitionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PolicyVersionDefaultArgs instead
     */
    export type PolicyVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PolicyVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PolicyVersionBranchDefaultArgs instead
     */
    export type PolicyVersionBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PolicyVersionBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationNodeDefaultArgs instead
     */
    export type LocationNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationNodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationNodeRevisionDefaultArgs instead
     */
    export type LocationNodeRevisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationNodeRevisionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitTypeCatalogDefaultArgs instead
     */
    export type UnitTypeCatalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitTypeCatalogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchUnitTypeDefaultArgs instead
     */
    export type BranchUnitTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchUnitTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitDefaultArgs instead
     */
    export type UnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitRoomDefaultArgs instead
     */
    export type UnitRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitRoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitResourceDefaultArgs instead
     */
    export type UnitResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentAssetDefaultArgs instead
     */
    export type EquipmentAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentAssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DowntimeTicketDefaultArgs instead
     */
    export type DowntimeTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DowntimeTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChargeMasterItemDefaultArgs instead
     */
    export type ChargeMasterItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChargeMasterItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceItemDefaultArgs instead
     */
    export type ServiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceChargeMappingDefaultArgs instead
     */
    export type ServiceChargeMappingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceChargeMappingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FixItTaskDefaultArgs instead
     */
    export type FixItTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FixItTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BulkImportJobDefaultArgs instead
     */
    export type BulkImportJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BulkImportJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcedureBookingDefaultArgs instead
     */
    export type ProcedureBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcedureBookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoLiveReportDefaultArgs instead
     */
    export type GoLiveReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoLiveReportDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}