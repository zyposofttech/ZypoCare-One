
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Specialty
 * 
 */
export type Specialty = $Result.DefaultSelection<Prisma.$SpecialtyPayload>
/**
 * Model Staff
 * 
 */
export type Staff = $Result.DefaultSelection<Prisma.$StaffPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Encounter
 * 
 */
export type Encounter = $Result.DefaultSelection<Prisma.$EncounterPayload>
/**
 * Model Ward
 * 
 */
export type Ward = $Result.DefaultSelection<Prisma.$WardPayload>
/**
 * Model Bed
 * 
 */
export type Bed = $Result.DefaultSelection<Prisma.$BedPayload>
/**
 * Model Admission
 * 
 */
export type Admission = $Result.DefaultSelection<Prisma.$AdmissionPayload>
/**
 * Model OT
 * 
 */
export type OT = $Result.DefaultSelection<Prisma.$OTPayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model TariffPlan
 * 
 */
export type TariffPlan = $Result.DefaultSelection<Prisma.$TariffPlanPayload>
/**
 * Model ServiceCatalogItem
 * 
 */
export type ServiceCatalogItem = $Result.DefaultSelection<Prisma.$ServiceCatalogItemPayload>
/**
 * Model TariffRate
 * 
 */
export type TariffRate = $Result.DefaultSelection<Prisma.$TariffRatePayload>
/**
 * Model ConsentRecord
 * 
 */
export type ConsentRecord = $Result.DefaultSelection<Prisma.$ConsentRecordPayload>
/**
 * Model RtbfRequest
 * 
 */
export type RtbfRequest = $Result.DefaultSelection<Prisma.$RtbfRequestPayload>
/**
 * Model StatutoryCase
 * 
 */
export type StatutoryCase = $Result.DefaultSelection<Prisma.$StatutoryCasePayload>
/**
 * Model AuditEvent
 * 
 */
export type AuditEvent = $Result.DefaultSelection<Prisma.$AuditEventPayload>
/**
 * Model OutboxEvent
 * 
 */
export type OutboxEvent = $Result.DefaultSelection<Prisma.$OutboxEventPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RoleTemplate
 * 
 */
export type RoleTemplate = $Result.DefaultSelection<Prisma.$RoleTemplatePayload>
/**
 * Model RoleTemplateVersion
 * 
 */
export type RoleTemplateVersion = $Result.DefaultSelection<Prisma.$RoleTemplateVersionPayload>
/**
 * Model RoleTemplatePermission
 * 
 */
export type RoleTemplatePermission = $Result.DefaultSelection<Prisma.$RoleTemplatePermissionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const EncounterType: {
  OPD: 'OPD',
  IPD: 'IPD',
  ER: 'ER'
};

export type EncounterType = (typeof EncounterType)[keyof typeof EncounterType]


export const BedState: {
  VACANT: 'VACANT',
  OCCUPIED: 'OCCUPIED',
  CLEANING: 'CLEANING',
  MAINTENANCE: 'MAINTENANCE'
};

export type BedState = (typeof BedState)[keyof typeof BedState]


export const ConsentScope: {
  VIEW: 'VIEW',
  STORE: 'STORE',
  SHARE: 'SHARE'
};

export type ConsentScope = (typeof ConsentScope)[keyof typeof ConsentScope]


export const ConsentStatus: {
  GRANTED: 'GRANTED',
  WITHDRAWN: 'WITHDRAWN'
};

export type ConsentStatus = (typeof ConsentStatus)[keyof typeof ConsentStatus]


export const RtbfStatus: {
  REQUESTED: 'REQUESTED',
  IN_REVIEW: 'IN_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  FULFILLED: 'FULFILLED'
};

export type RtbfStatus = (typeof RtbfStatus)[keyof typeof RtbfStatus]


export const OutboxStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  SENT: 'SENT',
  FAILED: 'FAILED'
};

export type OutboxStatus = (typeof OutboxStatus)[keyof typeof OutboxStatus]


export const RoleScope: {
  GLOBAL: 'GLOBAL',
  BRANCH: 'BRANCH'
};

export type RoleScope = (typeof RoleScope)[keyof typeof RoleScope]


export const RoleVersionStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  RETIRED: 'RETIRED'
};

export type RoleVersionStatus = (typeof RoleVersionStatus)[keyof typeof RoleVersionStatus]

}

export type EncounterType = $Enums.EncounterType

export const EncounterType: typeof $Enums.EncounterType

export type BedState = $Enums.BedState

export const BedState: typeof $Enums.BedState

export type ConsentScope = $Enums.ConsentScope

export const ConsentScope: typeof $Enums.ConsentScope

export type ConsentStatus = $Enums.ConsentStatus

export const ConsentStatus: typeof $Enums.ConsentStatus

export type RtbfStatus = $Enums.RtbfStatus

export const RtbfStatus: typeof $Enums.RtbfStatus

export type OutboxStatus = $Enums.OutboxStatus

export const OutboxStatus: typeof $Enums.OutboxStatus

export type RoleScope = $Enums.RoleScope

export const RoleScope: typeof $Enums.RoleScope

export type RoleVersionStatus = $Enums.RoleVersionStatus

export const RoleVersionStatus: typeof $Enums.RoleVersionStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Branches
 * const branches = await prisma.branch.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Branches
   * const branches = await prisma.branch.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs>;

  /**
   * `prisma.specialty`: Exposes CRUD operations for the **Specialty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specialties
    * const specialties = await prisma.specialty.findMany()
    * ```
    */
  get specialty(): Prisma.SpecialtyDelegate<ExtArgs>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs>;

  /**
   * `prisma.encounter`: Exposes CRUD operations for the **Encounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encounters
    * const encounters = await prisma.encounter.findMany()
    * ```
    */
  get encounter(): Prisma.EncounterDelegate<ExtArgs>;

  /**
   * `prisma.ward`: Exposes CRUD operations for the **Ward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wards
    * const wards = await prisma.ward.findMany()
    * ```
    */
  get ward(): Prisma.WardDelegate<ExtArgs>;

  /**
   * `prisma.bed`: Exposes CRUD operations for the **Bed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beds
    * const beds = await prisma.bed.findMany()
    * ```
    */
  get bed(): Prisma.BedDelegate<ExtArgs>;

  /**
   * `prisma.admission`: Exposes CRUD operations for the **Admission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admissions
    * const admissions = await prisma.admission.findMany()
    * ```
    */
  get admission(): Prisma.AdmissionDelegate<ExtArgs>;

  /**
   * `prisma.oT`: Exposes CRUD operations for the **OT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OTS
    * const oTS = await prisma.oT.findMany()
    * ```
    */
  get oT(): Prisma.OTDelegate<ExtArgs>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs>;

  /**
   * `prisma.tariffPlan`: Exposes CRUD operations for the **TariffPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TariffPlans
    * const tariffPlans = await prisma.tariffPlan.findMany()
    * ```
    */
  get tariffPlan(): Prisma.TariffPlanDelegate<ExtArgs>;

  /**
   * `prisma.serviceCatalogItem`: Exposes CRUD operations for the **ServiceCatalogItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCatalogItems
    * const serviceCatalogItems = await prisma.serviceCatalogItem.findMany()
    * ```
    */
  get serviceCatalogItem(): Prisma.ServiceCatalogItemDelegate<ExtArgs>;

  /**
   * `prisma.tariffRate`: Exposes CRUD operations for the **TariffRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TariffRates
    * const tariffRates = await prisma.tariffRate.findMany()
    * ```
    */
  get tariffRate(): Prisma.TariffRateDelegate<ExtArgs>;

  /**
   * `prisma.consentRecord`: Exposes CRUD operations for the **ConsentRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsentRecords
    * const consentRecords = await prisma.consentRecord.findMany()
    * ```
    */
  get consentRecord(): Prisma.ConsentRecordDelegate<ExtArgs>;

  /**
   * `prisma.rtbfRequest`: Exposes CRUD operations for the **RtbfRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RtbfRequests
    * const rtbfRequests = await prisma.rtbfRequest.findMany()
    * ```
    */
  get rtbfRequest(): Prisma.RtbfRequestDelegate<ExtArgs>;

  /**
   * `prisma.statutoryCase`: Exposes CRUD operations for the **StatutoryCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatutoryCases
    * const statutoryCases = await prisma.statutoryCase.findMany()
    * ```
    */
  get statutoryCase(): Prisma.StatutoryCaseDelegate<ExtArgs>;

  /**
   * `prisma.auditEvent`: Exposes CRUD operations for the **AuditEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditEvents
    * const auditEvents = await prisma.auditEvent.findMany()
    * ```
    */
  get auditEvent(): Prisma.AuditEventDelegate<ExtArgs>;

  /**
   * `prisma.outboxEvent`: Exposes CRUD operations for the **OutboxEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutboxEvents
    * const outboxEvents = await prisma.outboxEvent.findMany()
    * ```
    */
  get outboxEvent(): Prisma.OutboxEventDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.roleTemplate`: Exposes CRUD operations for the **RoleTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleTemplates
    * const roleTemplates = await prisma.roleTemplate.findMany()
    * ```
    */
  get roleTemplate(): Prisma.RoleTemplateDelegate<ExtArgs>;

  /**
   * `prisma.roleTemplateVersion`: Exposes CRUD operations for the **RoleTemplateVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleTemplateVersions
    * const roleTemplateVersions = await prisma.roleTemplateVersion.findMany()
    * ```
    */
  get roleTemplateVersion(): Prisma.RoleTemplateVersionDelegate<ExtArgs>;

  /**
   * `prisma.roleTemplatePermission`: Exposes CRUD operations for the **RoleTemplatePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleTemplatePermissions
    * const roleTemplatePermissions = await prisma.roleTemplatePermission.findMany()
    * ```
    */
  get roleTemplatePermission(): Prisma.RoleTemplatePermissionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Branch: 'Branch',
    Department: 'Department',
    Specialty: 'Specialty',
    Staff: 'Staff',
    User: 'User',
    Patient: 'Patient',
    Encounter: 'Encounter',
    Ward: 'Ward',
    Bed: 'Bed',
    Admission: 'Admission',
    OT: 'OT',
    Asset: 'Asset',
    TariffPlan: 'TariffPlan',
    ServiceCatalogItem: 'ServiceCatalogItem',
    TariffRate: 'TariffRate',
    ConsentRecord: 'ConsentRecord',
    RtbfRequest: 'RtbfRequest',
    StatutoryCase: 'StatutoryCase',
    AuditEvent: 'AuditEvent',
    OutboxEvent: 'OutboxEvent',
    Permission: 'Permission',
    RoleTemplate: 'RoleTemplate',
    RoleTemplateVersion: 'RoleTemplateVersion',
    RoleTemplatePermission: 'RoleTemplatePermission'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "branch" | "department" | "specialty" | "staff" | "user" | "patient" | "encounter" | "ward" | "bed" | "admission" | "oT" | "asset" | "tariffPlan" | "serviceCatalogItem" | "tariffRate" | "consentRecord" | "rtbfRequest" | "statutoryCase" | "auditEvent" | "outboxEvent" | "permission" | "roleTemplate" | "roleTemplateVersion" | "roleTemplatePermission"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Specialty: {
        payload: Prisma.$SpecialtyPayload<ExtArgs>
        fields: Prisma.SpecialtyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialtyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialtyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          findFirst: {
            args: Prisma.SpecialtyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialtyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          findMany: {
            args: Prisma.SpecialtyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          create: {
            args: Prisma.SpecialtyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          createMany: {
            args: Prisma.SpecialtyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecialtyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          delete: {
            args: Prisma.SpecialtyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          update: {
            args: Prisma.SpecialtyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          deleteMany: {
            args: Prisma.SpecialtyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialtyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpecialtyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          aggregate: {
            args: Prisma.SpecialtyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecialty>
          }
          groupBy: {
            args: Prisma.SpecialtyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecialtyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialtyCountArgs<ExtArgs>
            result: $Utils.Optional<SpecialtyCountAggregateOutputType> | number
          }
        }
      }
      Staff: {
        payload: Prisma.$StaffPayload<ExtArgs>
        fields: Prisma.StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Encounter: {
        payload: Prisma.$EncounterPayload<ExtArgs>
        fields: Prisma.EncounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findFirst: {
            args: Prisma.EncounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findMany: {
            args: Prisma.EncounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          create: {
            args: Prisma.EncounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          createMany: {
            args: Prisma.EncounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          delete: {
            args: Prisma.EncounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          update: {
            args: Prisma.EncounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          aggregate: {
            args: Prisma.EncounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounter>
          }
          groupBy: {
            args: Prisma.EncounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterCountAggregateOutputType> | number
          }
        }
      }
      Ward: {
        payload: Prisma.$WardPayload<ExtArgs>
        fields: Prisma.WardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          findFirst: {
            args: Prisma.WardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          findMany: {
            args: Prisma.WardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          create: {
            args: Prisma.WardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          createMany: {
            args: Prisma.WardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          delete: {
            args: Prisma.WardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          update: {
            args: Prisma.WardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          deleteMany: {
            args: Prisma.WardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          aggregate: {
            args: Prisma.WardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWard>
          }
          groupBy: {
            args: Prisma.WardGroupByArgs<ExtArgs>
            result: $Utils.Optional<WardGroupByOutputType>[]
          }
          count: {
            args: Prisma.WardCountArgs<ExtArgs>
            result: $Utils.Optional<WardCountAggregateOutputType> | number
          }
        }
      }
      Bed: {
        payload: Prisma.$BedPayload<ExtArgs>
        fields: Prisma.BedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          findFirst: {
            args: Prisma.BedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          findMany: {
            args: Prisma.BedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          create: {
            args: Prisma.BedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          createMany: {
            args: Prisma.BedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          delete: {
            args: Prisma.BedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          update: {
            args: Prisma.BedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          deleteMany: {
            args: Prisma.BedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          aggregate: {
            args: Prisma.BedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBed>
          }
          groupBy: {
            args: Prisma.BedGroupByArgs<ExtArgs>
            result: $Utils.Optional<BedGroupByOutputType>[]
          }
          count: {
            args: Prisma.BedCountArgs<ExtArgs>
            result: $Utils.Optional<BedCountAggregateOutputType> | number
          }
        }
      }
      Admission: {
        payload: Prisma.$AdmissionPayload<ExtArgs>
        fields: Prisma.AdmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findFirst: {
            args: Prisma.AdmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findMany: {
            args: Prisma.AdmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          create: {
            args: Prisma.AdmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          createMany: {
            args: Prisma.AdmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          delete: {
            args: Prisma.AdmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          update: {
            args: Prisma.AdmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          aggregate: {
            args: Prisma.AdmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmission>
          }
          groupBy: {
            args: Prisma.AdmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionCountAggregateOutputType> | number
          }
        }
      }
      OT: {
        payload: Prisma.$OTPayload<ExtArgs>
        fields: Prisma.OTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          findFirst: {
            args: Prisma.OTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          findMany: {
            args: Prisma.OTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>[]
          }
          create: {
            args: Prisma.OTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          createMany: {
            args: Prisma.OTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>[]
          }
          delete: {
            args: Prisma.OTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          update: {
            args: Prisma.OTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          deleteMany: {
            args: Prisma.OTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OTPayload>
          }
          aggregate: {
            args: Prisma.OTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOT>
          }
          groupBy: {
            args: Prisma.OTGroupByArgs<ExtArgs>
            result: $Utils.Optional<OTGroupByOutputType>[]
          }
          count: {
            args: Prisma.OTCountArgs<ExtArgs>
            result: $Utils.Optional<OTCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      TariffPlan: {
        payload: Prisma.$TariffPlanPayload<ExtArgs>
        fields: Prisma.TariffPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TariffPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TariffPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          findFirst: {
            args: Prisma.TariffPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TariffPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          findMany: {
            args: Prisma.TariffPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>[]
          }
          create: {
            args: Prisma.TariffPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          createMany: {
            args: Prisma.TariffPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TariffPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>[]
          }
          delete: {
            args: Prisma.TariffPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          update: {
            args: Prisma.TariffPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          deleteMany: {
            args: Prisma.TariffPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TariffPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TariffPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPlanPayload>
          }
          aggregate: {
            args: Prisma.TariffPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTariffPlan>
          }
          groupBy: {
            args: Prisma.TariffPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TariffPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TariffPlanCountArgs<ExtArgs>
            result: $Utils.Optional<TariffPlanCountAggregateOutputType> | number
          }
        }
      }
      ServiceCatalogItem: {
        payload: Prisma.$ServiceCatalogItemPayload<ExtArgs>
        fields: Prisma.ServiceCatalogItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceCatalogItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceCatalogItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          findFirst: {
            args: Prisma.ServiceCatalogItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceCatalogItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          findMany: {
            args: Prisma.ServiceCatalogItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>[]
          }
          create: {
            args: Prisma.ServiceCatalogItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          createMany: {
            args: Prisma.ServiceCatalogItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCatalogItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>[]
          }
          delete: {
            args: Prisma.ServiceCatalogItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          update: {
            args: Prisma.ServiceCatalogItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          deleteMany: {
            args: Prisma.ServiceCatalogItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceCatalogItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceCatalogItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceCatalogItemPayload>
          }
          aggregate: {
            args: Prisma.ServiceCatalogItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceCatalogItem>
          }
          groupBy: {
            args: Prisma.ServiceCatalogItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceCatalogItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCatalogItemCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCatalogItemCountAggregateOutputType> | number
          }
        }
      }
      TariffRate: {
        payload: Prisma.$TariffRatePayload<ExtArgs>
        fields: Prisma.TariffRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TariffRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TariffRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          findFirst: {
            args: Prisma.TariffRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TariffRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          findMany: {
            args: Prisma.TariffRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>[]
          }
          create: {
            args: Prisma.TariffRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          createMany: {
            args: Prisma.TariffRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TariffRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>[]
          }
          delete: {
            args: Prisma.TariffRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          update: {
            args: Prisma.TariffRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          deleteMany: {
            args: Prisma.TariffRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TariffRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TariffRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffRatePayload>
          }
          aggregate: {
            args: Prisma.TariffRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTariffRate>
          }
          groupBy: {
            args: Prisma.TariffRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TariffRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TariffRateCountArgs<ExtArgs>
            result: $Utils.Optional<TariffRateCountAggregateOutputType> | number
          }
        }
      }
      ConsentRecord: {
        payload: Prisma.$ConsentRecordPayload<ExtArgs>
        fields: Prisma.ConsentRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsentRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsentRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          findFirst: {
            args: Prisma.ConsentRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsentRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          findMany: {
            args: Prisma.ConsentRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>[]
          }
          create: {
            args: Prisma.ConsentRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          createMany: {
            args: Prisma.ConsentRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsentRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>[]
          }
          delete: {
            args: Prisma.ConsentRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          update: {
            args: Prisma.ConsentRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          deleteMany: {
            args: Prisma.ConsentRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsentRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsentRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsentRecordPayload>
          }
          aggregate: {
            args: Prisma.ConsentRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsentRecord>
          }
          groupBy: {
            args: Prisma.ConsentRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsentRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsentRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ConsentRecordCountAggregateOutputType> | number
          }
        }
      }
      RtbfRequest: {
        payload: Prisma.$RtbfRequestPayload<ExtArgs>
        fields: Prisma.RtbfRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RtbfRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RtbfRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          findFirst: {
            args: Prisma.RtbfRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RtbfRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          findMany: {
            args: Prisma.RtbfRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>[]
          }
          create: {
            args: Prisma.RtbfRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          createMany: {
            args: Prisma.RtbfRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RtbfRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>[]
          }
          delete: {
            args: Prisma.RtbfRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          update: {
            args: Prisma.RtbfRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          deleteMany: {
            args: Prisma.RtbfRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RtbfRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RtbfRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RtbfRequestPayload>
          }
          aggregate: {
            args: Prisma.RtbfRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRtbfRequest>
          }
          groupBy: {
            args: Prisma.RtbfRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RtbfRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RtbfRequestCountArgs<ExtArgs>
            result: $Utils.Optional<RtbfRequestCountAggregateOutputType> | number
          }
        }
      }
      StatutoryCase: {
        payload: Prisma.$StatutoryCasePayload<ExtArgs>
        fields: Prisma.StatutoryCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatutoryCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatutoryCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          findFirst: {
            args: Prisma.StatutoryCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatutoryCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          findMany: {
            args: Prisma.StatutoryCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>[]
          }
          create: {
            args: Prisma.StatutoryCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          createMany: {
            args: Prisma.StatutoryCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatutoryCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>[]
          }
          delete: {
            args: Prisma.StatutoryCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          update: {
            args: Prisma.StatutoryCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          deleteMany: {
            args: Prisma.StatutoryCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatutoryCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StatutoryCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatutoryCasePayload>
          }
          aggregate: {
            args: Prisma.StatutoryCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatutoryCase>
          }
          groupBy: {
            args: Prisma.StatutoryCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatutoryCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatutoryCaseCountArgs<ExtArgs>
            result: $Utils.Optional<StatutoryCaseCountAggregateOutputType> | number
          }
        }
      }
      AuditEvent: {
        payload: Prisma.$AuditEventPayload<ExtArgs>
        fields: Prisma.AuditEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findFirst: {
            args: Prisma.AuditEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findMany: {
            args: Prisma.AuditEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          create: {
            args: Prisma.AuditEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          createMany: {
            args: Prisma.AuditEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          delete: {
            args: Prisma.AuditEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          update: {
            args: Prisma.AuditEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          deleteMany: {
            args: Prisma.AuditEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          aggregate: {
            args: Prisma.AuditEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditEvent>
          }
          groupBy: {
            args: Prisma.AuditEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditEventCountArgs<ExtArgs>
            result: $Utils.Optional<AuditEventCountAggregateOutputType> | number
          }
        }
      }
      OutboxEvent: {
        payload: Prisma.$OutboxEventPayload<ExtArgs>
        fields: Prisma.OutboxEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutboxEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutboxEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          findFirst: {
            args: Prisma.OutboxEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutboxEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          findMany: {
            args: Prisma.OutboxEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>[]
          }
          create: {
            args: Prisma.OutboxEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          createMany: {
            args: Prisma.OutboxEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutboxEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>[]
          }
          delete: {
            args: Prisma.OutboxEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          update: {
            args: Prisma.OutboxEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          deleteMany: {
            args: Prisma.OutboxEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutboxEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OutboxEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxEventPayload>
          }
          aggregate: {
            args: Prisma.OutboxEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutboxEvent>
          }
          groupBy: {
            args: Prisma.OutboxEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutboxEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutboxEventCountArgs<ExtArgs>
            result: $Utils.Optional<OutboxEventCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RoleTemplate: {
        payload: Prisma.$RoleTemplatePayload<ExtArgs>
        fields: Prisma.RoleTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          findFirst: {
            args: Prisma.RoleTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          findMany: {
            args: Prisma.RoleTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>[]
          }
          create: {
            args: Prisma.RoleTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          createMany: {
            args: Prisma.RoleTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>[]
          }
          delete: {
            args: Prisma.RoleTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          update: {
            args: Prisma.RoleTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          deleteMany: {
            args: Prisma.RoleTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePayload>
          }
          aggregate: {
            args: Prisma.RoleTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleTemplate>
          }
          groupBy: {
            args: Prisma.RoleTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplateCountAggregateOutputType> | number
          }
        }
      }
      RoleTemplateVersion: {
        payload: Prisma.$RoleTemplateVersionPayload<ExtArgs>
        fields: Prisma.RoleTemplateVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleTemplateVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleTemplateVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          findFirst: {
            args: Prisma.RoleTemplateVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleTemplateVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          findMany: {
            args: Prisma.RoleTemplateVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>[]
          }
          create: {
            args: Prisma.RoleTemplateVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          createMany: {
            args: Prisma.RoleTemplateVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleTemplateVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>[]
          }
          delete: {
            args: Prisma.RoleTemplateVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          update: {
            args: Prisma.RoleTemplateVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          deleteMany: {
            args: Prisma.RoleTemplateVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleTemplateVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleTemplateVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplateVersionPayload>
          }
          aggregate: {
            args: Prisma.RoleTemplateVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleTemplateVersion>
          }
          groupBy: {
            args: Prisma.RoleTemplateVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplateVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleTemplateVersionCountArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplateVersionCountAggregateOutputType> | number
          }
        }
      }
      RoleTemplatePermission: {
        payload: Prisma.$RoleTemplatePermissionPayload<ExtArgs>
        fields: Prisma.RoleTemplatePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleTemplatePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleTemplatePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          findFirst: {
            args: Prisma.RoleTemplatePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleTemplatePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          findMany: {
            args: Prisma.RoleTemplatePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>[]
          }
          create: {
            args: Prisma.RoleTemplatePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          createMany: {
            args: Prisma.RoleTemplatePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleTemplatePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>[]
          }
          delete: {
            args: Prisma.RoleTemplatePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          update: {
            args: Prisma.RoleTemplatePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RoleTemplatePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleTemplatePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleTemplatePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleTemplatePermissionPayload>
          }
          aggregate: {
            args: Prisma.RoleTemplatePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleTemplatePermission>
          }
          groupBy: {
            args: Prisma.RoleTemplatePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplatePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleTemplatePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RoleTemplatePermissionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    departments: number
    users: number
    patients: number
    wards: number
    oTs: number
    tariffPlans: number
    assets: number
    Specialty: number
    Staff: number
    Encounter: number
    Bed: number
    Admission: number
    statutoryCases: number
    auditEvents: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | BranchCountOutputTypeCountDepartmentsArgs
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    patients?: boolean | BranchCountOutputTypeCountPatientsArgs
    wards?: boolean | BranchCountOutputTypeCountWardsArgs
    oTs?: boolean | BranchCountOutputTypeCountOTsArgs
    tariffPlans?: boolean | BranchCountOutputTypeCountTariffPlansArgs
    assets?: boolean | BranchCountOutputTypeCountAssetsArgs
    Specialty?: boolean | BranchCountOutputTypeCountSpecialtyArgs
    Staff?: boolean | BranchCountOutputTypeCountStaffArgs
    Encounter?: boolean | BranchCountOutputTypeCountEncounterArgs
    Bed?: boolean | BranchCountOutputTypeCountBedArgs
    Admission?: boolean | BranchCountOutputTypeCountAdmissionArgs
    statutoryCases?: boolean | BranchCountOutputTypeCountStatutoryCasesArgs
    auditEvents?: boolean | BranchCountOutputTypeCountAuditEventsArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountWardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountOTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountTariffPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffPlanWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSpecialtyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialtyWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountEncounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountBedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountStatutoryCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatutoryCaseWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountAuditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    staff: number
    specialties: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | DepartmentCountOutputTypeCountStaffArgs
    specialties?: boolean | DepartmentCountOutputTypeCountSpecialtiesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountSpecialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialtyWhereInput
  }


  /**
   * Count Type SpecialtyCountOutputType
   */

  export type SpecialtyCountOutputType = {
    staff: number
  }

  export type SpecialtyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | SpecialtyCountOutputTypeCountStaffArgs
  }

  // Custom InputTypes
  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialtyCountOutputType
     */
    select?: SpecialtyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdRoleVersions: number
    auditEventsAsActor: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdRoleVersions?: boolean | UserCountOutputTypeCountCreatedRoleVersionsArgs
    auditEventsAsActor?: boolean | UserCountOutputTypeCountAuditEventsAsActorArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedRoleVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplateVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditEventsAsActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    encounters: number
    Admission: number
    consentRecords: number
    rtbfRequests: number
    statutoryCases: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | PatientCountOutputTypeCountEncountersArgs
    Admission?: boolean | PatientCountOutputTypeCountAdmissionArgs
    consentRecords?: boolean | PatientCountOutputTypeCountConsentRecordsArgs
    rtbfRequests?: boolean | PatientCountOutputTypeCountRtbfRequestsArgs
    statutoryCases?: boolean | PatientCountOutputTypeCountStatutoryCasesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountConsentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentRecordWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountRtbfRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RtbfRequestWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountStatutoryCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatutoryCaseWhereInput
  }


  /**
   * Count Type EncounterCountOutputType
   */

  export type EncounterCountOutputType = {
    admissions: number
  }

  export type EncounterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admissions?: boolean | EncounterCountOutputTypeCountAdmissionsArgs
  }

  // Custom InputTypes
  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCountOutputType
     */
    select?: EncounterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }


  /**
   * Count Type WardCountOutputType
   */

  export type WardCountOutputType = {
    beds: number
  }

  export type WardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beds?: boolean | WardCountOutputTypeCountBedsArgs
  }

  // Custom InputTypes
  /**
   * WardCountOutputType without action
   */
  export type WardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardCountOutputType
     */
    select?: WardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WardCountOutputType without action
   */
  export type WardCountOutputTypeCountBedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
  }


  /**
   * Count Type BedCountOutputType
   */

  export type BedCountOutputType = {
    admissions: number
  }

  export type BedCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admissions?: boolean | BedCountOutputTypeCountAdmissionsArgs
  }

  // Custom InputTypes
  /**
   * BedCountOutputType without action
   */
  export type BedCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedCountOutputType
     */
    select?: BedCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BedCountOutputType without action
   */
  export type BedCountOutputTypeCountAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }


  /**
   * Count Type TariffPlanCountOutputType
   */

  export type TariffPlanCountOutputType = {
    rates: number
  }

  export type TariffPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rates?: boolean | TariffPlanCountOutputTypeCountRatesArgs
  }

  // Custom InputTypes
  /**
   * TariffPlanCountOutputType without action
   */
  export type TariffPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlanCountOutputType
     */
    select?: TariffPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TariffPlanCountOutputType without action
   */
  export type TariffPlanCountOutputTypeCountRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffRateWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roleGrants: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleGrants?: boolean | PermissionCountOutputTypeCountRoleGrantsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRoleGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplatePermissionWhereInput
  }


  /**
   * Count Type RoleTemplateCountOutputType
   */

  export type RoleTemplateCountOutputType = {
    versions: number
  }

  export type RoleTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | RoleTemplateCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * RoleTemplateCountOutputType without action
   */
  export type RoleTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateCountOutputType
     */
    select?: RoleTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleTemplateCountOutputType without action
   */
  export type RoleTemplateCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplateVersionWhereInput
  }


  /**
   * Count Type RoleTemplateVersionCountOutputType
   */

  export type RoleTemplateVersionCountOutputType = {
    permissions: number
    users: number
  }

  export type RoleTemplateVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleTemplateVersionCountOutputTypeCountPermissionsArgs
    users?: boolean | RoleTemplateVersionCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleTemplateVersionCountOutputType without action
   */
  export type RoleTemplateVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersionCountOutputType
     */
    select?: RoleTemplateVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleTemplateVersionCountOutputType without action
   */
  export type RoleTemplateVersionCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplatePermissionWhereInput
  }

  /**
   * RoleTemplateVersionCountOutputType without action
   */
  export type RoleTemplateVersionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    city: string | null
    address: string | null
    contactPhone1: string | null
    contactPhone2: string | null
    contactEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    city: string | null
    address: string | null
    contactPhone1: string | null
    contactPhone2: string | null
    contactEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    code: number
    name: number
    city: number
    address: number
    contactPhone1: number
    contactPhone2: number
    contactEmail: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BranchMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    city?: true
    address?: true
    contactPhone1?: true
    contactPhone2?: true
    contactEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    city?: true
    address?: true
    contactPhone1?: true
    contactPhone2?: true
    contactEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    city?: true
    address?: true
    contactPhone1?: true
    contactPhone2?: true
    contactEmail?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: string
    code: string
    name: string
    city: string
    address: string | null
    contactPhone1: string | null
    contactPhone2: string | null
    contactEmail: string | null
    createdAt: Date
    updatedAt: Date
    _count: BranchCountAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    city?: boolean
    address?: boolean
    contactPhone1?: boolean
    contactPhone2?: boolean
    contactEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departments?: boolean | Branch$departmentsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    patients?: boolean | Branch$patientsArgs<ExtArgs>
    wards?: boolean | Branch$wardsArgs<ExtArgs>
    oTs?: boolean | Branch$oTsArgs<ExtArgs>
    tariffPlans?: boolean | Branch$tariffPlansArgs<ExtArgs>
    assets?: boolean | Branch$assetsArgs<ExtArgs>
    Specialty?: boolean | Branch$SpecialtyArgs<ExtArgs>
    Staff?: boolean | Branch$StaffArgs<ExtArgs>
    Encounter?: boolean | Branch$EncounterArgs<ExtArgs>
    Bed?: boolean | Branch$BedArgs<ExtArgs>
    Admission?: boolean | Branch$AdmissionArgs<ExtArgs>
    statutoryCases?: boolean | Branch$statutoryCasesArgs<ExtArgs>
    auditEvents?: boolean | Branch$auditEventsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    city?: boolean
    address?: boolean
    contactPhone1?: boolean
    contactPhone2?: boolean
    contactEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    city?: boolean
    address?: boolean
    contactPhone1?: boolean
    contactPhone2?: boolean
    contactEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | Branch$departmentsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    patients?: boolean | Branch$patientsArgs<ExtArgs>
    wards?: boolean | Branch$wardsArgs<ExtArgs>
    oTs?: boolean | Branch$oTsArgs<ExtArgs>
    tariffPlans?: boolean | Branch$tariffPlansArgs<ExtArgs>
    assets?: boolean | Branch$assetsArgs<ExtArgs>
    Specialty?: boolean | Branch$SpecialtyArgs<ExtArgs>
    Staff?: boolean | Branch$StaffArgs<ExtArgs>
    Encounter?: boolean | Branch$EncounterArgs<ExtArgs>
    Bed?: boolean | Branch$BedArgs<ExtArgs>
    Admission?: boolean | Branch$AdmissionArgs<ExtArgs>
    statutoryCases?: boolean | Branch$statutoryCasesArgs<ExtArgs>
    auditEvents?: boolean | Branch$auditEventsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      patients: Prisma.$PatientPayload<ExtArgs>[]
      wards: Prisma.$WardPayload<ExtArgs>[]
      oTs: Prisma.$OTPayload<ExtArgs>[]
      tariffPlans: Prisma.$TariffPlanPayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
      Specialty: Prisma.$SpecialtyPayload<ExtArgs>[]
      Staff: Prisma.$StaffPayload<ExtArgs>[]
      Encounter: Prisma.$EncounterPayload<ExtArgs>[]
      Bed: Prisma.$BedPayload<ExtArgs>[]
      Admission: Prisma.$AdmissionPayload<ExtArgs>[]
      statutoryCases: Prisma.$StatutoryCasePayload<ExtArgs>[]
      auditEvents: Prisma.$AuditEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      city: string
      address: string | null
      contactPhone1: string | null
      contactPhone2: string | null
      contactEmail: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departments<T extends Branch$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    patients<T extends Branch$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany"> | Null>
    wards<T extends Branch$wardsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$wardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findMany"> | Null>
    oTs<T extends Branch$oTsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$oTsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findMany"> | Null>
    tariffPlans<T extends Branch$tariffPlansArgs<ExtArgs> = {}>(args?: Subset<T, Branch$tariffPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findMany"> | Null>
    assets<T extends Branch$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    Specialty<T extends Branch$SpecialtyArgs<ExtArgs> = {}>(args?: Subset<T, Branch$SpecialtyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findMany"> | Null>
    Staff<T extends Branch$StaffArgs<ExtArgs> = {}>(args?: Subset<T, Branch$StaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany"> | Null>
    Encounter<T extends Branch$EncounterArgs<ExtArgs> = {}>(args?: Subset<T, Branch$EncounterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    Bed<T extends Branch$BedArgs<ExtArgs> = {}>(args?: Subset<T, Branch$BedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany"> | Null>
    Admission<T extends Branch$AdmissionArgs<ExtArgs> = {}>(args?: Subset<T, Branch$AdmissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany"> | Null>
    statutoryCases<T extends Branch$statutoryCasesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$statutoryCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findMany"> | Null>
    auditEvents<T extends Branch$auditEventsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$auditEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */ 
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'String'>
    readonly code: FieldRef<"Branch", 'String'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly city: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly contactPhone1: FieldRef<"Branch", 'String'>
    readonly contactPhone2: FieldRef<"Branch", 'String'>
    readonly contactEmail: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
    readonly updatedAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
  }

  /**
   * Branch.departments
   */
  export type Branch$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.patients
   */
  export type Branch$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Branch.wards
   */
  export type Branch$wardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    where?: WardWhereInput
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    cursor?: WardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Branch.oTs
   */
  export type Branch$oTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    where?: OTWhereInput
    orderBy?: OTOrderByWithRelationInput | OTOrderByWithRelationInput[]
    cursor?: OTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OTScalarFieldEnum | OTScalarFieldEnum[]
  }

  /**
   * Branch.tariffPlans
   */
  export type Branch$tariffPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    where?: TariffPlanWhereInput
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    cursor?: TariffPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * Branch.assets
   */
  export type Branch$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Branch.Specialty
   */
  export type Branch$SpecialtyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    where?: SpecialtyWhereInput
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    cursor?: SpecialtyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Branch.Staff
   */
  export type Branch$StaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Branch.Encounter
   */
  export type Branch$EncounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Branch.Bed
   */
  export type Branch$BedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    where?: BedWhereInput
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    cursor?: BedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Branch.Admission
   */
  export type Branch$AdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Branch.statutoryCases
   */
  export type Branch$statutoryCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    where?: StatutoryCaseWhereInput
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    cursor?: StatutoryCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatutoryCaseScalarFieldEnum | StatutoryCaseScalarFieldEnum[]
  }

  /**
   * Branch.auditEvents
   */
  export type Branch$auditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    cursor?: AuditEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    staff?: boolean | Department$staffArgs<ExtArgs>
    specialties?: boolean | Department$specialtiesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    staff?: boolean | Department$staffArgs<ExtArgs>
    specialties?: boolean | Department$specialtiesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      staff: Prisma.$StaffPayload<ExtArgs>[]
      specialties: Prisma.$SpecialtyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    staff<T extends Department$staffArgs<ExtArgs> = {}>(args?: Subset<T, Department$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany"> | Null>
    specialties<T extends Department$specialtiesArgs<ExtArgs> = {}>(args?: Subset<T, Department$specialtiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly branchId: FieldRef<"Department", 'String'>
    readonly code: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly isActive: FieldRef<"Department", 'Boolean'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department.staff
   */
  export type Department$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Department.specialties
   */
  export type Department$specialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    where?: SpecialtyWhereInput
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    cursor?: SpecialtyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Specialty
   */

  export type AggregateSpecialty = {
    _count: SpecialtyCountAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  export type SpecialtyMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    departmentId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialtyMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    departmentId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialtyCountAggregateOutputType = {
    id: number
    branchId: number
    departmentId: number
    code: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpecialtyMinAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialtyMaxAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialtyCountAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpecialtyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialty to aggregate.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Specialties
    **/
    _count?: true | SpecialtyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialtyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialtyMaxAggregateInputType
  }

  export type GetSpecialtyAggregateType<T extends SpecialtyAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialty[P]>
      : GetScalarType<T[P], AggregateSpecialty[P]>
  }




  export type SpecialtyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialtyWhereInput
    orderBy?: SpecialtyOrderByWithAggregationInput | SpecialtyOrderByWithAggregationInput[]
    by: SpecialtyScalarFieldEnum[] | SpecialtyScalarFieldEnum
    having?: SpecialtyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialtyCountAggregateInputType | true
    _min?: SpecialtyMinAggregateInputType
    _max?: SpecialtyMaxAggregateInputType
  }

  export type SpecialtyGroupByOutputType = {
    id: string
    branchId: string
    departmentId: string | null
    code: string
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SpecialtyCountAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  type GetSpecialtyGroupByPayload<T extends SpecialtyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialtyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialtyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
        }
      >
    >


  export type SpecialtySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Specialty$departmentArgs<ExtArgs>
    staff?: boolean | Specialty$staffArgs<ExtArgs>
    _count?: boolean | SpecialtyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Specialty$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectScalar = {
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpecialtyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Specialty$departmentArgs<ExtArgs>
    staff?: boolean | Specialty$staffArgs<ExtArgs>
    _count?: boolean | SpecialtyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpecialtyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Specialty$departmentArgs<ExtArgs>
  }

  export type $SpecialtyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Specialty"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      staff: Prisma.$StaffPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      departmentId: string | null
      code: string
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["specialty"]>
    composites: {}
  }

  type SpecialtyGetPayload<S extends boolean | null | undefined | SpecialtyDefaultArgs> = $Result.GetResult<Prisma.$SpecialtyPayload, S>

  type SpecialtyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpecialtyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpecialtyCountAggregateInputType | true
    }

  export interface SpecialtyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Specialty'], meta: { name: 'Specialty' } }
    /**
     * Find zero or one Specialty that matches the filter.
     * @param {SpecialtyFindUniqueArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecialtyFindUniqueArgs>(args: SelectSubset<T, SpecialtyFindUniqueArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Specialty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpecialtyFindUniqueOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecialtyFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecialtyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Specialty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecialtyFindFirstArgs>(args?: SelectSubset<T, SpecialtyFindFirstArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Specialty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecialtyFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecialtyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Specialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specialties
     * const specialties = await prisma.specialty.findMany()
     * 
     * // Get first 10 Specialties
     * const specialties = await prisma.specialty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialtyWithIdOnly = await prisma.specialty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecialtyFindManyArgs>(args?: SelectSubset<T, SpecialtyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Specialty.
     * @param {SpecialtyCreateArgs} args - Arguments to create a Specialty.
     * @example
     * // Create one Specialty
     * const Specialty = await prisma.specialty.create({
     *   data: {
     *     // ... data to create a Specialty
     *   }
     * })
     * 
     */
    create<T extends SpecialtyCreateArgs>(args: SelectSubset<T, SpecialtyCreateArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Specialties.
     * @param {SpecialtyCreateManyArgs} args - Arguments to create many Specialties.
     * @example
     * // Create many Specialties
     * const specialty = await prisma.specialty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecialtyCreateManyArgs>(args?: SelectSubset<T, SpecialtyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Specialties and returns the data saved in the database.
     * @param {SpecialtyCreateManyAndReturnArgs} args - Arguments to create many Specialties.
     * @example
     * // Create many Specialties
     * const specialty = await prisma.specialty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Specialties and only return the `id`
     * const specialtyWithIdOnly = await prisma.specialty.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecialtyCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecialtyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Specialty.
     * @param {SpecialtyDeleteArgs} args - Arguments to delete one Specialty.
     * @example
     * // Delete one Specialty
     * const Specialty = await prisma.specialty.delete({
     *   where: {
     *     // ... filter to delete one Specialty
     *   }
     * })
     * 
     */
    delete<T extends SpecialtyDeleteArgs>(args: SelectSubset<T, SpecialtyDeleteArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Specialty.
     * @param {SpecialtyUpdateArgs} args - Arguments to update one Specialty.
     * @example
     * // Update one Specialty
     * const specialty = await prisma.specialty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecialtyUpdateArgs>(args: SelectSubset<T, SpecialtyUpdateArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Specialties.
     * @param {SpecialtyDeleteManyArgs} args - Arguments to filter Specialties to delete.
     * @example
     * // Delete a few Specialties
     * const { count } = await prisma.specialty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecialtyDeleteManyArgs>(args?: SelectSubset<T, SpecialtyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specialties
     * const specialty = await prisma.specialty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecialtyUpdateManyArgs>(args: SelectSubset<T, SpecialtyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Specialty.
     * @param {SpecialtyUpsertArgs} args - Arguments to update or create a Specialty.
     * @example
     * // Update or create a Specialty
     * const specialty = await prisma.specialty.upsert({
     *   create: {
     *     // ... data to create a Specialty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specialty we want to update
     *   }
     * })
     */
    upsert<T extends SpecialtyUpsertArgs>(args: SelectSubset<T, SpecialtyUpsertArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyCountArgs} args - Arguments to filter Specialties to count.
     * @example
     * // Count the number of Specialties
     * const count = await prisma.specialty.count({
     *   where: {
     *     // ... the filter for the Specialties we want to count
     *   }
     * })
    **/
    count<T extends SpecialtyCountArgs>(
      args?: Subset<T, SpecialtyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialtyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialtyAggregateArgs>(args: Subset<T, SpecialtyAggregateArgs>): Prisma.PrismaPromise<GetSpecialtyAggregateType<T>>

    /**
     * Group by Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialtyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialtyGroupByArgs['orderBy'] }
        : { orderBy?: SpecialtyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialtyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialtyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Specialty model
   */
  readonly fields: SpecialtyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Specialty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialtyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    department<T extends Specialty$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    staff<T extends Specialty$staffArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Specialty model
   */ 
  interface SpecialtyFieldRefs {
    readonly id: FieldRef<"Specialty", 'String'>
    readonly branchId: FieldRef<"Specialty", 'String'>
    readonly departmentId: FieldRef<"Specialty", 'String'>
    readonly code: FieldRef<"Specialty", 'String'>
    readonly name: FieldRef<"Specialty", 'String'>
    readonly isActive: FieldRef<"Specialty", 'Boolean'>
    readonly createdAt: FieldRef<"Specialty", 'DateTime'>
    readonly updatedAt: FieldRef<"Specialty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Specialty findUnique
   */
  export type SpecialtyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty findUniqueOrThrow
   */
  export type SpecialtyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty findFirst
   */
  export type SpecialtyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty findFirstOrThrow
   */
  export type SpecialtyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty findMany
   */
  export type SpecialtyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialties to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty create
   */
  export type SpecialtyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to create a Specialty.
     */
    data: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
  }

  /**
   * Specialty createMany
   */
  export type SpecialtyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Specialties.
     */
    data: SpecialtyCreateManyInput | SpecialtyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Specialty createManyAndReturn
   */
  export type SpecialtyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Specialties.
     */
    data: SpecialtyCreateManyInput | SpecialtyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Specialty update
   */
  export type SpecialtyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to update a Specialty.
     */
    data: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
    /**
     * Choose, which Specialty to update.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty updateMany
   */
  export type SpecialtyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Specialties.
     */
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which Specialties to update
     */
    where?: SpecialtyWhereInput
  }

  /**
   * Specialty upsert
   */
  export type SpecialtyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The filter to search for the Specialty to update in case it exists.
     */
    where: SpecialtyWhereUniqueInput
    /**
     * In case the Specialty found by the `where` argument doesn't exist, create a new Specialty with this data.
     */
    create: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
    /**
     * In case the Specialty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
  }

  /**
   * Specialty delete
   */
  export type SpecialtyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter which Specialty to delete.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty deleteMany
   */
  export type SpecialtyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialties to delete
     */
    where?: SpecialtyWhereInput
  }

  /**
   * Specialty.department
   */
  export type Specialty$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Specialty.staff
   */
  export type Specialty$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Specialty without action
   */
  export type SpecialtyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
  }


  /**
   * Model Staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    departmentId: string | null
    specialtyId: string | null
    empCode: string | null
    name: string | null
    designation: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    departmentId: string | null
    specialtyId: string | null
    empCode: string | null
    name: string | null
    designation: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    branchId: number
    departmentId: number
    specialtyId: number
    empCode: number
    name: number
    designation: number
    phone: number
    email: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffMinAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    specialtyId?: true
    empCode?: true
    name?: true
    designation?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    specialtyId?: true
    empCode?: true
    name?: true
    designation?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    branchId?: true
    departmentId?: true
    specialtyId?: true
    empCode?: true
    name?: true
    designation?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithAggregationInput | StaffOrderByWithAggregationInput[]
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }

  export type StaffGroupByOutputType = {
    id: string
    branchId: string
    departmentId: string | null
    specialtyId: string | null
    empCode: string
    name: string
    designation: string
    phone: string | null
    email: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    specialtyId?: boolean
    empCode?: boolean
    name?: boolean
    designation?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    specialty?: boolean | Staff$specialtyArgs<ExtArgs>
    user?: boolean | Staff$userArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    specialtyId?: boolean
    empCode?: boolean
    name?: boolean
    designation?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    specialty?: boolean | Staff$specialtyArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    branchId?: boolean
    departmentId?: boolean
    specialtyId?: boolean
    empCode?: boolean
    name?: boolean
    designation?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    specialty?: boolean | Staff$specialtyArgs<ExtArgs>
    user?: boolean | Staff$userArgs<ExtArgs>
  }
  export type StaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    specialty?: boolean | Staff$specialtyArgs<ExtArgs>
  }

  export type $StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Staff"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      specialty: Prisma.$SpecialtyPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      departmentId: string | null
      specialtyId: string | null
      empCode: string
      name: string
      designation: string
      phone: string | null
      email: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staff"]>
    composites: {}
  }

  type StaffGetPayload<S extends boolean | null | undefined | StaffDefaultArgs> = $Result.GetResult<Prisma.$StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffFindUniqueArgs>(args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffFindFirstArgs>(args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffFindManyArgs>(args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
     */
    create<T extends StaffCreateArgs>(args: SelectSubset<T, StaffCreateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Staff.
     * @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffCreateManyArgs>(args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {StaffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
     */
    delete<T extends StaffDeleteArgs>(args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffUpdateArgs>(args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffDeleteManyArgs>(args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffUpdateManyArgs>(args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends StaffUpsertArgs>(args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Staff model
   */
  readonly fields: StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    department<T extends Staff$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Staff$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    specialty<T extends Staff$specialtyArgs<ExtArgs> = {}>(args?: Subset<T, Staff$specialtyArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends Staff$userArgs<ExtArgs> = {}>(args?: Subset<T, Staff$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Staff model
   */ 
  interface StaffFieldRefs {
    readonly id: FieldRef<"Staff", 'String'>
    readonly branchId: FieldRef<"Staff", 'String'>
    readonly departmentId: FieldRef<"Staff", 'String'>
    readonly specialtyId: FieldRef<"Staff", 'String'>
    readonly empCode: FieldRef<"Staff", 'String'>
    readonly name: FieldRef<"Staff", 'String'>
    readonly designation: FieldRef<"Staff", 'String'>
    readonly phone: FieldRef<"Staff", 'String'>
    readonly email: FieldRef<"Staff", 'String'>
    readonly isActive: FieldRef<"Staff", 'Boolean'>
    readonly createdAt: FieldRef<"Staff", 'DateTime'>
    readonly updatedAt: FieldRef<"Staff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }

  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Staff createManyAndReturn
   */
  export type StaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
  }

  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }

  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
  }

  /**
   * Staff.department
   */
  export type Staff$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Staff.specialty
   */
  export type Staff$specialtyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    where?: SpecialtyWhereInput
  }

  /**
   * Staff.user
   */
  export type Staff$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Staff without action
   */
  export type StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: string | null
    phone: string | null
    branchId: string | null
    staffId: string | null
    isActive: boolean | null
    passwordHash: string | null
    mustChangePassword: boolean | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    roleVersionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: string | null
    phone: string | null
    branchId: string | null
    staffId: string | null
    isActive: boolean | null
    passwordHash: string | null
    mustChangePassword: boolean | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    roleVersionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    phone: number
    branchId: number
    staffId: number
    isActive: number
    passwordHash: number
    mustChangePassword: number
    passwordResetToken: number
    passwordResetExpires: number
    roleVersionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    phone?: true
    branchId?: true
    staffId?: true
    isActive?: true
    passwordHash?: true
    mustChangePassword?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    roleVersionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    phone?: true
    branchId?: true
    staffId?: true
    isActive?: true
    passwordHash?: true
    mustChangePassword?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    roleVersionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    phone?: true
    branchId?: true
    staffId?: true
    isActive?: true
    passwordHash?: true
    mustChangePassword?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    roleVersionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    role: string
    phone: string | null
    branchId: string | null
    staffId: string | null
    isActive: boolean
    passwordHash: string | null
    mustChangePassword: boolean
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    roleVersionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    phone?: boolean
    branchId?: boolean
    staffId?: boolean
    isActive?: boolean
    passwordHash?: boolean
    mustChangePassword?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    roleVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    roleVersion?: boolean | User$roleVersionArgs<ExtArgs>
    createdRoleVersions?: boolean | User$createdRoleVersionsArgs<ExtArgs>
    auditEventsAsActor?: boolean | User$auditEventsAsActorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    phone?: boolean
    branchId?: boolean
    staffId?: boolean
    isActive?: boolean
    passwordHash?: boolean
    mustChangePassword?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    roleVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | User$branchArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    roleVersion?: boolean | User$roleVersionArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    phone?: boolean
    branchId?: boolean
    staffId?: boolean
    isActive?: boolean
    passwordHash?: boolean
    mustChangePassword?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    roleVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    roleVersion?: boolean | User$roleVersionArgs<ExtArgs>
    createdRoleVersions?: boolean | User$createdRoleVersionsArgs<ExtArgs>
    auditEventsAsActor?: boolean | User$auditEventsAsActorArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | User$branchArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    roleVersion?: boolean | User$roleVersionArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      staff: Prisma.$StaffPayload<ExtArgs> | null
      roleVersion: Prisma.$RoleTemplateVersionPayload<ExtArgs> | null
      createdRoleVersions: Prisma.$RoleTemplateVersionPayload<ExtArgs>[]
      auditEventsAsActor: Prisma.$AuditEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      role: string
      phone: string | null
      branchId: string | null
      staffId: string | null
      isActive: boolean
      passwordHash: string | null
      mustChangePassword: boolean
      passwordResetToken: string | null
      passwordResetExpires: Date | null
      roleVersionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    staff<T extends User$staffArgs<ExtArgs> = {}>(args?: Subset<T, User$staffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    roleVersion<T extends User$roleVersionArgs<ExtArgs> = {}>(args?: Subset<T, User$roleVersionArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdRoleVersions<T extends User$createdRoleVersionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdRoleVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findMany"> | Null>
    auditEventsAsActor<T extends User$auditEventsAsActorArgs<ExtArgs> = {}>(args?: Subset<T, User$auditEventsAsActorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly branchId: FieldRef<"User", 'String'>
    readonly staffId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly mustChangePassword: FieldRef<"User", 'Boolean'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly passwordResetExpires: FieldRef<"User", 'DateTime'>
    readonly roleVersionId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User.staff
   */
  export type User$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * User.roleVersion
   */
  export type User$roleVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    where?: RoleTemplateVersionWhereInput
  }

  /**
   * User.createdRoleVersions
   */
  export type User$createdRoleVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    where?: RoleTemplateVersionWhereInput
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    cursor?: RoleTemplateVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleTemplateVersionScalarFieldEnum | RoleTemplateVersionScalarFieldEnum[]
  }

  /**
   * User.auditEventsAsActor
   */
  export type User$auditEventsAsActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    cursor?: AuditEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    uhid: string | null
    name: string | null
    gender: string | null
    dob: Date | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    uhid: string | null
    name: string | null
    gender: string | null
    dob: Date | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    branchId: number
    uhid: number
    name: number
    gender: number
    dob: number
    phone: number
    email: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    branchId?: true
    uhid?: true
    name?: true
    gender?: true
    dob?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    branchId?: true
    uhid?: true
    name?: true
    gender?: true
    dob?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    branchId?: true
    uhid?: true
    name?: true
    gender?: true
    dob?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    branchId: string
    uhid: string
    name: string
    gender: string | null
    dob: Date | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    uhid?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounters?: boolean | Patient$encountersArgs<ExtArgs>
    Admission?: boolean | Patient$AdmissionArgs<ExtArgs>
    consentRecords?: boolean | Patient$consentRecordsArgs<ExtArgs>
    rtbfRequests?: boolean | Patient$rtbfRequestsArgs<ExtArgs>
    statutoryCases?: boolean | Patient$statutoryCasesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    uhid?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    branchId?: boolean
    uhid?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounters?: boolean | Patient$encountersArgs<ExtArgs>
    Admission?: boolean | Patient$AdmissionArgs<ExtArgs>
    consentRecords?: boolean | Patient$consentRecordsArgs<ExtArgs>
    rtbfRequests?: boolean | Patient$rtbfRequestsArgs<ExtArgs>
    statutoryCases?: boolean | Patient$statutoryCasesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      Admission: Prisma.$AdmissionPayload<ExtArgs>[]
      consentRecords: Prisma.$ConsentRecordPayload<ExtArgs>[]
      rtbfRequests: Prisma.$RtbfRequestPayload<ExtArgs>[]
      statutoryCases: Prisma.$StatutoryCasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      uhid: string
      name: string
      gender: string | null
      dob: Date | null
      phone: string | null
      email: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    encounters<T extends Patient$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Patient$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    Admission<T extends Patient$AdmissionArgs<ExtArgs> = {}>(args?: Subset<T, Patient$AdmissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany"> | Null>
    consentRecords<T extends Patient$consentRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$consentRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findMany"> | Null>
    rtbfRequests<T extends Patient$rtbfRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$rtbfRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findMany"> | Null>
    statutoryCases<T extends Patient$statutoryCasesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$statutoryCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */ 
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly branchId: FieldRef<"Patient", 'String'>
    readonly uhid: FieldRef<"Patient", 'String'>
    readonly name: FieldRef<"Patient", 'String'>
    readonly gender: FieldRef<"Patient", 'String'>
    readonly dob: FieldRef<"Patient", 'DateTime'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly address: FieldRef<"Patient", 'String'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }

  /**
   * Patient.encounters
   */
  export type Patient$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Patient.Admission
   */
  export type Patient$AdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Patient.consentRecords
   */
  export type Patient$consentRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    where?: ConsentRecordWhereInput
    orderBy?: ConsentRecordOrderByWithRelationInput | ConsentRecordOrderByWithRelationInput[]
    cursor?: ConsentRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * Patient.rtbfRequests
   */
  export type Patient$rtbfRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    where?: RtbfRequestWhereInput
    orderBy?: RtbfRequestOrderByWithRelationInput | RtbfRequestOrderByWithRelationInput[]
    cursor?: RtbfRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RtbfRequestScalarFieldEnum | RtbfRequestScalarFieldEnum[]
  }

  /**
   * Patient.statutoryCases
   */
  export type Patient$statutoryCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    where?: StatutoryCaseWhereInput
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    cursor?: StatutoryCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatutoryCaseScalarFieldEnum | StatutoryCaseScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Encounter
   */

  export type AggregateEncounter = {
    _count: EncounterCountAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  export type EncounterMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    patientId: string | null
    type: $Enums.EncounterType | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    patientId: string | null
    type: $Enums.EncounterType | null
    startedAt: Date | null
    endedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterCountAggregateOutputType = {
    id: number
    branchId: number
    patientId: number
    type: number
    startedAt: number
    endedAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EncounterMinAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    type?: true
    startedAt?: true
    endedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterMaxAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    type?: true
    startedAt?: true
    endedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterCountAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    type?: true
    startedAt?: true
    endedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EncounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounter to aggregate.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encounters
    **/
    _count?: true | EncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterMaxAggregateInputType
  }

  export type GetEncounterAggregateType<T extends EncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounter[P]>
      : GetScalarType<T[P], AggregateEncounter[P]>
  }




  export type EncounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithAggregationInput | EncounterOrderByWithAggregationInput[]
    by: EncounterScalarFieldEnum[] | EncounterScalarFieldEnum
    having?: EncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterCountAggregateInputType | true
    _min?: EncounterMinAggregateInputType
    _max?: EncounterMaxAggregateInputType
  }

  export type EncounterGroupByOutputType = {
    id: string
    branchId: string
    patientId: string
    type: $Enums.EncounterType
    startedAt: Date
    endedAt: Date | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: EncounterCountAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  type GetEncounterGroupByPayload<T extends EncounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    type?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admissions?: boolean | Encounter$admissionsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    type?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectScalar = {
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    type?: boolean
    startedAt?: boolean
    endedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EncounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admissions?: boolean | Encounter$admissionsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $EncounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encounter"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      admissions: Prisma.$AdmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      patientId: string
      type: $Enums.EncounterType
      startedAt: Date
      endedAt: Date | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["encounter"]>
    composites: {}
  }

  type EncounterGetPayload<S extends boolean | null | undefined | EncounterDefaultArgs> = $Result.GetResult<Prisma.$EncounterPayload, S>

  type EncounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterCountAggregateInputType | true
    }

  export interface EncounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encounter'], meta: { name: 'Encounter' } }
    /**
     * Find zero or one Encounter that matches the filter.
     * @param {EncounterFindUniqueArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterFindUniqueArgs>(args: SelectSubset<T, EncounterFindUniqueArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Encounter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterFindUniqueOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Encounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterFindFirstArgs>(args?: SelectSubset<T, EncounterFindFirstArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Encounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Encounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encounters
     * const encounters = await prisma.encounter.findMany()
     * 
     * // Get first 10 Encounters
     * const encounters = await prisma.encounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterWithIdOnly = await prisma.encounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterFindManyArgs>(args?: SelectSubset<T, EncounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Encounter.
     * @param {EncounterCreateArgs} args - Arguments to create a Encounter.
     * @example
     * // Create one Encounter
     * const Encounter = await prisma.encounter.create({
     *   data: {
     *     // ... data to create a Encounter
     *   }
     * })
     * 
     */
    create<T extends EncounterCreateArgs>(args: SelectSubset<T, EncounterCreateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Encounters.
     * @param {EncounterCreateManyArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterCreateManyArgs>(args?: SelectSubset<T, EncounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encounters and returns the data saved in the database.
     * @param {EncounterCreateManyAndReturnArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Encounter.
     * @param {EncounterDeleteArgs} args - Arguments to delete one Encounter.
     * @example
     * // Delete one Encounter
     * const Encounter = await prisma.encounter.delete({
     *   where: {
     *     // ... filter to delete one Encounter
     *   }
     * })
     * 
     */
    delete<T extends EncounterDeleteArgs>(args: SelectSubset<T, EncounterDeleteArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Encounter.
     * @param {EncounterUpdateArgs} args - Arguments to update one Encounter.
     * @example
     * // Update one Encounter
     * const encounter = await prisma.encounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterUpdateArgs>(args: SelectSubset<T, EncounterUpdateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Encounters.
     * @param {EncounterDeleteManyArgs} args - Arguments to filter Encounters to delete.
     * @example
     * // Delete a few Encounters
     * const { count } = await prisma.encounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDeleteManyArgs>(args?: SelectSubset<T, EncounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterUpdateManyArgs>(args: SelectSubset<T, EncounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Encounter.
     * @param {EncounterUpsertArgs} args - Arguments to update or create a Encounter.
     * @example
     * // Update or create a Encounter
     * const encounter = await prisma.encounter.upsert({
     *   create: {
     *     // ... data to create a Encounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encounter we want to update
     *   }
     * })
     */
    upsert<T extends EncounterUpsertArgs>(args: SelectSubset<T, EncounterUpsertArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterCountArgs} args - Arguments to filter Encounters to count.
     * @example
     * // Count the number of Encounters
     * const count = await prisma.encounter.count({
     *   where: {
     *     // ... the filter for the Encounters we want to count
     *   }
     * })
    **/
    count<T extends EncounterCountArgs>(
      args?: Subset<T, EncounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterAggregateArgs>(args: Subset<T, EncounterAggregateArgs>): Prisma.PrismaPromise<GetEncounterAggregateType<T>>

    /**
     * Group by Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterGroupByArgs['orderBy'] }
        : { orderBy?: EncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encounter model
   */
  readonly fields: EncounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    admissions<T extends Encounter$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$admissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encounter model
   */ 
  interface EncounterFieldRefs {
    readonly id: FieldRef<"Encounter", 'String'>
    readonly branchId: FieldRef<"Encounter", 'String'>
    readonly patientId: FieldRef<"Encounter", 'String'>
    readonly type: FieldRef<"Encounter", 'EncounterType'>
    readonly startedAt: FieldRef<"Encounter", 'DateTime'>
    readonly endedAt: FieldRef<"Encounter", 'DateTime'>
    readonly status: FieldRef<"Encounter", 'String'>
    readonly createdAt: FieldRef<"Encounter", 'DateTime'>
    readonly updatedAt: FieldRef<"Encounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Encounter findUnique
   */
  export type EncounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findUniqueOrThrow
   */
  export type EncounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findFirst
   */
  export type EncounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findFirstOrThrow
   */
  export type EncounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findMany
   */
  export type EncounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounters to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter create
   */
  export type EncounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to create a Encounter.
     */
    data: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
  }

  /**
   * Encounter createMany
   */
  export type EncounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encounter createManyAndReturn
   */
  export type EncounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter update
   */
  export type EncounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to update a Encounter.
     */
    data: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
    /**
     * Choose, which Encounter to update.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter updateMany
   */
  export type EncounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter upsert
   */
  export type EncounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The filter to search for the Encounter to update in case it exists.
     */
    where: EncounterWhereUniqueInput
    /**
     * In case the Encounter found by the `where` argument doesn't exist, create a new Encounter with this data.
     */
    create: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
    /**
     * In case the Encounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
  }

  /**
   * Encounter delete
   */
  export type EncounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter which Encounter to delete.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter deleteMany
   */
  export type EncounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounters to delete
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter.admissions
   */
  export type Encounter$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Encounter without action
   */
  export type EncounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
  }


  /**
   * Model Ward
   */

  export type AggregateWard = {
    _count: WardCountAggregateOutputType | null
    _min: WardMinAggregateOutputType | null
    _max: WardMaxAggregateOutputType | null
  }

  export type WardMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    specialty: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WardMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    specialty: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WardCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    specialty: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WardMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    specialty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WardMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    specialty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WardCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    specialty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ward to aggregate.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wards
    **/
    _count?: true | WardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WardMaxAggregateInputType
  }

  export type GetWardAggregateType<T extends WardAggregateArgs> = {
        [P in keyof T & keyof AggregateWard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWard[P]>
      : GetScalarType<T[P], AggregateWard[P]>
  }




  export type WardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardWhereInput
    orderBy?: WardOrderByWithAggregationInput | WardOrderByWithAggregationInput[]
    by: WardScalarFieldEnum[] | WardScalarFieldEnum
    having?: WardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WardCountAggregateInputType | true
    _min?: WardMinAggregateInputType
    _max?: WardMaxAggregateInputType
  }

  export type WardGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    specialty: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: WardCountAggregateOutputType | null
    _min: WardMinAggregateOutputType | null
    _max: WardMaxAggregateOutputType | null
  }

  type GetWardGroupByPayload<T extends WardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WardGroupByOutputType[P]>
            : GetScalarType<T[P], WardGroupByOutputType[P]>
        }
      >
    >


  export type WardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    specialty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    beds?: boolean | Ward$bedsArgs<ExtArgs>
    _count?: boolean | WardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ward"]>

  export type WardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    specialty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ward"]>

  export type WardSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    specialty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    beds?: boolean | Ward$bedsArgs<ExtArgs>
    _count?: boolean | WardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $WardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ward"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      beds: Prisma.$BedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      specialty: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ward"]>
    composites: {}
  }

  type WardGetPayload<S extends boolean | null | undefined | WardDefaultArgs> = $Result.GetResult<Prisma.$WardPayload, S>

  type WardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WardCountAggregateInputType | true
    }

  export interface WardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ward'], meta: { name: 'Ward' } }
    /**
     * Find zero or one Ward that matches the filter.
     * @param {WardFindUniqueArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WardFindUniqueArgs>(args: SelectSubset<T, WardFindUniqueArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ward that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WardFindUniqueOrThrowArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WardFindUniqueOrThrowArgs>(args: SelectSubset<T, WardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindFirstArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WardFindFirstArgs>(args?: SelectSubset<T, WardFindFirstArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindFirstOrThrowArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WardFindFirstOrThrowArgs>(args?: SelectSubset<T, WardFindFirstOrThrowArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wards
     * const wards = await prisma.ward.findMany()
     * 
     * // Get first 10 Wards
     * const wards = await prisma.ward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wardWithIdOnly = await prisma.ward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WardFindManyArgs>(args?: SelectSubset<T, WardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ward.
     * @param {WardCreateArgs} args - Arguments to create a Ward.
     * @example
     * // Create one Ward
     * const Ward = await prisma.ward.create({
     *   data: {
     *     // ... data to create a Ward
     *   }
     * })
     * 
     */
    create<T extends WardCreateArgs>(args: SelectSubset<T, WardCreateArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wards.
     * @param {WardCreateManyArgs} args - Arguments to create many Wards.
     * @example
     * // Create many Wards
     * const ward = await prisma.ward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WardCreateManyArgs>(args?: SelectSubset<T, WardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wards and returns the data saved in the database.
     * @param {WardCreateManyAndReturnArgs} args - Arguments to create many Wards.
     * @example
     * // Create many Wards
     * const ward = await prisma.ward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wards and only return the `id`
     * const wardWithIdOnly = await prisma.ward.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WardCreateManyAndReturnArgs>(args?: SelectSubset<T, WardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ward.
     * @param {WardDeleteArgs} args - Arguments to delete one Ward.
     * @example
     * // Delete one Ward
     * const Ward = await prisma.ward.delete({
     *   where: {
     *     // ... filter to delete one Ward
     *   }
     * })
     * 
     */
    delete<T extends WardDeleteArgs>(args: SelectSubset<T, WardDeleteArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ward.
     * @param {WardUpdateArgs} args - Arguments to update one Ward.
     * @example
     * // Update one Ward
     * const ward = await prisma.ward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WardUpdateArgs>(args: SelectSubset<T, WardUpdateArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wards.
     * @param {WardDeleteManyArgs} args - Arguments to filter Wards to delete.
     * @example
     * // Delete a few Wards
     * const { count } = await prisma.ward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WardDeleteManyArgs>(args?: SelectSubset<T, WardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wards
     * const ward = await prisma.ward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WardUpdateManyArgs>(args: SelectSubset<T, WardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ward.
     * @param {WardUpsertArgs} args - Arguments to update or create a Ward.
     * @example
     * // Update or create a Ward
     * const ward = await prisma.ward.upsert({
     *   create: {
     *     // ... data to create a Ward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ward we want to update
     *   }
     * })
     */
    upsert<T extends WardUpsertArgs>(args: SelectSubset<T, WardUpsertArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardCountArgs} args - Arguments to filter Wards to count.
     * @example
     * // Count the number of Wards
     * const count = await prisma.ward.count({
     *   where: {
     *     // ... the filter for the Wards we want to count
     *   }
     * })
    **/
    count<T extends WardCountArgs>(
      args?: Subset<T, WardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WardAggregateArgs>(args: Subset<T, WardAggregateArgs>): Prisma.PrismaPromise<GetWardAggregateType<T>>

    /**
     * Group by Ward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WardGroupByArgs['orderBy'] }
        : { orderBy?: WardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ward model
   */
  readonly fields: WardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    beds<T extends Ward$bedsArgs<ExtArgs> = {}>(args?: Subset<T, Ward$bedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ward model
   */ 
  interface WardFieldRefs {
    readonly id: FieldRef<"Ward", 'String'>
    readonly branchId: FieldRef<"Ward", 'String'>
    readonly code: FieldRef<"Ward", 'String'>
    readonly name: FieldRef<"Ward", 'String'>
    readonly specialty: FieldRef<"Ward", 'String'>
    readonly isActive: FieldRef<"Ward", 'Boolean'>
    readonly createdAt: FieldRef<"Ward", 'DateTime'>
    readonly updatedAt: FieldRef<"Ward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ward findUnique
   */
  export type WardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward findUniqueOrThrow
   */
  export type WardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward findFirst
   */
  export type WardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wards.
     */
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward findFirstOrThrow
   */
  export type WardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wards.
     */
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward findMany
   */
  export type WardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Wards to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward create
   */
  export type WardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The data needed to create a Ward.
     */
    data: XOR<WardCreateInput, WardUncheckedCreateInput>
  }

  /**
   * Ward createMany
   */
  export type WardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wards.
     */
    data: WardCreateManyInput | WardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ward createManyAndReturn
   */
  export type WardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Wards.
     */
    data: WardCreateManyInput | WardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ward update
   */
  export type WardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The data needed to update a Ward.
     */
    data: XOR<WardUpdateInput, WardUncheckedUpdateInput>
    /**
     * Choose, which Ward to update.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward updateMany
   */
  export type WardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wards.
     */
    data: XOR<WardUpdateManyMutationInput, WardUncheckedUpdateManyInput>
    /**
     * Filter which Wards to update
     */
    where?: WardWhereInput
  }

  /**
   * Ward upsert
   */
  export type WardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The filter to search for the Ward to update in case it exists.
     */
    where: WardWhereUniqueInput
    /**
     * In case the Ward found by the `where` argument doesn't exist, create a new Ward with this data.
     */
    create: XOR<WardCreateInput, WardUncheckedCreateInput>
    /**
     * In case the Ward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WardUpdateInput, WardUncheckedUpdateInput>
  }

  /**
   * Ward delete
   */
  export type WardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter which Ward to delete.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward deleteMany
   */
  export type WardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wards to delete
     */
    where?: WardWhereInput
  }

  /**
   * Ward.beds
   */
  export type Ward$bedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    where?: BedWhereInput
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    cursor?: BedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Ward without action
   */
  export type WardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
  }


  /**
   * Model Bed
   */

  export type AggregateBed = {
    _count: BedCountAggregateOutputType | null
    _min: BedMinAggregateOutputType | null
    _max: BedMaxAggregateOutputType | null
  }

  export type BedMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    wardId: string | null
    code: string | null
    state: $Enums.BedState | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BedMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    wardId: string | null
    code: string | null
    state: $Enums.BedState | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BedCountAggregateOutputType = {
    id: number
    branchId: number
    wardId: number
    code: number
    state: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BedMinAggregateInputType = {
    id?: true
    branchId?: true
    wardId?: true
    code?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BedMaxAggregateInputType = {
    id?: true
    branchId?: true
    wardId?: true
    code?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BedCountAggregateInputType = {
    id?: true
    branchId?: true
    wardId?: true
    code?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bed to aggregate.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Beds
    **/
    _count?: true | BedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BedMaxAggregateInputType
  }

  export type GetBedAggregateType<T extends BedAggregateArgs> = {
        [P in keyof T & keyof AggregateBed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBed[P]>
      : GetScalarType<T[P], AggregateBed[P]>
  }




  export type BedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
    orderBy?: BedOrderByWithAggregationInput | BedOrderByWithAggregationInput[]
    by: BedScalarFieldEnum[] | BedScalarFieldEnum
    having?: BedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BedCountAggregateInputType | true
    _min?: BedMinAggregateInputType
    _max?: BedMaxAggregateInputType
  }

  export type BedGroupByOutputType = {
    id: string
    branchId: string
    wardId: string
    code: string
    state: $Enums.BedState
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BedCountAggregateOutputType | null
    _min: BedMinAggregateOutputType | null
    _max: BedMaxAggregateOutputType | null
  }

  type GetBedGroupByPayload<T extends BedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BedGroupByOutputType[P]>
            : GetScalarType<T[P], BedGroupByOutputType[P]>
        }
      >
    >


  export type BedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    wardId?: boolean
    code?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
    admissions?: boolean | Bed$admissionsArgs<ExtArgs>
    _count?: boolean | BedCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    wardId?: boolean
    code?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectScalar = {
    id?: boolean
    branchId?: boolean
    wardId?: boolean
    code?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
    admissions?: boolean | Bed$admissionsArgs<ExtArgs>
    _count?: boolean | BedCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }

  export type $BedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bed"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      ward: Prisma.$WardPayload<ExtArgs>
      admissions: Prisma.$AdmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      wardId: string
      code: string
      state: $Enums.BedState
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bed"]>
    composites: {}
  }

  type BedGetPayload<S extends boolean | null | undefined | BedDefaultArgs> = $Result.GetResult<Prisma.$BedPayload, S>

  type BedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BedFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BedCountAggregateInputType | true
    }

  export interface BedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bed'], meta: { name: 'Bed' } }
    /**
     * Find zero or one Bed that matches the filter.
     * @param {BedFindUniqueArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BedFindUniqueArgs>(args: SelectSubset<T, BedFindUniqueArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bed that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BedFindUniqueOrThrowArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BedFindUniqueOrThrowArgs>(args: SelectSubset<T, BedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindFirstArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BedFindFirstArgs>(args?: SelectSubset<T, BedFindFirstArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindFirstOrThrowArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BedFindFirstOrThrowArgs>(args?: SelectSubset<T, BedFindFirstOrThrowArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Beds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beds
     * const beds = await prisma.bed.findMany()
     * 
     * // Get first 10 Beds
     * const beds = await prisma.bed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bedWithIdOnly = await prisma.bed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BedFindManyArgs>(args?: SelectSubset<T, BedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bed.
     * @param {BedCreateArgs} args - Arguments to create a Bed.
     * @example
     * // Create one Bed
     * const Bed = await prisma.bed.create({
     *   data: {
     *     // ... data to create a Bed
     *   }
     * })
     * 
     */
    create<T extends BedCreateArgs>(args: SelectSubset<T, BedCreateArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Beds.
     * @param {BedCreateManyArgs} args - Arguments to create many Beds.
     * @example
     * // Create many Beds
     * const bed = await prisma.bed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BedCreateManyArgs>(args?: SelectSubset<T, BedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Beds and returns the data saved in the database.
     * @param {BedCreateManyAndReturnArgs} args - Arguments to create many Beds.
     * @example
     * // Create many Beds
     * const bed = await prisma.bed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Beds and only return the `id`
     * const bedWithIdOnly = await prisma.bed.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BedCreateManyAndReturnArgs>(args?: SelectSubset<T, BedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bed.
     * @param {BedDeleteArgs} args - Arguments to delete one Bed.
     * @example
     * // Delete one Bed
     * const Bed = await prisma.bed.delete({
     *   where: {
     *     // ... filter to delete one Bed
     *   }
     * })
     * 
     */
    delete<T extends BedDeleteArgs>(args: SelectSubset<T, BedDeleteArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bed.
     * @param {BedUpdateArgs} args - Arguments to update one Bed.
     * @example
     * // Update one Bed
     * const bed = await prisma.bed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BedUpdateArgs>(args: SelectSubset<T, BedUpdateArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Beds.
     * @param {BedDeleteManyArgs} args - Arguments to filter Beds to delete.
     * @example
     * // Delete a few Beds
     * const { count } = await prisma.bed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BedDeleteManyArgs>(args?: SelectSubset<T, BedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beds
     * const bed = await prisma.bed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BedUpdateManyArgs>(args: SelectSubset<T, BedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bed.
     * @param {BedUpsertArgs} args - Arguments to update or create a Bed.
     * @example
     * // Update or create a Bed
     * const bed = await prisma.bed.upsert({
     *   create: {
     *     // ... data to create a Bed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bed we want to update
     *   }
     * })
     */
    upsert<T extends BedUpsertArgs>(args: SelectSubset<T, BedUpsertArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Beds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedCountArgs} args - Arguments to filter Beds to count.
     * @example
     * // Count the number of Beds
     * const count = await prisma.bed.count({
     *   where: {
     *     // ... the filter for the Beds we want to count
     *   }
     * })
    **/
    count<T extends BedCountArgs>(
      args?: Subset<T, BedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BedAggregateArgs>(args: Subset<T, BedAggregateArgs>): Prisma.PrismaPromise<GetBedAggregateType<T>>

    /**
     * Group by Bed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BedGroupByArgs['orderBy'] }
        : { orderBy?: BedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bed model
   */
  readonly fields: BedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ward<T extends WardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardDefaultArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    admissions<T extends Bed$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, Bed$admissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bed model
   */ 
  interface BedFieldRefs {
    readonly id: FieldRef<"Bed", 'String'>
    readonly branchId: FieldRef<"Bed", 'String'>
    readonly wardId: FieldRef<"Bed", 'String'>
    readonly code: FieldRef<"Bed", 'String'>
    readonly state: FieldRef<"Bed", 'BedState'>
    readonly isActive: FieldRef<"Bed", 'Boolean'>
    readonly createdAt: FieldRef<"Bed", 'DateTime'>
    readonly updatedAt: FieldRef<"Bed", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bed findUnique
   */
  export type BedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed findUniqueOrThrow
   */
  export type BedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed findFirst
   */
  export type BedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beds.
     */
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed findFirstOrThrow
   */
  export type BedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beds.
     */
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed findMany
   */
  export type BedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Beds to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed create
   */
  export type BedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The data needed to create a Bed.
     */
    data: XOR<BedCreateInput, BedUncheckedCreateInput>
  }

  /**
   * Bed createMany
   */
  export type BedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Beds.
     */
    data: BedCreateManyInput | BedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bed createManyAndReturn
   */
  export type BedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Beds.
     */
    data: BedCreateManyInput | BedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bed update
   */
  export type BedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The data needed to update a Bed.
     */
    data: XOR<BedUpdateInput, BedUncheckedUpdateInput>
    /**
     * Choose, which Bed to update.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed updateMany
   */
  export type BedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Beds.
     */
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyInput>
    /**
     * Filter which Beds to update
     */
    where?: BedWhereInput
  }

  /**
   * Bed upsert
   */
  export type BedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The filter to search for the Bed to update in case it exists.
     */
    where: BedWhereUniqueInput
    /**
     * In case the Bed found by the `where` argument doesn't exist, create a new Bed with this data.
     */
    create: XOR<BedCreateInput, BedUncheckedCreateInput>
    /**
     * In case the Bed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BedUpdateInput, BedUncheckedUpdateInput>
  }

  /**
   * Bed delete
   */
  export type BedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter which Bed to delete.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed deleteMany
   */
  export type BedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Beds to delete
     */
    where?: BedWhereInput
  }

  /**
   * Bed.admissions
   */
  export type Bed$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Bed without action
   */
  export type BedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
  }


  /**
   * Model Admission
   */

  export type AggregateAdmission = {
    _count: AdmissionCountAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  export type AdmissionMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    encounterId: string | null
    patientId: string | null
    bedId: string | null
    admittedAt: Date | null
    dischargedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    encounterId: string | null
    patientId: string | null
    bedId: string | null
    admittedAt: Date | null
    dischargedAt: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionCountAggregateOutputType = {
    id: number
    branchId: number
    encounterId: number
    patientId: number
    bedId: number
    admittedAt: number
    dischargedAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdmissionMinAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    bedId?: true
    admittedAt?: true
    dischargedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionMaxAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    bedId?: true
    admittedAt?: true
    dischargedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionCountAggregateInputType = {
    id?: true
    branchId?: true
    encounterId?: true
    patientId?: true
    bedId?: true
    admittedAt?: true
    dischargedAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admission to aggregate.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admissions
    **/
    _count?: true | AdmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionMaxAggregateInputType
  }

  export type GetAdmissionAggregateType<T extends AdmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmission[P]>
      : GetScalarType<T[P], AggregateAdmission[P]>
  }




  export type AdmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithAggregationInput | AdmissionOrderByWithAggregationInput[]
    by: AdmissionScalarFieldEnum[] | AdmissionScalarFieldEnum
    having?: AdmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionCountAggregateInputType | true
    _min?: AdmissionMinAggregateInputType
    _max?: AdmissionMaxAggregateInputType
  }

  export type AdmissionGroupByOutputType = {
    id: string
    branchId: string
    encounterId: string | null
    patientId: string
    bedId: string | null
    admittedAt: Date
    dischargedAt: Date | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AdmissionCountAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  type GetAdmissionGroupByPayload<T extends AdmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    bedId?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounter?: boolean | Admission$encounterArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    bed?: boolean | Admission$bedArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    bedId?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounter?: boolean | Admission$encounterArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    bed?: boolean | Admission$bedArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectScalar = {
    id?: boolean
    branchId?: boolean
    encounterId?: boolean
    patientId?: boolean
    bedId?: boolean
    admittedAt?: boolean
    dischargedAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounter?: boolean | Admission$encounterArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    bed?: boolean | Admission$bedArgs<ExtArgs>
  }
  export type AdmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    encounter?: boolean | Admission$encounterArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    bed?: boolean | Admission$bedArgs<ExtArgs>
  }

  export type $AdmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admission"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      encounter: Prisma.$EncounterPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs>
      bed: Prisma.$BedPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      encounterId: string | null
      patientId: string
      bedId: string | null
      admittedAt: Date
      dischargedAt: Date | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admission"]>
    composites: {}
  }

  type AdmissionGetPayload<S extends boolean | null | undefined | AdmissionDefaultArgs> = $Result.GetResult<Prisma.$AdmissionPayload, S>

  type AdmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdmissionCountAggregateInputType | true
    }

  export interface AdmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admission'], meta: { name: 'Admission' } }
    /**
     * Find zero or one Admission that matches the filter.
     * @param {AdmissionFindUniqueArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionFindUniqueArgs>(args: SelectSubset<T, AdmissionFindUniqueArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdmissionFindUniqueOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionFindFirstArgs>(args?: SelectSubset<T, AdmissionFindFirstArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admissions
     * const admissions = await prisma.admission.findMany()
     * 
     * // Get first 10 Admissions
     * const admissions = await prisma.admission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionWithIdOnly = await prisma.admission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionFindManyArgs>(args?: SelectSubset<T, AdmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admission.
     * @param {AdmissionCreateArgs} args - Arguments to create a Admission.
     * @example
     * // Create one Admission
     * const Admission = await prisma.admission.create({
     *   data: {
     *     // ... data to create a Admission
     *   }
     * })
     * 
     */
    create<T extends AdmissionCreateArgs>(args: SelectSubset<T, AdmissionCreateArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admissions.
     * @param {AdmissionCreateManyArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admission = await prisma.admission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionCreateManyArgs>(args?: SelectSubset<T, AdmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admissions and returns the data saved in the database.
     * @param {AdmissionCreateManyAndReturnArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admission = await prisma.admission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admissions and only return the `id`
     * const admissionWithIdOnly = await prisma.admission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admission.
     * @param {AdmissionDeleteArgs} args - Arguments to delete one Admission.
     * @example
     * // Delete one Admission
     * const Admission = await prisma.admission.delete({
     *   where: {
     *     // ... filter to delete one Admission
     *   }
     * })
     * 
     */
    delete<T extends AdmissionDeleteArgs>(args: SelectSubset<T, AdmissionDeleteArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admission.
     * @param {AdmissionUpdateArgs} args - Arguments to update one Admission.
     * @example
     * // Update one Admission
     * const admission = await prisma.admission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionUpdateArgs>(args: SelectSubset<T, AdmissionUpdateArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admissions.
     * @param {AdmissionDeleteManyArgs} args - Arguments to filter Admissions to delete.
     * @example
     * // Delete a few Admissions
     * const { count } = await prisma.admission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionDeleteManyArgs>(args?: SelectSubset<T, AdmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admissions
     * const admission = await prisma.admission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionUpdateManyArgs>(args: SelectSubset<T, AdmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admission.
     * @param {AdmissionUpsertArgs} args - Arguments to update or create a Admission.
     * @example
     * // Update or create a Admission
     * const admission = await prisma.admission.upsert({
     *   create: {
     *     // ... data to create a Admission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admission we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionUpsertArgs>(args: SelectSubset<T, AdmissionUpsertArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionCountArgs} args - Arguments to filter Admissions to count.
     * @example
     * // Count the number of Admissions
     * const count = await prisma.admission.count({
     *   where: {
     *     // ... the filter for the Admissions we want to count
     *   }
     * })
    **/
    count<T extends AdmissionCountArgs>(
      args?: Subset<T, AdmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionAggregateArgs>(args: Subset<T, AdmissionAggregateArgs>): Prisma.PrismaPromise<GetAdmissionAggregateType<T>>

    /**
     * Group by Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admission model
   */
  readonly fields: AdmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    encounter<T extends Admission$encounterArgs<ExtArgs> = {}>(args?: Subset<T, Admission$encounterArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bed<T extends Admission$bedArgs<ExtArgs> = {}>(args?: Subset<T, Admission$bedArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admission model
   */ 
  interface AdmissionFieldRefs {
    readonly id: FieldRef<"Admission", 'String'>
    readonly branchId: FieldRef<"Admission", 'String'>
    readonly encounterId: FieldRef<"Admission", 'String'>
    readonly patientId: FieldRef<"Admission", 'String'>
    readonly bedId: FieldRef<"Admission", 'String'>
    readonly admittedAt: FieldRef<"Admission", 'DateTime'>
    readonly dischargedAt: FieldRef<"Admission", 'DateTime'>
    readonly status: FieldRef<"Admission", 'String'>
    readonly createdAt: FieldRef<"Admission", 'DateTime'>
    readonly updatedAt: FieldRef<"Admission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admission findUnique
   */
  export type AdmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission findUniqueOrThrow
   */
  export type AdmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission findFirst
   */
  export type AdmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission findFirstOrThrow
   */
  export type AdmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission findMany
   */
  export type AdmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admissions to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission create
   */
  export type AdmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Admission.
     */
    data: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
  }

  /**
   * Admission createMany
   */
  export type AdmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admissions.
     */
    data: AdmissionCreateManyInput | AdmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admission createManyAndReturn
   */
  export type AdmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admissions.
     */
    data: AdmissionCreateManyInput | AdmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admission update
   */
  export type AdmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Admission.
     */
    data: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
    /**
     * Choose, which Admission to update.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission updateMany
   */
  export type AdmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admissions.
     */
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyInput>
    /**
     * Filter which Admissions to update
     */
    where?: AdmissionWhereInput
  }

  /**
   * Admission upsert
   */
  export type AdmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Admission to update in case it exists.
     */
    where: AdmissionWhereUniqueInput
    /**
     * In case the Admission found by the `where` argument doesn't exist, create a new Admission with this data.
     */
    create: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
    /**
     * In case the Admission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
  }

  /**
   * Admission delete
   */
  export type AdmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter which Admission to delete.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission deleteMany
   */
  export type AdmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admissions to delete
     */
    where?: AdmissionWhereInput
  }

  /**
   * Admission.encounter
   */
  export type Admission$encounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
  }

  /**
   * Admission.bed
   */
  export type Admission$bedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    where?: BedWhereInput
  }

  /**
   * Admission without action
   */
  export type AdmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
  }


  /**
   * Model OT
   */

  export type AggregateOT = {
    _count: OTCountAggregateOutputType | null
    _min: OTMinAggregateOutputType | null
    _max: OTMaxAggregateOutputType | null
  }

  export type OTMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OTMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OTCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OTMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OTMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OTCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OT to aggregate.
     */
    where?: OTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTS to fetch.
     */
    orderBy?: OTOrderByWithRelationInput | OTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OTS
    **/
    _count?: true | OTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OTMaxAggregateInputType
  }

  export type GetOTAggregateType<T extends OTAggregateArgs> = {
        [P in keyof T & keyof AggregateOT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOT[P]>
      : GetScalarType<T[P], AggregateOT[P]>
  }




  export type OTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OTWhereInput
    orderBy?: OTOrderByWithAggregationInput | OTOrderByWithAggregationInput[]
    by: OTScalarFieldEnum[] | OTScalarFieldEnum
    having?: OTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OTCountAggregateInputType | true
    _min?: OTMinAggregateInputType
    _max?: OTMaxAggregateInputType
  }

  export type OTGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: OTCountAggregateOutputType | null
    _min: OTMinAggregateOutputType | null
    _max: OTMaxAggregateOutputType | null
  }

  type GetOTGroupByPayload<T extends OTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OTGroupByOutputType[P]>
            : GetScalarType<T[P], OTGroupByOutputType[P]>
        }
      >
    >


  export type OTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oT"]>

  export type OTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oT"]>

  export type OTSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type OTIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $OTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OT"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["oT"]>
    composites: {}
  }

  type OTGetPayload<S extends boolean | null | undefined | OTDefaultArgs> = $Result.GetResult<Prisma.$OTPayload, S>

  type OTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OTFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OTCountAggregateInputType | true
    }

  export interface OTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OT'], meta: { name: 'OT' } }
    /**
     * Find zero or one OT that matches the filter.
     * @param {OTFindUniqueArgs} args - Arguments to find a OT
     * @example
     * // Get one OT
     * const oT = await prisma.oT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OTFindUniqueArgs>(args: SelectSubset<T, OTFindUniqueArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OT that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OTFindUniqueOrThrowArgs} args - Arguments to find a OT
     * @example
     * // Get one OT
     * const oT = await prisma.oT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OTFindUniqueOrThrowArgs>(args: SelectSubset<T, OTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTFindFirstArgs} args - Arguments to find a OT
     * @example
     * // Get one OT
     * const oT = await prisma.oT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OTFindFirstArgs>(args?: SelectSubset<T, OTFindFirstArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTFindFirstOrThrowArgs} args - Arguments to find a OT
     * @example
     * // Get one OT
     * const oT = await prisma.oT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OTFindFirstOrThrowArgs>(args?: SelectSubset<T, OTFindFirstOrThrowArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OTS
     * const oTS = await prisma.oT.findMany()
     * 
     * // Get first 10 OTS
     * const oTS = await prisma.oT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oTWithIdOnly = await prisma.oT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OTFindManyArgs>(args?: SelectSubset<T, OTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OT.
     * @param {OTCreateArgs} args - Arguments to create a OT.
     * @example
     * // Create one OT
     * const OT = await prisma.oT.create({
     *   data: {
     *     // ... data to create a OT
     *   }
     * })
     * 
     */
    create<T extends OTCreateArgs>(args: SelectSubset<T, OTCreateArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OTS.
     * @param {OTCreateManyArgs} args - Arguments to create many OTS.
     * @example
     * // Create many OTS
     * const oT = await prisma.oT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OTCreateManyArgs>(args?: SelectSubset<T, OTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OTS and returns the data saved in the database.
     * @param {OTCreateManyAndReturnArgs} args - Arguments to create many OTS.
     * @example
     * // Create many OTS
     * const oT = await prisma.oT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OTS and only return the `id`
     * const oTWithIdOnly = await prisma.oT.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OTCreateManyAndReturnArgs>(args?: SelectSubset<T, OTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OT.
     * @param {OTDeleteArgs} args - Arguments to delete one OT.
     * @example
     * // Delete one OT
     * const OT = await prisma.oT.delete({
     *   where: {
     *     // ... filter to delete one OT
     *   }
     * })
     * 
     */
    delete<T extends OTDeleteArgs>(args: SelectSubset<T, OTDeleteArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OT.
     * @param {OTUpdateArgs} args - Arguments to update one OT.
     * @example
     * // Update one OT
     * const oT = await prisma.oT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OTUpdateArgs>(args: SelectSubset<T, OTUpdateArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OTS.
     * @param {OTDeleteManyArgs} args - Arguments to filter OTS to delete.
     * @example
     * // Delete a few OTS
     * const { count } = await prisma.oT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OTDeleteManyArgs>(args?: SelectSubset<T, OTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OTS
     * const oT = await prisma.oT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OTUpdateManyArgs>(args: SelectSubset<T, OTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OT.
     * @param {OTUpsertArgs} args - Arguments to update or create a OT.
     * @example
     * // Update or create a OT
     * const oT = await prisma.oT.upsert({
     *   create: {
     *     // ... data to create a OT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OT we want to update
     *   }
     * })
     */
    upsert<T extends OTUpsertArgs>(args: SelectSubset<T, OTUpsertArgs<ExtArgs>>): Prisma__OTClient<$Result.GetResult<Prisma.$OTPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTCountArgs} args - Arguments to filter OTS to count.
     * @example
     * // Count the number of OTS
     * const count = await prisma.oT.count({
     *   where: {
     *     // ... the filter for the OTS we want to count
     *   }
     * })
    **/
    count<T extends OTCountArgs>(
      args?: Subset<T, OTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OTAggregateArgs>(args: Subset<T, OTAggregateArgs>): Prisma.PrismaPromise<GetOTAggregateType<T>>

    /**
     * Group by OT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OTGroupByArgs['orderBy'] }
        : { orderBy?: OTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OT model
   */
  readonly fields: OTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OT model
   */ 
  interface OTFieldRefs {
    readonly id: FieldRef<"OT", 'String'>
    readonly branchId: FieldRef<"OT", 'String'>
    readonly code: FieldRef<"OT", 'String'>
    readonly name: FieldRef<"OT", 'String'>
    readonly isActive: FieldRef<"OT", 'Boolean'>
    readonly createdAt: FieldRef<"OT", 'DateTime'>
    readonly updatedAt: FieldRef<"OT", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OT findUnique
   */
  export type OTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter, which OT to fetch.
     */
    where: OTWhereUniqueInput
  }

  /**
   * OT findUniqueOrThrow
   */
  export type OTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter, which OT to fetch.
     */
    where: OTWhereUniqueInput
  }

  /**
   * OT findFirst
   */
  export type OTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter, which OT to fetch.
     */
    where?: OTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTS to fetch.
     */
    orderBy?: OTOrderByWithRelationInput | OTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTS.
     */
    cursor?: OTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTS.
     */
    distinct?: OTScalarFieldEnum | OTScalarFieldEnum[]
  }

  /**
   * OT findFirstOrThrow
   */
  export type OTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter, which OT to fetch.
     */
    where?: OTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTS to fetch.
     */
    orderBy?: OTOrderByWithRelationInput | OTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OTS.
     */
    cursor?: OTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OTS.
     */
    distinct?: OTScalarFieldEnum | OTScalarFieldEnum[]
  }

  /**
   * OT findMany
   */
  export type OTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter, which OTS to fetch.
     */
    where?: OTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OTS to fetch.
     */
    orderBy?: OTOrderByWithRelationInput | OTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OTS.
     */
    cursor?: OTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OTS.
     */
    skip?: number
    distinct?: OTScalarFieldEnum | OTScalarFieldEnum[]
  }

  /**
   * OT create
   */
  export type OTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * The data needed to create a OT.
     */
    data: XOR<OTCreateInput, OTUncheckedCreateInput>
  }

  /**
   * OT createMany
   */
  export type OTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OTS.
     */
    data: OTCreateManyInput | OTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OT createManyAndReturn
   */
  export type OTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OTS.
     */
    data: OTCreateManyInput | OTCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OT update
   */
  export type OTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * The data needed to update a OT.
     */
    data: XOR<OTUpdateInput, OTUncheckedUpdateInput>
    /**
     * Choose, which OT to update.
     */
    where: OTWhereUniqueInput
  }

  /**
   * OT updateMany
   */
  export type OTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OTS.
     */
    data: XOR<OTUpdateManyMutationInput, OTUncheckedUpdateManyInput>
    /**
     * Filter which OTS to update
     */
    where?: OTWhereInput
  }

  /**
   * OT upsert
   */
  export type OTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * The filter to search for the OT to update in case it exists.
     */
    where: OTWhereUniqueInput
    /**
     * In case the OT found by the `where` argument doesn't exist, create a new OT with this data.
     */
    create: XOR<OTCreateInput, OTUncheckedCreateInput>
    /**
     * In case the OT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OTUpdateInput, OTUncheckedUpdateInput>
  }

  /**
   * OT delete
   */
  export type OTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
    /**
     * Filter which OT to delete.
     */
    where: OTWhereUniqueInput
  }

  /**
   * OT deleteMany
   */
  export type OTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OTS to delete
     */
    where?: OTWhereInput
  }

  /**
   * OT without action
   */
  export type OTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OT
     */
    select?: OTSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OTInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    category: string | null
    location: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    category: string | null
    location: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    category: number
    location: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssetMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    category?: true
    location?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    category: string
    location: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AssetCountAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    location?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }
  export type AssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      category: string
      location: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */ 
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly branchId: FieldRef<"Asset", 'String'>
    readonly code: FieldRef<"Asset", 'String'>
    readonly name: FieldRef<"Asset", 'String'>
    readonly category: FieldRef<"Asset", 'String'>
    readonly location: FieldRef<"Asset", 'String'>
    readonly status: FieldRef<"Asset", 'String'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly updatedAt: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model TariffPlan
   */

  export type AggregateTariffPlan = {
    _count: TariffPlanCountAggregateOutputType | null
    _min: TariffPlanMinAggregateOutputType | null
    _max: TariffPlanMaxAggregateOutputType | null
  }

  export type TariffPlanMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    status: string | null
    payerType: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffPlanMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    code: string | null
    name: string | null
    status: string | null
    payerType: string | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffPlanCountAggregateOutputType = {
    id: number
    branchId: number
    code: number
    name: number
    status: number
    payerType: number
    effectiveFrom: number
    effectiveTo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TariffPlanMinAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    status?: true
    payerType?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffPlanMaxAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    status?: true
    payerType?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffPlanCountAggregateInputType = {
    id?: true
    branchId?: true
    code?: true
    name?: true
    status?: true
    payerType?: true
    effectiveFrom?: true
    effectiveTo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TariffPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffPlan to aggregate.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TariffPlans
    **/
    _count?: true | TariffPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TariffPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TariffPlanMaxAggregateInputType
  }

  export type GetTariffPlanAggregateType<T extends TariffPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateTariffPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTariffPlan[P]>
      : GetScalarType<T[P], AggregateTariffPlan[P]>
  }




  export type TariffPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffPlanWhereInput
    orderBy?: TariffPlanOrderByWithAggregationInput | TariffPlanOrderByWithAggregationInput[]
    by: TariffPlanScalarFieldEnum[] | TariffPlanScalarFieldEnum
    having?: TariffPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TariffPlanCountAggregateInputType | true
    _min?: TariffPlanMinAggregateInputType
    _max?: TariffPlanMaxAggregateInputType
  }

  export type TariffPlanGroupByOutputType = {
    id: string
    branchId: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date
    effectiveTo: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TariffPlanCountAggregateOutputType | null
    _min: TariffPlanMinAggregateOutputType | null
    _max: TariffPlanMaxAggregateOutputType | null
  }

  type GetTariffPlanGroupByPayload<T extends TariffPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TariffPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TariffPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TariffPlanGroupByOutputType[P]>
            : GetScalarType<T[P], TariffPlanGroupByOutputType[P]>
        }
      >
    >


  export type TariffPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    payerType?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    rates?: boolean | TariffPlan$ratesArgs<ExtArgs>
    _count?: boolean | TariffPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffPlan"]>

  export type TariffPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    payerType?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffPlan"]>

  export type TariffPlanSelectScalar = {
    id?: boolean
    branchId?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    payerType?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TariffPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    rates?: boolean | TariffPlan$ratesArgs<ExtArgs>
    _count?: boolean | TariffPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TariffPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
  }

  export type $TariffPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TariffPlan"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      rates: Prisma.$TariffRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      code: string
      name: string
      status: string
      payerType: string
      effectiveFrom: Date
      effectiveTo: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tariffPlan"]>
    composites: {}
  }

  type TariffPlanGetPayload<S extends boolean | null | undefined | TariffPlanDefaultArgs> = $Result.GetResult<Prisma.$TariffPlanPayload, S>

  type TariffPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TariffPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TariffPlanCountAggregateInputType | true
    }

  export interface TariffPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TariffPlan'], meta: { name: 'TariffPlan' } }
    /**
     * Find zero or one TariffPlan that matches the filter.
     * @param {TariffPlanFindUniqueArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TariffPlanFindUniqueArgs>(args: SelectSubset<T, TariffPlanFindUniqueArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TariffPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TariffPlanFindUniqueOrThrowArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TariffPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, TariffPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TariffPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanFindFirstArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TariffPlanFindFirstArgs>(args?: SelectSubset<T, TariffPlanFindFirstArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TariffPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanFindFirstOrThrowArgs} args - Arguments to find a TariffPlan
     * @example
     * // Get one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TariffPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, TariffPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TariffPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TariffPlans
     * const tariffPlans = await prisma.tariffPlan.findMany()
     * 
     * // Get first 10 TariffPlans
     * const tariffPlans = await prisma.tariffPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tariffPlanWithIdOnly = await prisma.tariffPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TariffPlanFindManyArgs>(args?: SelectSubset<T, TariffPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TariffPlan.
     * @param {TariffPlanCreateArgs} args - Arguments to create a TariffPlan.
     * @example
     * // Create one TariffPlan
     * const TariffPlan = await prisma.tariffPlan.create({
     *   data: {
     *     // ... data to create a TariffPlan
     *   }
     * })
     * 
     */
    create<T extends TariffPlanCreateArgs>(args: SelectSubset<T, TariffPlanCreateArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TariffPlans.
     * @param {TariffPlanCreateManyArgs} args - Arguments to create many TariffPlans.
     * @example
     * // Create many TariffPlans
     * const tariffPlan = await prisma.tariffPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TariffPlanCreateManyArgs>(args?: SelectSubset<T, TariffPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TariffPlans and returns the data saved in the database.
     * @param {TariffPlanCreateManyAndReturnArgs} args - Arguments to create many TariffPlans.
     * @example
     * // Create many TariffPlans
     * const tariffPlan = await prisma.tariffPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TariffPlans and only return the `id`
     * const tariffPlanWithIdOnly = await prisma.tariffPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TariffPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, TariffPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TariffPlan.
     * @param {TariffPlanDeleteArgs} args - Arguments to delete one TariffPlan.
     * @example
     * // Delete one TariffPlan
     * const TariffPlan = await prisma.tariffPlan.delete({
     *   where: {
     *     // ... filter to delete one TariffPlan
     *   }
     * })
     * 
     */
    delete<T extends TariffPlanDeleteArgs>(args: SelectSubset<T, TariffPlanDeleteArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TariffPlan.
     * @param {TariffPlanUpdateArgs} args - Arguments to update one TariffPlan.
     * @example
     * // Update one TariffPlan
     * const tariffPlan = await prisma.tariffPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TariffPlanUpdateArgs>(args: SelectSubset<T, TariffPlanUpdateArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TariffPlans.
     * @param {TariffPlanDeleteManyArgs} args - Arguments to filter TariffPlans to delete.
     * @example
     * // Delete a few TariffPlans
     * const { count } = await prisma.tariffPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TariffPlanDeleteManyArgs>(args?: SelectSubset<T, TariffPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TariffPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TariffPlans
     * const tariffPlan = await prisma.tariffPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TariffPlanUpdateManyArgs>(args: SelectSubset<T, TariffPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TariffPlan.
     * @param {TariffPlanUpsertArgs} args - Arguments to update or create a TariffPlan.
     * @example
     * // Update or create a TariffPlan
     * const tariffPlan = await prisma.tariffPlan.upsert({
     *   create: {
     *     // ... data to create a TariffPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TariffPlan we want to update
     *   }
     * })
     */
    upsert<T extends TariffPlanUpsertArgs>(args: SelectSubset<T, TariffPlanUpsertArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TariffPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanCountArgs} args - Arguments to filter TariffPlans to count.
     * @example
     * // Count the number of TariffPlans
     * const count = await prisma.tariffPlan.count({
     *   where: {
     *     // ... the filter for the TariffPlans we want to count
     *   }
     * })
    **/
    count<T extends TariffPlanCountArgs>(
      args?: Subset<T, TariffPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TariffPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TariffPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TariffPlanAggregateArgs>(args: Subset<T, TariffPlanAggregateArgs>): Prisma.PrismaPromise<GetTariffPlanAggregateType<T>>

    /**
     * Group by TariffPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TariffPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TariffPlanGroupByArgs['orderBy'] }
        : { orderBy?: TariffPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TariffPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTariffPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TariffPlan model
   */
  readonly fields: TariffPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TariffPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TariffPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rates<T extends TariffPlan$ratesArgs<ExtArgs> = {}>(args?: Subset<T, TariffPlan$ratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TariffPlan model
   */ 
  interface TariffPlanFieldRefs {
    readonly id: FieldRef<"TariffPlan", 'String'>
    readonly branchId: FieldRef<"TariffPlan", 'String'>
    readonly code: FieldRef<"TariffPlan", 'String'>
    readonly name: FieldRef<"TariffPlan", 'String'>
    readonly status: FieldRef<"TariffPlan", 'String'>
    readonly payerType: FieldRef<"TariffPlan", 'String'>
    readonly effectiveFrom: FieldRef<"TariffPlan", 'DateTime'>
    readonly effectiveTo: FieldRef<"TariffPlan", 'DateTime'>
    readonly createdAt: FieldRef<"TariffPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"TariffPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TariffPlan findUnique
   */
  export type TariffPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan findUniqueOrThrow
   */
  export type TariffPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan findFirst
   */
  export type TariffPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffPlans.
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffPlans.
     */
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * TariffPlan findFirstOrThrow
   */
  export type TariffPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlan to fetch.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffPlans.
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffPlans.
     */
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * TariffPlan findMany
   */
  export type TariffPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter, which TariffPlans to fetch.
     */
    where?: TariffPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffPlans to fetch.
     */
    orderBy?: TariffPlanOrderByWithRelationInput | TariffPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TariffPlans.
     */
    cursor?: TariffPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffPlans.
     */
    skip?: number
    distinct?: TariffPlanScalarFieldEnum | TariffPlanScalarFieldEnum[]
  }

  /**
   * TariffPlan create
   */
  export type TariffPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a TariffPlan.
     */
    data: XOR<TariffPlanCreateInput, TariffPlanUncheckedCreateInput>
  }

  /**
   * TariffPlan createMany
   */
  export type TariffPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TariffPlans.
     */
    data: TariffPlanCreateManyInput | TariffPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TariffPlan createManyAndReturn
   */
  export type TariffPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TariffPlans.
     */
    data: TariffPlanCreateManyInput | TariffPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TariffPlan update
   */
  export type TariffPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a TariffPlan.
     */
    data: XOR<TariffPlanUpdateInput, TariffPlanUncheckedUpdateInput>
    /**
     * Choose, which TariffPlan to update.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan updateMany
   */
  export type TariffPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TariffPlans.
     */
    data: XOR<TariffPlanUpdateManyMutationInput, TariffPlanUncheckedUpdateManyInput>
    /**
     * Filter which TariffPlans to update
     */
    where?: TariffPlanWhereInput
  }

  /**
   * TariffPlan upsert
   */
  export type TariffPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the TariffPlan to update in case it exists.
     */
    where: TariffPlanWhereUniqueInput
    /**
     * In case the TariffPlan found by the `where` argument doesn't exist, create a new TariffPlan with this data.
     */
    create: XOR<TariffPlanCreateInput, TariffPlanUncheckedCreateInput>
    /**
     * In case the TariffPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TariffPlanUpdateInput, TariffPlanUncheckedUpdateInput>
  }

  /**
   * TariffPlan delete
   */
  export type TariffPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
    /**
     * Filter which TariffPlan to delete.
     */
    where: TariffPlanWhereUniqueInput
  }

  /**
   * TariffPlan deleteMany
   */
  export type TariffPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffPlans to delete
     */
    where?: TariffPlanWhereInput
  }

  /**
   * TariffPlan.rates
   */
  export type TariffPlan$ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    where?: TariffRateWhereInput
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    cursor?: TariffRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffPlan without action
   */
  export type TariffPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffPlan
     */
    select?: TariffPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffPlanInclude<ExtArgs> | null
  }


  /**
   * Model ServiceCatalogItem
   */

  export type AggregateServiceCatalogItem = {
    _count: ServiceCatalogItemCountAggregateOutputType | null
    _min: ServiceCatalogItemMinAggregateOutputType | null
    _max: ServiceCatalogItemMaxAggregateOutputType | null
  }

  export type ServiceCatalogItemMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: string | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCatalogItemMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: string | null
    unit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCatalogItemCountAggregateOutputType = {
    id: number
    code: number
    name: number
    category: number
    unit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceCatalogItemMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCatalogItemMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCatalogItemCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceCatalogItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCatalogItem to aggregate.
     */
    where?: ServiceCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCatalogItems to fetch.
     */
    orderBy?: ServiceCatalogItemOrderByWithRelationInput | ServiceCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceCatalogItems
    **/
    _count?: true | ServiceCatalogItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceCatalogItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceCatalogItemMaxAggregateInputType
  }

  export type GetServiceCatalogItemAggregateType<T extends ServiceCatalogItemAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceCatalogItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceCatalogItem[P]>
      : GetScalarType<T[P], AggregateServiceCatalogItem[P]>
  }




  export type ServiceCatalogItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceCatalogItemWhereInput
    orderBy?: ServiceCatalogItemOrderByWithAggregationInput | ServiceCatalogItemOrderByWithAggregationInput[]
    by: ServiceCatalogItemScalarFieldEnum[] | ServiceCatalogItemScalarFieldEnum
    having?: ServiceCatalogItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCatalogItemCountAggregateInputType | true
    _min?: ServiceCatalogItemMinAggregateInputType
    _max?: ServiceCatalogItemMaxAggregateInputType
  }

  export type ServiceCatalogItemGroupByOutputType = {
    id: string
    code: string
    name: string
    category: string
    unit: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceCatalogItemCountAggregateOutputType | null
    _min: ServiceCatalogItemMinAggregateOutputType | null
    _max: ServiceCatalogItemMaxAggregateOutputType | null
  }

  type GetServiceCatalogItemGroupByPayload<T extends ServiceCatalogItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceCatalogItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceCatalogItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceCatalogItemGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceCatalogItemGroupByOutputType[P]>
        }
      >
    >


  export type ServiceCatalogItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCatalogItem"]>

  export type ServiceCatalogItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceCatalogItem"]>

  export type ServiceCatalogItemSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ServiceCatalogItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceCatalogItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      category: string
      unit: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceCatalogItem"]>
    composites: {}
  }

  type ServiceCatalogItemGetPayload<S extends boolean | null | undefined | ServiceCatalogItemDefaultArgs> = $Result.GetResult<Prisma.$ServiceCatalogItemPayload, S>

  type ServiceCatalogItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceCatalogItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceCatalogItemCountAggregateInputType | true
    }

  export interface ServiceCatalogItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceCatalogItem'], meta: { name: 'ServiceCatalogItem' } }
    /**
     * Find zero or one ServiceCatalogItem that matches the filter.
     * @param {ServiceCatalogItemFindUniqueArgs} args - Arguments to find a ServiceCatalogItem
     * @example
     * // Get one ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceCatalogItemFindUniqueArgs>(args: SelectSubset<T, ServiceCatalogItemFindUniqueArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceCatalogItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceCatalogItemFindUniqueOrThrowArgs} args - Arguments to find a ServiceCatalogItem
     * @example
     * // Get one ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceCatalogItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceCatalogItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceCatalogItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemFindFirstArgs} args - Arguments to find a ServiceCatalogItem
     * @example
     * // Get one ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceCatalogItemFindFirstArgs>(args?: SelectSubset<T, ServiceCatalogItemFindFirstArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceCatalogItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemFindFirstOrThrowArgs} args - Arguments to find a ServiceCatalogItem
     * @example
     * // Get one ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceCatalogItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceCatalogItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceCatalogItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceCatalogItems
     * const serviceCatalogItems = await prisma.serviceCatalogItem.findMany()
     * 
     * // Get first 10 ServiceCatalogItems
     * const serviceCatalogItems = await prisma.serviceCatalogItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceCatalogItemWithIdOnly = await prisma.serviceCatalogItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceCatalogItemFindManyArgs>(args?: SelectSubset<T, ServiceCatalogItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceCatalogItem.
     * @param {ServiceCatalogItemCreateArgs} args - Arguments to create a ServiceCatalogItem.
     * @example
     * // Create one ServiceCatalogItem
     * const ServiceCatalogItem = await prisma.serviceCatalogItem.create({
     *   data: {
     *     // ... data to create a ServiceCatalogItem
     *   }
     * })
     * 
     */
    create<T extends ServiceCatalogItemCreateArgs>(args: SelectSubset<T, ServiceCatalogItemCreateArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceCatalogItems.
     * @param {ServiceCatalogItemCreateManyArgs} args - Arguments to create many ServiceCatalogItems.
     * @example
     * // Create many ServiceCatalogItems
     * const serviceCatalogItem = await prisma.serviceCatalogItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCatalogItemCreateManyArgs>(args?: SelectSubset<T, ServiceCatalogItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceCatalogItems and returns the data saved in the database.
     * @param {ServiceCatalogItemCreateManyAndReturnArgs} args - Arguments to create many ServiceCatalogItems.
     * @example
     * // Create many ServiceCatalogItems
     * const serviceCatalogItem = await prisma.serviceCatalogItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceCatalogItems and only return the `id`
     * const serviceCatalogItemWithIdOnly = await prisma.serviceCatalogItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCatalogItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCatalogItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceCatalogItem.
     * @param {ServiceCatalogItemDeleteArgs} args - Arguments to delete one ServiceCatalogItem.
     * @example
     * // Delete one ServiceCatalogItem
     * const ServiceCatalogItem = await prisma.serviceCatalogItem.delete({
     *   where: {
     *     // ... filter to delete one ServiceCatalogItem
     *   }
     * })
     * 
     */
    delete<T extends ServiceCatalogItemDeleteArgs>(args: SelectSubset<T, ServiceCatalogItemDeleteArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceCatalogItem.
     * @param {ServiceCatalogItemUpdateArgs} args - Arguments to update one ServiceCatalogItem.
     * @example
     * // Update one ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceCatalogItemUpdateArgs>(args: SelectSubset<T, ServiceCatalogItemUpdateArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceCatalogItems.
     * @param {ServiceCatalogItemDeleteManyArgs} args - Arguments to filter ServiceCatalogItems to delete.
     * @example
     * // Delete a few ServiceCatalogItems
     * const { count } = await prisma.serviceCatalogItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceCatalogItemDeleteManyArgs>(args?: SelectSubset<T, ServiceCatalogItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceCatalogItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceCatalogItems
     * const serviceCatalogItem = await prisma.serviceCatalogItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceCatalogItemUpdateManyArgs>(args: SelectSubset<T, ServiceCatalogItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceCatalogItem.
     * @param {ServiceCatalogItemUpsertArgs} args - Arguments to update or create a ServiceCatalogItem.
     * @example
     * // Update or create a ServiceCatalogItem
     * const serviceCatalogItem = await prisma.serviceCatalogItem.upsert({
     *   create: {
     *     // ... data to create a ServiceCatalogItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceCatalogItem we want to update
     *   }
     * })
     */
    upsert<T extends ServiceCatalogItemUpsertArgs>(args: SelectSubset<T, ServiceCatalogItemUpsertArgs<ExtArgs>>): Prisma__ServiceCatalogItemClient<$Result.GetResult<Prisma.$ServiceCatalogItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceCatalogItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemCountArgs} args - Arguments to filter ServiceCatalogItems to count.
     * @example
     * // Count the number of ServiceCatalogItems
     * const count = await prisma.serviceCatalogItem.count({
     *   where: {
     *     // ... the filter for the ServiceCatalogItems we want to count
     *   }
     * })
    **/
    count<T extends ServiceCatalogItemCountArgs>(
      args?: Subset<T, ServiceCatalogItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCatalogItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceCatalogItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceCatalogItemAggregateArgs>(args: Subset<T, ServiceCatalogItemAggregateArgs>): Prisma.PrismaPromise<GetServiceCatalogItemAggregateType<T>>

    /**
     * Group by ServiceCatalogItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCatalogItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceCatalogItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceCatalogItemGroupByArgs['orderBy'] }
        : { orderBy?: ServiceCatalogItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceCatalogItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceCatalogItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceCatalogItem model
   */
  readonly fields: ServiceCatalogItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceCatalogItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceCatalogItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceCatalogItem model
   */ 
  interface ServiceCatalogItemFieldRefs {
    readonly id: FieldRef<"ServiceCatalogItem", 'String'>
    readonly code: FieldRef<"ServiceCatalogItem", 'String'>
    readonly name: FieldRef<"ServiceCatalogItem", 'String'>
    readonly category: FieldRef<"ServiceCatalogItem", 'String'>
    readonly unit: FieldRef<"ServiceCatalogItem", 'String'>
    readonly createdAt: FieldRef<"ServiceCatalogItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceCatalogItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceCatalogItem findUnique
   */
  export type ServiceCatalogItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter, which ServiceCatalogItem to fetch.
     */
    where: ServiceCatalogItemWhereUniqueInput
  }

  /**
   * ServiceCatalogItem findUniqueOrThrow
   */
  export type ServiceCatalogItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter, which ServiceCatalogItem to fetch.
     */
    where: ServiceCatalogItemWhereUniqueInput
  }

  /**
   * ServiceCatalogItem findFirst
   */
  export type ServiceCatalogItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter, which ServiceCatalogItem to fetch.
     */
    where?: ServiceCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCatalogItems to fetch.
     */
    orderBy?: ServiceCatalogItemOrderByWithRelationInput | ServiceCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCatalogItems.
     */
    cursor?: ServiceCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCatalogItems.
     */
    distinct?: ServiceCatalogItemScalarFieldEnum | ServiceCatalogItemScalarFieldEnum[]
  }

  /**
   * ServiceCatalogItem findFirstOrThrow
   */
  export type ServiceCatalogItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter, which ServiceCatalogItem to fetch.
     */
    where?: ServiceCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCatalogItems to fetch.
     */
    orderBy?: ServiceCatalogItemOrderByWithRelationInput | ServiceCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceCatalogItems.
     */
    cursor?: ServiceCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCatalogItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceCatalogItems.
     */
    distinct?: ServiceCatalogItemScalarFieldEnum | ServiceCatalogItemScalarFieldEnum[]
  }

  /**
   * ServiceCatalogItem findMany
   */
  export type ServiceCatalogItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter, which ServiceCatalogItems to fetch.
     */
    where?: ServiceCatalogItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceCatalogItems to fetch.
     */
    orderBy?: ServiceCatalogItemOrderByWithRelationInput | ServiceCatalogItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceCatalogItems.
     */
    cursor?: ServiceCatalogItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceCatalogItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceCatalogItems.
     */
    skip?: number
    distinct?: ServiceCatalogItemScalarFieldEnum | ServiceCatalogItemScalarFieldEnum[]
  }

  /**
   * ServiceCatalogItem create
   */
  export type ServiceCatalogItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * The data needed to create a ServiceCatalogItem.
     */
    data: XOR<ServiceCatalogItemCreateInput, ServiceCatalogItemUncheckedCreateInput>
  }

  /**
   * ServiceCatalogItem createMany
   */
  export type ServiceCatalogItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceCatalogItems.
     */
    data: ServiceCatalogItemCreateManyInput | ServiceCatalogItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCatalogItem createManyAndReturn
   */
  export type ServiceCatalogItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceCatalogItems.
     */
    data: ServiceCatalogItemCreateManyInput | ServiceCatalogItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceCatalogItem update
   */
  export type ServiceCatalogItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * The data needed to update a ServiceCatalogItem.
     */
    data: XOR<ServiceCatalogItemUpdateInput, ServiceCatalogItemUncheckedUpdateInput>
    /**
     * Choose, which ServiceCatalogItem to update.
     */
    where: ServiceCatalogItemWhereUniqueInput
  }

  /**
   * ServiceCatalogItem updateMany
   */
  export type ServiceCatalogItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceCatalogItems.
     */
    data: XOR<ServiceCatalogItemUpdateManyMutationInput, ServiceCatalogItemUncheckedUpdateManyInput>
    /**
     * Filter which ServiceCatalogItems to update
     */
    where?: ServiceCatalogItemWhereInput
  }

  /**
   * ServiceCatalogItem upsert
   */
  export type ServiceCatalogItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * The filter to search for the ServiceCatalogItem to update in case it exists.
     */
    where: ServiceCatalogItemWhereUniqueInput
    /**
     * In case the ServiceCatalogItem found by the `where` argument doesn't exist, create a new ServiceCatalogItem with this data.
     */
    create: XOR<ServiceCatalogItemCreateInput, ServiceCatalogItemUncheckedCreateInput>
    /**
     * In case the ServiceCatalogItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceCatalogItemUpdateInput, ServiceCatalogItemUncheckedUpdateInput>
  }

  /**
   * ServiceCatalogItem delete
   */
  export type ServiceCatalogItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
    /**
     * Filter which ServiceCatalogItem to delete.
     */
    where: ServiceCatalogItemWhereUniqueInput
  }

  /**
   * ServiceCatalogItem deleteMany
   */
  export type ServiceCatalogItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceCatalogItems to delete
     */
    where?: ServiceCatalogItemWhereInput
  }

  /**
   * ServiceCatalogItem without action
   */
  export type ServiceCatalogItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCatalogItem
     */
    select?: ServiceCatalogItemSelect<ExtArgs> | null
  }


  /**
   * Model TariffRate
   */

  export type AggregateTariffRate = {
    _count: TariffRateCountAggregateOutputType | null
    _avg: TariffRateAvgAggregateOutputType | null
    _sum: TariffRateSumAggregateOutputType | null
    _min: TariffRateMinAggregateOutputType | null
    _max: TariffRateMaxAggregateOutputType | null
  }

  export type TariffRateAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TariffRateSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TariffRateMinAggregateOutputType = {
    id: string | null
    tariffPlanId: string | null
    serviceCode: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffRateMaxAggregateOutputType = {
    id: string | null
    tariffPlanId: string | null
    serviceCode: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffRateCountAggregateOutputType = {
    id: number
    tariffPlanId: number
    serviceCode: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TariffRateAvgAggregateInputType = {
    amount?: true
  }

  export type TariffRateSumAggregateInputType = {
    amount?: true
  }

  export type TariffRateMinAggregateInputType = {
    id?: true
    tariffPlanId?: true
    serviceCode?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffRateMaxAggregateInputType = {
    id?: true
    tariffPlanId?: true
    serviceCode?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffRateCountAggregateInputType = {
    id?: true
    tariffPlanId?: true
    serviceCode?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TariffRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffRate to aggregate.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TariffRates
    **/
    _count?: true | TariffRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TariffRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TariffRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TariffRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TariffRateMaxAggregateInputType
  }

  export type GetTariffRateAggregateType<T extends TariffRateAggregateArgs> = {
        [P in keyof T & keyof AggregateTariffRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTariffRate[P]>
      : GetScalarType<T[P], AggregateTariffRate[P]>
  }




  export type TariffRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffRateWhereInput
    orderBy?: TariffRateOrderByWithAggregationInput | TariffRateOrderByWithAggregationInput[]
    by: TariffRateScalarFieldEnum[] | TariffRateScalarFieldEnum
    having?: TariffRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TariffRateCountAggregateInputType | true
    _avg?: TariffRateAvgAggregateInputType
    _sum?: TariffRateSumAggregateInputType
    _min?: TariffRateMinAggregateInputType
    _max?: TariffRateMaxAggregateInputType
  }

  export type TariffRateGroupByOutputType = {
    id: string
    tariffPlanId: string
    serviceCode: string
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: TariffRateCountAggregateOutputType | null
    _avg: TariffRateAvgAggregateOutputType | null
    _sum: TariffRateSumAggregateOutputType | null
    _min: TariffRateMinAggregateOutputType | null
    _max: TariffRateMaxAggregateOutputType | null
  }

  type GetTariffRateGroupByPayload<T extends TariffRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TariffRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TariffRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TariffRateGroupByOutputType[P]>
            : GetScalarType<T[P], TariffRateGroupByOutputType[P]>
        }
      >
    >


  export type TariffRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tariffPlanId?: boolean
    serviceCode?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffRate"]>

  export type TariffRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tariffPlanId?: boolean
    serviceCode?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariffRate"]>

  export type TariffRateSelectScalar = {
    id?: boolean
    tariffPlanId?: boolean
    serviceCode?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TariffRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }
  export type TariffRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tariffPlan?: boolean | TariffPlanDefaultArgs<ExtArgs>
  }

  export type $TariffRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TariffRate"
    objects: {
      tariffPlan: Prisma.$TariffPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tariffPlanId: string
      serviceCode: string
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tariffRate"]>
    composites: {}
  }

  type TariffRateGetPayload<S extends boolean | null | undefined | TariffRateDefaultArgs> = $Result.GetResult<Prisma.$TariffRatePayload, S>

  type TariffRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TariffRateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TariffRateCountAggregateInputType | true
    }

  export interface TariffRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TariffRate'], meta: { name: 'TariffRate' } }
    /**
     * Find zero or one TariffRate that matches the filter.
     * @param {TariffRateFindUniqueArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TariffRateFindUniqueArgs>(args: SelectSubset<T, TariffRateFindUniqueArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TariffRate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TariffRateFindUniqueOrThrowArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TariffRateFindUniqueOrThrowArgs>(args: SelectSubset<T, TariffRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TariffRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateFindFirstArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TariffRateFindFirstArgs>(args?: SelectSubset<T, TariffRateFindFirstArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TariffRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateFindFirstOrThrowArgs} args - Arguments to find a TariffRate
     * @example
     * // Get one TariffRate
     * const tariffRate = await prisma.tariffRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TariffRateFindFirstOrThrowArgs>(args?: SelectSubset<T, TariffRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TariffRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TariffRates
     * const tariffRates = await prisma.tariffRate.findMany()
     * 
     * // Get first 10 TariffRates
     * const tariffRates = await prisma.tariffRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tariffRateWithIdOnly = await prisma.tariffRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TariffRateFindManyArgs>(args?: SelectSubset<T, TariffRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TariffRate.
     * @param {TariffRateCreateArgs} args - Arguments to create a TariffRate.
     * @example
     * // Create one TariffRate
     * const TariffRate = await prisma.tariffRate.create({
     *   data: {
     *     // ... data to create a TariffRate
     *   }
     * })
     * 
     */
    create<T extends TariffRateCreateArgs>(args: SelectSubset<T, TariffRateCreateArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TariffRates.
     * @param {TariffRateCreateManyArgs} args - Arguments to create many TariffRates.
     * @example
     * // Create many TariffRates
     * const tariffRate = await prisma.tariffRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TariffRateCreateManyArgs>(args?: SelectSubset<T, TariffRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TariffRates and returns the data saved in the database.
     * @param {TariffRateCreateManyAndReturnArgs} args - Arguments to create many TariffRates.
     * @example
     * // Create many TariffRates
     * const tariffRate = await prisma.tariffRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TariffRates and only return the `id`
     * const tariffRateWithIdOnly = await prisma.tariffRate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TariffRateCreateManyAndReturnArgs>(args?: SelectSubset<T, TariffRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TariffRate.
     * @param {TariffRateDeleteArgs} args - Arguments to delete one TariffRate.
     * @example
     * // Delete one TariffRate
     * const TariffRate = await prisma.tariffRate.delete({
     *   where: {
     *     // ... filter to delete one TariffRate
     *   }
     * })
     * 
     */
    delete<T extends TariffRateDeleteArgs>(args: SelectSubset<T, TariffRateDeleteArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TariffRate.
     * @param {TariffRateUpdateArgs} args - Arguments to update one TariffRate.
     * @example
     * // Update one TariffRate
     * const tariffRate = await prisma.tariffRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TariffRateUpdateArgs>(args: SelectSubset<T, TariffRateUpdateArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TariffRates.
     * @param {TariffRateDeleteManyArgs} args - Arguments to filter TariffRates to delete.
     * @example
     * // Delete a few TariffRates
     * const { count } = await prisma.tariffRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TariffRateDeleteManyArgs>(args?: SelectSubset<T, TariffRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TariffRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TariffRates
     * const tariffRate = await prisma.tariffRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TariffRateUpdateManyArgs>(args: SelectSubset<T, TariffRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TariffRate.
     * @param {TariffRateUpsertArgs} args - Arguments to update or create a TariffRate.
     * @example
     * // Update or create a TariffRate
     * const tariffRate = await prisma.tariffRate.upsert({
     *   create: {
     *     // ... data to create a TariffRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TariffRate we want to update
     *   }
     * })
     */
    upsert<T extends TariffRateUpsertArgs>(args: SelectSubset<T, TariffRateUpsertArgs<ExtArgs>>): Prisma__TariffRateClient<$Result.GetResult<Prisma.$TariffRatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TariffRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateCountArgs} args - Arguments to filter TariffRates to count.
     * @example
     * // Count the number of TariffRates
     * const count = await prisma.tariffRate.count({
     *   where: {
     *     // ... the filter for the TariffRates we want to count
     *   }
     * })
    **/
    count<T extends TariffRateCountArgs>(
      args?: Subset<T, TariffRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TariffRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TariffRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TariffRateAggregateArgs>(args: Subset<T, TariffRateAggregateArgs>): Prisma.PrismaPromise<GetTariffRateAggregateType<T>>

    /**
     * Group by TariffRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TariffRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TariffRateGroupByArgs['orderBy'] }
        : { orderBy?: TariffRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TariffRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTariffRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TariffRate model
   */
  readonly fields: TariffRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TariffRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TariffRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tariffPlan<T extends TariffPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TariffPlanDefaultArgs<ExtArgs>>): Prisma__TariffPlanClient<$Result.GetResult<Prisma.$TariffPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TariffRate model
   */ 
  interface TariffRateFieldRefs {
    readonly id: FieldRef<"TariffRate", 'String'>
    readonly tariffPlanId: FieldRef<"TariffRate", 'String'>
    readonly serviceCode: FieldRef<"TariffRate", 'String'>
    readonly amount: FieldRef<"TariffRate", 'Decimal'>
    readonly createdAt: FieldRef<"TariffRate", 'DateTime'>
    readonly updatedAt: FieldRef<"TariffRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TariffRate findUnique
   */
  export type TariffRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate findUniqueOrThrow
   */
  export type TariffRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate findFirst
   */
  export type TariffRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffRates.
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffRates.
     */
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffRate findFirstOrThrow
   */
  export type TariffRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRate to fetch.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TariffRates.
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TariffRates.
     */
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffRate findMany
   */
  export type TariffRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter, which TariffRates to fetch.
     */
    where?: TariffRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TariffRates to fetch.
     */
    orderBy?: TariffRateOrderByWithRelationInput | TariffRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TariffRates.
     */
    cursor?: TariffRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TariffRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TariffRates.
     */
    skip?: number
    distinct?: TariffRateScalarFieldEnum | TariffRateScalarFieldEnum[]
  }

  /**
   * TariffRate create
   */
  export type TariffRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * The data needed to create a TariffRate.
     */
    data: XOR<TariffRateCreateInput, TariffRateUncheckedCreateInput>
  }

  /**
   * TariffRate createMany
   */
  export type TariffRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TariffRates.
     */
    data: TariffRateCreateManyInput | TariffRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TariffRate createManyAndReturn
   */
  export type TariffRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TariffRates.
     */
    data: TariffRateCreateManyInput | TariffRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TariffRate update
   */
  export type TariffRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * The data needed to update a TariffRate.
     */
    data: XOR<TariffRateUpdateInput, TariffRateUncheckedUpdateInput>
    /**
     * Choose, which TariffRate to update.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate updateMany
   */
  export type TariffRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TariffRates.
     */
    data: XOR<TariffRateUpdateManyMutationInput, TariffRateUncheckedUpdateManyInput>
    /**
     * Filter which TariffRates to update
     */
    where?: TariffRateWhereInput
  }

  /**
   * TariffRate upsert
   */
  export type TariffRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * The filter to search for the TariffRate to update in case it exists.
     */
    where: TariffRateWhereUniqueInput
    /**
     * In case the TariffRate found by the `where` argument doesn't exist, create a new TariffRate with this data.
     */
    create: XOR<TariffRateCreateInput, TariffRateUncheckedCreateInput>
    /**
     * In case the TariffRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TariffRateUpdateInput, TariffRateUncheckedUpdateInput>
  }

  /**
   * TariffRate delete
   */
  export type TariffRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
    /**
     * Filter which TariffRate to delete.
     */
    where: TariffRateWhereUniqueInput
  }

  /**
   * TariffRate deleteMany
   */
  export type TariffRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TariffRates to delete
     */
    where?: TariffRateWhereInput
  }

  /**
   * TariffRate without action
   */
  export type TariffRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffRate
     */
    select?: TariffRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffRateInclude<ExtArgs> | null
  }


  /**
   * Model ConsentRecord
   */

  export type AggregateConsentRecord = {
    _count: ConsentRecordCountAggregateOutputType | null
    _min: ConsentRecordMinAggregateOutputType | null
    _max: ConsentRecordMaxAggregateOutputType | null
  }

  export type ConsentRecordMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    scope: $Enums.ConsentScope | null
    purpose: string | null
    status: $Enums.ConsentStatus | null
    createdAt: Date | null
  }

  export type ConsentRecordMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    scope: $Enums.ConsentScope | null
    purpose: string | null
    status: $Enums.ConsentStatus | null
    createdAt: Date | null
  }

  export type ConsentRecordCountAggregateOutputType = {
    id: number
    patientId: number
    scope: number
    purpose: number
    status: number
    createdAt: number
    _all: number
  }


  export type ConsentRecordMinAggregateInputType = {
    id?: true
    patientId?: true
    scope?: true
    purpose?: true
    status?: true
    createdAt?: true
  }

  export type ConsentRecordMaxAggregateInputType = {
    id?: true
    patientId?: true
    scope?: true
    purpose?: true
    status?: true
    createdAt?: true
  }

  export type ConsentRecordCountAggregateInputType = {
    id?: true
    patientId?: true
    scope?: true
    purpose?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ConsentRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsentRecord to aggregate.
     */
    where?: ConsentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentRecords to fetch.
     */
    orderBy?: ConsentRecordOrderByWithRelationInput | ConsentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsentRecords
    **/
    _count?: true | ConsentRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsentRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsentRecordMaxAggregateInputType
  }

  export type GetConsentRecordAggregateType<T extends ConsentRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateConsentRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsentRecord[P]>
      : GetScalarType<T[P], AggregateConsentRecord[P]>
  }




  export type ConsentRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsentRecordWhereInput
    orderBy?: ConsentRecordOrderByWithAggregationInput | ConsentRecordOrderByWithAggregationInput[]
    by: ConsentRecordScalarFieldEnum[] | ConsentRecordScalarFieldEnum
    having?: ConsentRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsentRecordCountAggregateInputType | true
    _min?: ConsentRecordMinAggregateInputType
    _max?: ConsentRecordMaxAggregateInputType
  }

  export type ConsentRecordGroupByOutputType = {
    id: string
    patientId: string
    scope: $Enums.ConsentScope
    purpose: string
    status: $Enums.ConsentStatus
    createdAt: Date
    _count: ConsentRecordCountAggregateOutputType | null
    _min: ConsentRecordMinAggregateOutputType | null
    _max: ConsentRecordMaxAggregateOutputType | null
  }

  type GetConsentRecordGroupByPayload<T extends ConsentRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsentRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsentRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsentRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ConsentRecordGroupByOutputType[P]>
        }
      >
    >


  export type ConsentRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    scope?: boolean
    purpose?: boolean
    status?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consentRecord"]>

  export type ConsentRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    scope?: boolean
    purpose?: boolean
    status?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consentRecord"]>

  export type ConsentRecordSelectScalar = {
    id?: boolean
    patientId?: boolean
    scope?: boolean
    purpose?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ConsentRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ConsentRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $ConsentRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsentRecord"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      scope: $Enums.ConsentScope
      purpose: string
      status: $Enums.ConsentStatus
      createdAt: Date
    }, ExtArgs["result"]["consentRecord"]>
    composites: {}
  }

  type ConsentRecordGetPayload<S extends boolean | null | undefined | ConsentRecordDefaultArgs> = $Result.GetResult<Prisma.$ConsentRecordPayload, S>

  type ConsentRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsentRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsentRecordCountAggregateInputType | true
    }

  export interface ConsentRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsentRecord'], meta: { name: 'ConsentRecord' } }
    /**
     * Find zero or one ConsentRecord that matches the filter.
     * @param {ConsentRecordFindUniqueArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsentRecordFindUniqueArgs>(args: SelectSubset<T, ConsentRecordFindUniqueArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConsentRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsentRecordFindUniqueOrThrowArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsentRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsentRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConsentRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordFindFirstArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsentRecordFindFirstArgs>(args?: SelectSubset<T, ConsentRecordFindFirstArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConsentRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordFindFirstOrThrowArgs} args - Arguments to find a ConsentRecord
     * @example
     * // Get one ConsentRecord
     * const consentRecord = await prisma.consentRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsentRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsentRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConsentRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsentRecords
     * const consentRecords = await prisma.consentRecord.findMany()
     * 
     * // Get first 10 ConsentRecords
     * const consentRecords = await prisma.consentRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consentRecordWithIdOnly = await prisma.consentRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsentRecordFindManyArgs>(args?: SelectSubset<T, ConsentRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConsentRecord.
     * @param {ConsentRecordCreateArgs} args - Arguments to create a ConsentRecord.
     * @example
     * // Create one ConsentRecord
     * const ConsentRecord = await prisma.consentRecord.create({
     *   data: {
     *     // ... data to create a ConsentRecord
     *   }
     * })
     * 
     */
    create<T extends ConsentRecordCreateArgs>(args: SelectSubset<T, ConsentRecordCreateArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConsentRecords.
     * @param {ConsentRecordCreateManyArgs} args - Arguments to create many ConsentRecords.
     * @example
     * // Create many ConsentRecords
     * const consentRecord = await prisma.consentRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsentRecordCreateManyArgs>(args?: SelectSubset<T, ConsentRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsentRecords and returns the data saved in the database.
     * @param {ConsentRecordCreateManyAndReturnArgs} args - Arguments to create many ConsentRecords.
     * @example
     * // Create many ConsentRecords
     * const consentRecord = await prisma.consentRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsentRecords and only return the `id`
     * const consentRecordWithIdOnly = await prisma.consentRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsentRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsentRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConsentRecord.
     * @param {ConsentRecordDeleteArgs} args - Arguments to delete one ConsentRecord.
     * @example
     * // Delete one ConsentRecord
     * const ConsentRecord = await prisma.consentRecord.delete({
     *   where: {
     *     // ... filter to delete one ConsentRecord
     *   }
     * })
     * 
     */
    delete<T extends ConsentRecordDeleteArgs>(args: SelectSubset<T, ConsentRecordDeleteArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConsentRecord.
     * @param {ConsentRecordUpdateArgs} args - Arguments to update one ConsentRecord.
     * @example
     * // Update one ConsentRecord
     * const consentRecord = await prisma.consentRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsentRecordUpdateArgs>(args: SelectSubset<T, ConsentRecordUpdateArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConsentRecords.
     * @param {ConsentRecordDeleteManyArgs} args - Arguments to filter ConsentRecords to delete.
     * @example
     * // Delete a few ConsentRecords
     * const { count } = await prisma.consentRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsentRecordDeleteManyArgs>(args?: SelectSubset<T, ConsentRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsentRecords
     * const consentRecord = await prisma.consentRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsentRecordUpdateManyArgs>(args: SelectSubset<T, ConsentRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsentRecord.
     * @param {ConsentRecordUpsertArgs} args - Arguments to update or create a ConsentRecord.
     * @example
     * // Update or create a ConsentRecord
     * const consentRecord = await prisma.consentRecord.upsert({
     *   create: {
     *     // ... data to create a ConsentRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsentRecord we want to update
     *   }
     * })
     */
    upsert<T extends ConsentRecordUpsertArgs>(args: SelectSubset<T, ConsentRecordUpsertArgs<ExtArgs>>): Prisma__ConsentRecordClient<$Result.GetResult<Prisma.$ConsentRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConsentRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordCountArgs} args - Arguments to filter ConsentRecords to count.
     * @example
     * // Count the number of ConsentRecords
     * const count = await prisma.consentRecord.count({
     *   where: {
     *     // ... the filter for the ConsentRecords we want to count
     *   }
     * })
    **/
    count<T extends ConsentRecordCountArgs>(
      args?: Subset<T, ConsentRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsentRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsentRecordAggregateArgs>(args: Subset<T, ConsentRecordAggregateArgs>): Prisma.PrismaPromise<GetConsentRecordAggregateType<T>>

    /**
     * Group by ConsentRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsentRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsentRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsentRecordGroupByArgs['orderBy'] }
        : { orderBy?: ConsentRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsentRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsentRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsentRecord model
   */
  readonly fields: ConsentRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsentRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsentRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsentRecord model
   */ 
  interface ConsentRecordFieldRefs {
    readonly id: FieldRef<"ConsentRecord", 'String'>
    readonly patientId: FieldRef<"ConsentRecord", 'String'>
    readonly scope: FieldRef<"ConsentRecord", 'ConsentScope'>
    readonly purpose: FieldRef<"ConsentRecord", 'String'>
    readonly status: FieldRef<"ConsentRecord", 'ConsentStatus'>
    readonly createdAt: FieldRef<"ConsentRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsentRecord findUnique
   */
  export type ConsentRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter, which ConsentRecord to fetch.
     */
    where: ConsentRecordWhereUniqueInput
  }

  /**
   * ConsentRecord findUniqueOrThrow
   */
  export type ConsentRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter, which ConsentRecord to fetch.
     */
    where: ConsentRecordWhereUniqueInput
  }

  /**
   * ConsentRecord findFirst
   */
  export type ConsentRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter, which ConsentRecord to fetch.
     */
    where?: ConsentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentRecords to fetch.
     */
    orderBy?: ConsentRecordOrderByWithRelationInput | ConsentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsentRecords.
     */
    cursor?: ConsentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsentRecords.
     */
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * ConsentRecord findFirstOrThrow
   */
  export type ConsentRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter, which ConsentRecord to fetch.
     */
    where?: ConsentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentRecords to fetch.
     */
    orderBy?: ConsentRecordOrderByWithRelationInput | ConsentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsentRecords.
     */
    cursor?: ConsentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsentRecords.
     */
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * ConsentRecord findMany
   */
  export type ConsentRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter, which ConsentRecords to fetch.
     */
    where?: ConsentRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsentRecords to fetch.
     */
    orderBy?: ConsentRecordOrderByWithRelationInput | ConsentRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsentRecords.
     */
    cursor?: ConsentRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsentRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsentRecords.
     */
    skip?: number
    distinct?: ConsentRecordScalarFieldEnum | ConsentRecordScalarFieldEnum[]
  }

  /**
   * ConsentRecord create
   */
  export type ConsentRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a ConsentRecord.
     */
    data: XOR<ConsentRecordCreateInput, ConsentRecordUncheckedCreateInput>
  }

  /**
   * ConsentRecord createMany
   */
  export type ConsentRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsentRecords.
     */
    data: ConsentRecordCreateManyInput | ConsentRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConsentRecord createManyAndReturn
   */
  export type ConsentRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConsentRecords.
     */
    data: ConsentRecordCreateManyInput | ConsentRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConsentRecord update
   */
  export type ConsentRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a ConsentRecord.
     */
    data: XOR<ConsentRecordUpdateInput, ConsentRecordUncheckedUpdateInput>
    /**
     * Choose, which ConsentRecord to update.
     */
    where: ConsentRecordWhereUniqueInput
  }

  /**
   * ConsentRecord updateMany
   */
  export type ConsentRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsentRecords.
     */
    data: XOR<ConsentRecordUpdateManyMutationInput, ConsentRecordUncheckedUpdateManyInput>
    /**
     * Filter which ConsentRecords to update
     */
    where?: ConsentRecordWhereInput
  }

  /**
   * ConsentRecord upsert
   */
  export type ConsentRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the ConsentRecord to update in case it exists.
     */
    where: ConsentRecordWhereUniqueInput
    /**
     * In case the ConsentRecord found by the `where` argument doesn't exist, create a new ConsentRecord with this data.
     */
    create: XOR<ConsentRecordCreateInput, ConsentRecordUncheckedCreateInput>
    /**
     * In case the ConsentRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsentRecordUpdateInput, ConsentRecordUncheckedUpdateInput>
  }

  /**
   * ConsentRecord delete
   */
  export type ConsentRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
    /**
     * Filter which ConsentRecord to delete.
     */
    where: ConsentRecordWhereUniqueInput
  }

  /**
   * ConsentRecord deleteMany
   */
  export type ConsentRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsentRecords to delete
     */
    where?: ConsentRecordWhereInput
  }

  /**
   * ConsentRecord without action
   */
  export type ConsentRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsentRecord
     */
    select?: ConsentRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsentRecordInclude<ExtArgs> | null
  }


  /**
   * Model RtbfRequest
   */

  export type AggregateRtbfRequest = {
    _count: RtbfRequestCountAggregateOutputType | null
    _min: RtbfRequestMinAggregateOutputType | null
    _max: RtbfRequestMaxAggregateOutputType | null
  }

  export type RtbfRequestMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    reason: string | null
    status: $Enums.RtbfStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RtbfRequestMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    reason: string | null
    status: $Enums.RtbfStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RtbfRequestCountAggregateOutputType = {
    id: number
    patientId: number
    reason: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RtbfRequestMinAggregateInputType = {
    id?: true
    patientId?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RtbfRequestMaxAggregateInputType = {
    id?: true
    patientId?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RtbfRequestCountAggregateInputType = {
    id?: true
    patientId?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RtbfRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RtbfRequest to aggregate.
     */
    where?: RtbfRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RtbfRequests to fetch.
     */
    orderBy?: RtbfRequestOrderByWithRelationInput | RtbfRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RtbfRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RtbfRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RtbfRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RtbfRequests
    **/
    _count?: true | RtbfRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RtbfRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RtbfRequestMaxAggregateInputType
  }

  export type GetRtbfRequestAggregateType<T extends RtbfRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRtbfRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRtbfRequest[P]>
      : GetScalarType<T[P], AggregateRtbfRequest[P]>
  }




  export type RtbfRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RtbfRequestWhereInput
    orderBy?: RtbfRequestOrderByWithAggregationInput | RtbfRequestOrderByWithAggregationInput[]
    by: RtbfRequestScalarFieldEnum[] | RtbfRequestScalarFieldEnum
    having?: RtbfRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RtbfRequestCountAggregateInputType | true
    _min?: RtbfRequestMinAggregateInputType
    _max?: RtbfRequestMaxAggregateInputType
  }

  export type RtbfRequestGroupByOutputType = {
    id: string
    patientId: string
    reason: string
    status: $Enums.RtbfStatus
    createdAt: Date
    updatedAt: Date
    _count: RtbfRequestCountAggregateOutputType | null
    _min: RtbfRequestMinAggregateOutputType | null
    _max: RtbfRequestMaxAggregateOutputType | null
  }

  type GetRtbfRequestGroupByPayload<T extends RtbfRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RtbfRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RtbfRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RtbfRequestGroupByOutputType[P]>
            : GetScalarType<T[P], RtbfRequestGroupByOutputType[P]>
        }
      >
    >


  export type RtbfRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rtbfRequest"]>

  export type RtbfRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rtbfRequest"]>

  export type RtbfRequestSelectScalar = {
    id?: boolean
    patientId?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RtbfRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type RtbfRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $RtbfRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RtbfRequest"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      reason: string
      status: $Enums.RtbfStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rtbfRequest"]>
    composites: {}
  }

  type RtbfRequestGetPayload<S extends boolean | null | undefined | RtbfRequestDefaultArgs> = $Result.GetResult<Prisma.$RtbfRequestPayload, S>

  type RtbfRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RtbfRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RtbfRequestCountAggregateInputType | true
    }

  export interface RtbfRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RtbfRequest'], meta: { name: 'RtbfRequest' } }
    /**
     * Find zero or one RtbfRequest that matches the filter.
     * @param {RtbfRequestFindUniqueArgs} args - Arguments to find a RtbfRequest
     * @example
     * // Get one RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RtbfRequestFindUniqueArgs>(args: SelectSubset<T, RtbfRequestFindUniqueArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RtbfRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RtbfRequestFindUniqueOrThrowArgs} args - Arguments to find a RtbfRequest
     * @example
     * // Get one RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RtbfRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RtbfRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RtbfRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestFindFirstArgs} args - Arguments to find a RtbfRequest
     * @example
     * // Get one RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RtbfRequestFindFirstArgs>(args?: SelectSubset<T, RtbfRequestFindFirstArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RtbfRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestFindFirstOrThrowArgs} args - Arguments to find a RtbfRequest
     * @example
     * // Get one RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RtbfRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RtbfRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RtbfRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RtbfRequests
     * const rtbfRequests = await prisma.rtbfRequest.findMany()
     * 
     * // Get first 10 RtbfRequests
     * const rtbfRequests = await prisma.rtbfRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rtbfRequestWithIdOnly = await prisma.rtbfRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RtbfRequestFindManyArgs>(args?: SelectSubset<T, RtbfRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RtbfRequest.
     * @param {RtbfRequestCreateArgs} args - Arguments to create a RtbfRequest.
     * @example
     * // Create one RtbfRequest
     * const RtbfRequest = await prisma.rtbfRequest.create({
     *   data: {
     *     // ... data to create a RtbfRequest
     *   }
     * })
     * 
     */
    create<T extends RtbfRequestCreateArgs>(args: SelectSubset<T, RtbfRequestCreateArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RtbfRequests.
     * @param {RtbfRequestCreateManyArgs} args - Arguments to create many RtbfRequests.
     * @example
     * // Create many RtbfRequests
     * const rtbfRequest = await prisma.rtbfRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RtbfRequestCreateManyArgs>(args?: SelectSubset<T, RtbfRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RtbfRequests and returns the data saved in the database.
     * @param {RtbfRequestCreateManyAndReturnArgs} args - Arguments to create many RtbfRequests.
     * @example
     * // Create many RtbfRequests
     * const rtbfRequest = await prisma.rtbfRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RtbfRequests and only return the `id`
     * const rtbfRequestWithIdOnly = await prisma.rtbfRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RtbfRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RtbfRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RtbfRequest.
     * @param {RtbfRequestDeleteArgs} args - Arguments to delete one RtbfRequest.
     * @example
     * // Delete one RtbfRequest
     * const RtbfRequest = await prisma.rtbfRequest.delete({
     *   where: {
     *     // ... filter to delete one RtbfRequest
     *   }
     * })
     * 
     */
    delete<T extends RtbfRequestDeleteArgs>(args: SelectSubset<T, RtbfRequestDeleteArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RtbfRequest.
     * @param {RtbfRequestUpdateArgs} args - Arguments to update one RtbfRequest.
     * @example
     * // Update one RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RtbfRequestUpdateArgs>(args: SelectSubset<T, RtbfRequestUpdateArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RtbfRequests.
     * @param {RtbfRequestDeleteManyArgs} args - Arguments to filter RtbfRequests to delete.
     * @example
     * // Delete a few RtbfRequests
     * const { count } = await prisma.rtbfRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RtbfRequestDeleteManyArgs>(args?: SelectSubset<T, RtbfRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RtbfRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RtbfRequests
     * const rtbfRequest = await prisma.rtbfRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RtbfRequestUpdateManyArgs>(args: SelectSubset<T, RtbfRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RtbfRequest.
     * @param {RtbfRequestUpsertArgs} args - Arguments to update or create a RtbfRequest.
     * @example
     * // Update or create a RtbfRequest
     * const rtbfRequest = await prisma.rtbfRequest.upsert({
     *   create: {
     *     // ... data to create a RtbfRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RtbfRequest we want to update
     *   }
     * })
     */
    upsert<T extends RtbfRequestUpsertArgs>(args: SelectSubset<T, RtbfRequestUpsertArgs<ExtArgs>>): Prisma__RtbfRequestClient<$Result.GetResult<Prisma.$RtbfRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RtbfRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestCountArgs} args - Arguments to filter RtbfRequests to count.
     * @example
     * // Count the number of RtbfRequests
     * const count = await prisma.rtbfRequest.count({
     *   where: {
     *     // ... the filter for the RtbfRequests we want to count
     *   }
     * })
    **/
    count<T extends RtbfRequestCountArgs>(
      args?: Subset<T, RtbfRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RtbfRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RtbfRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RtbfRequestAggregateArgs>(args: Subset<T, RtbfRequestAggregateArgs>): Prisma.PrismaPromise<GetRtbfRequestAggregateType<T>>

    /**
     * Group by RtbfRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RtbfRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RtbfRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RtbfRequestGroupByArgs['orderBy'] }
        : { orderBy?: RtbfRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RtbfRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRtbfRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RtbfRequest model
   */
  readonly fields: RtbfRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RtbfRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RtbfRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RtbfRequest model
   */ 
  interface RtbfRequestFieldRefs {
    readonly id: FieldRef<"RtbfRequest", 'String'>
    readonly patientId: FieldRef<"RtbfRequest", 'String'>
    readonly reason: FieldRef<"RtbfRequest", 'String'>
    readonly status: FieldRef<"RtbfRequest", 'RtbfStatus'>
    readonly createdAt: FieldRef<"RtbfRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"RtbfRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RtbfRequest findUnique
   */
  export type RtbfRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter, which RtbfRequest to fetch.
     */
    where: RtbfRequestWhereUniqueInput
  }

  /**
   * RtbfRequest findUniqueOrThrow
   */
  export type RtbfRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter, which RtbfRequest to fetch.
     */
    where: RtbfRequestWhereUniqueInput
  }

  /**
   * RtbfRequest findFirst
   */
  export type RtbfRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter, which RtbfRequest to fetch.
     */
    where?: RtbfRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RtbfRequests to fetch.
     */
    orderBy?: RtbfRequestOrderByWithRelationInput | RtbfRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RtbfRequests.
     */
    cursor?: RtbfRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RtbfRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RtbfRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RtbfRequests.
     */
    distinct?: RtbfRequestScalarFieldEnum | RtbfRequestScalarFieldEnum[]
  }

  /**
   * RtbfRequest findFirstOrThrow
   */
  export type RtbfRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter, which RtbfRequest to fetch.
     */
    where?: RtbfRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RtbfRequests to fetch.
     */
    orderBy?: RtbfRequestOrderByWithRelationInput | RtbfRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RtbfRequests.
     */
    cursor?: RtbfRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RtbfRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RtbfRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RtbfRequests.
     */
    distinct?: RtbfRequestScalarFieldEnum | RtbfRequestScalarFieldEnum[]
  }

  /**
   * RtbfRequest findMany
   */
  export type RtbfRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter, which RtbfRequests to fetch.
     */
    where?: RtbfRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RtbfRequests to fetch.
     */
    orderBy?: RtbfRequestOrderByWithRelationInput | RtbfRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RtbfRequests.
     */
    cursor?: RtbfRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RtbfRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RtbfRequests.
     */
    skip?: number
    distinct?: RtbfRequestScalarFieldEnum | RtbfRequestScalarFieldEnum[]
  }

  /**
   * RtbfRequest create
   */
  export type RtbfRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a RtbfRequest.
     */
    data: XOR<RtbfRequestCreateInput, RtbfRequestUncheckedCreateInput>
  }

  /**
   * RtbfRequest createMany
   */
  export type RtbfRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RtbfRequests.
     */
    data: RtbfRequestCreateManyInput | RtbfRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RtbfRequest createManyAndReturn
   */
  export type RtbfRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RtbfRequests.
     */
    data: RtbfRequestCreateManyInput | RtbfRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RtbfRequest update
   */
  export type RtbfRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a RtbfRequest.
     */
    data: XOR<RtbfRequestUpdateInput, RtbfRequestUncheckedUpdateInput>
    /**
     * Choose, which RtbfRequest to update.
     */
    where: RtbfRequestWhereUniqueInput
  }

  /**
   * RtbfRequest updateMany
   */
  export type RtbfRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RtbfRequests.
     */
    data: XOR<RtbfRequestUpdateManyMutationInput, RtbfRequestUncheckedUpdateManyInput>
    /**
     * Filter which RtbfRequests to update
     */
    where?: RtbfRequestWhereInput
  }

  /**
   * RtbfRequest upsert
   */
  export type RtbfRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the RtbfRequest to update in case it exists.
     */
    where: RtbfRequestWhereUniqueInput
    /**
     * In case the RtbfRequest found by the `where` argument doesn't exist, create a new RtbfRequest with this data.
     */
    create: XOR<RtbfRequestCreateInput, RtbfRequestUncheckedCreateInput>
    /**
     * In case the RtbfRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RtbfRequestUpdateInput, RtbfRequestUncheckedUpdateInput>
  }

  /**
   * RtbfRequest delete
   */
  export type RtbfRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
    /**
     * Filter which RtbfRequest to delete.
     */
    where: RtbfRequestWhereUniqueInput
  }

  /**
   * RtbfRequest deleteMany
   */
  export type RtbfRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RtbfRequests to delete
     */
    where?: RtbfRequestWhereInput
  }

  /**
   * RtbfRequest without action
   */
  export type RtbfRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RtbfRequest
     */
    select?: RtbfRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RtbfRequestInclude<ExtArgs> | null
  }


  /**
   * Model StatutoryCase
   */

  export type AggregateStatutoryCase = {
    _count: StatutoryCaseCountAggregateOutputType | null
    _min: StatutoryCaseMinAggregateOutputType | null
    _max: StatutoryCaseMaxAggregateOutputType | null
  }

  export type StatutoryCaseMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    patientId: string | null
    program: string | null
    disease: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatutoryCaseMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    patientId: string | null
    program: string | null
    disease: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatutoryCaseCountAggregateOutputType = {
    id: number
    branchId: number
    patientId: number
    program: number
    disease: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatutoryCaseMinAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    program?: true
    disease?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatutoryCaseMaxAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    program?: true
    disease?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatutoryCaseCountAggregateInputType = {
    id?: true
    branchId?: true
    patientId?: true
    program?: true
    disease?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatutoryCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatutoryCase to aggregate.
     */
    where?: StatutoryCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatutoryCases to fetch.
     */
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatutoryCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatutoryCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatutoryCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatutoryCases
    **/
    _count?: true | StatutoryCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatutoryCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatutoryCaseMaxAggregateInputType
  }

  export type GetStatutoryCaseAggregateType<T extends StatutoryCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateStatutoryCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatutoryCase[P]>
      : GetScalarType<T[P], AggregateStatutoryCase[P]>
  }




  export type StatutoryCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatutoryCaseWhereInput
    orderBy?: StatutoryCaseOrderByWithAggregationInput | StatutoryCaseOrderByWithAggregationInput[]
    by: StatutoryCaseScalarFieldEnum[] | StatutoryCaseScalarFieldEnum
    having?: StatutoryCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatutoryCaseCountAggregateInputType | true
    _min?: StatutoryCaseMinAggregateInputType
    _max?: StatutoryCaseMaxAggregateInputType
  }

  export type StatutoryCaseGroupByOutputType = {
    id: string
    branchId: string
    patientId: string
    program: string
    disease: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: StatutoryCaseCountAggregateOutputType | null
    _min: StatutoryCaseMinAggregateOutputType | null
    _max: StatutoryCaseMaxAggregateOutputType | null
  }

  type GetStatutoryCaseGroupByPayload<T extends StatutoryCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatutoryCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatutoryCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatutoryCaseGroupByOutputType[P]>
            : GetScalarType<T[P], StatutoryCaseGroupByOutputType[P]>
        }
      >
    >


  export type StatutoryCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    program?: boolean
    disease?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statutoryCase"]>

  export type StatutoryCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    program?: boolean
    disease?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statutoryCase"]>

  export type StatutoryCaseSelectScalar = {
    id?: boolean
    branchId?: boolean
    patientId?: boolean
    program?: boolean
    disease?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StatutoryCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type StatutoryCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $StatutoryCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatutoryCase"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string
      patientId: string
      program: string
      disease: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["statutoryCase"]>
    composites: {}
  }

  type StatutoryCaseGetPayload<S extends boolean | null | undefined | StatutoryCaseDefaultArgs> = $Result.GetResult<Prisma.$StatutoryCasePayload, S>

  type StatutoryCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StatutoryCaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StatutoryCaseCountAggregateInputType | true
    }

  export interface StatutoryCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatutoryCase'], meta: { name: 'StatutoryCase' } }
    /**
     * Find zero or one StatutoryCase that matches the filter.
     * @param {StatutoryCaseFindUniqueArgs} args - Arguments to find a StatutoryCase
     * @example
     * // Get one StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatutoryCaseFindUniqueArgs>(args: SelectSubset<T, StatutoryCaseFindUniqueArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StatutoryCase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StatutoryCaseFindUniqueOrThrowArgs} args - Arguments to find a StatutoryCase
     * @example
     * // Get one StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatutoryCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, StatutoryCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StatutoryCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseFindFirstArgs} args - Arguments to find a StatutoryCase
     * @example
     * // Get one StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatutoryCaseFindFirstArgs>(args?: SelectSubset<T, StatutoryCaseFindFirstArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StatutoryCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseFindFirstOrThrowArgs} args - Arguments to find a StatutoryCase
     * @example
     * // Get one StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatutoryCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, StatutoryCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StatutoryCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatutoryCases
     * const statutoryCases = await prisma.statutoryCase.findMany()
     * 
     * // Get first 10 StatutoryCases
     * const statutoryCases = await prisma.statutoryCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statutoryCaseWithIdOnly = await prisma.statutoryCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatutoryCaseFindManyArgs>(args?: SelectSubset<T, StatutoryCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StatutoryCase.
     * @param {StatutoryCaseCreateArgs} args - Arguments to create a StatutoryCase.
     * @example
     * // Create one StatutoryCase
     * const StatutoryCase = await prisma.statutoryCase.create({
     *   data: {
     *     // ... data to create a StatutoryCase
     *   }
     * })
     * 
     */
    create<T extends StatutoryCaseCreateArgs>(args: SelectSubset<T, StatutoryCaseCreateArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StatutoryCases.
     * @param {StatutoryCaseCreateManyArgs} args - Arguments to create many StatutoryCases.
     * @example
     * // Create many StatutoryCases
     * const statutoryCase = await prisma.statutoryCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatutoryCaseCreateManyArgs>(args?: SelectSubset<T, StatutoryCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatutoryCases and returns the data saved in the database.
     * @param {StatutoryCaseCreateManyAndReturnArgs} args - Arguments to create many StatutoryCases.
     * @example
     * // Create many StatutoryCases
     * const statutoryCase = await prisma.statutoryCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatutoryCases and only return the `id`
     * const statutoryCaseWithIdOnly = await prisma.statutoryCase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatutoryCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, StatutoryCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StatutoryCase.
     * @param {StatutoryCaseDeleteArgs} args - Arguments to delete one StatutoryCase.
     * @example
     * // Delete one StatutoryCase
     * const StatutoryCase = await prisma.statutoryCase.delete({
     *   where: {
     *     // ... filter to delete one StatutoryCase
     *   }
     * })
     * 
     */
    delete<T extends StatutoryCaseDeleteArgs>(args: SelectSubset<T, StatutoryCaseDeleteArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StatutoryCase.
     * @param {StatutoryCaseUpdateArgs} args - Arguments to update one StatutoryCase.
     * @example
     * // Update one StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatutoryCaseUpdateArgs>(args: SelectSubset<T, StatutoryCaseUpdateArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StatutoryCases.
     * @param {StatutoryCaseDeleteManyArgs} args - Arguments to filter StatutoryCases to delete.
     * @example
     * // Delete a few StatutoryCases
     * const { count } = await prisma.statutoryCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatutoryCaseDeleteManyArgs>(args?: SelectSubset<T, StatutoryCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatutoryCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatutoryCases
     * const statutoryCase = await prisma.statutoryCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatutoryCaseUpdateManyArgs>(args: SelectSubset<T, StatutoryCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatutoryCase.
     * @param {StatutoryCaseUpsertArgs} args - Arguments to update or create a StatutoryCase.
     * @example
     * // Update or create a StatutoryCase
     * const statutoryCase = await prisma.statutoryCase.upsert({
     *   create: {
     *     // ... data to create a StatutoryCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatutoryCase we want to update
     *   }
     * })
     */
    upsert<T extends StatutoryCaseUpsertArgs>(args: SelectSubset<T, StatutoryCaseUpsertArgs<ExtArgs>>): Prisma__StatutoryCaseClient<$Result.GetResult<Prisma.$StatutoryCasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StatutoryCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseCountArgs} args - Arguments to filter StatutoryCases to count.
     * @example
     * // Count the number of StatutoryCases
     * const count = await prisma.statutoryCase.count({
     *   where: {
     *     // ... the filter for the StatutoryCases we want to count
     *   }
     * })
    **/
    count<T extends StatutoryCaseCountArgs>(
      args?: Subset<T, StatutoryCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatutoryCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatutoryCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatutoryCaseAggregateArgs>(args: Subset<T, StatutoryCaseAggregateArgs>): Prisma.PrismaPromise<GetStatutoryCaseAggregateType<T>>

    /**
     * Group by StatutoryCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatutoryCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatutoryCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatutoryCaseGroupByArgs['orderBy'] }
        : { orderBy?: StatutoryCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatutoryCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatutoryCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatutoryCase model
   */
  readonly fields: StatutoryCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatutoryCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatutoryCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatutoryCase model
   */ 
  interface StatutoryCaseFieldRefs {
    readonly id: FieldRef<"StatutoryCase", 'String'>
    readonly branchId: FieldRef<"StatutoryCase", 'String'>
    readonly patientId: FieldRef<"StatutoryCase", 'String'>
    readonly program: FieldRef<"StatutoryCase", 'String'>
    readonly disease: FieldRef<"StatutoryCase", 'String'>
    readonly status: FieldRef<"StatutoryCase", 'String'>
    readonly createdAt: FieldRef<"StatutoryCase", 'DateTime'>
    readonly updatedAt: FieldRef<"StatutoryCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatutoryCase findUnique
   */
  export type StatutoryCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter, which StatutoryCase to fetch.
     */
    where: StatutoryCaseWhereUniqueInput
  }

  /**
   * StatutoryCase findUniqueOrThrow
   */
  export type StatutoryCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter, which StatutoryCase to fetch.
     */
    where: StatutoryCaseWhereUniqueInput
  }

  /**
   * StatutoryCase findFirst
   */
  export type StatutoryCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter, which StatutoryCase to fetch.
     */
    where?: StatutoryCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatutoryCases to fetch.
     */
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatutoryCases.
     */
    cursor?: StatutoryCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatutoryCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatutoryCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatutoryCases.
     */
    distinct?: StatutoryCaseScalarFieldEnum | StatutoryCaseScalarFieldEnum[]
  }

  /**
   * StatutoryCase findFirstOrThrow
   */
  export type StatutoryCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter, which StatutoryCase to fetch.
     */
    where?: StatutoryCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatutoryCases to fetch.
     */
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatutoryCases.
     */
    cursor?: StatutoryCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatutoryCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatutoryCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatutoryCases.
     */
    distinct?: StatutoryCaseScalarFieldEnum | StatutoryCaseScalarFieldEnum[]
  }

  /**
   * StatutoryCase findMany
   */
  export type StatutoryCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter, which StatutoryCases to fetch.
     */
    where?: StatutoryCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatutoryCases to fetch.
     */
    orderBy?: StatutoryCaseOrderByWithRelationInput | StatutoryCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatutoryCases.
     */
    cursor?: StatutoryCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatutoryCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatutoryCases.
     */
    skip?: number
    distinct?: StatutoryCaseScalarFieldEnum | StatutoryCaseScalarFieldEnum[]
  }

  /**
   * StatutoryCase create
   */
  export type StatutoryCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a StatutoryCase.
     */
    data: XOR<StatutoryCaseCreateInput, StatutoryCaseUncheckedCreateInput>
  }

  /**
   * StatutoryCase createMany
   */
  export type StatutoryCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatutoryCases.
     */
    data: StatutoryCaseCreateManyInput | StatutoryCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatutoryCase createManyAndReturn
   */
  export type StatutoryCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StatutoryCases.
     */
    data: StatutoryCaseCreateManyInput | StatutoryCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatutoryCase update
   */
  export type StatutoryCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a StatutoryCase.
     */
    data: XOR<StatutoryCaseUpdateInput, StatutoryCaseUncheckedUpdateInput>
    /**
     * Choose, which StatutoryCase to update.
     */
    where: StatutoryCaseWhereUniqueInput
  }

  /**
   * StatutoryCase updateMany
   */
  export type StatutoryCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatutoryCases.
     */
    data: XOR<StatutoryCaseUpdateManyMutationInput, StatutoryCaseUncheckedUpdateManyInput>
    /**
     * Filter which StatutoryCases to update
     */
    where?: StatutoryCaseWhereInput
  }

  /**
   * StatutoryCase upsert
   */
  export type StatutoryCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the StatutoryCase to update in case it exists.
     */
    where: StatutoryCaseWhereUniqueInput
    /**
     * In case the StatutoryCase found by the `where` argument doesn't exist, create a new StatutoryCase with this data.
     */
    create: XOR<StatutoryCaseCreateInput, StatutoryCaseUncheckedCreateInput>
    /**
     * In case the StatutoryCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatutoryCaseUpdateInput, StatutoryCaseUncheckedUpdateInput>
  }

  /**
   * StatutoryCase delete
   */
  export type StatutoryCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
    /**
     * Filter which StatutoryCase to delete.
     */
    where: StatutoryCaseWhereUniqueInput
  }

  /**
   * StatutoryCase deleteMany
   */
  export type StatutoryCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatutoryCases to delete
     */
    where?: StatutoryCaseWhereInput
  }

  /**
   * StatutoryCase without action
   */
  export type StatutoryCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatutoryCase
     */
    select?: StatutoryCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatutoryCaseInclude<ExtArgs> | null
  }


  /**
   * Model AuditEvent
   */

  export type AggregateAuditEvent = {
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  export type AuditEventMinAggregateOutputType = {
    id: string | null
    branchId: string | null
    actorUserId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditEventMaxAggregateOutputType = {
    id: string | null
    branchId: string | null
    actorUserId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditEventCountAggregateOutputType = {
    id: number
    branchId: number
    actorUserId: number
    action: number
    entity: number
    entityId: number
    meta: number
    createdAt: number
    _all: number
  }


  export type AuditEventMinAggregateInputType = {
    id?: true
    branchId?: true
    actorUserId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditEventMaxAggregateInputType = {
    id?: true
    branchId?: true
    actorUserId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditEventCountAggregateInputType = {
    id?: true
    branchId?: true
    actorUserId?: true
    action?: true
    entity?: true
    entityId?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type AuditEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvent to aggregate.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditEvents
    **/
    _count?: true | AuditEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditEventMaxAggregateInputType
  }

  export type GetAuditEventAggregateType<T extends AuditEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditEvent[P]>
      : GetScalarType<T[P], AggregateAuditEvent[P]>
  }




  export type AuditEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithAggregationInput | AuditEventOrderByWithAggregationInput[]
    by: AuditEventScalarFieldEnum[] | AuditEventScalarFieldEnum
    having?: AuditEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditEventCountAggregateInputType | true
    _min?: AuditEventMinAggregateInputType
    _max?: AuditEventMaxAggregateInputType
  }

  export type AuditEventGroupByOutputType = {
    id: string
    branchId: string | null
    actorUserId: string | null
    action: string
    entity: string
    entityId: string | null
    meta: JsonValue | null
    createdAt: Date
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  type GetAuditEventGroupByPayload<T extends AuditEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
            : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
        }
      >
    >


  export type AuditEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    actorUserId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    meta?: boolean
    createdAt?: boolean
    branch?: boolean | AuditEvent$branchArgs<ExtArgs>
    actorUser?: boolean | AuditEvent$actorUserArgs<ExtArgs>
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branchId?: boolean
    actorUserId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    meta?: boolean
    createdAt?: boolean
    branch?: boolean | AuditEvent$branchArgs<ExtArgs>
    actorUser?: boolean | AuditEvent$actorUserArgs<ExtArgs>
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectScalar = {
    id?: boolean
    branchId?: boolean
    actorUserId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type AuditEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | AuditEvent$branchArgs<ExtArgs>
    actorUser?: boolean | AuditEvent$actorUserArgs<ExtArgs>
  }
  export type AuditEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | AuditEvent$branchArgs<ExtArgs>
    actorUser?: boolean | AuditEvent$actorUserArgs<ExtArgs>
  }

  export type $AuditEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditEvent"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      actorUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branchId: string | null
      actorUserId: string | null
      action: string
      entity: string
      entityId: string | null
      meta: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditEvent"]>
    composites: {}
  }

  type AuditEventGetPayload<S extends boolean | null | undefined | AuditEventDefaultArgs> = $Result.GetResult<Prisma.$AuditEventPayload, S>

  type AuditEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditEventCountAggregateInputType | true
    }

  export interface AuditEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditEvent'], meta: { name: 'AuditEvent' } }
    /**
     * Find zero or one AuditEvent that matches the filter.
     * @param {AuditEventFindUniqueArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditEventFindUniqueArgs>(args: SelectSubset<T, AuditEventFindUniqueArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditEventFindUniqueOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditEventFindFirstArgs>(args?: SelectSubset<T, AuditEventFindFirstArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany()
     * 
     * // Get first 10 AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditEventFindManyArgs>(args?: SelectSubset<T, AuditEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditEvent.
     * @param {AuditEventCreateArgs} args - Arguments to create a AuditEvent.
     * @example
     * // Create one AuditEvent
     * const AuditEvent = await prisma.auditEvent.create({
     *   data: {
     *     // ... data to create a AuditEvent
     *   }
     * })
     * 
     */
    create<T extends AuditEventCreateArgs>(args: SelectSubset<T, AuditEventCreateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditEvents.
     * @param {AuditEventCreateManyArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditEventCreateManyArgs>(args?: SelectSubset<T, AuditEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditEvents and returns the data saved in the database.
     * @param {AuditEventCreateManyAndReturnArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditEvents and only return the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditEvent.
     * @param {AuditEventDeleteArgs} args - Arguments to delete one AuditEvent.
     * @example
     * // Delete one AuditEvent
     * const AuditEvent = await prisma.auditEvent.delete({
     *   where: {
     *     // ... filter to delete one AuditEvent
     *   }
     * })
     * 
     */
    delete<T extends AuditEventDeleteArgs>(args: SelectSubset<T, AuditEventDeleteArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditEvent.
     * @param {AuditEventUpdateArgs} args - Arguments to update one AuditEvent.
     * @example
     * // Update one AuditEvent
     * const auditEvent = await prisma.auditEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditEventUpdateArgs>(args: SelectSubset<T, AuditEventUpdateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditEvents.
     * @param {AuditEventDeleteManyArgs} args - Arguments to filter AuditEvents to delete.
     * @example
     * // Delete a few AuditEvents
     * const { count } = await prisma.auditEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditEventDeleteManyArgs>(args?: SelectSubset<T, AuditEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditEvents
     * const auditEvent = await prisma.auditEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditEventUpdateManyArgs>(args: SelectSubset<T, AuditEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditEvent.
     * @param {AuditEventUpsertArgs} args - Arguments to update or create a AuditEvent.
     * @example
     * // Update or create a AuditEvent
     * const auditEvent = await prisma.auditEvent.upsert({
     *   create: {
     *     // ... data to create a AuditEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditEvent we want to update
     *   }
     * })
     */
    upsert<T extends AuditEventUpsertArgs>(args: SelectSubset<T, AuditEventUpsertArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventCountArgs} args - Arguments to filter AuditEvents to count.
     * @example
     * // Count the number of AuditEvents
     * const count = await prisma.auditEvent.count({
     *   where: {
     *     // ... the filter for the AuditEvents we want to count
     *   }
     * })
    **/
    count<T extends AuditEventCountArgs>(
      args?: Subset<T, AuditEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditEventAggregateArgs>(args: Subset<T, AuditEventAggregateArgs>): Prisma.PrismaPromise<GetAuditEventAggregateType<T>>

    /**
     * Group by AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditEventGroupByArgs['orderBy'] }
        : { orderBy?: AuditEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditEvent model
   */
  readonly fields: AuditEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends AuditEvent$branchArgs<ExtArgs> = {}>(args?: Subset<T, AuditEvent$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    actorUser<T extends AuditEvent$actorUserArgs<ExtArgs> = {}>(args?: Subset<T, AuditEvent$actorUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditEvent model
   */ 
  interface AuditEventFieldRefs {
    readonly id: FieldRef<"AuditEvent", 'String'>
    readonly branchId: FieldRef<"AuditEvent", 'String'>
    readonly actorUserId: FieldRef<"AuditEvent", 'String'>
    readonly action: FieldRef<"AuditEvent", 'String'>
    readonly entity: FieldRef<"AuditEvent", 'String'>
    readonly entityId: FieldRef<"AuditEvent", 'String'>
    readonly meta: FieldRef<"AuditEvent", 'Json'>
    readonly createdAt: FieldRef<"AuditEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditEvent findUnique
   */
  export type AuditEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findUniqueOrThrow
   */
  export type AuditEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findFirst
   */
  export type AuditEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findFirstOrThrow
   */
  export type AuditEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findMany
   */
  export type AuditEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvents to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent create
   */
  export type AuditEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditEvent.
     */
    data: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
  }

  /**
   * AuditEvent createMany
   */
  export type AuditEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditEvent createManyAndReturn
   */
  export type AuditEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditEvent update
   */
  export type AuditEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditEvent.
     */
    data: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
    /**
     * Choose, which AuditEvent to update.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent updateMany
   */
  export type AuditEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditEvents.
     */
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AuditEvents to update
     */
    where?: AuditEventWhereInput
  }

  /**
   * AuditEvent upsert
   */
  export type AuditEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditEvent to update in case it exists.
     */
    where: AuditEventWhereUniqueInput
    /**
     * In case the AuditEvent found by the `where` argument doesn't exist, create a new AuditEvent with this data.
     */
    create: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
    /**
     * In case the AuditEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
  }

  /**
   * AuditEvent delete
   */
  export type AuditEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter which AuditEvent to delete.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent deleteMany
   */
  export type AuditEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvents to delete
     */
    where?: AuditEventWhereInput
  }

  /**
   * AuditEvent.branch
   */
  export type AuditEvent$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * AuditEvent.actorUser
   */
  export type AuditEvent$actorUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditEvent without action
   */
  export type AuditEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
  }


  /**
   * Model OutboxEvent
   */

  export type AggregateOutboxEvent = {
    _count: OutboxEventCountAggregateOutputType | null
    _avg: OutboxEventAvgAggregateOutputType | null
    _sum: OutboxEventSumAggregateOutputType | null
    _min: OutboxEventMinAggregateOutputType | null
    _max: OutboxEventMaxAggregateOutputType | null
  }

  export type OutboxEventAvgAggregateOutputType = {
    attempts: number | null
  }

  export type OutboxEventSumAggregateOutputType = {
    attempts: number | null
  }

  export type OutboxEventMinAggregateOutputType = {
    id: string | null
    topic: string | null
    key: string | null
    status: $Enums.OutboxStatus | null
    attempts: number | null
    availableAt: Date | null
    lockedAt: Date | null
    sentAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutboxEventMaxAggregateOutputType = {
    id: string | null
    topic: string | null
    key: string | null
    status: $Enums.OutboxStatus | null
    attempts: number | null
    availableAt: Date | null
    lockedAt: Date | null
    sentAt: Date | null
    error: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutboxEventCountAggregateOutputType = {
    id: number
    topic: number
    key: number
    payload: number
    status: number
    attempts: number
    availableAt: number
    lockedAt: number
    sentAt: number
    error: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutboxEventAvgAggregateInputType = {
    attempts?: true
  }

  export type OutboxEventSumAggregateInputType = {
    attempts?: true
  }

  export type OutboxEventMinAggregateInputType = {
    id?: true
    topic?: true
    key?: true
    status?: true
    attempts?: true
    availableAt?: true
    lockedAt?: true
    sentAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutboxEventMaxAggregateInputType = {
    id?: true
    topic?: true
    key?: true
    status?: true
    attempts?: true
    availableAt?: true
    lockedAt?: true
    sentAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutboxEventCountAggregateInputType = {
    id?: true
    topic?: true
    key?: true
    payload?: true
    status?: true
    attempts?: true
    availableAt?: true
    lockedAt?: true
    sentAt?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutboxEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboxEvent to aggregate.
     */
    where?: OutboxEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboxEvents to fetch.
     */
    orderBy?: OutboxEventOrderByWithRelationInput | OutboxEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutboxEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboxEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboxEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutboxEvents
    **/
    _count?: true | OutboxEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutboxEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutboxEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutboxEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutboxEventMaxAggregateInputType
  }

  export type GetOutboxEventAggregateType<T extends OutboxEventAggregateArgs> = {
        [P in keyof T & keyof AggregateOutboxEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutboxEvent[P]>
      : GetScalarType<T[P], AggregateOutboxEvent[P]>
  }




  export type OutboxEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboxEventWhereInput
    orderBy?: OutboxEventOrderByWithAggregationInput | OutboxEventOrderByWithAggregationInput[]
    by: OutboxEventScalarFieldEnum[] | OutboxEventScalarFieldEnum
    having?: OutboxEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutboxEventCountAggregateInputType | true
    _avg?: OutboxEventAvgAggregateInputType
    _sum?: OutboxEventSumAggregateInputType
    _min?: OutboxEventMinAggregateInputType
    _max?: OutboxEventMaxAggregateInputType
  }

  export type OutboxEventGroupByOutputType = {
    id: string
    topic: string
    key: string | null
    payload: JsonValue
    status: $Enums.OutboxStatus
    attempts: number
    availableAt: Date
    lockedAt: Date | null
    sentAt: Date | null
    error: string | null
    createdAt: Date
    updatedAt: Date
    _count: OutboxEventCountAggregateOutputType | null
    _avg: OutboxEventAvgAggregateOutputType | null
    _sum: OutboxEventSumAggregateOutputType | null
    _min: OutboxEventMinAggregateOutputType | null
    _max: OutboxEventMaxAggregateOutputType | null
  }

  type GetOutboxEventGroupByPayload<T extends OutboxEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutboxEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutboxEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutboxEventGroupByOutputType[P]>
            : GetScalarType<T[P], OutboxEventGroupByOutputType[P]>
        }
      >
    >


  export type OutboxEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    key?: boolean
    payload?: boolean
    status?: boolean
    attempts?: boolean
    availableAt?: boolean
    lockedAt?: boolean
    sentAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["outboxEvent"]>

  export type OutboxEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    key?: boolean
    payload?: boolean
    status?: boolean
    attempts?: boolean
    availableAt?: boolean
    lockedAt?: boolean
    sentAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["outboxEvent"]>

  export type OutboxEventSelectScalar = {
    id?: boolean
    topic?: boolean
    key?: boolean
    payload?: boolean
    status?: boolean
    attempts?: boolean
    availableAt?: boolean
    lockedAt?: boolean
    sentAt?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $OutboxEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutboxEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topic: string
      key: string | null
      payload: Prisma.JsonValue
      status: $Enums.OutboxStatus
      attempts: number
      availableAt: Date
      lockedAt: Date | null
      sentAt: Date | null
      error: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["outboxEvent"]>
    composites: {}
  }

  type OutboxEventGetPayload<S extends boolean | null | undefined | OutboxEventDefaultArgs> = $Result.GetResult<Prisma.$OutboxEventPayload, S>

  type OutboxEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OutboxEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OutboxEventCountAggregateInputType | true
    }

  export interface OutboxEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutboxEvent'], meta: { name: 'OutboxEvent' } }
    /**
     * Find zero or one OutboxEvent that matches the filter.
     * @param {OutboxEventFindUniqueArgs} args - Arguments to find a OutboxEvent
     * @example
     * // Get one OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutboxEventFindUniqueArgs>(args: SelectSubset<T, OutboxEventFindUniqueArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OutboxEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OutboxEventFindUniqueOrThrowArgs} args - Arguments to find a OutboxEvent
     * @example
     * // Get one OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutboxEventFindUniqueOrThrowArgs>(args: SelectSubset<T, OutboxEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OutboxEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventFindFirstArgs} args - Arguments to find a OutboxEvent
     * @example
     * // Get one OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutboxEventFindFirstArgs>(args?: SelectSubset<T, OutboxEventFindFirstArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OutboxEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventFindFirstOrThrowArgs} args - Arguments to find a OutboxEvent
     * @example
     * // Get one OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutboxEventFindFirstOrThrowArgs>(args?: SelectSubset<T, OutboxEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OutboxEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutboxEvents
     * const outboxEvents = await prisma.outboxEvent.findMany()
     * 
     * // Get first 10 OutboxEvents
     * const outboxEvents = await prisma.outboxEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outboxEventWithIdOnly = await prisma.outboxEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutboxEventFindManyArgs>(args?: SelectSubset<T, OutboxEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OutboxEvent.
     * @param {OutboxEventCreateArgs} args - Arguments to create a OutboxEvent.
     * @example
     * // Create one OutboxEvent
     * const OutboxEvent = await prisma.outboxEvent.create({
     *   data: {
     *     // ... data to create a OutboxEvent
     *   }
     * })
     * 
     */
    create<T extends OutboxEventCreateArgs>(args: SelectSubset<T, OutboxEventCreateArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OutboxEvents.
     * @param {OutboxEventCreateManyArgs} args - Arguments to create many OutboxEvents.
     * @example
     * // Create many OutboxEvents
     * const outboxEvent = await prisma.outboxEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutboxEventCreateManyArgs>(args?: SelectSubset<T, OutboxEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutboxEvents and returns the data saved in the database.
     * @param {OutboxEventCreateManyAndReturnArgs} args - Arguments to create many OutboxEvents.
     * @example
     * // Create many OutboxEvents
     * const outboxEvent = await prisma.outboxEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutboxEvents and only return the `id`
     * const outboxEventWithIdOnly = await prisma.outboxEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutboxEventCreateManyAndReturnArgs>(args?: SelectSubset<T, OutboxEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OutboxEvent.
     * @param {OutboxEventDeleteArgs} args - Arguments to delete one OutboxEvent.
     * @example
     * // Delete one OutboxEvent
     * const OutboxEvent = await prisma.outboxEvent.delete({
     *   where: {
     *     // ... filter to delete one OutboxEvent
     *   }
     * })
     * 
     */
    delete<T extends OutboxEventDeleteArgs>(args: SelectSubset<T, OutboxEventDeleteArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OutboxEvent.
     * @param {OutboxEventUpdateArgs} args - Arguments to update one OutboxEvent.
     * @example
     * // Update one OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutboxEventUpdateArgs>(args: SelectSubset<T, OutboxEventUpdateArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OutboxEvents.
     * @param {OutboxEventDeleteManyArgs} args - Arguments to filter OutboxEvents to delete.
     * @example
     * // Delete a few OutboxEvents
     * const { count } = await prisma.outboxEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutboxEventDeleteManyArgs>(args?: SelectSubset<T, OutboxEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutboxEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutboxEvents
     * const outboxEvent = await prisma.outboxEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutboxEventUpdateManyArgs>(args: SelectSubset<T, OutboxEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OutboxEvent.
     * @param {OutboxEventUpsertArgs} args - Arguments to update or create a OutboxEvent.
     * @example
     * // Update or create a OutboxEvent
     * const outboxEvent = await prisma.outboxEvent.upsert({
     *   create: {
     *     // ... data to create a OutboxEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutboxEvent we want to update
     *   }
     * })
     */
    upsert<T extends OutboxEventUpsertArgs>(args: SelectSubset<T, OutboxEventUpsertArgs<ExtArgs>>): Prisma__OutboxEventClient<$Result.GetResult<Prisma.$OutboxEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OutboxEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventCountArgs} args - Arguments to filter OutboxEvents to count.
     * @example
     * // Count the number of OutboxEvents
     * const count = await prisma.outboxEvent.count({
     *   where: {
     *     // ... the filter for the OutboxEvents we want to count
     *   }
     * })
    **/
    count<T extends OutboxEventCountArgs>(
      args?: Subset<T, OutboxEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutboxEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutboxEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutboxEventAggregateArgs>(args: Subset<T, OutboxEventAggregateArgs>): Prisma.PrismaPromise<GetOutboxEventAggregateType<T>>

    /**
     * Group by OutboxEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutboxEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutboxEventGroupByArgs['orderBy'] }
        : { orderBy?: OutboxEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutboxEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutboxEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutboxEvent model
   */
  readonly fields: OutboxEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutboxEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutboxEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutboxEvent model
   */ 
  interface OutboxEventFieldRefs {
    readonly id: FieldRef<"OutboxEvent", 'String'>
    readonly topic: FieldRef<"OutboxEvent", 'String'>
    readonly key: FieldRef<"OutboxEvent", 'String'>
    readonly payload: FieldRef<"OutboxEvent", 'Json'>
    readonly status: FieldRef<"OutboxEvent", 'OutboxStatus'>
    readonly attempts: FieldRef<"OutboxEvent", 'Int'>
    readonly availableAt: FieldRef<"OutboxEvent", 'DateTime'>
    readonly lockedAt: FieldRef<"OutboxEvent", 'DateTime'>
    readonly sentAt: FieldRef<"OutboxEvent", 'DateTime'>
    readonly error: FieldRef<"OutboxEvent", 'String'>
    readonly createdAt: FieldRef<"OutboxEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"OutboxEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutboxEvent findUnique
   */
  export type OutboxEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter, which OutboxEvent to fetch.
     */
    where: OutboxEventWhereUniqueInput
  }

  /**
   * OutboxEvent findUniqueOrThrow
   */
  export type OutboxEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter, which OutboxEvent to fetch.
     */
    where: OutboxEventWhereUniqueInput
  }

  /**
   * OutboxEvent findFirst
   */
  export type OutboxEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter, which OutboxEvent to fetch.
     */
    where?: OutboxEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboxEvents to fetch.
     */
    orderBy?: OutboxEventOrderByWithRelationInput | OutboxEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboxEvents.
     */
    cursor?: OutboxEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboxEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboxEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboxEvents.
     */
    distinct?: OutboxEventScalarFieldEnum | OutboxEventScalarFieldEnum[]
  }

  /**
   * OutboxEvent findFirstOrThrow
   */
  export type OutboxEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter, which OutboxEvent to fetch.
     */
    where?: OutboxEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboxEvents to fetch.
     */
    orderBy?: OutboxEventOrderByWithRelationInput | OutboxEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutboxEvents.
     */
    cursor?: OutboxEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboxEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboxEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutboxEvents.
     */
    distinct?: OutboxEventScalarFieldEnum | OutboxEventScalarFieldEnum[]
  }

  /**
   * OutboxEvent findMany
   */
  export type OutboxEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter, which OutboxEvents to fetch.
     */
    where?: OutboxEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutboxEvents to fetch.
     */
    orderBy?: OutboxEventOrderByWithRelationInput | OutboxEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutboxEvents.
     */
    cursor?: OutboxEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutboxEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutboxEvents.
     */
    skip?: number
    distinct?: OutboxEventScalarFieldEnum | OutboxEventScalarFieldEnum[]
  }

  /**
   * OutboxEvent create
   */
  export type OutboxEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * The data needed to create a OutboxEvent.
     */
    data: XOR<OutboxEventCreateInput, OutboxEventUncheckedCreateInput>
  }

  /**
   * OutboxEvent createMany
   */
  export type OutboxEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutboxEvents.
     */
    data: OutboxEventCreateManyInput | OutboxEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutboxEvent createManyAndReturn
   */
  export type OutboxEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OutboxEvents.
     */
    data: OutboxEventCreateManyInput | OutboxEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutboxEvent update
   */
  export type OutboxEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * The data needed to update a OutboxEvent.
     */
    data: XOR<OutboxEventUpdateInput, OutboxEventUncheckedUpdateInput>
    /**
     * Choose, which OutboxEvent to update.
     */
    where: OutboxEventWhereUniqueInput
  }

  /**
   * OutboxEvent updateMany
   */
  export type OutboxEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutboxEvents.
     */
    data: XOR<OutboxEventUpdateManyMutationInput, OutboxEventUncheckedUpdateManyInput>
    /**
     * Filter which OutboxEvents to update
     */
    where?: OutboxEventWhereInput
  }

  /**
   * OutboxEvent upsert
   */
  export type OutboxEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * The filter to search for the OutboxEvent to update in case it exists.
     */
    where: OutboxEventWhereUniqueInput
    /**
     * In case the OutboxEvent found by the `where` argument doesn't exist, create a new OutboxEvent with this data.
     */
    create: XOR<OutboxEventCreateInput, OutboxEventUncheckedCreateInput>
    /**
     * In case the OutboxEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutboxEventUpdateInput, OutboxEventUncheckedUpdateInput>
  }

  /**
   * OutboxEvent delete
   */
  export type OutboxEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
    /**
     * Filter which OutboxEvent to delete.
     */
    where: OutboxEventWhereUniqueInput
  }

  /**
   * OutboxEvent deleteMany
   */
  export type OutboxEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutboxEvents to delete
     */
    where?: OutboxEventWhereInput
  }

  /**
   * OutboxEvent without action
   */
  export type OutboxEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutboxEvent
     */
    select?: OutboxEventSelect<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    code: number
    name: number
    category: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    code: string
    name: string
    category: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleGrants?: boolean | Permission$roleGrantsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleGrants?: boolean | Permission$roleGrantsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roleGrants: Prisma.$RoleTemplatePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      category: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roleGrants<T extends Permission$roleGrantsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$roleGrantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly code: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly category: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.roleGrants
   */
  export type Permission$roleGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    where?: RoleTemplatePermissionWhereInput
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    cursor?: RoleTemplatePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleTemplatePermissionScalarFieldEnum | RoleTemplatePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RoleTemplate
   */

  export type AggregateRoleTemplate = {
    _count: RoleTemplateCountAggregateOutputType | null
    _min: RoleTemplateMinAggregateOutputType | null
    _max: RoleTemplateMaxAggregateOutputType | null
  }

  export type RoleTemplateMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    scope: $Enums.RoleScope | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplateMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    scope: $Enums.RoleScope | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplateCountAggregateOutputType = {
    id: number
    code: number
    name: number
    scope: number
    description: number
    isSystem: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleTemplateMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    scope?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplateMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    scope?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplateCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    scope?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplate to aggregate.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleTemplates
    **/
    _count?: true | RoleTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleTemplateMaxAggregateInputType
  }

  export type GetRoleTemplateAggregateType<T extends RoleTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleTemplate[P]>
      : GetScalarType<T[P], AggregateRoleTemplate[P]>
  }




  export type RoleTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplateWhereInput
    orderBy?: RoleTemplateOrderByWithAggregationInput | RoleTemplateOrderByWithAggregationInput[]
    by: RoleTemplateScalarFieldEnum[] | RoleTemplateScalarFieldEnum
    having?: RoleTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleTemplateCountAggregateInputType | true
    _min?: RoleTemplateMinAggregateInputType
    _max?: RoleTemplateMaxAggregateInputType
  }

  export type RoleTemplateGroupByOutputType = {
    id: string
    code: string
    name: string
    scope: $Enums.RoleScope
    description: string | null
    isSystem: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleTemplateCountAggregateOutputType | null
    _min: RoleTemplateMinAggregateOutputType | null
    _max: RoleTemplateMaxAggregateOutputType | null
  }

  type GetRoleTemplateGroupByPayload<T extends RoleTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], RoleTemplateGroupByOutputType[P]>
        }
      >
    >


  export type RoleTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    scope?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    versions?: boolean | RoleTemplate$versionsArgs<ExtArgs>
    _count?: boolean | RoleTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleTemplate"]>

  export type RoleTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    scope?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["roleTemplate"]>

  export type RoleTemplateSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    scope?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | RoleTemplate$versionsArgs<ExtArgs>
    _count?: boolean | RoleTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoleTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleTemplate"
    objects: {
      versions: Prisma.$RoleTemplateVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      scope: $Enums.RoleScope
      description: string | null
      isSystem: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roleTemplate"]>
    composites: {}
  }

  type RoleTemplateGetPayload<S extends boolean | null | undefined | RoleTemplateDefaultArgs> = $Result.GetResult<Prisma.$RoleTemplatePayload, S>

  type RoleTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleTemplateCountAggregateInputType | true
    }

  export interface RoleTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleTemplate'], meta: { name: 'RoleTemplate' } }
    /**
     * Find zero or one RoleTemplate that matches the filter.
     * @param {RoleTemplateFindUniqueArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleTemplateFindUniqueArgs>(args: SelectSubset<T, RoleTemplateFindUniqueArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoleTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleTemplateFindUniqueOrThrowArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoleTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateFindFirstArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleTemplateFindFirstArgs>(args?: SelectSubset<T, RoleTemplateFindFirstArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoleTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateFindFirstOrThrowArgs} args - Arguments to find a RoleTemplate
     * @example
     * // Get one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoleTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleTemplates
     * const roleTemplates = await prisma.roleTemplate.findMany()
     * 
     * // Get first 10 RoleTemplates
     * const roleTemplates = await prisma.roleTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleTemplateWithIdOnly = await prisma.roleTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleTemplateFindManyArgs>(args?: SelectSubset<T, RoleTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoleTemplate.
     * @param {RoleTemplateCreateArgs} args - Arguments to create a RoleTemplate.
     * @example
     * // Create one RoleTemplate
     * const RoleTemplate = await prisma.roleTemplate.create({
     *   data: {
     *     // ... data to create a RoleTemplate
     *   }
     * })
     * 
     */
    create<T extends RoleTemplateCreateArgs>(args: SelectSubset<T, RoleTemplateCreateArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoleTemplates.
     * @param {RoleTemplateCreateManyArgs} args - Arguments to create many RoleTemplates.
     * @example
     * // Create many RoleTemplates
     * const roleTemplate = await prisma.roleTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleTemplateCreateManyArgs>(args?: SelectSubset<T, RoleTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleTemplates and returns the data saved in the database.
     * @param {RoleTemplateCreateManyAndReturnArgs} args - Arguments to create many RoleTemplates.
     * @example
     * // Create many RoleTemplates
     * const roleTemplate = await prisma.roleTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleTemplates and only return the `id`
     * const roleTemplateWithIdOnly = await prisma.roleTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoleTemplate.
     * @param {RoleTemplateDeleteArgs} args - Arguments to delete one RoleTemplate.
     * @example
     * // Delete one RoleTemplate
     * const RoleTemplate = await prisma.roleTemplate.delete({
     *   where: {
     *     // ... filter to delete one RoleTemplate
     *   }
     * })
     * 
     */
    delete<T extends RoleTemplateDeleteArgs>(args: SelectSubset<T, RoleTemplateDeleteArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoleTemplate.
     * @param {RoleTemplateUpdateArgs} args - Arguments to update one RoleTemplate.
     * @example
     * // Update one RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleTemplateUpdateArgs>(args: SelectSubset<T, RoleTemplateUpdateArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoleTemplates.
     * @param {RoleTemplateDeleteManyArgs} args - Arguments to filter RoleTemplates to delete.
     * @example
     * // Delete a few RoleTemplates
     * const { count } = await prisma.roleTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleTemplateDeleteManyArgs>(args?: SelectSubset<T, RoleTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleTemplates
     * const roleTemplate = await prisma.roleTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleTemplateUpdateManyArgs>(args: SelectSubset<T, RoleTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleTemplate.
     * @param {RoleTemplateUpsertArgs} args - Arguments to update or create a RoleTemplate.
     * @example
     * // Update or create a RoleTemplate
     * const roleTemplate = await prisma.roleTemplate.upsert({
     *   create: {
     *     // ... data to create a RoleTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleTemplate we want to update
     *   }
     * })
     */
    upsert<T extends RoleTemplateUpsertArgs>(args: SelectSubset<T, RoleTemplateUpsertArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoleTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateCountArgs} args - Arguments to filter RoleTemplates to count.
     * @example
     * // Count the number of RoleTemplates
     * const count = await prisma.roleTemplate.count({
     *   where: {
     *     // ... the filter for the RoleTemplates we want to count
     *   }
     * })
    **/
    count<T extends RoleTemplateCountArgs>(
      args?: Subset<T, RoleTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleTemplateAggregateArgs>(args: Subset<T, RoleTemplateAggregateArgs>): Prisma.PrismaPromise<GetRoleTemplateAggregateType<T>>

    /**
     * Group by RoleTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleTemplateGroupByArgs['orderBy'] }
        : { orderBy?: RoleTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleTemplate model
   */
  readonly fields: RoleTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    versions<T extends RoleTemplate$versionsArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplate$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleTemplate model
   */ 
  interface RoleTemplateFieldRefs {
    readonly id: FieldRef<"RoleTemplate", 'String'>
    readonly code: FieldRef<"RoleTemplate", 'String'>
    readonly name: FieldRef<"RoleTemplate", 'String'>
    readonly scope: FieldRef<"RoleTemplate", 'RoleScope'>
    readonly description: FieldRef<"RoleTemplate", 'String'>
    readonly isSystem: FieldRef<"RoleTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"RoleTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleTemplate findUnique
   */
  export type RoleTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate findUniqueOrThrow
   */
  export type RoleTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate findFirst
   */
  export type RoleTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplates.
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplates.
     */
    distinct?: RoleTemplateScalarFieldEnum | RoleTemplateScalarFieldEnum[]
  }

  /**
   * RoleTemplate findFirstOrThrow
   */
  export type RoleTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplate to fetch.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplates.
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplates.
     */
    distinct?: RoleTemplateScalarFieldEnum | RoleTemplateScalarFieldEnum[]
  }

  /**
   * RoleTemplate findMany
   */
  export type RoleTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplates to fetch.
     */
    where?: RoleTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplates to fetch.
     */
    orderBy?: RoleTemplateOrderByWithRelationInput | RoleTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleTemplates.
     */
    cursor?: RoleTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplates.
     */
    skip?: number
    distinct?: RoleTemplateScalarFieldEnum | RoleTemplateScalarFieldEnum[]
  }

  /**
   * RoleTemplate create
   */
  export type RoleTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleTemplate.
     */
    data: XOR<RoleTemplateCreateInput, RoleTemplateUncheckedCreateInput>
  }

  /**
   * RoleTemplate createMany
   */
  export type RoleTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleTemplates.
     */
    data: RoleTemplateCreateManyInput | RoleTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleTemplate createManyAndReturn
   */
  export type RoleTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoleTemplates.
     */
    data: RoleTemplateCreateManyInput | RoleTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleTemplate update
   */
  export type RoleTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleTemplate.
     */
    data: XOR<RoleTemplateUpdateInput, RoleTemplateUncheckedUpdateInput>
    /**
     * Choose, which RoleTemplate to update.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate updateMany
   */
  export type RoleTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleTemplates.
     */
    data: XOR<RoleTemplateUpdateManyMutationInput, RoleTemplateUncheckedUpdateManyInput>
    /**
     * Filter which RoleTemplates to update
     */
    where?: RoleTemplateWhereInput
  }

  /**
   * RoleTemplate upsert
   */
  export type RoleTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleTemplate to update in case it exists.
     */
    where: RoleTemplateWhereUniqueInput
    /**
     * In case the RoleTemplate found by the `where` argument doesn't exist, create a new RoleTemplate with this data.
     */
    create: XOR<RoleTemplateCreateInput, RoleTemplateUncheckedCreateInput>
    /**
     * In case the RoleTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleTemplateUpdateInput, RoleTemplateUncheckedUpdateInput>
  }

  /**
   * RoleTemplate delete
   */
  export type RoleTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
    /**
     * Filter which RoleTemplate to delete.
     */
    where: RoleTemplateWhereUniqueInput
  }

  /**
   * RoleTemplate deleteMany
   */
  export type RoleTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplates to delete
     */
    where?: RoleTemplateWhereInput
  }

  /**
   * RoleTemplate.versions
   */
  export type RoleTemplate$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    where?: RoleTemplateVersionWhereInput
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    cursor?: RoleTemplateVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleTemplateVersionScalarFieldEnum | RoleTemplateVersionScalarFieldEnum[]
  }

  /**
   * RoleTemplate without action
   */
  export type RoleTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplate
     */
    select?: RoleTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateInclude<ExtArgs> | null
  }


  /**
   * Model RoleTemplateVersion
   */

  export type AggregateRoleTemplateVersion = {
    _count: RoleTemplateVersionCountAggregateOutputType | null
    _avg: RoleTemplateVersionAvgAggregateOutputType | null
    _sum: RoleTemplateVersionSumAggregateOutputType | null
    _min: RoleTemplateVersionMinAggregateOutputType | null
    _max: RoleTemplateVersionMaxAggregateOutputType | null
  }

  export type RoleTemplateVersionAvgAggregateOutputType = {
    version: number | null
  }

  export type RoleTemplateVersionSumAggregateOutputType = {
    version: number | null
  }

  export type RoleTemplateVersionMinAggregateOutputType = {
    id: string | null
    roleTemplateId: string | null
    version: number | null
    status: $Enums.RoleVersionStatus | null
    notes: string | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplateVersionMaxAggregateOutputType = {
    id: string | null
    roleTemplateId: string | null
    version: number | null
    status: $Enums.RoleVersionStatus | null
    notes: string | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplateVersionCountAggregateOutputType = {
    id: number
    roleTemplateId: number
    version: number
    status: number
    notes: number
    createdByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleTemplateVersionAvgAggregateInputType = {
    version?: true
  }

  export type RoleTemplateVersionSumAggregateInputType = {
    version?: true
  }

  export type RoleTemplateVersionMinAggregateInputType = {
    id?: true
    roleTemplateId?: true
    version?: true
    status?: true
    notes?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplateVersionMaxAggregateInputType = {
    id?: true
    roleTemplateId?: true
    version?: true
    status?: true
    notes?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplateVersionCountAggregateInputType = {
    id?: true
    roleTemplateId?: true
    version?: true
    status?: true
    notes?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleTemplateVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplateVersion to aggregate.
     */
    where?: RoleTemplateVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplateVersions to fetch.
     */
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleTemplateVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplateVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplateVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleTemplateVersions
    **/
    _count?: true | RoleTemplateVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleTemplateVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleTemplateVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleTemplateVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleTemplateVersionMaxAggregateInputType
  }

  export type GetRoleTemplateVersionAggregateType<T extends RoleTemplateVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleTemplateVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleTemplateVersion[P]>
      : GetScalarType<T[P], AggregateRoleTemplateVersion[P]>
  }




  export type RoleTemplateVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplateVersionWhereInput
    orderBy?: RoleTemplateVersionOrderByWithAggregationInput | RoleTemplateVersionOrderByWithAggregationInput[]
    by: RoleTemplateVersionScalarFieldEnum[] | RoleTemplateVersionScalarFieldEnum
    having?: RoleTemplateVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleTemplateVersionCountAggregateInputType | true
    _avg?: RoleTemplateVersionAvgAggregateInputType
    _sum?: RoleTemplateVersionSumAggregateInputType
    _min?: RoleTemplateVersionMinAggregateInputType
    _max?: RoleTemplateVersionMaxAggregateInputType
  }

  export type RoleTemplateVersionGroupByOutputType = {
    id: string
    roleTemplateId: string
    version: number
    status: $Enums.RoleVersionStatus
    notes: string | null
    createdByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleTemplateVersionCountAggregateOutputType | null
    _avg: RoleTemplateVersionAvgAggregateOutputType | null
    _sum: RoleTemplateVersionSumAggregateOutputType | null
    _min: RoleTemplateVersionMinAggregateOutputType | null
    _max: RoleTemplateVersionMaxAggregateOutputType | null
  }

  type GetRoleTemplateVersionGroupByPayload<T extends RoleTemplateVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleTemplateVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleTemplateVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleTemplateVersionGroupByOutputType[P]>
            : GetScalarType<T[P], RoleTemplateVersionGroupByOutputType[P]>
        }
      >
    >


  export type RoleTemplateVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleTemplateId?: boolean
    version?: boolean
    status?: boolean
    notes?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleTemplate?: boolean | RoleTemplateDefaultArgs<ExtArgs>
    createdByUser?: boolean | RoleTemplateVersion$createdByUserArgs<ExtArgs>
    permissions?: boolean | RoleTemplateVersion$permissionsArgs<ExtArgs>
    users?: boolean | RoleTemplateVersion$usersArgs<ExtArgs>
    _count?: boolean | RoleTemplateVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleTemplateVersion"]>

  export type RoleTemplateVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleTemplateId?: boolean
    version?: boolean
    status?: boolean
    notes?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleTemplate?: boolean | RoleTemplateDefaultArgs<ExtArgs>
    createdByUser?: boolean | RoleTemplateVersion$createdByUserArgs<ExtArgs>
  }, ExtArgs["result"]["roleTemplateVersion"]>

  export type RoleTemplateVersionSelectScalar = {
    id?: boolean
    roleTemplateId?: boolean
    version?: boolean
    status?: boolean
    notes?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleTemplateVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleTemplate?: boolean | RoleTemplateDefaultArgs<ExtArgs>
    createdByUser?: boolean | RoleTemplateVersion$createdByUserArgs<ExtArgs>
    permissions?: boolean | RoleTemplateVersion$permissionsArgs<ExtArgs>
    users?: boolean | RoleTemplateVersion$usersArgs<ExtArgs>
    _count?: boolean | RoleTemplateVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleTemplateVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleTemplate?: boolean | RoleTemplateDefaultArgs<ExtArgs>
    createdByUser?: boolean | RoleTemplateVersion$createdByUserArgs<ExtArgs>
  }

  export type $RoleTemplateVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleTemplateVersion"
    objects: {
      roleTemplate: Prisma.$RoleTemplatePayload<ExtArgs>
      createdByUser: Prisma.$UserPayload<ExtArgs> | null
      permissions: Prisma.$RoleTemplatePermissionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleTemplateId: string
      version: number
      status: $Enums.RoleVersionStatus
      notes: string | null
      createdByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roleTemplateVersion"]>
    composites: {}
  }

  type RoleTemplateVersionGetPayload<S extends boolean | null | undefined | RoleTemplateVersionDefaultArgs> = $Result.GetResult<Prisma.$RoleTemplateVersionPayload, S>

  type RoleTemplateVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleTemplateVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleTemplateVersionCountAggregateInputType | true
    }

  export interface RoleTemplateVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleTemplateVersion'], meta: { name: 'RoleTemplateVersion' } }
    /**
     * Find zero or one RoleTemplateVersion that matches the filter.
     * @param {RoleTemplateVersionFindUniqueArgs} args - Arguments to find a RoleTemplateVersion
     * @example
     * // Get one RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleTemplateVersionFindUniqueArgs>(args: SelectSubset<T, RoleTemplateVersionFindUniqueArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoleTemplateVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleTemplateVersionFindUniqueOrThrowArgs} args - Arguments to find a RoleTemplateVersion
     * @example
     * // Get one RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleTemplateVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleTemplateVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoleTemplateVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionFindFirstArgs} args - Arguments to find a RoleTemplateVersion
     * @example
     * // Get one RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleTemplateVersionFindFirstArgs>(args?: SelectSubset<T, RoleTemplateVersionFindFirstArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoleTemplateVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionFindFirstOrThrowArgs} args - Arguments to find a RoleTemplateVersion
     * @example
     * // Get one RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleTemplateVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleTemplateVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoleTemplateVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleTemplateVersions
     * const roleTemplateVersions = await prisma.roleTemplateVersion.findMany()
     * 
     * // Get first 10 RoleTemplateVersions
     * const roleTemplateVersions = await prisma.roleTemplateVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleTemplateVersionWithIdOnly = await prisma.roleTemplateVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleTemplateVersionFindManyArgs>(args?: SelectSubset<T, RoleTemplateVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoleTemplateVersion.
     * @param {RoleTemplateVersionCreateArgs} args - Arguments to create a RoleTemplateVersion.
     * @example
     * // Create one RoleTemplateVersion
     * const RoleTemplateVersion = await prisma.roleTemplateVersion.create({
     *   data: {
     *     // ... data to create a RoleTemplateVersion
     *   }
     * })
     * 
     */
    create<T extends RoleTemplateVersionCreateArgs>(args: SelectSubset<T, RoleTemplateVersionCreateArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoleTemplateVersions.
     * @param {RoleTemplateVersionCreateManyArgs} args - Arguments to create many RoleTemplateVersions.
     * @example
     * // Create many RoleTemplateVersions
     * const roleTemplateVersion = await prisma.roleTemplateVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleTemplateVersionCreateManyArgs>(args?: SelectSubset<T, RoleTemplateVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleTemplateVersions and returns the data saved in the database.
     * @param {RoleTemplateVersionCreateManyAndReturnArgs} args - Arguments to create many RoleTemplateVersions.
     * @example
     * // Create many RoleTemplateVersions
     * const roleTemplateVersion = await prisma.roleTemplateVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleTemplateVersions and only return the `id`
     * const roleTemplateVersionWithIdOnly = await prisma.roleTemplateVersion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleTemplateVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleTemplateVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoleTemplateVersion.
     * @param {RoleTemplateVersionDeleteArgs} args - Arguments to delete one RoleTemplateVersion.
     * @example
     * // Delete one RoleTemplateVersion
     * const RoleTemplateVersion = await prisma.roleTemplateVersion.delete({
     *   where: {
     *     // ... filter to delete one RoleTemplateVersion
     *   }
     * })
     * 
     */
    delete<T extends RoleTemplateVersionDeleteArgs>(args: SelectSubset<T, RoleTemplateVersionDeleteArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoleTemplateVersion.
     * @param {RoleTemplateVersionUpdateArgs} args - Arguments to update one RoleTemplateVersion.
     * @example
     * // Update one RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleTemplateVersionUpdateArgs>(args: SelectSubset<T, RoleTemplateVersionUpdateArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoleTemplateVersions.
     * @param {RoleTemplateVersionDeleteManyArgs} args - Arguments to filter RoleTemplateVersions to delete.
     * @example
     * // Delete a few RoleTemplateVersions
     * const { count } = await prisma.roleTemplateVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleTemplateVersionDeleteManyArgs>(args?: SelectSubset<T, RoleTemplateVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleTemplateVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleTemplateVersions
     * const roleTemplateVersion = await prisma.roleTemplateVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleTemplateVersionUpdateManyArgs>(args: SelectSubset<T, RoleTemplateVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleTemplateVersion.
     * @param {RoleTemplateVersionUpsertArgs} args - Arguments to update or create a RoleTemplateVersion.
     * @example
     * // Update or create a RoleTemplateVersion
     * const roleTemplateVersion = await prisma.roleTemplateVersion.upsert({
     *   create: {
     *     // ... data to create a RoleTemplateVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleTemplateVersion we want to update
     *   }
     * })
     */
    upsert<T extends RoleTemplateVersionUpsertArgs>(args: SelectSubset<T, RoleTemplateVersionUpsertArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoleTemplateVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionCountArgs} args - Arguments to filter RoleTemplateVersions to count.
     * @example
     * // Count the number of RoleTemplateVersions
     * const count = await prisma.roleTemplateVersion.count({
     *   where: {
     *     // ... the filter for the RoleTemplateVersions we want to count
     *   }
     * })
    **/
    count<T extends RoleTemplateVersionCountArgs>(
      args?: Subset<T, RoleTemplateVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleTemplateVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleTemplateVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleTemplateVersionAggregateArgs>(args: Subset<T, RoleTemplateVersionAggregateArgs>): Prisma.PrismaPromise<GetRoleTemplateVersionAggregateType<T>>

    /**
     * Group by RoleTemplateVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplateVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleTemplateVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleTemplateVersionGroupByArgs['orderBy'] }
        : { orderBy?: RoleTemplateVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleTemplateVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleTemplateVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleTemplateVersion model
   */
  readonly fields: RoleTemplateVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleTemplateVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleTemplateVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roleTemplate<T extends RoleTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplateDefaultArgs<ExtArgs>>): Prisma__RoleTemplateClient<$Result.GetResult<Prisma.$RoleTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdByUser<T extends RoleTemplateVersion$createdByUserArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplateVersion$createdByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    permissions<T extends RoleTemplateVersion$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplateVersion$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends RoleTemplateVersion$usersArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplateVersion$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleTemplateVersion model
   */ 
  interface RoleTemplateVersionFieldRefs {
    readonly id: FieldRef<"RoleTemplateVersion", 'String'>
    readonly roleTemplateId: FieldRef<"RoleTemplateVersion", 'String'>
    readonly version: FieldRef<"RoleTemplateVersion", 'Int'>
    readonly status: FieldRef<"RoleTemplateVersion", 'RoleVersionStatus'>
    readonly notes: FieldRef<"RoleTemplateVersion", 'String'>
    readonly createdByUserId: FieldRef<"RoleTemplateVersion", 'String'>
    readonly createdAt: FieldRef<"RoleTemplateVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleTemplateVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleTemplateVersion findUnique
   */
  export type RoleTemplateVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplateVersion to fetch.
     */
    where: RoleTemplateVersionWhereUniqueInput
  }

  /**
   * RoleTemplateVersion findUniqueOrThrow
   */
  export type RoleTemplateVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplateVersion to fetch.
     */
    where: RoleTemplateVersionWhereUniqueInput
  }

  /**
   * RoleTemplateVersion findFirst
   */
  export type RoleTemplateVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplateVersion to fetch.
     */
    where?: RoleTemplateVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplateVersions to fetch.
     */
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplateVersions.
     */
    cursor?: RoleTemplateVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplateVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplateVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplateVersions.
     */
    distinct?: RoleTemplateVersionScalarFieldEnum | RoleTemplateVersionScalarFieldEnum[]
  }

  /**
   * RoleTemplateVersion findFirstOrThrow
   */
  export type RoleTemplateVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplateVersion to fetch.
     */
    where?: RoleTemplateVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplateVersions to fetch.
     */
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplateVersions.
     */
    cursor?: RoleTemplateVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplateVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplateVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplateVersions.
     */
    distinct?: RoleTemplateVersionScalarFieldEnum | RoleTemplateVersionScalarFieldEnum[]
  }

  /**
   * RoleTemplateVersion findMany
   */
  export type RoleTemplateVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplateVersions to fetch.
     */
    where?: RoleTemplateVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplateVersions to fetch.
     */
    orderBy?: RoleTemplateVersionOrderByWithRelationInput | RoleTemplateVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleTemplateVersions.
     */
    cursor?: RoleTemplateVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplateVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplateVersions.
     */
    skip?: number
    distinct?: RoleTemplateVersionScalarFieldEnum | RoleTemplateVersionScalarFieldEnum[]
  }

  /**
   * RoleTemplateVersion create
   */
  export type RoleTemplateVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleTemplateVersion.
     */
    data: XOR<RoleTemplateVersionCreateInput, RoleTemplateVersionUncheckedCreateInput>
  }

  /**
   * RoleTemplateVersion createMany
   */
  export type RoleTemplateVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleTemplateVersions.
     */
    data: RoleTemplateVersionCreateManyInput | RoleTemplateVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleTemplateVersion createManyAndReturn
   */
  export type RoleTemplateVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoleTemplateVersions.
     */
    data: RoleTemplateVersionCreateManyInput | RoleTemplateVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleTemplateVersion update
   */
  export type RoleTemplateVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleTemplateVersion.
     */
    data: XOR<RoleTemplateVersionUpdateInput, RoleTemplateVersionUncheckedUpdateInput>
    /**
     * Choose, which RoleTemplateVersion to update.
     */
    where: RoleTemplateVersionWhereUniqueInput
  }

  /**
   * RoleTemplateVersion updateMany
   */
  export type RoleTemplateVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleTemplateVersions.
     */
    data: XOR<RoleTemplateVersionUpdateManyMutationInput, RoleTemplateVersionUncheckedUpdateManyInput>
    /**
     * Filter which RoleTemplateVersions to update
     */
    where?: RoleTemplateVersionWhereInput
  }

  /**
   * RoleTemplateVersion upsert
   */
  export type RoleTemplateVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleTemplateVersion to update in case it exists.
     */
    where: RoleTemplateVersionWhereUniqueInput
    /**
     * In case the RoleTemplateVersion found by the `where` argument doesn't exist, create a new RoleTemplateVersion with this data.
     */
    create: XOR<RoleTemplateVersionCreateInput, RoleTemplateVersionUncheckedCreateInput>
    /**
     * In case the RoleTemplateVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleTemplateVersionUpdateInput, RoleTemplateVersionUncheckedUpdateInput>
  }

  /**
   * RoleTemplateVersion delete
   */
  export type RoleTemplateVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
    /**
     * Filter which RoleTemplateVersion to delete.
     */
    where: RoleTemplateVersionWhereUniqueInput
  }

  /**
   * RoleTemplateVersion deleteMany
   */
  export type RoleTemplateVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplateVersions to delete
     */
    where?: RoleTemplateVersionWhereInput
  }

  /**
   * RoleTemplateVersion.createdByUser
   */
  export type RoleTemplateVersion$createdByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RoleTemplateVersion.permissions
   */
  export type RoleTemplateVersion$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    where?: RoleTemplatePermissionWhereInput
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    cursor?: RoleTemplatePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleTemplatePermissionScalarFieldEnum | RoleTemplatePermissionScalarFieldEnum[]
  }

  /**
   * RoleTemplateVersion.users
   */
  export type RoleTemplateVersion$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * RoleTemplateVersion without action
   */
  export type RoleTemplateVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplateVersion
     */
    select?: RoleTemplateVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplateVersionInclude<ExtArgs> | null
  }


  /**
   * Model RoleTemplatePermission
   */

  export type AggregateRoleTemplatePermission = {
    _count: RoleTemplatePermissionCountAggregateOutputType | null
    _min: RoleTemplatePermissionMinAggregateOutputType | null
    _max: RoleTemplatePermissionMaxAggregateOutputType | null
  }

  export type RoleTemplatePermissionMinAggregateOutputType = {
    id: string | null
    roleVersionId: string | null
    permissionId: string | null
    allowed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplatePermissionMaxAggregateOutputType = {
    id: string | null
    roleVersionId: string | null
    permissionId: string | null
    allowed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleTemplatePermissionCountAggregateOutputType = {
    id: number
    roleVersionId: number
    permissionId: number
    allowed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleTemplatePermissionMinAggregateInputType = {
    id?: true
    roleVersionId?: true
    permissionId?: true
    allowed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplatePermissionMaxAggregateInputType = {
    id?: true
    roleVersionId?: true
    permissionId?: true
    allowed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleTemplatePermissionCountAggregateInputType = {
    id?: true
    roleVersionId?: true
    permissionId?: true
    allowed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleTemplatePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplatePermission to aggregate.
     */
    where?: RoleTemplatePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplatePermissions to fetch.
     */
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleTemplatePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplatePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplatePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleTemplatePermissions
    **/
    _count?: true | RoleTemplatePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleTemplatePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleTemplatePermissionMaxAggregateInputType
  }

  export type GetRoleTemplatePermissionAggregateType<T extends RoleTemplatePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleTemplatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleTemplatePermission[P]>
      : GetScalarType<T[P], AggregateRoleTemplatePermission[P]>
  }




  export type RoleTemplatePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleTemplatePermissionWhereInput
    orderBy?: RoleTemplatePermissionOrderByWithAggregationInput | RoleTemplatePermissionOrderByWithAggregationInput[]
    by: RoleTemplatePermissionScalarFieldEnum[] | RoleTemplatePermissionScalarFieldEnum
    having?: RoleTemplatePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleTemplatePermissionCountAggregateInputType | true
    _min?: RoleTemplatePermissionMinAggregateInputType
    _max?: RoleTemplatePermissionMaxAggregateInputType
  }

  export type RoleTemplatePermissionGroupByOutputType = {
    id: string
    roleVersionId: string
    permissionId: string
    allowed: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleTemplatePermissionCountAggregateOutputType | null
    _min: RoleTemplatePermissionMinAggregateOutputType | null
    _max: RoleTemplatePermissionMaxAggregateOutputType | null
  }

  type GetRoleTemplatePermissionGroupByPayload<T extends RoleTemplatePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleTemplatePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleTemplatePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleTemplatePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RoleTemplatePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RoleTemplatePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleVersionId?: boolean
    permissionId?: boolean
    allowed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleVersion?: boolean | RoleTemplateVersionDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleTemplatePermission"]>

  export type RoleTemplatePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleVersionId?: boolean
    permissionId?: boolean
    allowed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleVersion?: boolean | RoleTemplateVersionDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleTemplatePermission"]>

  export type RoleTemplatePermissionSelectScalar = {
    id?: boolean
    roleVersionId?: boolean
    permissionId?: boolean
    allowed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleTemplatePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleVersion?: boolean | RoleTemplateVersionDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RoleTemplatePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleVersion?: boolean | RoleTemplateVersionDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RoleTemplatePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleTemplatePermission"
    objects: {
      roleVersion: Prisma.$RoleTemplateVersionPayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleVersionId: string
      permissionId: string
      allowed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roleTemplatePermission"]>
    composites: {}
  }

  type RoleTemplatePermissionGetPayload<S extends boolean | null | undefined | RoleTemplatePermissionDefaultArgs> = $Result.GetResult<Prisma.$RoleTemplatePermissionPayload, S>

  type RoleTemplatePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleTemplatePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleTemplatePermissionCountAggregateInputType | true
    }

  export interface RoleTemplatePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleTemplatePermission'], meta: { name: 'RoleTemplatePermission' } }
    /**
     * Find zero or one RoleTemplatePermission that matches the filter.
     * @param {RoleTemplatePermissionFindUniqueArgs} args - Arguments to find a RoleTemplatePermission
     * @example
     * // Get one RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleTemplatePermissionFindUniqueArgs>(args: SelectSubset<T, RoleTemplatePermissionFindUniqueArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoleTemplatePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleTemplatePermissionFindUniqueOrThrowArgs} args - Arguments to find a RoleTemplatePermission
     * @example
     * // Get one RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleTemplatePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleTemplatePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoleTemplatePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionFindFirstArgs} args - Arguments to find a RoleTemplatePermission
     * @example
     * // Get one RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleTemplatePermissionFindFirstArgs>(args?: SelectSubset<T, RoleTemplatePermissionFindFirstArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoleTemplatePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionFindFirstOrThrowArgs} args - Arguments to find a RoleTemplatePermission
     * @example
     * // Get one RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleTemplatePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleTemplatePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoleTemplatePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleTemplatePermissions
     * const roleTemplatePermissions = await prisma.roleTemplatePermission.findMany()
     * 
     * // Get first 10 RoleTemplatePermissions
     * const roleTemplatePermissions = await prisma.roleTemplatePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleTemplatePermissionWithIdOnly = await prisma.roleTemplatePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleTemplatePermissionFindManyArgs>(args?: SelectSubset<T, RoleTemplatePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoleTemplatePermission.
     * @param {RoleTemplatePermissionCreateArgs} args - Arguments to create a RoleTemplatePermission.
     * @example
     * // Create one RoleTemplatePermission
     * const RoleTemplatePermission = await prisma.roleTemplatePermission.create({
     *   data: {
     *     // ... data to create a RoleTemplatePermission
     *   }
     * })
     * 
     */
    create<T extends RoleTemplatePermissionCreateArgs>(args: SelectSubset<T, RoleTemplatePermissionCreateArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoleTemplatePermissions.
     * @param {RoleTemplatePermissionCreateManyArgs} args - Arguments to create many RoleTemplatePermissions.
     * @example
     * // Create many RoleTemplatePermissions
     * const roleTemplatePermission = await prisma.roleTemplatePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleTemplatePermissionCreateManyArgs>(args?: SelectSubset<T, RoleTemplatePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleTemplatePermissions and returns the data saved in the database.
     * @param {RoleTemplatePermissionCreateManyAndReturnArgs} args - Arguments to create many RoleTemplatePermissions.
     * @example
     * // Create many RoleTemplatePermissions
     * const roleTemplatePermission = await prisma.roleTemplatePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleTemplatePermissions and only return the `id`
     * const roleTemplatePermissionWithIdOnly = await prisma.roleTemplatePermission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleTemplatePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleTemplatePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoleTemplatePermission.
     * @param {RoleTemplatePermissionDeleteArgs} args - Arguments to delete one RoleTemplatePermission.
     * @example
     * // Delete one RoleTemplatePermission
     * const RoleTemplatePermission = await prisma.roleTemplatePermission.delete({
     *   where: {
     *     // ... filter to delete one RoleTemplatePermission
     *   }
     * })
     * 
     */
    delete<T extends RoleTemplatePermissionDeleteArgs>(args: SelectSubset<T, RoleTemplatePermissionDeleteArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoleTemplatePermission.
     * @param {RoleTemplatePermissionUpdateArgs} args - Arguments to update one RoleTemplatePermission.
     * @example
     * // Update one RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleTemplatePermissionUpdateArgs>(args: SelectSubset<T, RoleTemplatePermissionUpdateArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoleTemplatePermissions.
     * @param {RoleTemplatePermissionDeleteManyArgs} args - Arguments to filter RoleTemplatePermissions to delete.
     * @example
     * // Delete a few RoleTemplatePermissions
     * const { count } = await prisma.roleTemplatePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleTemplatePermissionDeleteManyArgs>(args?: SelectSubset<T, RoleTemplatePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleTemplatePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleTemplatePermissions
     * const roleTemplatePermission = await prisma.roleTemplatePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleTemplatePermissionUpdateManyArgs>(args: SelectSubset<T, RoleTemplatePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoleTemplatePermission.
     * @param {RoleTemplatePermissionUpsertArgs} args - Arguments to update or create a RoleTemplatePermission.
     * @example
     * // Update or create a RoleTemplatePermission
     * const roleTemplatePermission = await prisma.roleTemplatePermission.upsert({
     *   create: {
     *     // ... data to create a RoleTemplatePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleTemplatePermission we want to update
     *   }
     * })
     */
    upsert<T extends RoleTemplatePermissionUpsertArgs>(args: SelectSubset<T, RoleTemplatePermissionUpsertArgs<ExtArgs>>): Prisma__RoleTemplatePermissionClient<$Result.GetResult<Prisma.$RoleTemplatePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoleTemplatePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionCountArgs} args - Arguments to filter RoleTemplatePermissions to count.
     * @example
     * // Count the number of RoleTemplatePermissions
     * const count = await prisma.roleTemplatePermission.count({
     *   where: {
     *     // ... the filter for the RoleTemplatePermissions we want to count
     *   }
     * })
    **/
    count<T extends RoleTemplatePermissionCountArgs>(
      args?: Subset<T, RoleTemplatePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleTemplatePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleTemplatePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleTemplatePermissionAggregateArgs>(args: Subset<T, RoleTemplatePermissionAggregateArgs>): Prisma.PrismaPromise<GetRoleTemplatePermissionAggregateType<T>>

    /**
     * Group by RoleTemplatePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleTemplatePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleTemplatePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleTemplatePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RoleTemplatePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleTemplatePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleTemplatePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleTemplatePermission model
   */
  readonly fields: RoleTemplatePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleTemplatePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleTemplatePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roleVersion<T extends RoleTemplateVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleTemplateVersionDefaultArgs<ExtArgs>>): Prisma__RoleTemplateVersionClient<$Result.GetResult<Prisma.$RoleTemplateVersionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleTemplatePermission model
   */ 
  interface RoleTemplatePermissionFieldRefs {
    readonly id: FieldRef<"RoleTemplatePermission", 'String'>
    readonly roleVersionId: FieldRef<"RoleTemplatePermission", 'String'>
    readonly permissionId: FieldRef<"RoleTemplatePermission", 'String'>
    readonly allowed: FieldRef<"RoleTemplatePermission", 'Boolean'>
    readonly createdAt: FieldRef<"RoleTemplatePermission", 'DateTime'>
    readonly updatedAt: FieldRef<"RoleTemplatePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoleTemplatePermission findUnique
   */
  export type RoleTemplatePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplatePermission to fetch.
     */
    where: RoleTemplatePermissionWhereUniqueInput
  }

  /**
   * RoleTemplatePermission findUniqueOrThrow
   */
  export type RoleTemplatePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplatePermission to fetch.
     */
    where: RoleTemplatePermissionWhereUniqueInput
  }

  /**
   * RoleTemplatePermission findFirst
   */
  export type RoleTemplatePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplatePermission to fetch.
     */
    where?: RoleTemplatePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplatePermissions to fetch.
     */
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplatePermissions.
     */
    cursor?: RoleTemplatePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplatePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplatePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplatePermissions.
     */
    distinct?: RoleTemplatePermissionScalarFieldEnum | RoleTemplatePermissionScalarFieldEnum[]
  }

  /**
   * RoleTemplatePermission findFirstOrThrow
   */
  export type RoleTemplatePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplatePermission to fetch.
     */
    where?: RoleTemplatePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplatePermissions to fetch.
     */
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleTemplatePermissions.
     */
    cursor?: RoleTemplatePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplatePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplatePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleTemplatePermissions.
     */
    distinct?: RoleTemplatePermissionScalarFieldEnum | RoleTemplatePermissionScalarFieldEnum[]
  }

  /**
   * RoleTemplatePermission findMany
   */
  export type RoleTemplatePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RoleTemplatePermissions to fetch.
     */
    where?: RoleTemplatePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleTemplatePermissions to fetch.
     */
    orderBy?: RoleTemplatePermissionOrderByWithRelationInput | RoleTemplatePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleTemplatePermissions.
     */
    cursor?: RoleTemplatePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleTemplatePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleTemplatePermissions.
     */
    skip?: number
    distinct?: RoleTemplatePermissionScalarFieldEnum | RoleTemplatePermissionScalarFieldEnum[]
  }

  /**
   * RoleTemplatePermission create
   */
  export type RoleTemplatePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleTemplatePermission.
     */
    data: XOR<RoleTemplatePermissionCreateInput, RoleTemplatePermissionUncheckedCreateInput>
  }

  /**
   * RoleTemplatePermission createMany
   */
  export type RoleTemplatePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleTemplatePermissions.
     */
    data: RoleTemplatePermissionCreateManyInput | RoleTemplatePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleTemplatePermission createManyAndReturn
   */
  export type RoleTemplatePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoleTemplatePermissions.
     */
    data: RoleTemplatePermissionCreateManyInput | RoleTemplatePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleTemplatePermission update
   */
  export type RoleTemplatePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleTemplatePermission.
     */
    data: XOR<RoleTemplatePermissionUpdateInput, RoleTemplatePermissionUncheckedUpdateInput>
    /**
     * Choose, which RoleTemplatePermission to update.
     */
    where: RoleTemplatePermissionWhereUniqueInput
  }

  /**
   * RoleTemplatePermission updateMany
   */
  export type RoleTemplatePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleTemplatePermissions.
     */
    data: XOR<RoleTemplatePermissionUpdateManyMutationInput, RoleTemplatePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RoleTemplatePermissions to update
     */
    where?: RoleTemplatePermissionWhereInput
  }

  /**
   * RoleTemplatePermission upsert
   */
  export type RoleTemplatePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleTemplatePermission to update in case it exists.
     */
    where: RoleTemplatePermissionWhereUniqueInput
    /**
     * In case the RoleTemplatePermission found by the `where` argument doesn't exist, create a new RoleTemplatePermission with this data.
     */
    create: XOR<RoleTemplatePermissionCreateInput, RoleTemplatePermissionUncheckedCreateInput>
    /**
     * In case the RoleTemplatePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleTemplatePermissionUpdateInput, RoleTemplatePermissionUncheckedUpdateInput>
  }

  /**
   * RoleTemplatePermission delete
   */
  export type RoleTemplatePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
    /**
     * Filter which RoleTemplatePermission to delete.
     */
    where: RoleTemplatePermissionWhereUniqueInput
  }

  /**
   * RoleTemplatePermission deleteMany
   */
  export type RoleTemplatePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleTemplatePermissions to delete
     */
    where?: RoleTemplatePermissionWhereInput
  }

  /**
   * RoleTemplatePermission without action
   */
  export type RoleTemplatePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleTemplatePermission
     */
    select?: RoleTemplatePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleTemplatePermissionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BranchScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    city: 'city',
    address: 'address',
    contactPhone1: 'contactPhone1',
    contactPhone2: 'contactPhone2',
    contactEmail: 'contactEmail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const SpecialtyScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    departmentId: 'departmentId',
    code: 'code',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpecialtyScalarFieldEnum = (typeof SpecialtyScalarFieldEnum)[keyof typeof SpecialtyScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    departmentId: 'departmentId',
    specialtyId: 'specialtyId',
    empCode: 'empCode',
    name: 'name',
    designation: 'designation',
    phone: 'phone',
    email: 'email',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    phone: 'phone',
    branchId: 'branchId',
    staffId: 'staffId',
    isActive: 'isActive',
    passwordHash: 'passwordHash',
    mustChangePassword: 'mustChangePassword',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpires: 'passwordResetExpires',
    roleVersionId: 'roleVersionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    uhid: 'uhid',
    name: 'name',
    gender: 'gender',
    dob: 'dob',
    phone: 'phone',
    email: 'email',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const EncounterScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    patientId: 'patientId',
    type: 'type',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EncounterScalarFieldEnum = (typeof EncounterScalarFieldEnum)[keyof typeof EncounterScalarFieldEnum]


  export const WardScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    specialty: 'specialty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WardScalarFieldEnum = (typeof WardScalarFieldEnum)[keyof typeof WardScalarFieldEnum]


  export const BedScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    wardId: 'wardId',
    code: 'code',
    state: 'state',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BedScalarFieldEnum = (typeof BedScalarFieldEnum)[keyof typeof BedScalarFieldEnum]


  export const AdmissionScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    encounterId: 'encounterId',
    patientId: 'patientId',
    bedId: 'bedId',
    admittedAt: 'admittedAt',
    dischargedAt: 'dischargedAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdmissionScalarFieldEnum = (typeof AdmissionScalarFieldEnum)[keyof typeof AdmissionScalarFieldEnum]


  export const OTScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OTScalarFieldEnum = (typeof OTScalarFieldEnum)[keyof typeof OTScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    category: 'category',
    location: 'location',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const TariffPlanScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    code: 'code',
    name: 'name',
    status: 'status',
    payerType: 'payerType',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TariffPlanScalarFieldEnum = (typeof TariffPlanScalarFieldEnum)[keyof typeof TariffPlanScalarFieldEnum]


  export const ServiceCatalogItemScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    category: 'category',
    unit: 'unit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceCatalogItemScalarFieldEnum = (typeof ServiceCatalogItemScalarFieldEnum)[keyof typeof ServiceCatalogItemScalarFieldEnum]


  export const TariffRateScalarFieldEnum: {
    id: 'id',
    tariffPlanId: 'tariffPlanId',
    serviceCode: 'serviceCode',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TariffRateScalarFieldEnum = (typeof TariffRateScalarFieldEnum)[keyof typeof TariffRateScalarFieldEnum]


  export const ConsentRecordScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    scope: 'scope',
    purpose: 'purpose',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ConsentRecordScalarFieldEnum = (typeof ConsentRecordScalarFieldEnum)[keyof typeof ConsentRecordScalarFieldEnum]


  export const RtbfRequestScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    reason: 'reason',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RtbfRequestScalarFieldEnum = (typeof RtbfRequestScalarFieldEnum)[keyof typeof RtbfRequestScalarFieldEnum]


  export const StatutoryCaseScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    patientId: 'patientId',
    program: 'program',
    disease: 'disease',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatutoryCaseScalarFieldEnum = (typeof StatutoryCaseScalarFieldEnum)[keyof typeof StatutoryCaseScalarFieldEnum]


  export const AuditEventScalarFieldEnum: {
    id: 'id',
    branchId: 'branchId',
    actorUserId: 'actorUserId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type AuditEventScalarFieldEnum = (typeof AuditEventScalarFieldEnum)[keyof typeof AuditEventScalarFieldEnum]


  export const OutboxEventScalarFieldEnum: {
    id: 'id',
    topic: 'topic',
    key: 'key',
    payload: 'payload',
    status: 'status',
    attempts: 'attempts',
    availableAt: 'availableAt',
    lockedAt: 'lockedAt',
    sentAt: 'sentAt',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutboxEventScalarFieldEnum = (typeof OutboxEventScalarFieldEnum)[keyof typeof OutboxEventScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    category: 'category',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RoleTemplateScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    scope: 'scope',
    description: 'description',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleTemplateScalarFieldEnum = (typeof RoleTemplateScalarFieldEnum)[keyof typeof RoleTemplateScalarFieldEnum]


  export const RoleTemplateVersionScalarFieldEnum: {
    id: 'id',
    roleTemplateId: 'roleTemplateId',
    version: 'version',
    status: 'status',
    notes: 'notes',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleTemplateVersionScalarFieldEnum = (typeof RoleTemplateVersionScalarFieldEnum)[keyof typeof RoleTemplateVersionScalarFieldEnum]


  export const RoleTemplatePermissionScalarFieldEnum: {
    id: 'id',
    roleVersionId: 'roleVersionId',
    permissionId: 'permissionId',
    allowed: 'allowed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleTemplatePermissionScalarFieldEnum = (typeof RoleTemplatePermissionScalarFieldEnum)[keyof typeof RoleTemplatePermissionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'EncounterType'
   */
  export type EnumEncounterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EncounterType'>
    


  /**
   * Reference to a field of type 'EncounterType[]'
   */
  export type ListEnumEncounterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EncounterType[]'>
    


  /**
   * Reference to a field of type 'BedState'
   */
  export type EnumBedStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BedState'>
    


  /**
   * Reference to a field of type 'BedState[]'
   */
  export type ListEnumBedStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BedState[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ConsentScope'
   */
  export type EnumConsentScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentScope'>
    


  /**
   * Reference to a field of type 'ConsentScope[]'
   */
  export type ListEnumConsentScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentScope[]'>
    


  /**
   * Reference to a field of type 'ConsentStatus'
   */
  export type EnumConsentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentStatus'>
    


  /**
   * Reference to a field of type 'ConsentStatus[]'
   */
  export type ListEnumConsentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsentStatus[]'>
    


  /**
   * Reference to a field of type 'RtbfStatus'
   */
  export type EnumRtbfStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RtbfStatus'>
    


  /**
   * Reference to a field of type 'RtbfStatus[]'
   */
  export type ListEnumRtbfStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RtbfStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'OutboxStatus'
   */
  export type EnumOutboxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OutboxStatus'>
    


  /**
   * Reference to a field of type 'OutboxStatus[]'
   */
  export type ListEnumOutboxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OutboxStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'RoleScope'
   */
  export type EnumRoleScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleScope'>
    


  /**
   * Reference to a field of type 'RoleScope[]'
   */
  export type ListEnumRoleScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleScope[]'>
    


  /**
   * Reference to a field of type 'RoleVersionStatus'
   */
  export type EnumRoleVersionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleVersionStatus'>
    


  /**
   * Reference to a field of type 'RoleVersionStatus[]'
   */
  export type ListEnumRoleVersionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleVersionStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: StringFilter<"Branch"> | string
    code?: StringFilter<"Branch"> | string
    name?: StringFilter<"Branch"> | string
    city?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    contactPhone1?: StringNullableFilter<"Branch"> | string | null
    contactPhone2?: StringNullableFilter<"Branch"> | string | null
    contactEmail?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    departments?: DepartmentListRelationFilter
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    wards?: WardListRelationFilter
    oTs?: OTListRelationFilter
    tariffPlans?: TariffPlanListRelationFilter
    assets?: AssetListRelationFilter
    Specialty?: SpecialtyListRelationFilter
    Staff?: StaffListRelationFilter
    Encounter?: EncounterListRelationFilter
    Bed?: BedListRelationFilter
    Admission?: AdmissionListRelationFilter
    statutoryCases?: StatutoryCaseListRelationFilter
    auditEvents?: AuditEventListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    address?: SortOrderInput | SortOrder
    contactPhone1?: SortOrderInput | SortOrder
    contactPhone2?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departments?: DepartmentOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    patients?: PatientOrderByRelationAggregateInput
    wards?: WardOrderByRelationAggregateInput
    oTs?: OTOrderByRelationAggregateInput
    tariffPlans?: TariffPlanOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
    Specialty?: SpecialtyOrderByRelationAggregateInput
    Staff?: StaffOrderByRelationAggregateInput
    Encounter?: EncounterOrderByRelationAggregateInput
    Bed?: BedOrderByRelationAggregateInput
    Admission?: AdmissionOrderByRelationAggregateInput
    statutoryCases?: StatutoryCaseOrderByRelationAggregateInput
    auditEvents?: AuditEventOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    name?: StringFilter<"Branch"> | string
    city?: StringFilter<"Branch"> | string
    address?: StringNullableFilter<"Branch"> | string | null
    contactPhone1?: StringNullableFilter<"Branch"> | string | null
    contactPhone2?: StringNullableFilter<"Branch"> | string | null
    contactEmail?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    updatedAt?: DateTimeFilter<"Branch"> | Date | string
    departments?: DepartmentListRelationFilter
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    wards?: WardListRelationFilter
    oTs?: OTListRelationFilter
    tariffPlans?: TariffPlanListRelationFilter
    assets?: AssetListRelationFilter
    Specialty?: SpecialtyListRelationFilter
    Staff?: StaffListRelationFilter
    Encounter?: EncounterListRelationFilter
    Bed?: BedListRelationFilter
    Admission?: AdmissionListRelationFilter
    statutoryCases?: StatutoryCaseListRelationFilter
    auditEvents?: AuditEventListRelationFilter
  }, "id" | "code">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    address?: SortOrderInput | SortOrder
    contactPhone1?: SortOrderInput | SortOrder
    contactPhone2?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Branch"> | string
    code?: StringWithAggregatesFilter<"Branch"> | string
    name?: StringWithAggregatesFilter<"Branch"> | string
    city?: StringWithAggregatesFilter<"Branch"> | string
    address?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    contactPhone1?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    contactPhone2?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    branchId?: StringFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    staff?: StaffListRelationFilter
    specialties?: SpecialtyListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    staff?: StaffOrderByRelationAggregateInput
    specialties?: SpecialtyOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: DepartmentBranchIdCodeCompoundUniqueInput
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    branchId?: StringFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    staff?: StaffListRelationFilter
    specialties?: SpecialtyListRelationFilter
  }, "id" | "branchId_code">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    branchId?: StringWithAggregatesFilter<"Department"> | string
    code?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    isActive?: BoolWithAggregatesFilter<"Department"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type SpecialtyWhereInput = {
    AND?: SpecialtyWhereInput | SpecialtyWhereInput[]
    OR?: SpecialtyWhereInput[]
    NOT?: SpecialtyWhereInput | SpecialtyWhereInput[]
    id?: StringFilter<"Specialty"> | string
    branchId?: StringFilter<"Specialty"> | string
    departmentId?: StringNullableFilter<"Specialty"> | string | null
    code?: StringFilter<"Specialty"> | string
    name?: StringFilter<"Specialty"> | string
    isActive?: BoolFilter<"Specialty"> | boolean
    createdAt?: DateTimeFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeFilter<"Specialty"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    staff?: StaffListRelationFilter
  }

  export type SpecialtyOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    staff?: StaffOrderByRelationAggregateInput
  }

  export type SpecialtyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: SpecialtyBranchIdCodeCompoundUniqueInput
    AND?: SpecialtyWhereInput | SpecialtyWhereInput[]
    OR?: SpecialtyWhereInput[]
    NOT?: SpecialtyWhereInput | SpecialtyWhereInput[]
    branchId?: StringFilter<"Specialty"> | string
    departmentId?: StringNullableFilter<"Specialty"> | string | null
    code?: StringFilter<"Specialty"> | string
    name?: StringFilter<"Specialty"> | string
    isActive?: BoolFilter<"Specialty"> | boolean
    createdAt?: DateTimeFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeFilter<"Specialty"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    staff?: StaffListRelationFilter
  }, "id" | "branchId_code">

  export type SpecialtyOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpecialtyCountOrderByAggregateInput
    _max?: SpecialtyMaxOrderByAggregateInput
    _min?: SpecialtyMinOrderByAggregateInput
  }

  export type SpecialtyScalarWhereWithAggregatesInput = {
    AND?: SpecialtyScalarWhereWithAggregatesInput | SpecialtyScalarWhereWithAggregatesInput[]
    OR?: SpecialtyScalarWhereWithAggregatesInput[]
    NOT?: SpecialtyScalarWhereWithAggregatesInput | SpecialtyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Specialty"> | string
    branchId?: StringWithAggregatesFilter<"Specialty"> | string
    departmentId?: StringNullableWithAggregatesFilter<"Specialty"> | string | null
    code?: StringWithAggregatesFilter<"Specialty"> | string
    name?: StringWithAggregatesFilter<"Specialty"> | string
    isActive?: BoolWithAggregatesFilter<"Specialty"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Specialty"> | Date | string
  }

  export type StaffWhereInput = {
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    id?: StringFilter<"Staff"> | string
    branchId?: StringFilter<"Staff"> | string
    departmentId?: StringNullableFilter<"Staff"> | string | null
    specialtyId?: StringNullableFilter<"Staff"> | string | null
    empCode?: StringFilter<"Staff"> | string
    name?: StringFilter<"Staff"> | string
    designation?: StringFilter<"Staff"> | string
    phone?: StringNullableFilter<"Staff"> | string | null
    email?: StringNullableFilter<"Staff"> | string | null
    isActive?: BoolFilter<"Staff"> | boolean
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    specialty?: XOR<SpecialtyNullableRelationFilter, SpecialtyWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    specialtyId?: SortOrderInput | SortOrder
    empCode?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_empCode?: StaffBranchIdEmpCodeCompoundUniqueInput
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    branchId?: StringFilter<"Staff"> | string
    departmentId?: StringNullableFilter<"Staff"> | string | null
    specialtyId?: StringNullableFilter<"Staff"> | string | null
    empCode?: StringFilter<"Staff"> | string
    name?: StringFilter<"Staff"> | string
    designation?: StringFilter<"Staff"> | string
    phone?: StringNullableFilter<"Staff"> | string | null
    email?: StringNullableFilter<"Staff"> | string | null
    isActive?: BoolFilter<"Staff"> | boolean
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    specialty?: XOR<SpecialtyNullableRelationFilter, SpecialtyWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "branchId_empCode">

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    specialtyId?: SortOrderInput | SortOrder
    empCode?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    OR?: StaffScalarWhereWithAggregatesInput[]
    NOT?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Staff"> | string
    branchId?: StringWithAggregatesFilter<"Staff"> | string
    departmentId?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    specialtyId?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    empCode?: StringWithAggregatesFilter<"Staff"> | string
    name?: StringWithAggregatesFilter<"Staff"> | string
    designation?: StringWithAggregatesFilter<"Staff"> | string
    phone?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    email?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    isActive?: BoolWithAggregatesFilter<"Staff"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    branchId?: StringNullableFilter<"User"> | string | null
    staffId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    passwordHash?: StringNullableFilter<"User"> | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    roleVersionId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    staff?: XOR<StaffNullableRelationFilter, StaffWhereInput> | null
    roleVersion?: XOR<RoleTemplateVersionNullableRelationFilter, RoleTemplateVersionWhereInput> | null
    createdRoleVersions?: RoleTemplateVersionListRelationFilter
    auditEventsAsActor?: AuditEventListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    mustChangePassword?: SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    roleVersionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
    roleVersion?: RoleTemplateVersionOrderByWithRelationInput
    createdRoleVersions?: RoleTemplateVersionOrderByRelationAggregateInput
    auditEventsAsActor?: AuditEventOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    staffId?: string
    passwordResetToken?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    branchId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    passwordHash?: StringNullableFilter<"User"> | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    roleVersionId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    staff?: XOR<StaffNullableRelationFilter, StaffWhereInput> | null
    roleVersion?: XOR<RoleTemplateVersionNullableRelationFilter, RoleTemplateVersionWhereInput> | null
    createdRoleVersions?: RoleTemplateVersionListRelationFilter
    auditEventsAsActor?: AuditEventListRelationFilter
  }, "id" | "email" | "staffId" | "passwordResetToken">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    mustChangePassword?: SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    roleVersionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    branchId?: StringNullableWithAggregatesFilter<"User"> | string | null
    staffId?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    mustChangePassword?: BoolWithAggregatesFilter<"User"> | boolean
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    roleVersionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    branchId?: StringFilter<"Patient"> | string
    uhid?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    dob?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounters?: EncounterListRelationFilter
    Admission?: AdmissionListRelationFilter
    consentRecords?: ConsentRecordListRelationFilter
    rtbfRequests?: RtbfRequestListRelationFilter
    statutoryCases?: StatutoryCaseListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    uhid?: SortOrder
    name?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
    Admission?: AdmissionOrderByRelationAggregateInput
    consentRecords?: ConsentRecordOrderByRelationAggregateInput
    rtbfRequests?: RtbfRequestOrderByRelationAggregateInput
    statutoryCases?: StatutoryCaseOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_uhid?: PatientBranchIdUhidCompoundUniqueInput
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    branchId?: StringFilter<"Patient"> | string
    uhid?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    dob?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounters?: EncounterListRelationFilter
    Admission?: AdmissionListRelationFilter
    consentRecords?: ConsentRecordListRelationFilter
    rtbfRequests?: RtbfRequestListRelationFilter
    statutoryCases?: StatutoryCaseListRelationFilter
  }, "id" | "branchId_uhid">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    uhid?: SortOrder
    name?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    branchId?: StringWithAggregatesFilter<"Patient"> | string
    uhid?: StringWithAggregatesFilter<"Patient"> | string
    name?: StringWithAggregatesFilter<"Patient"> | string
    gender?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    email?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    address?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type EncounterWhereInput = {
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    id?: StringFilter<"Encounter"> | string
    branchId?: StringFilter<"Encounter"> | string
    patientId?: StringFilter<"Encounter"> | string
    type?: EnumEncounterTypeFilter<"Encounter"> | $Enums.EncounterType
    startedAt?: DateTimeFilter<"Encounter"> | Date | string
    endedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    status?: StringFilter<"Encounter"> | string
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    admissions?: AdmissionListRelationFilter
  }

  export type EncounterOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    admissions?: AdmissionOrderByRelationAggregateInput
  }

  export type EncounterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    branchId?: StringFilter<"Encounter"> | string
    patientId?: StringFilter<"Encounter"> | string
    type?: EnumEncounterTypeFilter<"Encounter"> | $Enums.EncounterType
    startedAt?: DateTimeFilter<"Encounter"> | Date | string
    endedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    status?: StringFilter<"Encounter"> | string
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    admissions?: AdmissionListRelationFilter
  }, "id">

  export type EncounterOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EncounterCountOrderByAggregateInput
    _max?: EncounterMaxOrderByAggregateInput
    _min?: EncounterMinOrderByAggregateInput
  }

  export type EncounterScalarWhereWithAggregatesInput = {
    AND?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    OR?: EncounterScalarWhereWithAggregatesInput[]
    NOT?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Encounter"> | string
    branchId?: StringWithAggregatesFilter<"Encounter"> | string
    patientId?: StringWithAggregatesFilter<"Encounter"> | string
    type?: EnumEncounterTypeWithAggregatesFilter<"Encounter"> | $Enums.EncounterType
    startedAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"Encounter"> | Date | string | null
    status?: StringWithAggregatesFilter<"Encounter"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
  }

  export type WardWhereInput = {
    AND?: WardWhereInput | WardWhereInput[]
    OR?: WardWhereInput[]
    NOT?: WardWhereInput | WardWhereInput[]
    id?: StringFilter<"Ward"> | string
    branchId?: StringFilter<"Ward"> | string
    code?: StringFilter<"Ward"> | string
    name?: StringFilter<"Ward"> | string
    specialty?: StringNullableFilter<"Ward"> | string | null
    isActive?: BoolFilter<"Ward"> | boolean
    createdAt?: DateTimeFilter<"Ward"> | Date | string
    updatedAt?: DateTimeFilter<"Ward"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    beds?: BedListRelationFilter
  }

  export type WardOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    specialty?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    beds?: BedOrderByRelationAggregateInput
  }

  export type WardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: WardBranchIdCodeCompoundUniqueInput
    AND?: WardWhereInput | WardWhereInput[]
    OR?: WardWhereInput[]
    NOT?: WardWhereInput | WardWhereInput[]
    branchId?: StringFilter<"Ward"> | string
    code?: StringFilter<"Ward"> | string
    name?: StringFilter<"Ward"> | string
    specialty?: StringNullableFilter<"Ward"> | string | null
    isActive?: BoolFilter<"Ward"> | boolean
    createdAt?: DateTimeFilter<"Ward"> | Date | string
    updatedAt?: DateTimeFilter<"Ward"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    beds?: BedListRelationFilter
  }, "id" | "branchId_code">

  export type WardOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    specialty?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WardCountOrderByAggregateInput
    _max?: WardMaxOrderByAggregateInput
    _min?: WardMinOrderByAggregateInput
  }

  export type WardScalarWhereWithAggregatesInput = {
    AND?: WardScalarWhereWithAggregatesInput | WardScalarWhereWithAggregatesInput[]
    OR?: WardScalarWhereWithAggregatesInput[]
    NOT?: WardScalarWhereWithAggregatesInput | WardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ward"> | string
    branchId?: StringWithAggregatesFilter<"Ward"> | string
    code?: StringWithAggregatesFilter<"Ward"> | string
    name?: StringWithAggregatesFilter<"Ward"> | string
    specialty?: StringNullableWithAggregatesFilter<"Ward"> | string | null
    isActive?: BoolWithAggregatesFilter<"Ward"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Ward"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ward"> | Date | string
  }

  export type BedWhereInput = {
    AND?: BedWhereInput | BedWhereInput[]
    OR?: BedWhereInput[]
    NOT?: BedWhereInput | BedWhereInput[]
    id?: StringFilter<"Bed"> | string
    branchId?: StringFilter<"Bed"> | string
    wardId?: StringFilter<"Bed"> | string
    code?: StringFilter<"Bed"> | string
    state?: EnumBedStateFilter<"Bed"> | $Enums.BedState
    isActive?: BoolFilter<"Bed"> | boolean
    createdAt?: DateTimeFilter<"Bed"> | Date | string
    updatedAt?: DateTimeFilter<"Bed"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    ward?: XOR<WardRelationFilter, WardWhereInput>
    admissions?: AdmissionListRelationFilter
  }

  export type BedOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    wardId?: SortOrder
    code?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    ward?: WardOrderByWithRelationInput
    admissions?: AdmissionOrderByRelationAggregateInput
  }

  export type BedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    wardId_code?: BedWardIdCodeCompoundUniqueInput
    AND?: BedWhereInput | BedWhereInput[]
    OR?: BedWhereInput[]
    NOT?: BedWhereInput | BedWhereInput[]
    branchId?: StringFilter<"Bed"> | string
    wardId?: StringFilter<"Bed"> | string
    code?: StringFilter<"Bed"> | string
    state?: EnumBedStateFilter<"Bed"> | $Enums.BedState
    isActive?: BoolFilter<"Bed"> | boolean
    createdAt?: DateTimeFilter<"Bed"> | Date | string
    updatedAt?: DateTimeFilter<"Bed"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    ward?: XOR<WardRelationFilter, WardWhereInput>
    admissions?: AdmissionListRelationFilter
  }, "id" | "wardId_code">

  export type BedOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    wardId?: SortOrder
    code?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BedCountOrderByAggregateInput
    _max?: BedMaxOrderByAggregateInput
    _min?: BedMinOrderByAggregateInput
  }

  export type BedScalarWhereWithAggregatesInput = {
    AND?: BedScalarWhereWithAggregatesInput | BedScalarWhereWithAggregatesInput[]
    OR?: BedScalarWhereWithAggregatesInput[]
    NOT?: BedScalarWhereWithAggregatesInput | BedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bed"> | string
    branchId?: StringWithAggregatesFilter<"Bed"> | string
    wardId?: StringWithAggregatesFilter<"Bed"> | string
    code?: StringWithAggregatesFilter<"Bed"> | string
    state?: EnumBedStateWithAggregatesFilter<"Bed"> | $Enums.BedState
    isActive?: BoolWithAggregatesFilter<"Bed"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Bed"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bed"> | Date | string
  }

  export type AdmissionWhereInput = {
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    id?: StringFilter<"Admission"> | string
    branchId?: StringFilter<"Admission"> | string
    encounterId?: StringNullableFilter<"Admission"> | string | null
    patientId?: StringFilter<"Admission"> | string
    bedId?: StringNullableFilter<"Admission"> | string | null
    admittedAt?: DateTimeFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"Admission"> | Date | string | null
    status?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounter?: XOR<EncounterNullableRelationFilter, EncounterWhereInput> | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    bed?: XOR<BedNullableRelationFilter, BedWhereInput> | null
  }

  export type AdmissionOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    bedId?: SortOrderInput | SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    encounter?: EncounterOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    bed?: BedOrderByWithRelationInput
  }

  export type AdmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    branchId?: StringFilter<"Admission"> | string
    encounterId?: StringNullableFilter<"Admission"> | string | null
    patientId?: StringFilter<"Admission"> | string
    bedId?: StringNullableFilter<"Admission"> | string | null
    admittedAt?: DateTimeFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"Admission"> | Date | string | null
    status?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    encounter?: XOR<EncounterNullableRelationFilter, EncounterWhereInput> | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    bed?: XOR<BedNullableRelationFilter, BedWhereInput> | null
  }, "id">

  export type AdmissionOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    bedId?: SortOrderInput | SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdmissionCountOrderByAggregateInput
    _max?: AdmissionMaxOrderByAggregateInput
    _min?: AdmissionMinOrderByAggregateInput
  }

  export type AdmissionScalarWhereWithAggregatesInput = {
    AND?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    OR?: AdmissionScalarWhereWithAggregatesInput[]
    NOT?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admission"> | string
    branchId?: StringWithAggregatesFilter<"Admission"> | string
    encounterId?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    patientId?: StringWithAggregatesFilter<"Admission"> | string
    bedId?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    admittedAt?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableWithAggregatesFilter<"Admission"> | Date | string | null
    status?: StringWithAggregatesFilter<"Admission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
  }

  export type OTWhereInput = {
    AND?: OTWhereInput | OTWhereInput[]
    OR?: OTWhereInput[]
    NOT?: OTWhereInput | OTWhereInput[]
    id?: StringFilter<"OT"> | string
    branchId?: StringFilter<"OT"> | string
    code?: StringFilter<"OT"> | string
    name?: StringFilter<"OT"> | string
    isActive?: BoolFilter<"OT"> | boolean
    createdAt?: DateTimeFilter<"OT"> | Date | string
    updatedAt?: DateTimeFilter<"OT"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type OTOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type OTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: OTBranchIdCodeCompoundUniqueInput
    AND?: OTWhereInput | OTWhereInput[]
    OR?: OTWhereInput[]
    NOT?: OTWhereInput | OTWhereInput[]
    branchId?: StringFilter<"OT"> | string
    code?: StringFilter<"OT"> | string
    name?: StringFilter<"OT"> | string
    isActive?: BoolFilter<"OT"> | boolean
    createdAt?: DateTimeFilter<"OT"> | Date | string
    updatedAt?: DateTimeFilter<"OT"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "branchId_code">

  export type OTOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OTCountOrderByAggregateInput
    _max?: OTMaxOrderByAggregateInput
    _min?: OTMinOrderByAggregateInput
  }

  export type OTScalarWhereWithAggregatesInput = {
    AND?: OTScalarWhereWithAggregatesInput | OTScalarWhereWithAggregatesInput[]
    OR?: OTScalarWhereWithAggregatesInput[]
    NOT?: OTScalarWhereWithAggregatesInput | OTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OT"> | string
    branchId?: StringWithAggregatesFilter<"OT"> | string
    code?: StringWithAggregatesFilter<"OT"> | string
    name?: StringWithAggregatesFilter<"OT"> | string
    isActive?: BoolWithAggregatesFilter<"OT"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OT"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OT"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: StringFilter<"Asset"> | string
    branchId?: StringFilter<"Asset"> | string
    code?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    category?: StringFilter<"Asset"> | string
    location?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: AssetBranchIdCodeCompoundUniqueInput
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    branchId?: StringFilter<"Asset"> | string
    code?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    category?: StringFilter<"Asset"> | string
    location?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
  }, "id" | "branchId_code">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asset"> | string
    branchId?: StringWithAggregatesFilter<"Asset"> | string
    code?: StringWithAggregatesFilter<"Asset"> | string
    name?: StringWithAggregatesFilter<"Asset"> | string
    category?: StringWithAggregatesFilter<"Asset"> | string
    location?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    status?: StringWithAggregatesFilter<"Asset"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
  }

  export type TariffPlanWhereInput = {
    AND?: TariffPlanWhereInput | TariffPlanWhereInput[]
    OR?: TariffPlanWhereInput[]
    NOT?: TariffPlanWhereInput | TariffPlanWhereInput[]
    id?: StringFilter<"TariffPlan"> | string
    branchId?: StringFilter<"TariffPlan"> | string
    code?: StringFilter<"TariffPlan"> | string
    name?: StringFilter<"TariffPlan"> | string
    status?: StringFilter<"TariffPlan"> | string
    payerType?: StringFilter<"TariffPlan"> | string
    effectiveFrom?: DateTimeFilter<"TariffPlan"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TariffPlan"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    rates?: TariffRateListRelationFilter
  }

  export type TariffPlanOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    payerType?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    rates?: TariffRateOrderByRelationAggregateInput
  }

  export type TariffPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    branchId_code?: TariffPlanBranchIdCodeCompoundUniqueInput
    AND?: TariffPlanWhereInput | TariffPlanWhereInput[]
    OR?: TariffPlanWhereInput[]
    NOT?: TariffPlanWhereInput | TariffPlanWhereInput[]
    branchId?: StringFilter<"TariffPlan"> | string
    code?: StringFilter<"TariffPlan"> | string
    name?: StringFilter<"TariffPlan"> | string
    status?: StringFilter<"TariffPlan"> | string
    payerType?: StringFilter<"TariffPlan"> | string
    effectiveFrom?: DateTimeFilter<"TariffPlan"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TariffPlan"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    rates?: TariffRateListRelationFilter
  }, "id" | "branchId_code">

  export type TariffPlanOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    payerType?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TariffPlanCountOrderByAggregateInput
    _max?: TariffPlanMaxOrderByAggregateInput
    _min?: TariffPlanMinOrderByAggregateInput
  }

  export type TariffPlanScalarWhereWithAggregatesInput = {
    AND?: TariffPlanScalarWhereWithAggregatesInput | TariffPlanScalarWhereWithAggregatesInput[]
    OR?: TariffPlanScalarWhereWithAggregatesInput[]
    NOT?: TariffPlanScalarWhereWithAggregatesInput | TariffPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TariffPlan"> | string
    branchId?: StringWithAggregatesFilter<"TariffPlan"> | string
    code?: StringWithAggregatesFilter<"TariffPlan"> | string
    name?: StringWithAggregatesFilter<"TariffPlan"> | string
    status?: StringWithAggregatesFilter<"TariffPlan"> | string
    payerType?: StringWithAggregatesFilter<"TariffPlan"> | string
    effectiveFrom?: DateTimeWithAggregatesFilter<"TariffPlan"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"TariffPlan"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TariffPlan"> | Date | string
  }

  export type ServiceCatalogItemWhereInput = {
    AND?: ServiceCatalogItemWhereInput | ServiceCatalogItemWhereInput[]
    OR?: ServiceCatalogItemWhereInput[]
    NOT?: ServiceCatalogItemWhereInput | ServiceCatalogItemWhereInput[]
    id?: StringFilter<"ServiceCatalogItem"> | string
    code?: StringFilter<"ServiceCatalogItem"> | string
    name?: StringFilter<"ServiceCatalogItem"> | string
    category?: StringFilter<"ServiceCatalogItem"> | string
    unit?: StringNullableFilter<"ServiceCatalogItem"> | string | null
    createdAt?: DateTimeFilter<"ServiceCatalogItem"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCatalogItem"> | Date | string
  }

  export type ServiceCatalogItemOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCatalogItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ServiceCatalogItemWhereInput | ServiceCatalogItemWhereInput[]
    OR?: ServiceCatalogItemWhereInput[]
    NOT?: ServiceCatalogItemWhereInput | ServiceCatalogItemWhereInput[]
    name?: StringFilter<"ServiceCatalogItem"> | string
    category?: StringFilter<"ServiceCatalogItem"> | string
    unit?: StringNullableFilter<"ServiceCatalogItem"> | string | null
    createdAt?: DateTimeFilter<"ServiceCatalogItem"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceCatalogItem"> | Date | string
  }, "id" | "code">

  export type ServiceCatalogItemOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCatalogItemCountOrderByAggregateInput
    _max?: ServiceCatalogItemMaxOrderByAggregateInput
    _min?: ServiceCatalogItemMinOrderByAggregateInput
  }

  export type ServiceCatalogItemScalarWhereWithAggregatesInput = {
    AND?: ServiceCatalogItemScalarWhereWithAggregatesInput | ServiceCatalogItemScalarWhereWithAggregatesInput[]
    OR?: ServiceCatalogItemScalarWhereWithAggregatesInput[]
    NOT?: ServiceCatalogItemScalarWhereWithAggregatesInput | ServiceCatalogItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceCatalogItem"> | string
    code?: StringWithAggregatesFilter<"ServiceCatalogItem"> | string
    name?: StringWithAggregatesFilter<"ServiceCatalogItem"> | string
    category?: StringWithAggregatesFilter<"ServiceCatalogItem"> | string
    unit?: StringNullableWithAggregatesFilter<"ServiceCatalogItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceCatalogItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceCatalogItem"> | Date | string
  }

  export type TariffRateWhereInput = {
    AND?: TariffRateWhereInput | TariffRateWhereInput[]
    OR?: TariffRateWhereInput[]
    NOT?: TariffRateWhereInput | TariffRateWhereInput[]
    id?: StringFilter<"TariffRate"> | string
    tariffPlanId?: StringFilter<"TariffRate"> | string
    serviceCode?: StringFilter<"TariffRate"> | string
    amount?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeFilter<"TariffRate"> | Date | string
    tariffPlan?: XOR<TariffPlanRelationFilter, TariffPlanWhereInput>
  }

  export type TariffRateOrderByWithRelationInput = {
    id?: SortOrder
    tariffPlanId?: SortOrder
    serviceCode?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tariffPlan?: TariffPlanOrderByWithRelationInput
  }

  export type TariffRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tariffPlanId_serviceCode?: TariffRateTariffPlanIdServiceCodeCompoundUniqueInput
    AND?: TariffRateWhereInput | TariffRateWhereInput[]
    OR?: TariffRateWhereInput[]
    NOT?: TariffRateWhereInput | TariffRateWhereInput[]
    tariffPlanId?: StringFilter<"TariffRate"> | string
    serviceCode?: StringFilter<"TariffRate"> | string
    amount?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeFilter<"TariffRate"> | Date | string
    tariffPlan?: XOR<TariffPlanRelationFilter, TariffPlanWhereInput>
  }, "id" | "tariffPlanId_serviceCode">

  export type TariffRateOrderByWithAggregationInput = {
    id?: SortOrder
    tariffPlanId?: SortOrder
    serviceCode?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TariffRateCountOrderByAggregateInput
    _avg?: TariffRateAvgOrderByAggregateInput
    _max?: TariffRateMaxOrderByAggregateInput
    _min?: TariffRateMinOrderByAggregateInput
    _sum?: TariffRateSumOrderByAggregateInput
  }

  export type TariffRateScalarWhereWithAggregatesInput = {
    AND?: TariffRateScalarWhereWithAggregatesInput | TariffRateScalarWhereWithAggregatesInput[]
    OR?: TariffRateScalarWhereWithAggregatesInput[]
    NOT?: TariffRateScalarWhereWithAggregatesInput | TariffRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TariffRate"> | string
    tariffPlanId?: StringWithAggregatesFilter<"TariffRate"> | string
    serviceCode?: StringWithAggregatesFilter<"TariffRate"> | string
    amount?: DecimalWithAggregatesFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TariffRate"> | Date | string
  }

  export type ConsentRecordWhereInput = {
    AND?: ConsentRecordWhereInput | ConsentRecordWhereInput[]
    OR?: ConsentRecordWhereInput[]
    NOT?: ConsentRecordWhereInput | ConsentRecordWhereInput[]
    id?: StringFilter<"ConsentRecord"> | string
    patientId?: StringFilter<"ConsentRecord"> | string
    scope?: EnumConsentScopeFilter<"ConsentRecord"> | $Enums.ConsentScope
    purpose?: StringFilter<"ConsentRecord"> | string
    status?: EnumConsentStatusFilter<"ConsentRecord"> | $Enums.ConsentStatus
    createdAt?: DateTimeFilter<"ConsentRecord"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type ConsentRecordOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    scope?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type ConsentRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsentRecordWhereInput | ConsentRecordWhereInput[]
    OR?: ConsentRecordWhereInput[]
    NOT?: ConsentRecordWhereInput | ConsentRecordWhereInput[]
    patientId?: StringFilter<"ConsentRecord"> | string
    scope?: EnumConsentScopeFilter<"ConsentRecord"> | $Enums.ConsentScope
    purpose?: StringFilter<"ConsentRecord"> | string
    status?: EnumConsentStatusFilter<"ConsentRecord"> | $Enums.ConsentStatus
    createdAt?: DateTimeFilter<"ConsentRecord"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type ConsentRecordOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    scope?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ConsentRecordCountOrderByAggregateInput
    _max?: ConsentRecordMaxOrderByAggregateInput
    _min?: ConsentRecordMinOrderByAggregateInput
  }

  export type ConsentRecordScalarWhereWithAggregatesInput = {
    AND?: ConsentRecordScalarWhereWithAggregatesInput | ConsentRecordScalarWhereWithAggregatesInput[]
    OR?: ConsentRecordScalarWhereWithAggregatesInput[]
    NOT?: ConsentRecordScalarWhereWithAggregatesInput | ConsentRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConsentRecord"> | string
    patientId?: StringWithAggregatesFilter<"ConsentRecord"> | string
    scope?: EnumConsentScopeWithAggregatesFilter<"ConsentRecord"> | $Enums.ConsentScope
    purpose?: StringWithAggregatesFilter<"ConsentRecord"> | string
    status?: EnumConsentStatusWithAggregatesFilter<"ConsentRecord"> | $Enums.ConsentStatus
    createdAt?: DateTimeWithAggregatesFilter<"ConsentRecord"> | Date | string
  }

  export type RtbfRequestWhereInput = {
    AND?: RtbfRequestWhereInput | RtbfRequestWhereInput[]
    OR?: RtbfRequestWhereInput[]
    NOT?: RtbfRequestWhereInput | RtbfRequestWhereInput[]
    id?: StringFilter<"RtbfRequest"> | string
    patientId?: StringFilter<"RtbfRequest"> | string
    reason?: StringFilter<"RtbfRequest"> | string
    status?: EnumRtbfStatusFilter<"RtbfRequest"> | $Enums.RtbfStatus
    createdAt?: DateTimeFilter<"RtbfRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RtbfRequest"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type RtbfRequestOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type RtbfRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RtbfRequestWhereInput | RtbfRequestWhereInput[]
    OR?: RtbfRequestWhereInput[]
    NOT?: RtbfRequestWhereInput | RtbfRequestWhereInput[]
    patientId?: StringFilter<"RtbfRequest"> | string
    reason?: StringFilter<"RtbfRequest"> | string
    status?: EnumRtbfStatusFilter<"RtbfRequest"> | $Enums.RtbfStatus
    createdAt?: DateTimeFilter<"RtbfRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RtbfRequest"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type RtbfRequestOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RtbfRequestCountOrderByAggregateInput
    _max?: RtbfRequestMaxOrderByAggregateInput
    _min?: RtbfRequestMinOrderByAggregateInput
  }

  export type RtbfRequestScalarWhereWithAggregatesInput = {
    AND?: RtbfRequestScalarWhereWithAggregatesInput | RtbfRequestScalarWhereWithAggregatesInput[]
    OR?: RtbfRequestScalarWhereWithAggregatesInput[]
    NOT?: RtbfRequestScalarWhereWithAggregatesInput | RtbfRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RtbfRequest"> | string
    patientId?: StringWithAggregatesFilter<"RtbfRequest"> | string
    reason?: StringWithAggregatesFilter<"RtbfRequest"> | string
    status?: EnumRtbfStatusWithAggregatesFilter<"RtbfRequest"> | $Enums.RtbfStatus
    createdAt?: DateTimeWithAggregatesFilter<"RtbfRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RtbfRequest"> | Date | string
  }

  export type StatutoryCaseWhereInput = {
    AND?: StatutoryCaseWhereInput | StatutoryCaseWhereInput[]
    OR?: StatutoryCaseWhereInput[]
    NOT?: StatutoryCaseWhereInput | StatutoryCaseWhereInput[]
    id?: StringFilter<"StatutoryCase"> | string
    branchId?: StringFilter<"StatutoryCase"> | string
    patientId?: StringFilter<"StatutoryCase"> | string
    program?: StringFilter<"StatutoryCase"> | string
    disease?: StringFilter<"StatutoryCase"> | string
    status?: StringFilter<"StatutoryCase"> | string
    createdAt?: DateTimeFilter<"StatutoryCase"> | Date | string
    updatedAt?: DateTimeFilter<"StatutoryCase"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type StatutoryCaseOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    program?: SortOrder
    disease?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type StatutoryCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StatutoryCaseWhereInput | StatutoryCaseWhereInput[]
    OR?: StatutoryCaseWhereInput[]
    NOT?: StatutoryCaseWhereInput | StatutoryCaseWhereInput[]
    branchId?: StringFilter<"StatutoryCase"> | string
    patientId?: StringFilter<"StatutoryCase"> | string
    program?: StringFilter<"StatutoryCase"> | string
    disease?: StringFilter<"StatutoryCase"> | string
    status?: StringFilter<"StatutoryCase"> | string
    createdAt?: DateTimeFilter<"StatutoryCase"> | Date | string
    updatedAt?: DateTimeFilter<"StatutoryCase"> | Date | string
    branch?: XOR<BranchRelationFilter, BranchWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type StatutoryCaseOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    program?: SortOrder
    disease?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StatutoryCaseCountOrderByAggregateInput
    _max?: StatutoryCaseMaxOrderByAggregateInput
    _min?: StatutoryCaseMinOrderByAggregateInput
  }

  export type StatutoryCaseScalarWhereWithAggregatesInput = {
    AND?: StatutoryCaseScalarWhereWithAggregatesInput | StatutoryCaseScalarWhereWithAggregatesInput[]
    OR?: StatutoryCaseScalarWhereWithAggregatesInput[]
    NOT?: StatutoryCaseScalarWhereWithAggregatesInput | StatutoryCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StatutoryCase"> | string
    branchId?: StringWithAggregatesFilter<"StatutoryCase"> | string
    patientId?: StringWithAggregatesFilter<"StatutoryCase"> | string
    program?: StringWithAggregatesFilter<"StatutoryCase"> | string
    disease?: StringWithAggregatesFilter<"StatutoryCase"> | string
    status?: StringWithAggregatesFilter<"StatutoryCase"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StatutoryCase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StatutoryCase"> | Date | string
  }

  export type AuditEventWhereInput = {
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    id?: StringFilter<"AuditEvent"> | string
    branchId?: StringNullableFilter<"AuditEvent"> | string | null
    actorUserId?: StringNullableFilter<"AuditEvent"> | string | null
    action?: StringFilter<"AuditEvent"> | string
    entity?: StringFilter<"AuditEvent"> | string
    entityId?: StringNullableFilter<"AuditEvent"> | string | null
    meta?: JsonNullableFilter<"AuditEvent">
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    actorUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditEventOrderByWithRelationInput = {
    id?: SortOrder
    branchId?: SortOrderInput | SortOrder
    actorUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    branch?: BranchOrderByWithRelationInput
    actorUser?: UserOrderByWithRelationInput
  }

  export type AuditEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    branchId?: StringNullableFilter<"AuditEvent"> | string | null
    actorUserId?: StringNullableFilter<"AuditEvent"> | string | null
    action?: StringFilter<"AuditEvent"> | string
    entity?: StringFilter<"AuditEvent"> | string
    entityId?: StringNullableFilter<"AuditEvent"> | string | null
    meta?: JsonNullableFilter<"AuditEvent">
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
    branch?: XOR<BranchNullableRelationFilter, BranchWhereInput> | null
    actorUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditEventOrderByWithAggregationInput = {
    id?: SortOrder
    branchId?: SortOrderInput | SortOrder
    actorUserId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditEventCountOrderByAggregateInput
    _max?: AuditEventMaxOrderByAggregateInput
    _min?: AuditEventMinOrderByAggregateInput
  }

  export type AuditEventScalarWhereWithAggregatesInput = {
    AND?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    OR?: AuditEventScalarWhereWithAggregatesInput[]
    NOT?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditEvent"> | string
    branchId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    actorUserId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    action?: StringWithAggregatesFilter<"AuditEvent"> | string
    entity?: StringWithAggregatesFilter<"AuditEvent"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"AuditEvent">
    createdAt?: DateTimeWithAggregatesFilter<"AuditEvent"> | Date | string
  }

  export type OutboxEventWhereInput = {
    AND?: OutboxEventWhereInput | OutboxEventWhereInput[]
    OR?: OutboxEventWhereInput[]
    NOT?: OutboxEventWhereInput | OutboxEventWhereInput[]
    id?: StringFilter<"OutboxEvent"> | string
    topic?: StringFilter<"OutboxEvent"> | string
    key?: StringNullableFilter<"OutboxEvent"> | string | null
    payload?: JsonFilter<"OutboxEvent">
    status?: EnumOutboxStatusFilter<"OutboxEvent"> | $Enums.OutboxStatus
    attempts?: IntFilter<"OutboxEvent"> | number
    availableAt?: DateTimeFilter<"OutboxEvent"> | Date | string
    lockedAt?: DateTimeNullableFilter<"OutboxEvent"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"OutboxEvent"> | Date | string | null
    error?: StringNullableFilter<"OutboxEvent"> | string | null
    createdAt?: DateTimeFilter<"OutboxEvent"> | Date | string
    updatedAt?: DateTimeFilter<"OutboxEvent"> | Date | string
  }

  export type OutboxEventOrderByWithRelationInput = {
    id?: SortOrder
    topic?: SortOrder
    key?: SortOrderInput | SortOrder
    payload?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    availableAt?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboxEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutboxEventWhereInput | OutboxEventWhereInput[]
    OR?: OutboxEventWhereInput[]
    NOT?: OutboxEventWhereInput | OutboxEventWhereInput[]
    topic?: StringFilter<"OutboxEvent"> | string
    key?: StringNullableFilter<"OutboxEvent"> | string | null
    payload?: JsonFilter<"OutboxEvent">
    status?: EnumOutboxStatusFilter<"OutboxEvent"> | $Enums.OutboxStatus
    attempts?: IntFilter<"OutboxEvent"> | number
    availableAt?: DateTimeFilter<"OutboxEvent"> | Date | string
    lockedAt?: DateTimeNullableFilter<"OutboxEvent"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"OutboxEvent"> | Date | string | null
    error?: StringNullableFilter<"OutboxEvent"> | string | null
    createdAt?: DateTimeFilter<"OutboxEvent"> | Date | string
    updatedAt?: DateTimeFilter<"OutboxEvent"> | Date | string
  }, "id">

  export type OutboxEventOrderByWithAggregationInput = {
    id?: SortOrder
    topic?: SortOrder
    key?: SortOrderInput | SortOrder
    payload?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    availableAt?: SortOrder
    lockedAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutboxEventCountOrderByAggregateInput
    _avg?: OutboxEventAvgOrderByAggregateInput
    _max?: OutboxEventMaxOrderByAggregateInput
    _min?: OutboxEventMinOrderByAggregateInput
    _sum?: OutboxEventSumOrderByAggregateInput
  }

  export type OutboxEventScalarWhereWithAggregatesInput = {
    AND?: OutboxEventScalarWhereWithAggregatesInput | OutboxEventScalarWhereWithAggregatesInput[]
    OR?: OutboxEventScalarWhereWithAggregatesInput[]
    NOT?: OutboxEventScalarWhereWithAggregatesInput | OutboxEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutboxEvent"> | string
    topic?: StringWithAggregatesFilter<"OutboxEvent"> | string
    key?: StringNullableWithAggregatesFilter<"OutboxEvent"> | string | null
    payload?: JsonWithAggregatesFilter<"OutboxEvent">
    status?: EnumOutboxStatusWithAggregatesFilter<"OutboxEvent"> | $Enums.OutboxStatus
    attempts?: IntWithAggregatesFilter<"OutboxEvent"> | number
    availableAt?: DateTimeWithAggregatesFilter<"OutboxEvent"> | Date | string
    lockedAt?: DateTimeNullableWithAggregatesFilter<"OutboxEvent"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"OutboxEvent"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"OutboxEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OutboxEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OutboxEvent"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    code?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    category?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roleGrants?: RoleTemplatePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleGrants?: RoleTemplatePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    name?: StringFilter<"Permission"> | string
    category?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roleGrants?: RoleTemplatePermissionListRelationFilter
  }, "id" | "code">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    code?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    category?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RoleTemplateWhereInput = {
    AND?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    OR?: RoleTemplateWhereInput[]
    NOT?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    id?: StringFilter<"RoleTemplate"> | string
    code?: StringFilter<"RoleTemplate"> | string
    name?: StringFilter<"RoleTemplate"> | string
    scope?: EnumRoleScopeFilter<"RoleTemplate"> | $Enums.RoleScope
    description?: StringNullableFilter<"RoleTemplate"> | string | null
    isSystem?: BoolFilter<"RoleTemplate"> | boolean
    createdAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    versions?: RoleTemplateVersionListRelationFilter
  }

  export type RoleTemplateOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    versions?: RoleTemplateVersionOrderByRelationAggregateInput
  }

  export type RoleTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    OR?: RoleTemplateWhereInput[]
    NOT?: RoleTemplateWhereInput | RoleTemplateWhereInput[]
    name?: StringFilter<"RoleTemplate"> | string
    scope?: EnumRoleScopeFilter<"RoleTemplate"> | $Enums.RoleScope
    description?: StringNullableFilter<"RoleTemplate"> | string | null
    isSystem?: BoolFilter<"RoleTemplate"> | boolean
    createdAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplate"> | Date | string
    versions?: RoleTemplateVersionListRelationFilter
  }, "id" | "code">

  export type RoleTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleTemplateCountOrderByAggregateInput
    _max?: RoleTemplateMaxOrderByAggregateInput
    _min?: RoleTemplateMinOrderByAggregateInput
  }

  export type RoleTemplateScalarWhereWithAggregatesInput = {
    AND?: RoleTemplateScalarWhereWithAggregatesInput | RoleTemplateScalarWhereWithAggregatesInput[]
    OR?: RoleTemplateScalarWhereWithAggregatesInput[]
    NOT?: RoleTemplateScalarWhereWithAggregatesInput | RoleTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleTemplate"> | string
    code?: StringWithAggregatesFilter<"RoleTemplate"> | string
    name?: StringWithAggregatesFilter<"RoleTemplate"> | string
    scope?: EnumRoleScopeWithAggregatesFilter<"RoleTemplate"> | $Enums.RoleScope
    description?: StringNullableWithAggregatesFilter<"RoleTemplate"> | string | null
    isSystem?: BoolWithAggregatesFilter<"RoleTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RoleTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoleTemplate"> | Date | string
  }

  export type RoleTemplateVersionWhereInput = {
    AND?: RoleTemplateVersionWhereInput | RoleTemplateVersionWhereInput[]
    OR?: RoleTemplateVersionWhereInput[]
    NOT?: RoleTemplateVersionWhereInput | RoleTemplateVersionWhereInput[]
    id?: StringFilter<"RoleTemplateVersion"> | string
    roleTemplateId?: StringFilter<"RoleTemplateVersion"> | string
    version?: IntFilter<"RoleTemplateVersion"> | number
    status?: EnumRoleVersionStatusFilter<"RoleTemplateVersion"> | $Enums.RoleVersionStatus
    notes?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdByUserId?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
    roleTemplate?: XOR<RoleTemplateRelationFilter, RoleTemplateWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    permissions?: RoleTemplatePermissionListRelationFilter
    users?: UserListRelationFilter
  }

  export type RoleTemplateVersionOrderByWithRelationInput = {
    id?: SortOrder
    roleTemplateId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleTemplate?: RoleTemplateOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
    permissions?: RoleTemplatePermissionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleTemplateVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleTemplateId_version?: RoleTemplateVersionRoleTemplateIdVersionCompoundUniqueInput
    AND?: RoleTemplateVersionWhereInput | RoleTemplateVersionWhereInput[]
    OR?: RoleTemplateVersionWhereInput[]
    NOT?: RoleTemplateVersionWhereInput | RoleTemplateVersionWhereInput[]
    roleTemplateId?: StringFilter<"RoleTemplateVersion"> | string
    version?: IntFilter<"RoleTemplateVersion"> | number
    status?: EnumRoleVersionStatusFilter<"RoleTemplateVersion"> | $Enums.RoleVersionStatus
    notes?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdByUserId?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
    roleTemplate?: XOR<RoleTemplateRelationFilter, RoleTemplateWhereInput>
    createdByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    permissions?: RoleTemplatePermissionListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "roleTemplateId_version">

  export type RoleTemplateVersionOrderByWithAggregationInput = {
    id?: SortOrder
    roleTemplateId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleTemplateVersionCountOrderByAggregateInput
    _avg?: RoleTemplateVersionAvgOrderByAggregateInput
    _max?: RoleTemplateVersionMaxOrderByAggregateInput
    _min?: RoleTemplateVersionMinOrderByAggregateInput
    _sum?: RoleTemplateVersionSumOrderByAggregateInput
  }

  export type RoleTemplateVersionScalarWhereWithAggregatesInput = {
    AND?: RoleTemplateVersionScalarWhereWithAggregatesInput | RoleTemplateVersionScalarWhereWithAggregatesInput[]
    OR?: RoleTemplateVersionScalarWhereWithAggregatesInput[]
    NOT?: RoleTemplateVersionScalarWhereWithAggregatesInput | RoleTemplateVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleTemplateVersion"> | string
    roleTemplateId?: StringWithAggregatesFilter<"RoleTemplateVersion"> | string
    version?: IntWithAggregatesFilter<"RoleTemplateVersion"> | number
    status?: EnumRoleVersionStatusWithAggregatesFilter<"RoleTemplateVersion"> | $Enums.RoleVersionStatus
    notes?: StringNullableWithAggregatesFilter<"RoleTemplateVersion"> | string | null
    createdByUserId?: StringNullableWithAggregatesFilter<"RoleTemplateVersion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoleTemplateVersion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoleTemplateVersion"> | Date | string
  }

  export type RoleTemplatePermissionWhereInput = {
    AND?: RoleTemplatePermissionWhereInput | RoleTemplatePermissionWhereInput[]
    OR?: RoleTemplatePermissionWhereInput[]
    NOT?: RoleTemplatePermissionWhereInput | RoleTemplatePermissionWhereInput[]
    id?: StringFilter<"RoleTemplatePermission"> | string
    roleVersionId?: StringFilter<"RoleTemplatePermission"> | string
    permissionId?: StringFilter<"RoleTemplatePermission"> | string
    allowed?: BoolFilter<"RoleTemplatePermission"> | boolean
    createdAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
    roleVersion?: XOR<RoleTemplateVersionRelationFilter, RoleTemplateVersionWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }

  export type RoleTemplatePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleVersionId?: SortOrder
    permissionId?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleVersion?: RoleTemplateVersionOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RoleTemplatePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleVersionId_permissionId?: RoleTemplatePermissionRoleVersionIdPermissionIdCompoundUniqueInput
    AND?: RoleTemplatePermissionWhereInput | RoleTemplatePermissionWhereInput[]
    OR?: RoleTemplatePermissionWhereInput[]
    NOT?: RoleTemplatePermissionWhereInput | RoleTemplatePermissionWhereInput[]
    roleVersionId?: StringFilter<"RoleTemplatePermission"> | string
    permissionId?: StringFilter<"RoleTemplatePermission"> | string
    allowed?: BoolFilter<"RoleTemplatePermission"> | boolean
    createdAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
    roleVersion?: XOR<RoleTemplateVersionRelationFilter, RoleTemplateVersionWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }, "id" | "roleVersionId_permissionId">

  export type RoleTemplatePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleVersionId?: SortOrder
    permissionId?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleTemplatePermissionCountOrderByAggregateInput
    _max?: RoleTemplatePermissionMaxOrderByAggregateInput
    _min?: RoleTemplatePermissionMinOrderByAggregateInput
  }

  export type RoleTemplatePermissionScalarWhereWithAggregatesInput = {
    AND?: RoleTemplatePermissionScalarWhereWithAggregatesInput | RoleTemplatePermissionScalarWhereWithAggregatesInput[]
    OR?: RoleTemplatePermissionScalarWhereWithAggregatesInput[]
    NOT?: RoleTemplatePermissionScalarWhereWithAggregatesInput | RoleTemplatePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleTemplatePermission"> | string
    roleVersionId?: StringWithAggregatesFilter<"RoleTemplatePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RoleTemplatePermission"> | string
    allowed?: BoolWithAggregatesFilter<"RoleTemplatePermission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RoleTemplatePermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoleTemplatePermission"> | Date | string
  }

  export type BranchCreateInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    specialties?: SpecialtyCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    specialties?: SpecialtyUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyCreateInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSpecialtyInput
    department?: DepartmentCreateNestedOneWithoutSpecialtiesInput
    staff?: StaffCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSpecialtyNestedInput
    department?: DepartmentUpdateOneWithoutSpecialtiesNestedInput
    staff?: StaffUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyCreateManyInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    specialty?: SpecialtyCreateNestedOneWithoutStaffInput
    user?: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    specialty?: SpecialtyUpdateOneWithoutStaffNestedInput
    user?: UserUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffCreateManyInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateInput = {
    id?: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
    admissions?: AdmissionCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateInput = {
    id?: string
    branchId: string
    patientId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    admissions?: AdmissionUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterCreateManyInput = {
    id?: string
    branchId: string
    patientId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardCreateInput = {
    id?: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutWardsInput
    beds?: BedCreateNestedManyWithoutWardInput
  }

  export type WardUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    beds?: BedUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutWardsNestedInput
    beds?: BedUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beds?: BedUncheckedUpdateManyWithoutWardNestedInput
  }

  export type WardCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedCreateInput = {
    id?: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBedInput
    ward: WardCreateNestedOneWithoutBedsInput
    admissions?: AdmissionCreateNestedManyWithoutBedInput
  }

  export type BedUncheckedCreateInput = {
    id?: string
    branchId: string
    wardId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutBedInput
  }

  export type BedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBedNestedInput
    ward?: WardUpdateOneRequiredWithoutBedsNestedInput
    admissions?: AdmissionUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutBedNestedInput
  }

  export type BedCreateManyInput = {
    id?: string
    branchId: string
    wardId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionCreateInput = {
    id?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutAdmissionInput
    encounter?: EncounterCreateNestedOneWithoutAdmissionsInput
    patient: PatientCreateNestedOneWithoutAdmissionInput
    bed?: BedCreateNestedOneWithoutAdmissionsInput
  }

  export type AdmissionUncheckedCreateInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutAdmissionNestedInput
    encounter?: EncounterUpdateOneWithoutAdmissionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAdmissionNestedInput
    bed?: BedUpdateOneWithoutAdmissionsNestedInput
  }

  export type AdmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionCreateManyInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTCreateInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutOTsInput
  }

  export type OTUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutOTsNestedInput
  }

  export type OTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffPlanCreateInput = {
    id?: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutTariffPlansInput
    rates?: TariffRateCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanUncheckedCreateInput = {
    id?: string
    branchId: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rates?: TariffRateUncheckedCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutTariffPlansNestedInput
    rates?: TariffRateUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rates?: TariffRateUncheckedUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanCreateManyInput = {
    id?: string
    branchId: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCatalogItemCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCatalogItemUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCatalogItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCatalogItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCatalogItemCreateManyInput = {
    id?: string
    code: string
    name: string
    category: string
    unit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceCatalogItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCatalogItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateCreateInput = {
    id?: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tariffPlan: TariffPlanCreateNestedOneWithoutRatesInput
  }

  export type TariffRateUncheckedCreateInput = {
    id?: string
    tariffPlanId: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tariffPlan?: TariffPlanUpdateOneRequiredWithoutRatesNestedInput
  }

  export type TariffRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tariffPlanId?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateCreateManyInput = {
    id?: string
    tariffPlanId: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tariffPlanId?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordCreateInput = {
    id?: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutConsentRecordsInput
  }

  export type ConsentRecordUncheckedCreateInput = {
    id?: string
    patientId: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
  }

  export type ConsentRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutConsentRecordsNestedInput
  }

  export type ConsentRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordCreateManyInput = {
    id?: string
    patientId: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
  }

  export type ConsentRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestCreateInput = {
    id?: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutRtbfRequestsInput
  }

  export type RtbfRequestUncheckedCreateInput = {
    id?: string
    patientId: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RtbfRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRtbfRequestsNestedInput
  }

  export type RtbfRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestCreateManyInput = {
    id?: string
    patientId: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RtbfRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseCreateInput = {
    id?: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStatutoryCasesInput
    patient: PatientCreateNestedOneWithoutStatutoryCasesInput
  }

  export type StatutoryCaseUncheckedCreateInput = {
    id?: string
    branchId: string
    patientId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStatutoryCasesNestedInput
    patient?: PatientUpdateOneRequiredWithoutStatutoryCasesNestedInput
  }

  export type StatutoryCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseCreateManyInput = {
    id?: string
    branchId: string
    patientId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventCreateInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutAuditEventsInput
    actorUser?: UserCreateNestedOneWithoutAuditEventsAsActorInput
  }

  export type AuditEventUncheckedCreateInput = {
    id?: string
    branchId?: string | null
    actorUserId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutAuditEventsNestedInput
    actorUser?: UserUpdateOneWithoutAuditEventsAsActorNestedInput
  }

  export type AuditEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventCreateManyInput = {
    id?: string
    branchId?: string | null
    actorUserId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboxEventCreateInput = {
    id?: string
    topic: string
    key?: string | null
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.OutboxStatus
    attempts?: number
    availableAt?: Date | string
    lockedAt?: Date | string | null
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboxEventUncheckedCreateInput = {
    id?: string
    topic: string
    key?: string | null
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.OutboxStatus
    attempts?: number
    availableAt?: Date | string
    lockedAt?: Date | string | null
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboxEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    attempts?: IntFieldUpdateOperationsInput | number
    availableAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboxEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    attempts?: IntFieldUpdateOperationsInput | number
    availableAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboxEventCreateManyInput = {
    id?: string
    topic: string
    key?: string | null
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.OutboxStatus
    attempts?: number
    availableAt?: Date | string
    lockedAt?: Date | string | null
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutboxEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    attempts?: IntFieldUpdateOperationsInput | number
    availableAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutboxEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    attempts?: IntFieldUpdateOperationsInput | number
    availableAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleGrants?: RoleTemplatePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleGrants?: RoleTemplatePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleGrants?: RoleTemplatePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleGrants?: RoleTemplatePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    code: string
    name: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateCreateInput = {
    id?: string
    code: string
    name: string
    scope?: $Enums.RoleScope
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: RoleTemplateVersionCreateNestedManyWithoutRoleTemplateInput
  }

  export type RoleTemplateUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    scope?: $Enums.RoleScope
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutRoleTemplateInput
  }

  export type RoleTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: RoleTemplateVersionUpdateManyWithoutRoleTemplateNestedInput
  }

  export type RoleTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: RoleTemplateVersionUncheckedUpdateManyWithoutRoleTemplateNestedInput
  }

  export type RoleTemplateCreateManyInput = {
    id?: string
    code: string
    name: string
    scope?: $Enums.RoleScope
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateVersionCreateInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleTemplate: RoleTemplateCreateNestedOneWithoutVersionsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedRoleVersionsInput
    permissions?: RoleTemplatePermissionCreateNestedManyWithoutRoleVersionInput
    users?: UserCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUncheckedCreateInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RoleTemplatePermissionUncheckedCreateNestedManyWithoutRoleVersionInput
    users?: UserUncheckedCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleTemplate?: RoleTemplateUpdateOneRequiredWithoutVersionsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedRoleVersionsNestedInput
    permissions?: RoleTemplatePermissionUpdateManyWithoutRoleVersionNestedInput
    users?: UserUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionCreateManyInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionCreateInput = {
    id?: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roleVersion: RoleTemplateVersionCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRoleGrantsInput
  }

  export type RoleTemplatePermissionUncheckedCreateInput = {
    id?: string
    roleVersionId: string
    permissionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleVersion?: RoleTemplateVersionUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRoleGrantsNestedInput
  }

  export type RoleTemplatePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleVersionId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionCreateManyInput = {
    id?: string
    roleVersionId: string
    permissionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleVersionId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type WardListRelationFilter = {
    every?: WardWhereInput
    some?: WardWhereInput
    none?: WardWhereInput
  }

  export type OTListRelationFilter = {
    every?: OTWhereInput
    some?: OTWhereInput
    none?: OTWhereInput
  }

  export type TariffPlanListRelationFilter = {
    every?: TariffPlanWhereInput
    some?: TariffPlanWhereInput
    none?: TariffPlanWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type SpecialtyListRelationFilter = {
    every?: SpecialtyWhereInput
    some?: SpecialtyWhereInput
    none?: SpecialtyWhereInput
  }

  export type StaffListRelationFilter = {
    every?: StaffWhereInput
    some?: StaffWhereInput
    none?: StaffWhereInput
  }

  export type EncounterListRelationFilter = {
    every?: EncounterWhereInput
    some?: EncounterWhereInput
    none?: EncounterWhereInput
  }

  export type BedListRelationFilter = {
    every?: BedWhereInput
    some?: BedWhereInput
    none?: BedWhereInput
  }

  export type AdmissionListRelationFilter = {
    every?: AdmissionWhereInput
    some?: AdmissionWhereInput
    none?: AdmissionWhereInput
  }

  export type StatutoryCaseListRelationFilter = {
    every?: StatutoryCaseWhereInput
    some?: StatutoryCaseWhereInput
    none?: StatutoryCaseWhereInput
  }

  export type AuditEventListRelationFilter = {
    every?: AuditEventWhereInput
    some?: AuditEventWhereInput
    none?: AuditEventWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OTOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TariffPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecialtyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StatutoryCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    address?: SortOrder
    contactPhone1?: SortOrder
    contactPhone2?: SortOrder
    contactEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    address?: SortOrder
    contactPhone1?: SortOrder
    contactPhone2?: SortOrder
    contactEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    address?: SortOrder
    contactPhone1?: SortOrder
    contactPhone2?: SortOrder
    contactEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BranchRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type DepartmentBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DepartmentNullableRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type SpecialtyBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type SpecialtyCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyNullableRelationFilter = {
    is?: SpecialtyWhereInput | null
    isNot?: SpecialtyWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type StaffBranchIdEmpCodeCompoundUniqueInput = {
    branchId: string
    empCode: string
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    specialtyId?: SortOrder
    empCode?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    specialtyId?: SortOrder
    empCode?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    departmentId?: SortOrder
    specialtyId?: SortOrder
    empCode?: SortOrder
    name?: SortOrder
    designation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BranchNullableRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type StaffNullableRelationFilter = {
    is?: StaffWhereInput | null
    isNot?: StaffWhereInput | null
  }

  export type RoleTemplateVersionNullableRelationFilter = {
    is?: RoleTemplateVersionWhereInput | null
    isNot?: RoleTemplateVersionWhereInput | null
  }

  export type RoleTemplateVersionListRelationFilter = {
    every?: RoleTemplateVersionWhereInput
    some?: RoleTemplateVersionWhereInput
    none?: RoleTemplateVersionWhereInput
  }

  export type RoleTemplateVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    branchId?: SortOrder
    staffId?: SortOrder
    isActive?: SortOrder
    passwordHash?: SortOrder
    mustChangePassword?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    roleVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    branchId?: SortOrder
    staffId?: SortOrder
    isActive?: SortOrder
    passwordHash?: SortOrder
    mustChangePassword?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    roleVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    branchId?: SortOrder
    staffId?: SortOrder
    isActive?: SortOrder
    passwordHash?: SortOrder
    mustChangePassword?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    roleVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ConsentRecordListRelationFilter = {
    every?: ConsentRecordWhereInput
    some?: ConsentRecordWhereInput
    none?: ConsentRecordWhereInput
  }

  export type RtbfRequestListRelationFilter = {
    every?: RtbfRequestWhereInput
    some?: RtbfRequestWhereInput
    none?: RtbfRequestWhereInput
  }

  export type ConsentRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RtbfRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientBranchIdUhidCompoundUniqueInput = {
    branchId: string
    uhid: string
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    uhid?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    uhid?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    uhid?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEncounterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterType | EnumEncounterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterTypeFilter<$PrismaModel> | $Enums.EncounterType
  }

  export type PatientRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type EncounterCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEncounterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterType | EnumEncounterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterTypeWithAggregatesFilter<$PrismaModel> | $Enums.EncounterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEncounterTypeFilter<$PrismaModel>
    _max?: NestedEnumEncounterTypeFilter<$PrismaModel>
  }

  export type WardBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type WardCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    specialty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WardMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    specialty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WardMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    specialty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBedStateFilter<$PrismaModel = never> = {
    equals?: $Enums.BedState | EnumBedStateFieldRefInput<$PrismaModel>
    in?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStateFilter<$PrismaModel> | $Enums.BedState
  }

  export type WardRelationFilter = {
    is?: WardWhereInput
    isNot?: WardWhereInput
  }

  export type BedWardIdCodeCompoundUniqueInput = {
    wardId: string
    code: string
  }

  export type BedCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    wardId?: SortOrder
    code?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BedMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    wardId?: SortOrder
    code?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BedMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    wardId?: SortOrder
    code?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBedStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BedState | EnumBedStateFieldRefInput<$PrismaModel>
    in?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStateWithAggregatesFilter<$PrismaModel> | $Enums.BedState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBedStateFilter<$PrismaModel>
    _max?: NestedEnumBedStateFilter<$PrismaModel>
  }

  export type EncounterNullableRelationFilter = {
    is?: EncounterWhereInput | null
    isNot?: EncounterWhereInput | null
  }

  export type BedNullableRelationFilter = {
    is?: BedWhereInput | null
    isNot?: BedWhereInput | null
  }

  export type AdmissionCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    bedId?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    bedId?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    encounterId?: SortOrder
    patientId?: SortOrder
    bedId?: SortOrder
    admittedAt?: SortOrder
    dischargedAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type OTCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OTMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    location?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffRateListRelationFilter = {
    every?: TariffRateWhereInput
    some?: TariffRateWhereInput
    none?: TariffRateWhereInput
  }

  export type TariffRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TariffPlanBranchIdCodeCompoundUniqueInput = {
    branchId: string
    code: string
  }

  export type TariffPlanCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    payerType?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    payerType?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffPlanMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    payerType?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCatalogItemCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCatalogItemMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceCatalogItemMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TariffPlanRelationFilter = {
    is?: TariffPlanWhereInput
    isNot?: TariffPlanWhereInput
  }

  export type TariffRateTariffPlanIdServiceCodeCompoundUniqueInput = {
    tariffPlanId: string
    serviceCode: string
  }

  export type TariffRateCountOrderByAggregateInput = {
    id?: SortOrder
    tariffPlanId?: SortOrder
    serviceCode?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffRateAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TariffRateMaxOrderByAggregateInput = {
    id?: SortOrder
    tariffPlanId?: SortOrder
    serviceCode?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffRateMinOrderByAggregateInput = {
    id?: SortOrder
    tariffPlanId?: SortOrder
    serviceCode?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffRateSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumConsentScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentScope | EnumConsentScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentScopeFilter<$PrismaModel> | $Enums.ConsentScope
  }

  export type EnumConsentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusFilter<$PrismaModel> | $Enums.ConsentStatus
  }

  export type ConsentRecordCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    scope?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsentRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    scope?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsentRecordMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    scope?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumConsentScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentScope | EnumConsentScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentScopeWithAggregatesFilter<$PrismaModel> | $Enums.ConsentScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentScopeFilter<$PrismaModel>
    _max?: NestedEnumConsentScopeFilter<$PrismaModel>
  }

  export type EnumConsentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConsentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentStatusFilter<$PrismaModel>
    _max?: NestedEnumConsentStatusFilter<$PrismaModel>
  }

  export type EnumRtbfStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RtbfStatus | EnumRtbfStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRtbfStatusFilter<$PrismaModel> | $Enums.RtbfStatus
  }

  export type RtbfRequestCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RtbfRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RtbfRequestMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRtbfStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RtbfStatus | EnumRtbfStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRtbfStatusWithAggregatesFilter<$PrismaModel> | $Enums.RtbfStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRtbfStatusFilter<$PrismaModel>
    _max?: NestedEnumRtbfStatusFilter<$PrismaModel>
  }

  export type StatutoryCaseCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    program?: SortOrder
    disease?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatutoryCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    program?: SortOrder
    disease?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatutoryCaseMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    patientId?: SortOrder
    program?: SortOrder
    disease?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditEventCountOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventMaxOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventMinOrderByAggregateInput = {
    id?: SortOrder
    branchId?: SortOrder
    actorUserId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumOutboxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusFilter<$PrismaModel> | $Enums.OutboxStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type OutboxEventCountOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    key?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    availableAt?: SortOrder
    lockedAt?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboxEventAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type OutboxEventMaxOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    key?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    availableAt?: SortOrder
    lockedAt?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboxEventMinOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    key?: SortOrder
    status?: SortOrder
    attempts?: SortOrder
    availableAt?: SortOrder
    lockedAt?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutboxEventSumOrderByAggregateInput = {
    attempts?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumOutboxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusWithAggregatesFilter<$PrismaModel> | $Enums.OutboxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOutboxStatusFilter<$PrismaModel>
    _max?: NestedEnumOutboxStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type RoleTemplatePermissionListRelationFilter = {
    every?: RoleTemplatePermissionWhereInput
    some?: RoleTemplatePermissionWhereInput
    none?: RoleTemplatePermissionWhereInput
  }

  export type RoleTemplatePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleScope | EnumRoleScopeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleScopeFilter<$PrismaModel> | $Enums.RoleScope
  }

  export type RoleTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    scope?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleScope | EnumRoleScopeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleScopeWithAggregatesFilter<$PrismaModel> | $Enums.RoleScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleScopeFilter<$PrismaModel>
    _max?: NestedEnumRoleScopeFilter<$PrismaModel>
  }

  export type EnumRoleVersionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleVersionStatus | EnumRoleVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleVersionStatusFilter<$PrismaModel> | $Enums.RoleVersionStatus
  }

  export type RoleTemplateRelationFilter = {
    is?: RoleTemplateWhereInput
    isNot?: RoleTemplateWhereInput
  }

  export type RoleTemplateVersionRoleTemplateIdVersionCompoundUniqueInput = {
    roleTemplateId: string
    version: number
  }

  export type RoleTemplateVersionCountOrderByAggregateInput = {
    id?: SortOrder
    roleTemplateId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateVersionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type RoleTemplateVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleTemplateId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateVersionMinOrderByAggregateInput = {
    id?: SortOrder
    roleTemplateId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplateVersionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumRoleVersionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleVersionStatus | EnumRoleVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleVersionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoleVersionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleVersionStatusFilter<$PrismaModel>
    _max?: NestedEnumRoleVersionStatusFilter<$PrismaModel>
  }

  export type RoleTemplateVersionRelationFilter = {
    is?: RoleTemplateVersionWhereInput
    isNot?: RoleTemplateVersionWhereInput
  }

  export type PermissionRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RoleTemplatePermissionRoleVersionIdPermissionIdCompoundUniqueInput = {
    roleVersionId: string
    permissionId: string
  }

  export type RoleTemplatePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleVersionId?: SortOrder
    permissionId?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplatePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleVersionId?: SortOrder
    permissionId?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleTemplatePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleVersionId?: SortOrder
    permissionId?: SortOrder
    allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentCreateNestedManyWithoutBranchInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutBranchInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type WardCreateNestedManyWithoutBranchInput = {
    create?: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput> | WardCreateWithoutBranchInput[] | WardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WardCreateOrConnectWithoutBranchInput | WardCreateOrConnectWithoutBranchInput[]
    createMany?: WardCreateManyBranchInputEnvelope
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
  }

  export type OTCreateNestedManyWithoutBranchInput = {
    create?: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput> | OTCreateWithoutBranchInput[] | OTUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: OTCreateOrConnectWithoutBranchInput | OTCreateOrConnectWithoutBranchInput[]
    createMany?: OTCreateManyBranchInputEnvelope
    connect?: OTWhereUniqueInput | OTWhereUniqueInput[]
  }

  export type TariffPlanCreateNestedManyWithoutBranchInput = {
    create?: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput> | TariffPlanCreateWithoutBranchInput[] | TariffPlanUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutBranchInput | TariffPlanCreateOrConnectWithoutBranchInput[]
    createMany?: TariffPlanCreateManyBranchInputEnvelope
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutBranchInput = {
    create?: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput> | AssetCreateWithoutBranchInput[] | AssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBranchInput | AssetCreateOrConnectWithoutBranchInput[]
    createMany?: AssetCreateManyBranchInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type SpecialtyCreateNestedManyWithoutBranchInput = {
    create?: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput> | SpecialtyCreateWithoutBranchInput[] | SpecialtyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutBranchInput | SpecialtyCreateOrConnectWithoutBranchInput[]
    createMany?: SpecialtyCreateManyBranchInputEnvelope
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
  }

  export type StaffCreateNestedManyWithoutBranchInput = {
    create?: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput> | StaffCreateWithoutBranchInput[] | StaffUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutBranchInput | StaffCreateOrConnectWithoutBranchInput[]
    createMany?: StaffCreateManyBranchInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutBranchInput = {
    create?: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput> | EncounterCreateWithoutBranchInput[] | EncounterUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutBranchInput | EncounterCreateOrConnectWithoutBranchInput[]
    createMany?: EncounterCreateManyBranchInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type BedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput> | BedCreateWithoutBranchInput[] | BedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBranchInput | BedCreateOrConnectWithoutBranchInput[]
    createMany?: BedCreateManyBranchInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type AdmissionCreateNestedManyWithoutBranchInput = {
    create?: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput> | AdmissionCreateWithoutBranchInput[] | AdmissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBranchInput | AdmissionCreateOrConnectWithoutBranchInput[]
    createMany?: AdmissionCreateManyBranchInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type StatutoryCaseCreateNestedManyWithoutBranchInput = {
    create?: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput> | StatutoryCaseCreateWithoutBranchInput[] | StatutoryCaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutBranchInput | StatutoryCaseCreateOrConnectWithoutBranchInput[]
    createMany?: StatutoryCaseCreateManyBranchInputEnvelope
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
  }

  export type AuditEventCreateNestedManyWithoutBranchInput = {
    create?: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput> | AuditEventCreateWithoutBranchInput[] | AuditEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutBranchInput | AuditEventCreateOrConnectWithoutBranchInput[]
    createMany?: AuditEventCreateManyBranchInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type WardUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput> | WardCreateWithoutBranchInput[] | WardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WardCreateOrConnectWithoutBranchInput | WardCreateOrConnectWithoutBranchInput[]
    createMany?: WardCreateManyBranchInputEnvelope
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
  }

  export type OTUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput> | OTCreateWithoutBranchInput[] | OTUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: OTCreateOrConnectWithoutBranchInput | OTCreateOrConnectWithoutBranchInput[]
    createMany?: OTCreateManyBranchInputEnvelope
    connect?: OTWhereUniqueInput | OTWhereUniqueInput[]
  }

  export type TariffPlanUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput> | TariffPlanCreateWithoutBranchInput[] | TariffPlanUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutBranchInput | TariffPlanCreateOrConnectWithoutBranchInput[]
    createMany?: TariffPlanCreateManyBranchInputEnvelope
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput> | AssetCreateWithoutBranchInput[] | AssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBranchInput | AssetCreateOrConnectWithoutBranchInput[]
    createMany?: AssetCreateManyBranchInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type SpecialtyUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput> | SpecialtyCreateWithoutBranchInput[] | SpecialtyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutBranchInput | SpecialtyCreateOrConnectWithoutBranchInput[]
    createMany?: SpecialtyCreateManyBranchInputEnvelope
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput> | StaffCreateWithoutBranchInput[] | StaffUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutBranchInput | StaffCreateOrConnectWithoutBranchInput[]
    createMany?: StaffCreateManyBranchInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput> | EncounterCreateWithoutBranchInput[] | EncounterUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutBranchInput | EncounterCreateOrConnectWithoutBranchInput[]
    createMany?: EncounterCreateManyBranchInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type BedUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput> | BedCreateWithoutBranchInput[] | BedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBranchInput | BedCreateOrConnectWithoutBranchInput[]
    createMany?: BedCreateManyBranchInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput> | AdmissionCreateWithoutBranchInput[] | AdmissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBranchInput | AdmissionCreateOrConnectWithoutBranchInput[]
    createMany?: AdmissionCreateManyBranchInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput> | StatutoryCaseCreateWithoutBranchInput[] | StatutoryCaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutBranchInput | StatutoryCaseCreateOrConnectWithoutBranchInput[]
    createMany?: StatutoryCaseCreateManyBranchInputEnvelope
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
  }

  export type AuditEventUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput> | AuditEventCreateWithoutBranchInput[] | AuditEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutBranchInput | AuditEventCreateOrConnectWithoutBranchInput[]
    createMany?: AuditEventCreateManyBranchInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DepartmentUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutBranchInput | DepartmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutBranchInput | DepartmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutBranchInput | DepartmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutBranchInput | PatientUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutBranchInput | PatientUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutBranchInput | PatientUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type WardUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput> | WardCreateWithoutBranchInput[] | WardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WardCreateOrConnectWithoutBranchInput | WardCreateOrConnectWithoutBranchInput[]
    upsert?: WardUpsertWithWhereUniqueWithoutBranchInput | WardUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WardCreateManyBranchInputEnvelope
    set?: WardWhereUniqueInput | WardWhereUniqueInput[]
    disconnect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    delete?: WardWhereUniqueInput | WardWhereUniqueInput[]
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    update?: WardUpdateWithWhereUniqueWithoutBranchInput | WardUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WardUpdateManyWithWhereWithoutBranchInput | WardUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WardScalarWhereInput | WardScalarWhereInput[]
  }

  export type OTUpdateManyWithoutBranchNestedInput = {
    create?: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput> | OTCreateWithoutBranchInput[] | OTUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: OTCreateOrConnectWithoutBranchInput | OTCreateOrConnectWithoutBranchInput[]
    upsert?: OTUpsertWithWhereUniqueWithoutBranchInput | OTUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: OTCreateManyBranchInputEnvelope
    set?: OTWhereUniqueInput | OTWhereUniqueInput[]
    disconnect?: OTWhereUniqueInput | OTWhereUniqueInput[]
    delete?: OTWhereUniqueInput | OTWhereUniqueInput[]
    connect?: OTWhereUniqueInput | OTWhereUniqueInput[]
    update?: OTUpdateWithWhereUniqueWithoutBranchInput | OTUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: OTUpdateManyWithWhereWithoutBranchInput | OTUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: OTScalarWhereInput | OTScalarWhereInput[]
  }

  export type TariffPlanUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput> | TariffPlanCreateWithoutBranchInput[] | TariffPlanUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutBranchInput | TariffPlanCreateOrConnectWithoutBranchInput[]
    upsert?: TariffPlanUpsertWithWhereUniqueWithoutBranchInput | TariffPlanUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TariffPlanCreateManyBranchInputEnvelope
    set?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    disconnect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    delete?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    update?: TariffPlanUpdateWithWhereUniqueWithoutBranchInput | TariffPlanUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TariffPlanUpdateManyWithWhereWithoutBranchInput | TariffPlanUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput> | AssetCreateWithoutBranchInput[] | AssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBranchInput | AssetCreateOrConnectWithoutBranchInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutBranchInput | AssetUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AssetCreateManyBranchInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutBranchInput | AssetUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutBranchInput | AssetUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type SpecialtyUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput> | SpecialtyCreateWithoutBranchInput[] | SpecialtyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutBranchInput | SpecialtyCreateOrConnectWithoutBranchInput[]
    upsert?: SpecialtyUpsertWithWhereUniqueWithoutBranchInput | SpecialtyUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SpecialtyCreateManyBranchInputEnvelope
    set?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    disconnect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    delete?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    update?: SpecialtyUpdateWithWhereUniqueWithoutBranchInput | SpecialtyUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SpecialtyUpdateManyWithWhereWithoutBranchInput | SpecialtyUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
  }

  export type StaffUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput> | StaffCreateWithoutBranchInput[] | StaffUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutBranchInput | StaffCreateOrConnectWithoutBranchInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutBranchInput | StaffUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StaffCreateManyBranchInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutBranchInput | StaffUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutBranchInput | StaffUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput> | EncounterCreateWithoutBranchInput[] | EncounterUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutBranchInput | EncounterCreateOrConnectWithoutBranchInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutBranchInput | EncounterUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EncounterCreateManyBranchInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutBranchInput | EncounterUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutBranchInput | EncounterUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type BedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput> | BedCreateWithoutBranchInput[] | BedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBranchInput | BedCreateOrConnectWithoutBranchInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutBranchInput | BedUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BedCreateManyBranchInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutBranchInput | BedUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BedUpdateManyWithWhereWithoutBranchInput | BedUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type AdmissionUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput> | AdmissionCreateWithoutBranchInput[] | AdmissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBranchInput | AdmissionCreateOrConnectWithoutBranchInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutBranchInput | AdmissionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AdmissionCreateManyBranchInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutBranchInput | AdmissionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutBranchInput | AdmissionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type StatutoryCaseUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput> | StatutoryCaseCreateWithoutBranchInput[] | StatutoryCaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutBranchInput | StatutoryCaseCreateOrConnectWithoutBranchInput[]
    upsert?: StatutoryCaseUpsertWithWhereUniqueWithoutBranchInput | StatutoryCaseUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StatutoryCaseCreateManyBranchInputEnvelope
    set?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    disconnect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    delete?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    update?: StatutoryCaseUpdateWithWhereUniqueWithoutBranchInput | StatutoryCaseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StatutoryCaseUpdateManyWithWhereWithoutBranchInput | StatutoryCaseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
  }

  export type AuditEventUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput> | AuditEventCreateWithoutBranchInput[] | AuditEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutBranchInput | AuditEventCreateOrConnectWithoutBranchInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutBranchInput | AuditEventUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AuditEventCreateManyBranchInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutBranchInput | AuditEventUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutBranchInput | AuditEventUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput> | DepartmentCreateWithoutBranchInput[] | DepartmentUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutBranchInput | DepartmentCreateOrConnectWithoutBranchInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutBranchInput | DepartmentUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: DepartmentCreateManyBranchInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutBranchInput | DepartmentUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutBranchInput | DepartmentUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput> | PatientCreateWithoutBranchInput[] | PatientUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutBranchInput | PatientCreateOrConnectWithoutBranchInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutBranchInput | PatientUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: PatientCreateManyBranchInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutBranchInput | PatientUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutBranchInput | PatientUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type WardUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput> | WardCreateWithoutBranchInput[] | WardUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: WardCreateOrConnectWithoutBranchInput | WardCreateOrConnectWithoutBranchInput[]
    upsert?: WardUpsertWithWhereUniqueWithoutBranchInput | WardUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: WardCreateManyBranchInputEnvelope
    set?: WardWhereUniqueInput | WardWhereUniqueInput[]
    disconnect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    delete?: WardWhereUniqueInput | WardWhereUniqueInput[]
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    update?: WardUpdateWithWhereUniqueWithoutBranchInput | WardUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: WardUpdateManyWithWhereWithoutBranchInput | WardUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: WardScalarWhereInput | WardScalarWhereInput[]
  }

  export type OTUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput> | OTCreateWithoutBranchInput[] | OTUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: OTCreateOrConnectWithoutBranchInput | OTCreateOrConnectWithoutBranchInput[]
    upsert?: OTUpsertWithWhereUniqueWithoutBranchInput | OTUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: OTCreateManyBranchInputEnvelope
    set?: OTWhereUniqueInput | OTWhereUniqueInput[]
    disconnect?: OTWhereUniqueInput | OTWhereUniqueInput[]
    delete?: OTWhereUniqueInput | OTWhereUniqueInput[]
    connect?: OTWhereUniqueInput | OTWhereUniqueInput[]
    update?: OTUpdateWithWhereUniqueWithoutBranchInput | OTUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: OTUpdateManyWithWhereWithoutBranchInput | OTUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: OTScalarWhereInput | OTScalarWhereInput[]
  }

  export type TariffPlanUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput> | TariffPlanCreateWithoutBranchInput[] | TariffPlanUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: TariffPlanCreateOrConnectWithoutBranchInput | TariffPlanCreateOrConnectWithoutBranchInput[]
    upsert?: TariffPlanUpsertWithWhereUniqueWithoutBranchInput | TariffPlanUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: TariffPlanCreateManyBranchInputEnvelope
    set?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    disconnect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    delete?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    connect?: TariffPlanWhereUniqueInput | TariffPlanWhereUniqueInput[]
    update?: TariffPlanUpdateWithWhereUniqueWithoutBranchInput | TariffPlanUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: TariffPlanUpdateManyWithWhereWithoutBranchInput | TariffPlanUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput> | AssetCreateWithoutBranchInput[] | AssetUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutBranchInput | AssetCreateOrConnectWithoutBranchInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutBranchInput | AssetUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AssetCreateManyBranchInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutBranchInput | AssetUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutBranchInput | AssetUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type SpecialtyUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput> | SpecialtyCreateWithoutBranchInput[] | SpecialtyUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutBranchInput | SpecialtyCreateOrConnectWithoutBranchInput[]
    upsert?: SpecialtyUpsertWithWhereUniqueWithoutBranchInput | SpecialtyUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SpecialtyCreateManyBranchInputEnvelope
    set?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    disconnect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    delete?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    update?: SpecialtyUpdateWithWhereUniqueWithoutBranchInput | SpecialtyUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SpecialtyUpdateManyWithWhereWithoutBranchInput | SpecialtyUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput> | StaffCreateWithoutBranchInput[] | StaffUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutBranchInput | StaffCreateOrConnectWithoutBranchInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutBranchInput | StaffUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StaffCreateManyBranchInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutBranchInput | StaffUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutBranchInput | StaffUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput> | EncounterCreateWithoutBranchInput[] | EncounterUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutBranchInput | EncounterCreateOrConnectWithoutBranchInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutBranchInput | EncounterUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EncounterCreateManyBranchInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutBranchInput | EncounterUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutBranchInput | EncounterUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type BedUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput> | BedCreateWithoutBranchInput[] | BedUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BedCreateOrConnectWithoutBranchInput | BedCreateOrConnectWithoutBranchInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutBranchInput | BedUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BedCreateManyBranchInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutBranchInput | BedUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BedUpdateManyWithWhereWithoutBranchInput | BedUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput> | AdmissionCreateWithoutBranchInput[] | AdmissionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBranchInput | AdmissionCreateOrConnectWithoutBranchInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutBranchInput | AdmissionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AdmissionCreateManyBranchInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutBranchInput | AdmissionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutBranchInput | AdmissionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput> | StatutoryCaseCreateWithoutBranchInput[] | StatutoryCaseUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutBranchInput | StatutoryCaseCreateOrConnectWithoutBranchInput[]
    upsert?: StatutoryCaseUpsertWithWhereUniqueWithoutBranchInput | StatutoryCaseUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StatutoryCaseCreateManyBranchInputEnvelope
    set?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    disconnect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    delete?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    update?: StatutoryCaseUpdateWithWhereUniqueWithoutBranchInput | StatutoryCaseUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StatutoryCaseUpdateManyWithWhereWithoutBranchInput | StatutoryCaseUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
  }

  export type AuditEventUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput> | AuditEventCreateWithoutBranchInput[] | AuditEventUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutBranchInput | AuditEventCreateOrConnectWithoutBranchInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutBranchInput | AuditEventUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: AuditEventCreateManyBranchInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutBranchInput | AuditEventUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutBranchInput | AuditEventUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDepartmentsInput
    connect?: BranchWhereUniqueInput
  }

  export type StaffCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type SpecialtyCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<SpecialtyCreateWithoutDepartmentInput, SpecialtyUncheckedCreateWithoutDepartmentInput> | SpecialtyCreateWithoutDepartmentInput[] | SpecialtyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutDepartmentInput | SpecialtyCreateOrConnectWithoutDepartmentInput[]
    createMany?: SpecialtyCreateManyDepartmentInputEnvelope
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type SpecialtyUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<SpecialtyCreateWithoutDepartmentInput, SpecialtyUncheckedCreateWithoutDepartmentInput> | SpecialtyCreateWithoutDepartmentInput[] | SpecialtyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutDepartmentInput | SpecialtyCreateOrConnectWithoutDepartmentInput[]
    createMany?: SpecialtyCreateManyDepartmentInputEnvelope
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BranchUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutDepartmentsInput
    upsert?: BranchUpsertWithoutDepartmentsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutDepartmentsInput, BranchUpdateWithoutDepartmentsInput>, BranchUncheckedUpdateWithoutDepartmentsInput>
  }

  export type StaffUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutDepartmentInput | StaffUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutDepartmentInput | StaffUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutDepartmentInput | StaffUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type SpecialtyUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<SpecialtyCreateWithoutDepartmentInput, SpecialtyUncheckedCreateWithoutDepartmentInput> | SpecialtyCreateWithoutDepartmentInput[] | SpecialtyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutDepartmentInput | SpecialtyCreateOrConnectWithoutDepartmentInput[]
    upsert?: SpecialtyUpsertWithWhereUniqueWithoutDepartmentInput | SpecialtyUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: SpecialtyCreateManyDepartmentInputEnvelope
    set?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    disconnect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    delete?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    update?: SpecialtyUpdateWithWhereUniqueWithoutDepartmentInput | SpecialtyUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: SpecialtyUpdateManyWithWhereWithoutDepartmentInput | SpecialtyUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutDepartmentInput | StaffUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutDepartmentInput | StaffUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutDepartmentInput | StaffUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type SpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<SpecialtyCreateWithoutDepartmentInput, SpecialtyUncheckedCreateWithoutDepartmentInput> | SpecialtyCreateWithoutDepartmentInput[] | SpecialtyUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutDepartmentInput | SpecialtyCreateOrConnectWithoutDepartmentInput[]
    upsert?: SpecialtyUpsertWithWhereUniqueWithoutDepartmentInput | SpecialtyUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: SpecialtyCreateManyDepartmentInputEnvelope
    set?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    disconnect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    delete?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    update?: SpecialtyUpdateWithWhereUniqueWithoutDepartmentInput | SpecialtyUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: SpecialtyUpdateManyWithWhereWithoutDepartmentInput | SpecialtyUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutSpecialtyInput = {
    create?: XOR<BranchCreateWithoutSpecialtyInput, BranchUncheckedCreateWithoutSpecialtyInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSpecialtyInput
    connect?: BranchWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutSpecialtiesInput = {
    create?: XOR<DepartmentCreateWithoutSpecialtiesInput, DepartmentUncheckedCreateWithoutSpecialtiesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSpecialtiesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type StaffCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput> | StaffCreateWithoutSpecialtyInput[] | StaffUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSpecialtyInput | StaffCreateOrConnectWithoutSpecialtyInput[]
    createMany?: StaffCreateManySpecialtyInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput> | StaffCreateWithoutSpecialtyInput[] | StaffUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSpecialtyInput | StaffCreateOrConnectWithoutSpecialtyInput[]
    createMany?: StaffCreateManySpecialtyInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutSpecialtyNestedInput = {
    create?: XOR<BranchCreateWithoutSpecialtyInput, BranchUncheckedCreateWithoutSpecialtyInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSpecialtyInput
    upsert?: BranchUpsertWithoutSpecialtyInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSpecialtyInput, BranchUpdateWithoutSpecialtyInput>, BranchUncheckedUpdateWithoutSpecialtyInput>
  }

  export type DepartmentUpdateOneWithoutSpecialtiesNestedInput = {
    create?: XOR<DepartmentCreateWithoutSpecialtiesInput, DepartmentUncheckedCreateWithoutSpecialtiesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSpecialtiesInput
    upsert?: DepartmentUpsertWithoutSpecialtiesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutSpecialtiesInput, DepartmentUpdateWithoutSpecialtiesInput>, DepartmentUncheckedUpdateWithoutSpecialtiesInput>
  }

  export type StaffUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput> | StaffCreateWithoutSpecialtyInput[] | StaffUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSpecialtyInput | StaffCreateOrConnectWithoutSpecialtyInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutSpecialtyInput | StaffUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: StaffCreateManySpecialtyInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutSpecialtyInput | StaffUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutSpecialtyInput | StaffUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput> | StaffCreateWithoutSpecialtyInput[] | StaffUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutSpecialtyInput | StaffCreateOrConnectWithoutSpecialtyInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutSpecialtyInput | StaffUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: StaffCreateManySpecialtyInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutSpecialtyInput | StaffUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutSpecialtyInput | StaffUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutStaffInput = {
    create?: XOR<BranchCreateWithoutStaffInput, BranchUncheckedCreateWithoutStaffInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStaffInput
    connect?: BranchWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutStaffInput = {
    create?: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffInput
    connect?: DepartmentWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutStaffInput = {
    create?: XOR<SpecialtyCreateWithoutStaffInput, SpecialtyUncheckedCreateWithoutStaffInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutStaffInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStaffInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    connect?: UserWhereUniqueInput
  }

  export type UserUncheckedCreateNestedOneWithoutStaffInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    connect?: UserWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<BranchCreateWithoutStaffInput, BranchUncheckedCreateWithoutStaffInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStaffInput
    upsert?: BranchUpsertWithoutStaffInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutStaffInput, BranchUpdateWithoutStaffInput>, BranchUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentUpdateOneWithoutStaffNestedInput = {
    create?: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffInput
    upsert?: DepartmentUpsertWithoutStaffInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutStaffInput, DepartmentUpdateWithoutStaffInput>, DepartmentUncheckedUpdateWithoutStaffInput>
  }

  export type SpecialtyUpdateOneWithoutStaffNestedInput = {
    create?: XOR<SpecialtyCreateWithoutStaffInput, SpecialtyUncheckedCreateWithoutStaffInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutStaffInput
    upsert?: SpecialtyUpsertWithoutStaffInput
    disconnect?: SpecialtyWhereInput | boolean
    delete?: SpecialtyWhereInput | boolean
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<XOR<SpecialtyUpdateToOneWithWhereWithoutStaffInput, SpecialtyUpdateWithoutStaffInput>, SpecialtyUncheckedUpdateWithoutStaffInput>
  }

  export type UserUpdateOneWithoutStaffNestedInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    upsert?: UserUpsertWithoutStaffInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffInput, UserUpdateWithoutStaffInput>, UserUncheckedUpdateWithoutStaffInput>
  }

  export type UserUncheckedUpdateOneWithoutStaffNestedInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    upsert?: UserUpsertWithoutStaffInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffInput, UserUpdateWithoutStaffInput>, UserUncheckedUpdateWithoutStaffInput>
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    connect?: StaffWhereUniqueInput
  }

  export type RoleTemplateVersionCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutUsersInput, RoleTemplateVersionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutUsersInput
    connect?: RoleTemplateVersionWhereUniqueInput
  }

  export type RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput> | RoleTemplateVersionCreateWithoutCreatedByUserInput[] | RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput | RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: RoleTemplateVersionCreateManyCreatedByUserInputEnvelope
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
  }

  export type AuditEventCreateNestedManyWithoutActorUserInput = {
    create?: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput> | AuditEventCreateWithoutActorUserInput[] | AuditEventUncheckedCreateWithoutActorUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorUserInput | AuditEventCreateOrConnectWithoutActorUserInput[]
    createMany?: AuditEventCreateManyActorUserInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput> | RoleTemplateVersionCreateWithoutCreatedByUserInput[] | RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput | RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: RoleTemplateVersionCreateManyCreatedByUserInputEnvelope
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
  }

  export type AuditEventUncheckedCreateNestedManyWithoutActorUserInput = {
    create?: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput> | AuditEventCreateWithoutActorUserInput[] | AuditEventUncheckedCreateWithoutActorUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorUserInput | AuditEventCreateOrConnectWithoutActorUserInput[]
    createMany?: AuditEventCreateManyActorUserInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type StaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    upsert?: StaffUpsertWithoutUserInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutUserInput, StaffUpdateWithoutUserInput>, StaffUncheckedUpdateWithoutUserInput>
  }

  export type RoleTemplateVersionUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutUsersInput, RoleTemplateVersionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutUsersInput
    upsert?: RoleTemplateVersionUpsertWithoutUsersInput
    disconnect?: RoleTemplateVersionWhereInput | boolean
    delete?: RoleTemplateVersionWhereInput | boolean
    connect?: RoleTemplateVersionWhereUniqueInput
    update?: XOR<XOR<RoleTemplateVersionUpdateToOneWithWhereWithoutUsersInput, RoleTemplateVersionUpdateWithoutUsersInput>, RoleTemplateVersionUncheckedUpdateWithoutUsersInput>
  }

  export type RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput> | RoleTemplateVersionCreateWithoutCreatedByUserInput[] | RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput | RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: RoleTemplateVersionUpsertWithWhereUniqueWithoutCreatedByUserInput | RoleTemplateVersionUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: RoleTemplateVersionCreateManyCreatedByUserInputEnvelope
    set?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    disconnect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    delete?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    update?: RoleTemplateVersionUpdateWithWhereUniqueWithoutCreatedByUserInput | RoleTemplateVersionUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: RoleTemplateVersionUpdateManyWithWhereWithoutCreatedByUserInput | RoleTemplateVersionUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
  }

  export type AuditEventUpdateManyWithoutActorUserNestedInput = {
    create?: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput> | AuditEventCreateWithoutActorUserInput[] | AuditEventUncheckedCreateWithoutActorUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorUserInput | AuditEventCreateOrConnectWithoutActorUserInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutActorUserInput | AuditEventUpsertWithWhereUniqueWithoutActorUserInput[]
    createMany?: AuditEventCreateManyActorUserInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutActorUserInput | AuditEventUpdateWithWhereUniqueWithoutActorUserInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutActorUserInput | AuditEventUpdateManyWithWhereWithoutActorUserInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput> | RoleTemplateVersionCreateWithoutCreatedByUserInput[] | RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput | RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: RoleTemplateVersionUpsertWithWhereUniqueWithoutCreatedByUserInput | RoleTemplateVersionUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: RoleTemplateVersionCreateManyCreatedByUserInputEnvelope
    set?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    disconnect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    delete?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    update?: RoleTemplateVersionUpdateWithWhereUniqueWithoutCreatedByUserInput | RoleTemplateVersionUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: RoleTemplateVersionUpdateManyWithWhereWithoutCreatedByUserInput | RoleTemplateVersionUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
  }

  export type AuditEventUncheckedUpdateManyWithoutActorUserNestedInput = {
    create?: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput> | AuditEventCreateWithoutActorUserInput[] | AuditEventUncheckedCreateWithoutActorUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorUserInput | AuditEventCreateOrConnectWithoutActorUserInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutActorUserInput | AuditEventUpsertWithWhereUniqueWithoutActorUserInput[]
    createMany?: AuditEventCreateManyActorUserInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutActorUserInput | AuditEventUpdateWithWhereUniqueWithoutActorUserInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutActorUserInput | AuditEventUpdateManyWithWhereWithoutActorUserInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutPatientsInput = {
    create?: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPatientsInput
    connect?: BranchWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutPatientInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type AdmissionCreateNestedManyWithoutPatientInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type ConsentRecordCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput> | ConsentRecordCreateWithoutPatientInput[] | ConsentRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsentRecordCreateOrConnectWithoutPatientInput | ConsentRecordCreateOrConnectWithoutPatientInput[]
    createMany?: ConsentRecordCreateManyPatientInputEnvelope
    connect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
  }

  export type RtbfRequestCreateNestedManyWithoutPatientInput = {
    create?: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput> | RtbfRequestCreateWithoutPatientInput[] | RtbfRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RtbfRequestCreateOrConnectWithoutPatientInput | RtbfRequestCreateOrConnectWithoutPatientInput[]
    createMany?: RtbfRequestCreateManyPatientInputEnvelope
    connect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
  }

  export type StatutoryCaseCreateNestedManyWithoutPatientInput = {
    create?: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput> | StatutoryCaseCreateWithoutPatientInput[] | StatutoryCaseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutPatientInput | StatutoryCaseCreateOrConnectWithoutPatientInput[]
    createMany?: StatutoryCaseCreateManyPatientInputEnvelope
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type ConsentRecordUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput> | ConsentRecordCreateWithoutPatientInput[] | ConsentRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsentRecordCreateOrConnectWithoutPatientInput | ConsentRecordCreateOrConnectWithoutPatientInput[]
    createMany?: ConsentRecordCreateManyPatientInputEnvelope
    connect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
  }

  export type RtbfRequestUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput> | RtbfRequestCreateWithoutPatientInput[] | RtbfRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RtbfRequestCreateOrConnectWithoutPatientInput | RtbfRequestCreateOrConnectWithoutPatientInput[]
    createMany?: RtbfRequestCreateManyPatientInputEnvelope
    connect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
  }

  export type StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput> | StatutoryCaseCreateWithoutPatientInput[] | StatutoryCaseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutPatientInput | StatutoryCaseCreateOrConnectWithoutPatientInput[]
    createMany?: StatutoryCaseCreateManyPatientInputEnvelope
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutPatientsInput
    upsert?: BranchUpsertWithoutPatientsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutPatientsInput, BranchUpdateWithoutPatientsInput>, BranchUncheckedUpdateWithoutPatientsInput>
  }

  export type EncounterUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientInput | EncounterUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientInput | EncounterUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientInput | EncounterUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type AdmissionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutPatientInput | AdmissionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutPatientInput | AdmissionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutPatientInput | AdmissionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type ConsentRecordUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput> | ConsentRecordCreateWithoutPatientInput[] | ConsentRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsentRecordCreateOrConnectWithoutPatientInput | ConsentRecordCreateOrConnectWithoutPatientInput[]
    upsert?: ConsentRecordUpsertWithWhereUniqueWithoutPatientInput | ConsentRecordUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsentRecordCreateManyPatientInputEnvelope
    set?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    disconnect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    delete?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    connect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    update?: ConsentRecordUpdateWithWhereUniqueWithoutPatientInput | ConsentRecordUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsentRecordUpdateManyWithWhereWithoutPatientInput | ConsentRecordUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsentRecordScalarWhereInput | ConsentRecordScalarWhereInput[]
  }

  export type RtbfRequestUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput> | RtbfRequestCreateWithoutPatientInput[] | RtbfRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RtbfRequestCreateOrConnectWithoutPatientInput | RtbfRequestCreateOrConnectWithoutPatientInput[]
    upsert?: RtbfRequestUpsertWithWhereUniqueWithoutPatientInput | RtbfRequestUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RtbfRequestCreateManyPatientInputEnvelope
    set?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    disconnect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    delete?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    connect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    update?: RtbfRequestUpdateWithWhereUniqueWithoutPatientInput | RtbfRequestUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RtbfRequestUpdateManyWithWhereWithoutPatientInput | RtbfRequestUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RtbfRequestScalarWhereInput | RtbfRequestScalarWhereInput[]
  }

  export type StatutoryCaseUpdateManyWithoutPatientNestedInput = {
    create?: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput> | StatutoryCaseCreateWithoutPatientInput[] | StatutoryCaseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutPatientInput | StatutoryCaseCreateOrConnectWithoutPatientInput[]
    upsert?: StatutoryCaseUpsertWithWhereUniqueWithoutPatientInput | StatutoryCaseUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: StatutoryCaseCreateManyPatientInputEnvelope
    set?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    disconnect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    delete?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    update?: StatutoryCaseUpdateWithWhereUniqueWithoutPatientInput | StatutoryCaseUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: StatutoryCaseUpdateManyWithWhereWithoutPatientInput | StatutoryCaseUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput> | EncounterCreateWithoutPatientInput[] | EncounterUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPatientInput | EncounterCreateOrConnectWithoutPatientInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPatientInput | EncounterUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: EncounterCreateManyPatientInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPatientInput | EncounterUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPatientInput | EncounterUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutPatientInput | AdmissionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutPatientInput | AdmissionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutPatientInput | AdmissionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput> | ConsentRecordCreateWithoutPatientInput[] | ConsentRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsentRecordCreateOrConnectWithoutPatientInput | ConsentRecordCreateOrConnectWithoutPatientInput[]
    upsert?: ConsentRecordUpsertWithWhereUniqueWithoutPatientInput | ConsentRecordUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsentRecordCreateManyPatientInputEnvelope
    set?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    disconnect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    delete?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    connect?: ConsentRecordWhereUniqueInput | ConsentRecordWhereUniqueInput[]
    update?: ConsentRecordUpdateWithWhereUniqueWithoutPatientInput | ConsentRecordUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsentRecordUpdateManyWithWhereWithoutPatientInput | ConsentRecordUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsentRecordScalarWhereInput | ConsentRecordScalarWhereInput[]
  }

  export type RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput> | RtbfRequestCreateWithoutPatientInput[] | RtbfRequestUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RtbfRequestCreateOrConnectWithoutPatientInput | RtbfRequestCreateOrConnectWithoutPatientInput[]
    upsert?: RtbfRequestUpsertWithWhereUniqueWithoutPatientInput | RtbfRequestUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RtbfRequestCreateManyPatientInputEnvelope
    set?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    disconnect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    delete?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    connect?: RtbfRequestWhereUniqueInput | RtbfRequestWhereUniqueInput[]
    update?: RtbfRequestUpdateWithWhereUniqueWithoutPatientInput | RtbfRequestUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RtbfRequestUpdateManyWithWhereWithoutPatientInput | RtbfRequestUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RtbfRequestScalarWhereInput | RtbfRequestScalarWhereInput[]
  }

  export type StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput> | StatutoryCaseCreateWithoutPatientInput[] | StatutoryCaseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StatutoryCaseCreateOrConnectWithoutPatientInput | StatutoryCaseCreateOrConnectWithoutPatientInput[]
    upsert?: StatutoryCaseUpsertWithWhereUniqueWithoutPatientInput | StatutoryCaseUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: StatutoryCaseCreateManyPatientInputEnvelope
    set?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    disconnect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    delete?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    connect?: StatutoryCaseWhereUniqueInput | StatutoryCaseWhereUniqueInput[]
    update?: StatutoryCaseUpdateWithWhereUniqueWithoutPatientInput | StatutoryCaseUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: StatutoryCaseUpdateManyWithWhereWithoutPatientInput | StatutoryCaseUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutEncounterInput = {
    create?: XOR<BranchCreateWithoutEncounterInput, BranchUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEncounterInput
    connect?: BranchWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutEncountersInput = {
    create?: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEncountersInput
    connect?: PatientWhereUniqueInput
  }

  export type AdmissionCreateNestedManyWithoutEncounterInput = {
    create?: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput> | AdmissionCreateWithoutEncounterInput[] | AdmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutEncounterInput | AdmissionCreateOrConnectWithoutEncounterInput[]
    createMany?: AdmissionCreateManyEncounterInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput> | AdmissionCreateWithoutEncounterInput[] | AdmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutEncounterInput | AdmissionCreateOrConnectWithoutEncounterInput[]
    createMany?: AdmissionCreateManyEncounterInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type EnumEncounterTypeFieldUpdateOperationsInput = {
    set?: $Enums.EncounterType
  }

  export type BranchUpdateOneRequiredWithoutEncounterNestedInput = {
    create?: XOR<BranchCreateWithoutEncounterInput, BranchUncheckedCreateWithoutEncounterInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEncounterInput
    upsert?: BranchUpsertWithoutEncounterInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutEncounterInput, BranchUpdateWithoutEncounterInput>, BranchUncheckedUpdateWithoutEncounterInput>
  }

  export type PatientUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEncountersInput
    upsert?: PatientUpsertWithoutEncountersInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutEncountersInput, PatientUpdateWithoutEncountersInput>, PatientUncheckedUpdateWithoutEncountersInput>
  }

  export type AdmissionUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput> | AdmissionCreateWithoutEncounterInput[] | AdmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutEncounterInput | AdmissionCreateOrConnectWithoutEncounterInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutEncounterInput | AdmissionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: AdmissionCreateManyEncounterInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutEncounterInput | AdmissionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutEncounterInput | AdmissionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput> | AdmissionCreateWithoutEncounterInput[] | AdmissionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutEncounterInput | AdmissionCreateOrConnectWithoutEncounterInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutEncounterInput | AdmissionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: AdmissionCreateManyEncounterInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutEncounterInput | AdmissionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutEncounterInput | AdmissionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutWardsInput = {
    create?: XOR<BranchCreateWithoutWardsInput, BranchUncheckedCreateWithoutWardsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWardsInput
    connect?: BranchWhereUniqueInput
  }

  export type BedCreateNestedManyWithoutWardInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type BedUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutWardsNestedInput = {
    create?: XOR<BranchCreateWithoutWardsInput, BranchUncheckedCreateWithoutWardsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutWardsInput
    upsert?: BranchUpsertWithoutWardsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutWardsInput, BranchUpdateWithoutWardsInput>, BranchUncheckedUpdateWithoutWardsInput>
  }

  export type BedUpdateManyWithoutWardNestedInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutWardInput | BedUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutWardInput | BedUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: BedUpdateManyWithWhereWithoutWardInput | BedUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type BedUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutWardInput | BedUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutWardInput | BedUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: BedUpdateManyWithWhereWithoutWardInput | BedUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutBedInput = {
    create?: XOR<BranchCreateWithoutBedInput, BranchUncheckedCreateWithoutBedInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBedInput
    connect?: BranchWhereUniqueInput
  }

  export type WardCreateNestedOneWithoutBedsInput = {
    create?: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
    connectOrCreate?: WardCreateOrConnectWithoutBedsInput
    connect?: WardWhereUniqueInput
  }

  export type AdmissionCreateNestedManyWithoutBedInput = {
    create?: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput> | AdmissionCreateWithoutBedInput[] | AdmissionUncheckedCreateWithoutBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBedInput | AdmissionCreateOrConnectWithoutBedInput[]
    createMany?: AdmissionCreateManyBedInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutBedInput = {
    create?: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput> | AdmissionCreateWithoutBedInput[] | AdmissionUncheckedCreateWithoutBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBedInput | AdmissionCreateOrConnectWithoutBedInput[]
    createMany?: AdmissionCreateManyBedInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type EnumBedStateFieldUpdateOperationsInput = {
    set?: $Enums.BedState
  }

  export type BranchUpdateOneRequiredWithoutBedNestedInput = {
    create?: XOR<BranchCreateWithoutBedInput, BranchUncheckedCreateWithoutBedInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBedInput
    upsert?: BranchUpsertWithoutBedInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutBedInput, BranchUpdateWithoutBedInput>, BranchUncheckedUpdateWithoutBedInput>
  }

  export type WardUpdateOneRequiredWithoutBedsNestedInput = {
    create?: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
    connectOrCreate?: WardCreateOrConnectWithoutBedsInput
    upsert?: WardUpsertWithoutBedsInput
    connect?: WardWhereUniqueInput
    update?: XOR<XOR<WardUpdateToOneWithWhereWithoutBedsInput, WardUpdateWithoutBedsInput>, WardUncheckedUpdateWithoutBedsInput>
  }

  export type AdmissionUpdateManyWithoutBedNestedInput = {
    create?: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput> | AdmissionCreateWithoutBedInput[] | AdmissionUncheckedCreateWithoutBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBedInput | AdmissionCreateOrConnectWithoutBedInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutBedInput | AdmissionUpsertWithWhereUniqueWithoutBedInput[]
    createMany?: AdmissionCreateManyBedInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutBedInput | AdmissionUpdateWithWhereUniqueWithoutBedInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutBedInput | AdmissionUpdateManyWithWhereWithoutBedInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutBedNestedInput = {
    create?: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput> | AdmissionCreateWithoutBedInput[] | AdmissionUncheckedCreateWithoutBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutBedInput | AdmissionCreateOrConnectWithoutBedInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutBedInput | AdmissionUpsertWithWhereUniqueWithoutBedInput[]
    createMany?: AdmissionCreateManyBedInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutBedInput | AdmissionUpdateWithWhereUniqueWithoutBedInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutBedInput | AdmissionUpdateManyWithWhereWithoutBedInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutAdmissionInput = {
    create?: XOR<BranchCreateWithoutAdmissionInput, BranchUncheckedCreateWithoutAdmissionInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAdmissionInput
    connect?: BranchWhereUniqueInput
  }

  export type EncounterCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<EncounterCreateWithoutAdmissionsInput, EncounterUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutAdmissionsInput
    connect?: EncounterWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutAdmissionInput = {
    create?: XOR<PatientCreateWithoutAdmissionInput, PatientUncheckedCreateWithoutAdmissionInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAdmissionInput
    connect?: PatientWhereUniqueInput
  }

  export type BedCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<BedCreateWithoutAdmissionsInput, BedUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: BedCreateOrConnectWithoutAdmissionsInput
    connect?: BedWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutAdmissionNestedInput = {
    create?: XOR<BranchCreateWithoutAdmissionInput, BranchUncheckedCreateWithoutAdmissionInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAdmissionInput
    upsert?: BranchUpsertWithoutAdmissionInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAdmissionInput, BranchUpdateWithoutAdmissionInput>, BranchUncheckedUpdateWithoutAdmissionInput>
  }

  export type EncounterUpdateOneWithoutAdmissionsNestedInput = {
    create?: XOR<EncounterCreateWithoutAdmissionsInput, EncounterUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutAdmissionsInput
    upsert?: EncounterUpsertWithoutAdmissionsInput
    disconnect?: EncounterWhereInput | boolean
    delete?: EncounterWhereInput | boolean
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutAdmissionsInput, EncounterUpdateWithoutAdmissionsInput>, EncounterUncheckedUpdateWithoutAdmissionsInput>
  }

  export type PatientUpdateOneRequiredWithoutAdmissionNestedInput = {
    create?: XOR<PatientCreateWithoutAdmissionInput, PatientUncheckedCreateWithoutAdmissionInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAdmissionInput
    upsert?: PatientUpsertWithoutAdmissionInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAdmissionInput, PatientUpdateWithoutAdmissionInput>, PatientUncheckedUpdateWithoutAdmissionInput>
  }

  export type BedUpdateOneWithoutAdmissionsNestedInput = {
    create?: XOR<BedCreateWithoutAdmissionsInput, BedUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: BedCreateOrConnectWithoutAdmissionsInput
    upsert?: BedUpsertWithoutAdmissionsInput
    disconnect?: BedWhereInput | boolean
    delete?: BedWhereInput | boolean
    connect?: BedWhereUniqueInput
    update?: XOR<XOR<BedUpdateToOneWithWhereWithoutAdmissionsInput, BedUpdateWithoutAdmissionsInput>, BedUncheckedUpdateWithoutAdmissionsInput>
  }

  export type BranchCreateNestedOneWithoutOTsInput = {
    create?: XOR<BranchCreateWithoutOTsInput, BranchUncheckedCreateWithoutOTsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutOTsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutOTsNestedInput = {
    create?: XOR<BranchCreateWithoutOTsInput, BranchUncheckedCreateWithoutOTsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutOTsInput
    upsert?: BranchUpsertWithoutOTsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutOTsInput, BranchUpdateWithoutOTsInput>, BranchUncheckedUpdateWithoutOTsInput>
  }

  export type BranchCreateNestedOneWithoutAssetsInput = {
    create?: XOR<BranchCreateWithoutAssetsInput, BranchUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAssetsInput
    connect?: BranchWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<BranchCreateWithoutAssetsInput, BranchUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAssetsInput
    upsert?: BranchUpsertWithoutAssetsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAssetsInput, BranchUpdateWithoutAssetsInput>, BranchUncheckedUpdateWithoutAssetsInput>
  }

  export type BranchCreateNestedOneWithoutTariffPlansInput = {
    create?: XOR<BranchCreateWithoutTariffPlansInput, BranchUncheckedCreateWithoutTariffPlansInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTariffPlansInput
    connect?: BranchWhereUniqueInput
  }

  export type TariffRateCreateNestedManyWithoutTariffPlanInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
  }

  export type TariffRateUncheckedCreateNestedManyWithoutTariffPlanInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutTariffPlansNestedInput = {
    create?: XOR<BranchCreateWithoutTariffPlansInput, BranchUncheckedCreateWithoutTariffPlansInput>
    connectOrCreate?: BranchCreateOrConnectWithoutTariffPlansInput
    upsert?: BranchUpsertWithoutTariffPlansInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutTariffPlansInput, BranchUpdateWithoutTariffPlansInput>, BranchUncheckedUpdateWithoutTariffPlansInput>
  }

  export type TariffRateUpdateManyWithoutTariffPlanNestedInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    upsert?: TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput | TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    set?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    disconnect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    delete?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    update?: TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput | TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput[]
    updateMany?: TariffRateUpdateManyWithWhereWithoutTariffPlanInput | TariffRateUpdateManyWithWhereWithoutTariffPlanInput[]
    deleteMany?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
  }

  export type TariffRateUncheckedUpdateManyWithoutTariffPlanNestedInput = {
    create?: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput> | TariffRateCreateWithoutTariffPlanInput[] | TariffRateUncheckedCreateWithoutTariffPlanInput[]
    connectOrCreate?: TariffRateCreateOrConnectWithoutTariffPlanInput | TariffRateCreateOrConnectWithoutTariffPlanInput[]
    upsert?: TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput | TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput[]
    createMany?: TariffRateCreateManyTariffPlanInputEnvelope
    set?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    disconnect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    delete?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    connect?: TariffRateWhereUniqueInput | TariffRateWhereUniqueInput[]
    update?: TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput | TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput[]
    updateMany?: TariffRateUpdateManyWithWhereWithoutTariffPlanInput | TariffRateUpdateManyWithWhereWithoutTariffPlanInput[]
    deleteMany?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
  }

  export type TariffPlanCreateNestedOneWithoutRatesInput = {
    create?: XOR<TariffPlanCreateWithoutRatesInput, TariffPlanUncheckedCreateWithoutRatesInput>
    connectOrCreate?: TariffPlanCreateOrConnectWithoutRatesInput
    connect?: TariffPlanWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TariffPlanUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<TariffPlanCreateWithoutRatesInput, TariffPlanUncheckedCreateWithoutRatesInput>
    connectOrCreate?: TariffPlanCreateOrConnectWithoutRatesInput
    upsert?: TariffPlanUpsertWithoutRatesInput
    connect?: TariffPlanWhereUniqueInput
    update?: XOR<XOR<TariffPlanUpdateToOneWithWhereWithoutRatesInput, TariffPlanUpdateWithoutRatesInput>, TariffPlanUncheckedUpdateWithoutRatesInput>
  }

  export type PatientCreateNestedOneWithoutConsentRecordsInput = {
    create?: XOR<PatientCreateWithoutConsentRecordsInput, PatientUncheckedCreateWithoutConsentRecordsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsentRecordsInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumConsentScopeFieldUpdateOperationsInput = {
    set?: $Enums.ConsentScope
  }

  export type EnumConsentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConsentStatus
  }

  export type PatientUpdateOneRequiredWithoutConsentRecordsNestedInput = {
    create?: XOR<PatientCreateWithoutConsentRecordsInput, PatientUncheckedCreateWithoutConsentRecordsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsentRecordsInput
    upsert?: PatientUpsertWithoutConsentRecordsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutConsentRecordsInput, PatientUpdateWithoutConsentRecordsInput>, PatientUncheckedUpdateWithoutConsentRecordsInput>
  }

  export type PatientCreateNestedOneWithoutRtbfRequestsInput = {
    create?: XOR<PatientCreateWithoutRtbfRequestsInput, PatientUncheckedCreateWithoutRtbfRequestsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRtbfRequestsInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumRtbfStatusFieldUpdateOperationsInput = {
    set?: $Enums.RtbfStatus
  }

  export type PatientUpdateOneRequiredWithoutRtbfRequestsNestedInput = {
    create?: XOR<PatientCreateWithoutRtbfRequestsInput, PatientUncheckedCreateWithoutRtbfRequestsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRtbfRequestsInput
    upsert?: PatientUpsertWithoutRtbfRequestsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutRtbfRequestsInput, PatientUpdateWithoutRtbfRequestsInput>, PatientUncheckedUpdateWithoutRtbfRequestsInput>
  }

  export type BranchCreateNestedOneWithoutStatutoryCasesInput = {
    create?: XOR<BranchCreateWithoutStatutoryCasesInput, BranchUncheckedCreateWithoutStatutoryCasesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStatutoryCasesInput
    connect?: BranchWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutStatutoryCasesInput = {
    create?: XOR<PatientCreateWithoutStatutoryCasesInput, PatientUncheckedCreateWithoutStatutoryCasesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutStatutoryCasesInput
    connect?: PatientWhereUniqueInput
  }

  export type BranchUpdateOneRequiredWithoutStatutoryCasesNestedInput = {
    create?: XOR<BranchCreateWithoutStatutoryCasesInput, BranchUncheckedCreateWithoutStatutoryCasesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStatutoryCasesInput
    upsert?: BranchUpsertWithoutStatutoryCasesInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutStatutoryCasesInput, BranchUpdateWithoutStatutoryCasesInput>, BranchUncheckedUpdateWithoutStatutoryCasesInput>
  }

  export type PatientUpdateOneRequiredWithoutStatutoryCasesNestedInput = {
    create?: XOR<PatientCreateWithoutStatutoryCasesInput, PatientUncheckedCreateWithoutStatutoryCasesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutStatutoryCasesInput
    upsert?: PatientUpsertWithoutStatutoryCasesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutStatutoryCasesInput, PatientUpdateWithoutStatutoryCasesInput>, PatientUncheckedUpdateWithoutStatutoryCasesInput>
  }

  export type BranchCreateNestedOneWithoutAuditEventsInput = {
    create?: XOR<BranchCreateWithoutAuditEventsInput, BranchUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAuditEventsInput
    connect?: BranchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditEventsAsActorInput = {
    create?: XOR<UserCreateWithoutAuditEventsAsActorInput, UserUncheckedCreateWithoutAuditEventsAsActorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditEventsAsActorInput
    connect?: UserWhereUniqueInput
  }

  export type BranchUpdateOneWithoutAuditEventsNestedInput = {
    create?: XOR<BranchCreateWithoutAuditEventsInput, BranchUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutAuditEventsInput
    upsert?: BranchUpsertWithoutAuditEventsInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutAuditEventsInput, BranchUpdateWithoutAuditEventsInput>, BranchUncheckedUpdateWithoutAuditEventsInput>
  }

  export type UserUpdateOneWithoutAuditEventsAsActorNestedInput = {
    create?: XOR<UserCreateWithoutAuditEventsAsActorInput, UserUncheckedCreateWithoutAuditEventsAsActorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditEventsAsActorInput
    upsert?: UserUpsertWithoutAuditEventsAsActorInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditEventsAsActorInput, UserUpdateWithoutAuditEventsAsActorInput>, UserUncheckedUpdateWithoutAuditEventsAsActorInput>
  }

  export type EnumOutboxStatusFieldUpdateOperationsInput = {
    set?: $Enums.OutboxStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RoleTemplatePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput> | RoleTemplatePermissionCreateWithoutPermissionInput[] | RoleTemplatePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutPermissionInput | RoleTemplatePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RoleTemplatePermissionCreateManyPermissionInputEnvelope
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
  }

  export type RoleTemplatePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput> | RoleTemplatePermissionCreateWithoutPermissionInput[] | RoleTemplatePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutPermissionInput | RoleTemplatePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RoleTemplatePermissionCreateManyPermissionInputEnvelope
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
  }

  export type RoleTemplatePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput> | RoleTemplatePermissionCreateWithoutPermissionInput[] | RoleTemplatePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutPermissionInput | RoleTemplatePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RoleTemplatePermissionUpsertWithWhereUniqueWithoutPermissionInput | RoleTemplatePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RoleTemplatePermissionCreateManyPermissionInputEnvelope
    set?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    disconnect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    delete?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    update?: RoleTemplatePermissionUpdateWithWhereUniqueWithoutPermissionInput | RoleTemplatePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RoleTemplatePermissionUpdateManyWithWhereWithoutPermissionInput | RoleTemplatePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
  }

  export type RoleTemplatePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput> | RoleTemplatePermissionCreateWithoutPermissionInput[] | RoleTemplatePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutPermissionInput | RoleTemplatePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RoleTemplatePermissionUpsertWithWhereUniqueWithoutPermissionInput | RoleTemplatePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RoleTemplatePermissionCreateManyPermissionInputEnvelope
    set?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    disconnect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    delete?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    update?: RoleTemplatePermissionUpdateWithWhereUniqueWithoutPermissionInput | RoleTemplatePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RoleTemplatePermissionUpdateManyWithWhereWithoutPermissionInput | RoleTemplatePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
  }

  export type RoleTemplateVersionCreateNestedManyWithoutRoleTemplateInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput> | RoleTemplateVersionCreateWithoutRoleTemplateInput[] | RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput | RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput[]
    createMany?: RoleTemplateVersionCreateManyRoleTemplateInputEnvelope
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
  }

  export type RoleTemplateVersionUncheckedCreateNestedManyWithoutRoleTemplateInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput> | RoleTemplateVersionCreateWithoutRoleTemplateInput[] | RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput | RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput[]
    createMany?: RoleTemplateVersionCreateManyRoleTemplateInputEnvelope
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
  }

  export type EnumRoleScopeFieldUpdateOperationsInput = {
    set?: $Enums.RoleScope
  }

  export type RoleTemplateVersionUpdateManyWithoutRoleTemplateNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput> | RoleTemplateVersionCreateWithoutRoleTemplateInput[] | RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput | RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput[]
    upsert?: RoleTemplateVersionUpsertWithWhereUniqueWithoutRoleTemplateInput | RoleTemplateVersionUpsertWithWhereUniqueWithoutRoleTemplateInput[]
    createMany?: RoleTemplateVersionCreateManyRoleTemplateInputEnvelope
    set?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    disconnect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    delete?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    update?: RoleTemplateVersionUpdateWithWhereUniqueWithoutRoleTemplateInput | RoleTemplateVersionUpdateWithWhereUniqueWithoutRoleTemplateInput[]
    updateMany?: RoleTemplateVersionUpdateManyWithWhereWithoutRoleTemplateInput | RoleTemplateVersionUpdateManyWithWhereWithoutRoleTemplateInput[]
    deleteMany?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
  }

  export type RoleTemplateVersionUncheckedUpdateManyWithoutRoleTemplateNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput> | RoleTemplateVersionCreateWithoutRoleTemplateInput[] | RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput[]
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput | RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput[]
    upsert?: RoleTemplateVersionUpsertWithWhereUniqueWithoutRoleTemplateInput | RoleTemplateVersionUpsertWithWhereUniqueWithoutRoleTemplateInput[]
    createMany?: RoleTemplateVersionCreateManyRoleTemplateInputEnvelope
    set?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    disconnect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    delete?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    connect?: RoleTemplateVersionWhereUniqueInput | RoleTemplateVersionWhereUniqueInput[]
    update?: RoleTemplateVersionUpdateWithWhereUniqueWithoutRoleTemplateInput | RoleTemplateVersionUpdateWithWhereUniqueWithoutRoleTemplateInput[]
    updateMany?: RoleTemplateVersionUpdateManyWithWhereWithoutRoleTemplateInput | RoleTemplateVersionUpdateManyWithWhereWithoutRoleTemplateInput[]
    deleteMany?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
  }

  export type RoleTemplateCreateNestedOneWithoutVersionsInput = {
    create?: XOR<RoleTemplateCreateWithoutVersionsInput, RoleTemplateUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: RoleTemplateCreateOrConnectWithoutVersionsInput
    connect?: RoleTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedRoleVersionsInput = {
    create?: XOR<UserCreateWithoutCreatedRoleVersionsInput, UserUncheckedCreateWithoutCreatedRoleVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRoleVersionsInput
    connect?: UserWhereUniqueInput
  }

  export type RoleTemplatePermissionCreateNestedManyWithoutRoleVersionInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput> | RoleTemplatePermissionCreateWithoutRoleVersionInput[] | RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput | RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput[]
    createMany?: RoleTemplatePermissionCreateManyRoleVersionInputEnvelope
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRoleVersionInput = {
    create?: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput> | UserCreateWithoutRoleVersionInput[] | UserUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleVersionInput | UserCreateOrConnectWithoutRoleVersionInput[]
    createMany?: UserCreateManyRoleVersionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RoleTemplatePermissionUncheckedCreateNestedManyWithoutRoleVersionInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput> | RoleTemplatePermissionCreateWithoutRoleVersionInput[] | RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput | RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput[]
    createMany?: RoleTemplatePermissionCreateManyRoleVersionInputEnvelope
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleVersionInput = {
    create?: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput> | UserCreateWithoutRoleVersionInput[] | UserUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleVersionInput | UserCreateOrConnectWithoutRoleVersionInput[]
    createMany?: UserCreateManyRoleVersionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EnumRoleVersionStatusFieldUpdateOperationsInput = {
    set?: $Enums.RoleVersionStatus
  }

  export type RoleTemplateUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<RoleTemplateCreateWithoutVersionsInput, RoleTemplateUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: RoleTemplateCreateOrConnectWithoutVersionsInput
    upsert?: RoleTemplateUpsertWithoutVersionsInput
    connect?: RoleTemplateWhereUniqueInput
    update?: XOR<XOR<RoleTemplateUpdateToOneWithWhereWithoutVersionsInput, RoleTemplateUpdateWithoutVersionsInput>, RoleTemplateUncheckedUpdateWithoutVersionsInput>
  }

  export type UserUpdateOneWithoutCreatedRoleVersionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedRoleVersionsInput, UserUncheckedCreateWithoutCreatedRoleVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedRoleVersionsInput
    upsert?: UserUpsertWithoutCreatedRoleVersionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedRoleVersionsInput, UserUpdateWithoutCreatedRoleVersionsInput>, UserUncheckedUpdateWithoutCreatedRoleVersionsInput>
  }

  export type RoleTemplatePermissionUpdateManyWithoutRoleVersionNestedInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput> | RoleTemplatePermissionCreateWithoutRoleVersionInput[] | RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput | RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput[]
    upsert?: RoleTemplatePermissionUpsertWithWhereUniqueWithoutRoleVersionInput | RoleTemplatePermissionUpsertWithWhereUniqueWithoutRoleVersionInput[]
    createMany?: RoleTemplatePermissionCreateManyRoleVersionInputEnvelope
    set?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    disconnect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    delete?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    update?: RoleTemplatePermissionUpdateWithWhereUniqueWithoutRoleVersionInput | RoleTemplatePermissionUpdateWithWhereUniqueWithoutRoleVersionInput[]
    updateMany?: RoleTemplatePermissionUpdateManyWithWhereWithoutRoleVersionInput | RoleTemplatePermissionUpdateManyWithWhereWithoutRoleVersionInput[]
    deleteMany?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRoleVersionNestedInput = {
    create?: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput> | UserCreateWithoutRoleVersionInput[] | UserUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleVersionInput | UserCreateOrConnectWithoutRoleVersionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleVersionInput | UserUpsertWithWhereUniqueWithoutRoleVersionInput[]
    createMany?: UserCreateManyRoleVersionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleVersionInput | UserUpdateWithWhereUniqueWithoutRoleVersionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleVersionInput | UserUpdateManyWithWhereWithoutRoleVersionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionNestedInput = {
    create?: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput> | RoleTemplatePermissionCreateWithoutRoleVersionInput[] | RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput | RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput[]
    upsert?: RoleTemplatePermissionUpsertWithWhereUniqueWithoutRoleVersionInput | RoleTemplatePermissionUpsertWithWhereUniqueWithoutRoleVersionInput[]
    createMany?: RoleTemplatePermissionCreateManyRoleVersionInputEnvelope
    set?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    disconnect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    delete?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    connect?: RoleTemplatePermissionWhereUniqueInput | RoleTemplatePermissionWhereUniqueInput[]
    update?: RoleTemplatePermissionUpdateWithWhereUniqueWithoutRoleVersionInput | RoleTemplatePermissionUpdateWithWhereUniqueWithoutRoleVersionInput[]
    updateMany?: RoleTemplatePermissionUpdateManyWithWhereWithoutRoleVersionInput | RoleTemplatePermissionUpdateManyWithWhereWithoutRoleVersionInput[]
    deleteMany?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleVersionNestedInput = {
    create?: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput> | UserCreateWithoutRoleVersionInput[] | UserUncheckedCreateWithoutRoleVersionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleVersionInput | UserCreateOrConnectWithoutRoleVersionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleVersionInput | UserUpsertWithWhereUniqueWithoutRoleVersionInput[]
    createMany?: UserCreateManyRoleVersionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleVersionInput | UserUpdateWithWhereUniqueWithoutRoleVersionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleVersionInput | UserUpdateManyWithWhereWithoutRoleVersionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleTemplateVersionCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutPermissionsInput, RoleTemplateVersionUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutPermissionsInput
    connect?: RoleTemplateVersionWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRoleGrantsInput = {
    create?: XOR<PermissionCreateWithoutRoleGrantsInput, PermissionUncheckedCreateWithoutRoleGrantsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleGrantsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleTemplateVersionUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleTemplateVersionCreateWithoutPermissionsInput, RoleTemplateVersionUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleTemplateVersionCreateOrConnectWithoutPermissionsInput
    upsert?: RoleTemplateVersionUpsertWithoutPermissionsInput
    connect?: RoleTemplateVersionWhereUniqueInput
    update?: XOR<XOR<RoleTemplateVersionUpdateToOneWithWhereWithoutPermissionsInput, RoleTemplateVersionUpdateWithoutPermissionsInput>, RoleTemplateVersionUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRoleGrantsNestedInput = {
    create?: XOR<PermissionCreateWithoutRoleGrantsInput, PermissionUncheckedCreateWithoutRoleGrantsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleGrantsInput
    upsert?: PermissionUpsertWithoutRoleGrantsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRoleGrantsInput, PermissionUpdateWithoutRoleGrantsInput>, PermissionUncheckedUpdateWithoutRoleGrantsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEncounterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterType | EnumEncounterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterTypeFilter<$PrismaModel> | $Enums.EncounterType
  }

  export type NestedEnumEncounterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EncounterType | EnumEncounterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EncounterType[] | ListEnumEncounterTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEncounterTypeWithAggregatesFilter<$PrismaModel> | $Enums.EncounterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEncounterTypeFilter<$PrismaModel>
    _max?: NestedEnumEncounterTypeFilter<$PrismaModel>
  }

  export type NestedEnumBedStateFilter<$PrismaModel = never> = {
    equals?: $Enums.BedState | EnumBedStateFieldRefInput<$PrismaModel>
    in?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStateFilter<$PrismaModel> | $Enums.BedState
  }

  export type NestedEnumBedStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BedState | EnumBedStateFieldRefInput<$PrismaModel>
    in?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedState[] | ListEnumBedStateFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStateWithAggregatesFilter<$PrismaModel> | $Enums.BedState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBedStateFilter<$PrismaModel>
    _max?: NestedEnumBedStateFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumConsentScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentScope | EnumConsentScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentScopeFilter<$PrismaModel> | $Enums.ConsentScope
  }

  export type NestedEnumConsentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusFilter<$PrismaModel> | $Enums.ConsentStatus
  }

  export type NestedEnumConsentScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentScope | EnumConsentScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentScope[] | ListEnumConsentScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentScopeWithAggregatesFilter<$PrismaModel> | $Enums.ConsentScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentScopeFilter<$PrismaModel>
    _max?: NestedEnumConsentScopeFilter<$PrismaModel>
  }

  export type NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsentStatus | EnumConsentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsentStatus[] | ListEnumConsentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConsentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConsentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsentStatusFilter<$PrismaModel>
    _max?: NestedEnumConsentStatusFilter<$PrismaModel>
  }

  export type NestedEnumRtbfStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RtbfStatus | EnumRtbfStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRtbfStatusFilter<$PrismaModel> | $Enums.RtbfStatus
  }

  export type NestedEnumRtbfStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RtbfStatus | EnumRtbfStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RtbfStatus[] | ListEnumRtbfStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRtbfStatusWithAggregatesFilter<$PrismaModel> | $Enums.RtbfStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRtbfStatusFilter<$PrismaModel>
    _max?: NestedEnumRtbfStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumOutboxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusFilter<$PrismaModel> | $Enums.OutboxStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumOutboxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusWithAggregatesFilter<$PrismaModel> | $Enums.OutboxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOutboxStatusFilter<$PrismaModel>
    _max?: NestedEnumOutboxStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleScope | EnumRoleScopeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleScopeFilter<$PrismaModel> | $Enums.RoleScope
  }

  export type NestedEnumRoleScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleScope | EnumRoleScopeFieldRefInput<$PrismaModel>
    in?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleScope[] | ListEnumRoleScopeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleScopeWithAggregatesFilter<$PrismaModel> | $Enums.RoleScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleScopeFilter<$PrismaModel>
    _max?: NestedEnumRoleScopeFilter<$PrismaModel>
  }

  export type NestedEnumRoleVersionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleVersionStatus | EnumRoleVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleVersionStatusFilter<$PrismaModel> | $Enums.RoleVersionStatus
  }

  export type NestedEnumRoleVersionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleVersionStatus | EnumRoleVersionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleVersionStatus[] | ListEnumRoleVersionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleVersionStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoleVersionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleVersionStatusFilter<$PrismaModel>
    _max?: NestedEnumRoleVersionStatusFilter<$PrismaModel>
  }

  export type DepartmentCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedManyWithoutDepartmentInput
    specialties?: SpecialtyCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutBranchInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput>
  }

  export type DepartmentCreateManyBranchInputEnvelope = {
    data: DepartmentCreateManyBranchInput | DepartmentCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBranchInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutBranchInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutBranchInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutBranchInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput>
  }

  export type PatientCreateManyBranchInputEnvelope = {
    data: PatientCreateManyBranchInput | PatientCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type WardCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    beds?: BedCreateNestedManyWithoutWardInput
  }

  export type WardUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    beds?: BedUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardCreateOrConnectWithoutBranchInput = {
    where: WardWhereUniqueInput
    create: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput>
  }

  export type WardCreateManyBranchInputEnvelope = {
    data: WardCreateManyBranchInput | WardCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type OTCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTCreateOrConnectWithoutBranchInput = {
    where: OTWhereUniqueInput
    create: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput>
  }

  export type OTCreateManyBranchInputEnvelope = {
    data: OTCreateManyBranchInput | OTCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type TariffPlanCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rates?: TariffRateCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rates?: TariffRateUncheckedCreateNestedManyWithoutTariffPlanInput
  }

  export type TariffPlanCreateOrConnectWithoutBranchInput = {
    where: TariffPlanWhereUniqueInput
    create: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput>
  }

  export type TariffPlanCreateManyBranchInputEnvelope = {
    data: TariffPlanCreateManyBranchInput | TariffPlanCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetUncheckedCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateOrConnectWithoutBranchInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput>
  }

  export type AssetCreateManyBranchInputEnvelope = {
    data: AssetCreateManyBranchInput | AssetCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type SpecialtyCreateWithoutBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutSpecialtiesInput
    staff?: StaffCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutBranchInput = {
    id?: string
    departmentId?: string | null
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutBranchInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput>
  }

  export type SpecialtyCreateManyBranchInputEnvelope = {
    data: SpecialtyCreateManyBranchInput | SpecialtyCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type StaffCreateWithoutBranchInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutStaffInput
    specialty?: SpecialtyCreateNestedOneWithoutStaffInput
    user?: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutBranchInput = {
    id?: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutBranchInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput>
  }

  export type StaffCreateManyBranchInputEnvelope = {
    data: StaffCreateManyBranchInput | StaffCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutBranchInput = {
    id?: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutEncountersInput
    admissions?: AdmissionCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutBranchInput = {
    id?: string
    patientId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutBranchInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput>
  }

  export type EncounterCreateManyBranchInputEnvelope = {
    data: EncounterCreateManyBranchInput | EncounterCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type BedCreateWithoutBranchInput = {
    id?: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ward: WardCreateNestedOneWithoutBedsInput
    admissions?: AdmissionCreateNestedManyWithoutBedInput
  }

  export type BedUncheckedCreateWithoutBranchInput = {
    id?: string
    wardId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutBedInput
  }

  export type BedCreateOrConnectWithoutBranchInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput>
  }

  export type BedCreateManyBranchInputEnvelope = {
    data: BedCreateManyBranchInput | BedCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionCreateWithoutBranchInput = {
    id?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter?: EncounterCreateNestedOneWithoutAdmissionsInput
    patient: PatientCreateNestedOneWithoutAdmissionInput
    bed?: BedCreateNestedOneWithoutAdmissionsInput
  }

  export type AdmissionUncheckedCreateWithoutBranchInput = {
    id?: string
    encounterId?: string | null
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateOrConnectWithoutBranchInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput>
  }

  export type AdmissionCreateManyBranchInputEnvelope = {
    data: AdmissionCreateManyBranchInput | AdmissionCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type StatutoryCaseCreateWithoutBranchInput = {
    id?: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutStatutoryCasesInput
  }

  export type StatutoryCaseUncheckedCreateWithoutBranchInput = {
    id?: string
    patientId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseCreateOrConnectWithoutBranchInput = {
    where: StatutoryCaseWhereUniqueInput
    create: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput>
  }

  export type StatutoryCaseCreateManyBranchInputEnvelope = {
    data: StatutoryCaseCreateManyBranchInput | StatutoryCaseCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type AuditEventCreateWithoutBranchInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actorUser?: UserCreateNestedOneWithoutAuditEventsAsActorInput
  }

  export type AuditEventUncheckedCreateWithoutBranchInput = {
    id?: string
    actorUserId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditEventCreateOrConnectWithoutBranchInput = {
    where: AuditEventWhereUniqueInput
    create: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput>
  }

  export type AuditEventCreateManyBranchInputEnvelope = {
    data: AuditEventCreateManyBranchInput | AuditEventCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithWhereUniqueWithoutBranchInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutBranchInput, DepartmentUncheckedUpdateWithoutBranchInput>
    create: XOR<DepartmentCreateWithoutBranchInput, DepartmentUncheckedCreateWithoutBranchInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutBranchInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutBranchInput, DepartmentUncheckedUpdateWithoutBranchInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutBranchInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutBranchInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    branchId?: StringFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    branchId?: StringNullableFilter<"User"> | string | null
    staffId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    passwordHash?: StringNullableFilter<"User"> | string | null
    mustChangePassword?: BoolFilter<"User"> | boolean
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    roleVersionId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type PatientUpsertWithWhereUniqueWithoutBranchInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutBranchInput, PatientUncheckedUpdateWithoutBranchInput>
    create: XOR<PatientCreateWithoutBranchInput, PatientUncheckedCreateWithoutBranchInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutBranchInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutBranchInput, PatientUncheckedUpdateWithoutBranchInput>
  }

  export type PatientUpdateManyWithWhereWithoutBranchInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutBranchInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: StringFilter<"Patient"> | string
    branchId?: StringFilter<"Patient"> | string
    uhid?: StringFilter<"Patient"> | string
    name?: StringFilter<"Patient"> | string
    gender?: StringNullableFilter<"Patient"> | string | null
    dob?: DateTimeNullableFilter<"Patient"> | Date | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    email?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
  }

  export type WardUpsertWithWhereUniqueWithoutBranchInput = {
    where: WardWhereUniqueInput
    update: XOR<WardUpdateWithoutBranchInput, WardUncheckedUpdateWithoutBranchInput>
    create: XOR<WardCreateWithoutBranchInput, WardUncheckedCreateWithoutBranchInput>
  }

  export type WardUpdateWithWhereUniqueWithoutBranchInput = {
    where: WardWhereUniqueInput
    data: XOR<WardUpdateWithoutBranchInput, WardUncheckedUpdateWithoutBranchInput>
  }

  export type WardUpdateManyWithWhereWithoutBranchInput = {
    where: WardScalarWhereInput
    data: XOR<WardUpdateManyMutationInput, WardUncheckedUpdateManyWithoutBranchInput>
  }

  export type WardScalarWhereInput = {
    AND?: WardScalarWhereInput | WardScalarWhereInput[]
    OR?: WardScalarWhereInput[]
    NOT?: WardScalarWhereInput | WardScalarWhereInput[]
    id?: StringFilter<"Ward"> | string
    branchId?: StringFilter<"Ward"> | string
    code?: StringFilter<"Ward"> | string
    name?: StringFilter<"Ward"> | string
    specialty?: StringNullableFilter<"Ward"> | string | null
    isActive?: BoolFilter<"Ward"> | boolean
    createdAt?: DateTimeFilter<"Ward"> | Date | string
    updatedAt?: DateTimeFilter<"Ward"> | Date | string
  }

  export type OTUpsertWithWhereUniqueWithoutBranchInput = {
    where: OTWhereUniqueInput
    update: XOR<OTUpdateWithoutBranchInput, OTUncheckedUpdateWithoutBranchInput>
    create: XOR<OTCreateWithoutBranchInput, OTUncheckedCreateWithoutBranchInput>
  }

  export type OTUpdateWithWhereUniqueWithoutBranchInput = {
    where: OTWhereUniqueInput
    data: XOR<OTUpdateWithoutBranchInput, OTUncheckedUpdateWithoutBranchInput>
  }

  export type OTUpdateManyWithWhereWithoutBranchInput = {
    where: OTScalarWhereInput
    data: XOR<OTUpdateManyMutationInput, OTUncheckedUpdateManyWithoutBranchInput>
  }

  export type OTScalarWhereInput = {
    AND?: OTScalarWhereInput | OTScalarWhereInput[]
    OR?: OTScalarWhereInput[]
    NOT?: OTScalarWhereInput | OTScalarWhereInput[]
    id?: StringFilter<"OT"> | string
    branchId?: StringFilter<"OT"> | string
    code?: StringFilter<"OT"> | string
    name?: StringFilter<"OT"> | string
    isActive?: BoolFilter<"OT"> | boolean
    createdAt?: DateTimeFilter<"OT"> | Date | string
    updatedAt?: DateTimeFilter<"OT"> | Date | string
  }

  export type TariffPlanUpsertWithWhereUniqueWithoutBranchInput = {
    where: TariffPlanWhereUniqueInput
    update: XOR<TariffPlanUpdateWithoutBranchInput, TariffPlanUncheckedUpdateWithoutBranchInput>
    create: XOR<TariffPlanCreateWithoutBranchInput, TariffPlanUncheckedCreateWithoutBranchInput>
  }

  export type TariffPlanUpdateWithWhereUniqueWithoutBranchInput = {
    where: TariffPlanWhereUniqueInput
    data: XOR<TariffPlanUpdateWithoutBranchInput, TariffPlanUncheckedUpdateWithoutBranchInput>
  }

  export type TariffPlanUpdateManyWithWhereWithoutBranchInput = {
    where: TariffPlanScalarWhereInput
    data: XOR<TariffPlanUpdateManyMutationInput, TariffPlanUncheckedUpdateManyWithoutBranchInput>
  }

  export type TariffPlanScalarWhereInput = {
    AND?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
    OR?: TariffPlanScalarWhereInput[]
    NOT?: TariffPlanScalarWhereInput | TariffPlanScalarWhereInput[]
    id?: StringFilter<"TariffPlan"> | string
    branchId?: StringFilter<"TariffPlan"> | string
    code?: StringFilter<"TariffPlan"> | string
    name?: StringFilter<"TariffPlan"> | string
    status?: StringFilter<"TariffPlan"> | string
    payerType?: StringFilter<"TariffPlan"> | string
    effectiveFrom?: DateTimeFilter<"TariffPlan"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TariffPlan"> | Date | string | null
    createdAt?: DateTimeFilter<"TariffPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TariffPlan"> | Date | string
  }

  export type AssetUpsertWithWhereUniqueWithoutBranchInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutBranchInput, AssetUncheckedUpdateWithoutBranchInput>
    create: XOR<AssetCreateWithoutBranchInput, AssetUncheckedCreateWithoutBranchInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutBranchInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutBranchInput, AssetUncheckedUpdateWithoutBranchInput>
  }

  export type AssetUpdateManyWithWhereWithoutBranchInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutBranchInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: StringFilter<"Asset"> | string
    branchId?: StringFilter<"Asset"> | string
    code?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    category?: StringFilter<"Asset"> | string
    location?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    updatedAt?: DateTimeFilter<"Asset"> | Date | string
  }

  export type SpecialtyUpsertWithWhereUniqueWithoutBranchInput = {
    where: SpecialtyWhereUniqueInput
    update: XOR<SpecialtyUpdateWithoutBranchInput, SpecialtyUncheckedUpdateWithoutBranchInput>
    create: XOR<SpecialtyCreateWithoutBranchInput, SpecialtyUncheckedCreateWithoutBranchInput>
  }

  export type SpecialtyUpdateWithWhereUniqueWithoutBranchInput = {
    where: SpecialtyWhereUniqueInput
    data: XOR<SpecialtyUpdateWithoutBranchInput, SpecialtyUncheckedUpdateWithoutBranchInput>
  }

  export type SpecialtyUpdateManyWithWhereWithoutBranchInput = {
    where: SpecialtyScalarWhereInput
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyWithoutBranchInput>
  }

  export type SpecialtyScalarWhereInput = {
    AND?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
    OR?: SpecialtyScalarWhereInput[]
    NOT?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
    id?: StringFilter<"Specialty"> | string
    branchId?: StringFilter<"Specialty"> | string
    departmentId?: StringNullableFilter<"Specialty"> | string | null
    code?: StringFilter<"Specialty"> | string
    name?: StringFilter<"Specialty"> | string
    isActive?: BoolFilter<"Specialty"> | boolean
    createdAt?: DateTimeFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeFilter<"Specialty"> | Date | string
  }

  export type StaffUpsertWithWhereUniqueWithoutBranchInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutBranchInput, StaffUncheckedUpdateWithoutBranchInput>
    create: XOR<StaffCreateWithoutBranchInput, StaffUncheckedCreateWithoutBranchInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutBranchInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutBranchInput, StaffUncheckedUpdateWithoutBranchInput>
  }

  export type StaffUpdateManyWithWhereWithoutBranchInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutBranchInput>
  }

  export type StaffScalarWhereInput = {
    AND?: StaffScalarWhereInput | StaffScalarWhereInput[]
    OR?: StaffScalarWhereInput[]
    NOT?: StaffScalarWhereInput | StaffScalarWhereInput[]
    id?: StringFilter<"Staff"> | string
    branchId?: StringFilter<"Staff"> | string
    departmentId?: StringNullableFilter<"Staff"> | string | null
    specialtyId?: StringNullableFilter<"Staff"> | string | null
    empCode?: StringFilter<"Staff"> | string
    name?: StringFilter<"Staff"> | string
    designation?: StringFilter<"Staff"> | string
    phone?: StringNullableFilter<"Staff"> | string | null
    email?: StringNullableFilter<"Staff"> | string | null
    isActive?: BoolFilter<"Staff"> | boolean
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
  }

  export type EncounterUpsertWithWhereUniqueWithoutBranchInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutBranchInput, EncounterUncheckedUpdateWithoutBranchInput>
    create: XOR<EncounterCreateWithoutBranchInput, EncounterUncheckedCreateWithoutBranchInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutBranchInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutBranchInput, EncounterUncheckedUpdateWithoutBranchInput>
  }

  export type EncounterUpdateManyWithWhereWithoutBranchInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutBranchInput>
  }

  export type EncounterScalarWhereInput = {
    AND?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    OR?: EncounterScalarWhereInput[]
    NOT?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    id?: StringFilter<"Encounter"> | string
    branchId?: StringFilter<"Encounter"> | string
    patientId?: StringFilter<"Encounter"> | string
    type?: EnumEncounterTypeFilter<"Encounter"> | $Enums.EncounterType
    startedAt?: DateTimeFilter<"Encounter"> | Date | string
    endedAt?: DateTimeNullableFilter<"Encounter"> | Date | string | null
    status?: StringFilter<"Encounter"> | string
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
  }

  export type BedUpsertWithWhereUniqueWithoutBranchInput = {
    where: BedWhereUniqueInput
    update: XOR<BedUpdateWithoutBranchInput, BedUncheckedUpdateWithoutBranchInput>
    create: XOR<BedCreateWithoutBranchInput, BedUncheckedCreateWithoutBranchInput>
  }

  export type BedUpdateWithWhereUniqueWithoutBranchInput = {
    where: BedWhereUniqueInput
    data: XOR<BedUpdateWithoutBranchInput, BedUncheckedUpdateWithoutBranchInput>
  }

  export type BedUpdateManyWithWhereWithoutBranchInput = {
    where: BedScalarWhereInput
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyWithoutBranchInput>
  }

  export type BedScalarWhereInput = {
    AND?: BedScalarWhereInput | BedScalarWhereInput[]
    OR?: BedScalarWhereInput[]
    NOT?: BedScalarWhereInput | BedScalarWhereInput[]
    id?: StringFilter<"Bed"> | string
    branchId?: StringFilter<"Bed"> | string
    wardId?: StringFilter<"Bed"> | string
    code?: StringFilter<"Bed"> | string
    state?: EnumBedStateFilter<"Bed"> | $Enums.BedState
    isActive?: BoolFilter<"Bed"> | boolean
    createdAt?: DateTimeFilter<"Bed"> | Date | string
    updatedAt?: DateTimeFilter<"Bed"> | Date | string
  }

  export type AdmissionUpsertWithWhereUniqueWithoutBranchInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutBranchInput, AdmissionUncheckedUpdateWithoutBranchInput>
    create: XOR<AdmissionCreateWithoutBranchInput, AdmissionUncheckedCreateWithoutBranchInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutBranchInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutBranchInput, AdmissionUncheckedUpdateWithoutBranchInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutBranchInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutBranchInput>
  }

  export type AdmissionScalarWhereInput = {
    AND?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    OR?: AdmissionScalarWhereInput[]
    NOT?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    id?: StringFilter<"Admission"> | string
    branchId?: StringFilter<"Admission"> | string
    encounterId?: StringNullableFilter<"Admission"> | string | null
    patientId?: StringFilter<"Admission"> | string
    bedId?: StringNullableFilter<"Admission"> | string | null
    admittedAt?: DateTimeFilter<"Admission"> | Date | string
    dischargedAt?: DateTimeNullableFilter<"Admission"> | Date | string | null
    status?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
  }

  export type StatutoryCaseUpsertWithWhereUniqueWithoutBranchInput = {
    where: StatutoryCaseWhereUniqueInput
    update: XOR<StatutoryCaseUpdateWithoutBranchInput, StatutoryCaseUncheckedUpdateWithoutBranchInput>
    create: XOR<StatutoryCaseCreateWithoutBranchInput, StatutoryCaseUncheckedCreateWithoutBranchInput>
  }

  export type StatutoryCaseUpdateWithWhereUniqueWithoutBranchInput = {
    where: StatutoryCaseWhereUniqueInput
    data: XOR<StatutoryCaseUpdateWithoutBranchInput, StatutoryCaseUncheckedUpdateWithoutBranchInput>
  }

  export type StatutoryCaseUpdateManyWithWhereWithoutBranchInput = {
    where: StatutoryCaseScalarWhereInput
    data: XOR<StatutoryCaseUpdateManyMutationInput, StatutoryCaseUncheckedUpdateManyWithoutBranchInput>
  }

  export type StatutoryCaseScalarWhereInput = {
    AND?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
    OR?: StatutoryCaseScalarWhereInput[]
    NOT?: StatutoryCaseScalarWhereInput | StatutoryCaseScalarWhereInput[]
    id?: StringFilter<"StatutoryCase"> | string
    branchId?: StringFilter<"StatutoryCase"> | string
    patientId?: StringFilter<"StatutoryCase"> | string
    program?: StringFilter<"StatutoryCase"> | string
    disease?: StringFilter<"StatutoryCase"> | string
    status?: StringFilter<"StatutoryCase"> | string
    createdAt?: DateTimeFilter<"StatutoryCase"> | Date | string
    updatedAt?: DateTimeFilter<"StatutoryCase"> | Date | string
  }

  export type AuditEventUpsertWithWhereUniqueWithoutBranchInput = {
    where: AuditEventWhereUniqueInput
    update: XOR<AuditEventUpdateWithoutBranchInput, AuditEventUncheckedUpdateWithoutBranchInput>
    create: XOR<AuditEventCreateWithoutBranchInput, AuditEventUncheckedCreateWithoutBranchInput>
  }

  export type AuditEventUpdateWithWhereUniqueWithoutBranchInput = {
    where: AuditEventWhereUniqueInput
    data: XOR<AuditEventUpdateWithoutBranchInput, AuditEventUncheckedUpdateWithoutBranchInput>
  }

  export type AuditEventUpdateManyWithWhereWithoutBranchInput = {
    where: AuditEventScalarWhereInput
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyWithoutBranchInput>
  }

  export type AuditEventScalarWhereInput = {
    AND?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
    OR?: AuditEventScalarWhereInput[]
    NOT?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
    id?: StringFilter<"AuditEvent"> | string
    branchId?: StringNullableFilter<"AuditEvent"> | string | null
    actorUserId?: StringNullableFilter<"AuditEvent"> | string | null
    action?: StringFilter<"AuditEvent"> | string
    entity?: StringFilter<"AuditEvent"> | string
    entityId?: StringNullableFilter<"AuditEvent"> | string | null
    meta?: JsonNullableFilter<"AuditEvent">
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
  }

  export type BranchCreateWithoutDepartmentsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutDepartmentsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
  }

  export type StaffCreateWithoutDepartmentInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStaffInput
    specialty?: SpecialtyCreateNestedOneWithoutStaffInput
    user?: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutDepartmentInput = {
    id?: string
    branchId: string
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffCreateManyDepartmentInputEnvelope = {
    data: StaffCreateManyDepartmentInput | StaffCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type SpecialtyCreateWithoutDepartmentInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSpecialtyInput
    staff?: StaffCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutDepartmentInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutDepartmentInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutDepartmentInput, SpecialtyUncheckedCreateWithoutDepartmentInput>
  }

  export type SpecialtyCreateManyDepartmentInputEnvelope = {
    data: SpecialtyCreateManyDepartmentInput | SpecialtyCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutDepartmentsInput = {
    update: XOR<BranchUpdateWithoutDepartmentsInput, BranchUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<BranchCreateWithoutDepartmentsInput, BranchUncheckedCreateWithoutDepartmentsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutDepartmentsInput, BranchUncheckedUpdateWithoutDepartmentsInput>
  }

  export type BranchUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type StaffUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutDepartmentInput, StaffUncheckedUpdateWithoutDepartmentInput>
    create: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutDepartmentInput, StaffUncheckedUpdateWithoutDepartmentInput>
  }

  export type StaffUpdateManyWithWhereWithoutDepartmentInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type SpecialtyUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: SpecialtyWhereUniqueInput
    update: XOR<SpecialtyUpdateWithoutDepartmentInput, SpecialtyUncheckedUpdateWithoutDepartmentInput>
    create: XOR<SpecialtyCreateWithoutDepartmentInput, SpecialtyUncheckedCreateWithoutDepartmentInput>
  }

  export type SpecialtyUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: SpecialtyWhereUniqueInput
    data: XOR<SpecialtyUpdateWithoutDepartmentInput, SpecialtyUncheckedUpdateWithoutDepartmentInput>
  }

  export type SpecialtyUpdateManyWithWhereWithoutDepartmentInput = {
    where: SpecialtyScalarWhereInput
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type BranchCreateWithoutSpecialtyInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSpecialtyInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSpecialtyInput, BranchUncheckedCreateWithoutSpecialtyInput>
  }

  export type DepartmentCreateWithoutSpecialtiesInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutSpecialtiesInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutSpecialtiesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutSpecialtiesInput, DepartmentUncheckedCreateWithoutSpecialtiesInput>
  }

  export type StaffCreateWithoutSpecialtyInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    user?: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserUncheckedCreateNestedOneWithoutStaffInput
  }

  export type StaffCreateOrConnectWithoutSpecialtyInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput>
  }

  export type StaffCreateManySpecialtyInputEnvelope = {
    data: StaffCreateManySpecialtyInput | StaffCreateManySpecialtyInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutSpecialtyInput = {
    update: XOR<BranchUpdateWithoutSpecialtyInput, BranchUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<BranchCreateWithoutSpecialtyInput, BranchUncheckedCreateWithoutSpecialtyInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSpecialtyInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSpecialtyInput, BranchUncheckedUpdateWithoutSpecialtyInput>
  }

  export type BranchUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type DepartmentUpsertWithoutSpecialtiesInput = {
    update: XOR<DepartmentUpdateWithoutSpecialtiesInput, DepartmentUncheckedUpdateWithoutSpecialtiesInput>
    create: XOR<DepartmentCreateWithoutSpecialtiesInput, DepartmentUncheckedCreateWithoutSpecialtiesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutSpecialtiesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutSpecialtiesInput, DepartmentUncheckedUpdateWithoutSpecialtiesInput>
  }

  export type DepartmentUpdateWithoutSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type StaffUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutSpecialtyInput, StaffUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<StaffCreateWithoutSpecialtyInput, StaffUncheckedCreateWithoutSpecialtyInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutSpecialtyInput, StaffUncheckedUpdateWithoutSpecialtyInput>
  }

  export type StaffUpdateManyWithWhereWithoutSpecialtyInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutSpecialtyInput>
  }

  export type BranchCreateWithoutStaffInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutStaffInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutStaffInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutStaffInput, BranchUncheckedCreateWithoutStaffInput>
  }

  export type DepartmentCreateWithoutStaffInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutDepartmentsInput
    specialties?: SpecialtyCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutStaffInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutStaffInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
  }

  export type SpecialtyCreateWithoutStaffInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutSpecialtyInput
    department?: DepartmentCreateNestedOneWithoutSpecialtiesInput
  }

  export type SpecialtyUncheckedCreateWithoutStaffInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyCreateOrConnectWithoutStaffInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutStaffInput, SpecialtyUncheckedCreateWithoutStaffInput>
  }

  export type UserCreateWithoutStaffInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
  }

  export type UserUncheckedCreateWithoutStaffInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
  }

  export type UserCreateOrConnectWithoutStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
  }

  export type BranchUpsertWithoutStaffInput = {
    update: XOR<BranchUpdateWithoutStaffInput, BranchUncheckedUpdateWithoutStaffInput>
    create: XOR<BranchCreateWithoutStaffInput, BranchUncheckedCreateWithoutStaffInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutStaffInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutStaffInput, BranchUncheckedUpdateWithoutStaffInput>
  }

  export type BranchUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type DepartmentUpsertWithoutStaffInput = {
    update: XOR<DepartmentUpdateWithoutStaffInput, DepartmentUncheckedUpdateWithoutStaffInput>
    create: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutStaffInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutStaffInput, DepartmentUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutDepartmentsNestedInput
    specialties?: SpecialtyUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialties?: SpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type SpecialtyUpsertWithoutStaffInput = {
    update: XOR<SpecialtyUpdateWithoutStaffInput, SpecialtyUncheckedUpdateWithoutStaffInput>
    create: XOR<SpecialtyCreateWithoutStaffInput, SpecialtyUncheckedCreateWithoutStaffInput>
    where?: SpecialtyWhereInput
  }

  export type SpecialtyUpdateToOneWithWhereWithoutStaffInput = {
    where?: SpecialtyWhereInput
    data: XOR<SpecialtyUpdateWithoutStaffInput, SpecialtyUncheckedUpdateWithoutStaffInput>
  }

  export type SpecialtyUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSpecialtyNestedInput
    department?: DepartmentUpdateOneWithoutSpecialtiesNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutStaffInput = {
    update: XOR<UserUpdateWithoutStaffInput, UserUncheckedUpdateWithoutStaffInput>
    create: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffInput, UserUncheckedUpdateWithoutStaffInput>
  }

  export type UserUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
  }

  export type BranchCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type StaffCreateWithoutUserInput = {
    id?: string
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    specialty?: SpecialtyCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutUserInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateOrConnectWithoutUserInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
  }

  export type RoleTemplateVersionCreateWithoutUsersInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleTemplate: RoleTemplateCreateNestedOneWithoutVersionsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedRoleVersionsInput
    permissions?: RoleTemplatePermissionCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUncheckedCreateWithoutUsersInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RoleTemplatePermissionUncheckedCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionCreateOrConnectWithoutUsersInput = {
    where: RoleTemplateVersionWhereUniqueInput
    create: XOR<RoleTemplateVersionCreateWithoutUsersInput, RoleTemplateVersionUncheckedCreateWithoutUsersInput>
  }

  export type RoleTemplateVersionCreateWithoutCreatedByUserInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleTemplate: RoleTemplateCreateNestedOneWithoutVersionsInput
    permissions?: RoleTemplatePermissionCreateNestedManyWithoutRoleVersionInput
    users?: UserCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RoleTemplatePermissionUncheckedCreateNestedManyWithoutRoleVersionInput
    users?: UserUncheckedCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionCreateOrConnectWithoutCreatedByUserInput = {
    where: RoleTemplateVersionWhereUniqueInput
    create: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput>
  }

  export type RoleTemplateVersionCreateManyCreatedByUserInputEnvelope = {
    data: RoleTemplateVersionCreateManyCreatedByUserInput | RoleTemplateVersionCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditEventCreateWithoutActorUserInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    branch?: BranchCreateNestedOneWithoutAuditEventsInput
  }

  export type AuditEventUncheckedCreateWithoutActorUserInput = {
    id?: string
    branchId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditEventCreateOrConnectWithoutActorUserInput = {
    where: AuditEventWhereUniqueInput
    create: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput>
  }

  export type AuditEventCreateManyActorUserInputEnvelope = {
    data: AuditEventCreateManyActorUserInput | AuditEventCreateManyActorUserInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type StaffUpsertWithoutUserInput = {
    update: XOR<StaffUpdateWithoutUserInput, StaffUncheckedUpdateWithoutUserInput>
    create: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutUserInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutUserInput, StaffUncheckedUpdateWithoutUserInput>
  }

  export type StaffUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    specialty?: SpecialtyUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateVersionUpsertWithoutUsersInput = {
    update: XOR<RoleTemplateVersionUpdateWithoutUsersInput, RoleTemplateVersionUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleTemplateVersionCreateWithoutUsersInput, RoleTemplateVersionUncheckedCreateWithoutUsersInput>
    where?: RoleTemplateVersionWhereInput
  }

  export type RoleTemplateVersionUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleTemplateVersionWhereInput
    data: XOR<RoleTemplateVersionUpdateWithoutUsersInput, RoleTemplateVersionUncheckedUpdateWithoutUsersInput>
  }

  export type RoleTemplateVersionUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleTemplate?: RoleTemplateUpdateOneRequiredWithoutVersionsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedRoleVersionsNestedInput
    permissions?: RoleTemplatePermissionUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: RoleTemplateVersionWhereUniqueInput
    update: XOR<RoleTemplateVersionUpdateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<RoleTemplateVersionCreateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedCreateWithoutCreatedByUserInput>
  }

  export type RoleTemplateVersionUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: RoleTemplateVersionWhereUniqueInput
    data: XOR<RoleTemplateVersionUpdateWithoutCreatedByUserInput, RoleTemplateVersionUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type RoleTemplateVersionUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: RoleTemplateVersionScalarWhereInput
    data: XOR<RoleTemplateVersionUpdateManyMutationInput, RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type RoleTemplateVersionScalarWhereInput = {
    AND?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
    OR?: RoleTemplateVersionScalarWhereInput[]
    NOT?: RoleTemplateVersionScalarWhereInput | RoleTemplateVersionScalarWhereInput[]
    id?: StringFilter<"RoleTemplateVersion"> | string
    roleTemplateId?: StringFilter<"RoleTemplateVersion"> | string
    version?: IntFilter<"RoleTemplateVersion"> | number
    status?: EnumRoleVersionStatusFilter<"RoleTemplateVersion"> | $Enums.RoleVersionStatus
    notes?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdByUserId?: StringNullableFilter<"RoleTemplateVersion"> | string | null
    createdAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplateVersion"> | Date | string
  }

  export type AuditEventUpsertWithWhereUniqueWithoutActorUserInput = {
    where: AuditEventWhereUniqueInput
    update: XOR<AuditEventUpdateWithoutActorUserInput, AuditEventUncheckedUpdateWithoutActorUserInput>
    create: XOR<AuditEventCreateWithoutActorUserInput, AuditEventUncheckedCreateWithoutActorUserInput>
  }

  export type AuditEventUpdateWithWhereUniqueWithoutActorUserInput = {
    where: AuditEventWhereUniqueInput
    data: XOR<AuditEventUpdateWithoutActorUserInput, AuditEventUncheckedUpdateWithoutActorUserInput>
  }

  export type AuditEventUpdateManyWithWhereWithoutActorUserInput = {
    where: AuditEventScalarWhereInput
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyWithoutActorUserInput>
  }

  export type BranchCreateWithoutPatientsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutPatientsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutPatientsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
  }

  export type EncounterCreateWithoutPatientInput = {
    id?: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEncounterInput
    admissions?: AdmissionCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutPatientInput = {
    id?: string
    branchId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput>
  }

  export type EncounterCreateManyPatientInputEnvelope = {
    data: EncounterCreateManyPatientInput | EncounterCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionCreateWithoutPatientInput = {
    id?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutAdmissionInput
    encounter?: EncounterCreateNestedOneWithoutAdmissionsInput
    bed?: BedCreateNestedOneWithoutAdmissionsInput
  }

  export type AdmissionUncheckedCreateWithoutPatientInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateOrConnectWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput>
  }

  export type AdmissionCreateManyPatientInputEnvelope = {
    data: AdmissionCreateManyPatientInput | AdmissionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ConsentRecordCreateWithoutPatientInput = {
    id?: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
  }

  export type ConsentRecordUncheckedCreateWithoutPatientInput = {
    id?: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
  }

  export type ConsentRecordCreateOrConnectWithoutPatientInput = {
    where: ConsentRecordWhereUniqueInput
    create: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput>
  }

  export type ConsentRecordCreateManyPatientInputEnvelope = {
    data: ConsentRecordCreateManyPatientInput | ConsentRecordCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type RtbfRequestCreateWithoutPatientInput = {
    id?: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RtbfRequestUncheckedCreateWithoutPatientInput = {
    id?: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RtbfRequestCreateOrConnectWithoutPatientInput = {
    where: RtbfRequestWhereUniqueInput
    create: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput>
  }

  export type RtbfRequestCreateManyPatientInputEnvelope = {
    data: RtbfRequestCreateManyPatientInput | RtbfRequestCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type StatutoryCaseCreateWithoutPatientInput = {
    id?: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutStatutoryCasesInput
  }

  export type StatutoryCaseUncheckedCreateWithoutPatientInput = {
    id?: string
    branchId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseCreateOrConnectWithoutPatientInput = {
    where: StatutoryCaseWhereUniqueInput
    create: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput>
  }

  export type StatutoryCaseCreateManyPatientInputEnvelope = {
    data: StatutoryCaseCreateManyPatientInput | StatutoryCaseCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutPatientsInput = {
    update: XOR<BranchUpdateWithoutPatientsInput, BranchUncheckedUpdateWithoutPatientsInput>
    create: XOR<BranchCreateWithoutPatientsInput, BranchUncheckedCreateWithoutPatientsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutPatientsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutPatientsInput, BranchUncheckedUpdateWithoutPatientsInput>
  }

  export type BranchUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutPatientInput, EncounterUncheckedUpdateWithoutPatientInput>
    create: XOR<EncounterCreateWithoutPatientInput, EncounterUncheckedCreateWithoutPatientInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutPatientInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutPatientInput, EncounterUncheckedUpdateWithoutPatientInput>
  }

  export type EncounterUpdateManyWithWhereWithoutPatientInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutPatientInput>
  }

  export type AdmissionUpsertWithWhereUniqueWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutPatientInput, AdmissionUncheckedUpdateWithoutPatientInput>
    create: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutPatientInput, AdmissionUncheckedUpdateWithoutPatientInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutPatientInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutPatientInput>
  }

  export type ConsentRecordUpsertWithWhereUniqueWithoutPatientInput = {
    where: ConsentRecordWhereUniqueInput
    update: XOR<ConsentRecordUpdateWithoutPatientInput, ConsentRecordUncheckedUpdateWithoutPatientInput>
    create: XOR<ConsentRecordCreateWithoutPatientInput, ConsentRecordUncheckedCreateWithoutPatientInput>
  }

  export type ConsentRecordUpdateWithWhereUniqueWithoutPatientInput = {
    where: ConsentRecordWhereUniqueInput
    data: XOR<ConsentRecordUpdateWithoutPatientInput, ConsentRecordUncheckedUpdateWithoutPatientInput>
  }

  export type ConsentRecordUpdateManyWithWhereWithoutPatientInput = {
    where: ConsentRecordScalarWhereInput
    data: XOR<ConsentRecordUpdateManyMutationInput, ConsentRecordUncheckedUpdateManyWithoutPatientInput>
  }

  export type ConsentRecordScalarWhereInput = {
    AND?: ConsentRecordScalarWhereInput | ConsentRecordScalarWhereInput[]
    OR?: ConsentRecordScalarWhereInput[]
    NOT?: ConsentRecordScalarWhereInput | ConsentRecordScalarWhereInput[]
    id?: StringFilter<"ConsentRecord"> | string
    patientId?: StringFilter<"ConsentRecord"> | string
    scope?: EnumConsentScopeFilter<"ConsentRecord"> | $Enums.ConsentScope
    purpose?: StringFilter<"ConsentRecord"> | string
    status?: EnumConsentStatusFilter<"ConsentRecord"> | $Enums.ConsentStatus
    createdAt?: DateTimeFilter<"ConsentRecord"> | Date | string
  }

  export type RtbfRequestUpsertWithWhereUniqueWithoutPatientInput = {
    where: RtbfRequestWhereUniqueInput
    update: XOR<RtbfRequestUpdateWithoutPatientInput, RtbfRequestUncheckedUpdateWithoutPatientInput>
    create: XOR<RtbfRequestCreateWithoutPatientInput, RtbfRequestUncheckedCreateWithoutPatientInput>
  }

  export type RtbfRequestUpdateWithWhereUniqueWithoutPatientInput = {
    where: RtbfRequestWhereUniqueInput
    data: XOR<RtbfRequestUpdateWithoutPatientInput, RtbfRequestUncheckedUpdateWithoutPatientInput>
  }

  export type RtbfRequestUpdateManyWithWhereWithoutPatientInput = {
    where: RtbfRequestScalarWhereInput
    data: XOR<RtbfRequestUpdateManyMutationInput, RtbfRequestUncheckedUpdateManyWithoutPatientInput>
  }

  export type RtbfRequestScalarWhereInput = {
    AND?: RtbfRequestScalarWhereInput | RtbfRequestScalarWhereInput[]
    OR?: RtbfRequestScalarWhereInput[]
    NOT?: RtbfRequestScalarWhereInput | RtbfRequestScalarWhereInput[]
    id?: StringFilter<"RtbfRequest"> | string
    patientId?: StringFilter<"RtbfRequest"> | string
    reason?: StringFilter<"RtbfRequest"> | string
    status?: EnumRtbfStatusFilter<"RtbfRequest"> | $Enums.RtbfStatus
    createdAt?: DateTimeFilter<"RtbfRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RtbfRequest"> | Date | string
  }

  export type StatutoryCaseUpsertWithWhereUniqueWithoutPatientInput = {
    where: StatutoryCaseWhereUniqueInput
    update: XOR<StatutoryCaseUpdateWithoutPatientInput, StatutoryCaseUncheckedUpdateWithoutPatientInput>
    create: XOR<StatutoryCaseCreateWithoutPatientInput, StatutoryCaseUncheckedCreateWithoutPatientInput>
  }

  export type StatutoryCaseUpdateWithWhereUniqueWithoutPatientInput = {
    where: StatutoryCaseWhereUniqueInput
    data: XOR<StatutoryCaseUpdateWithoutPatientInput, StatutoryCaseUncheckedUpdateWithoutPatientInput>
  }

  export type StatutoryCaseUpdateManyWithWhereWithoutPatientInput = {
    where: StatutoryCaseScalarWhereInput
    data: XOR<StatutoryCaseUpdateManyMutationInput, StatutoryCaseUncheckedUpdateManyWithoutPatientInput>
  }

  export type BranchCreateWithoutEncounterInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutEncounterInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutEncounterInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutEncounterInput, BranchUncheckedCreateWithoutEncounterInput>
  }

  export type PatientCreateWithoutEncountersInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutEncountersInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutEncountersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
  }

  export type AdmissionCreateWithoutEncounterInput = {
    id?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutAdmissionInput
    patient: PatientCreateNestedOneWithoutAdmissionInput
    bed?: BedCreateNestedOneWithoutAdmissionsInput
  }

  export type AdmissionUncheckedCreateWithoutEncounterInput = {
    id?: string
    branchId: string
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateOrConnectWithoutEncounterInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput>
  }

  export type AdmissionCreateManyEncounterInputEnvelope = {
    data: AdmissionCreateManyEncounterInput | AdmissionCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutEncounterInput = {
    update: XOR<BranchUpdateWithoutEncounterInput, BranchUncheckedUpdateWithoutEncounterInput>
    create: XOR<BranchCreateWithoutEncounterInput, BranchUncheckedCreateWithoutEncounterInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutEncounterInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutEncounterInput, BranchUncheckedUpdateWithoutEncounterInput>
  }

  export type BranchUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PatientUpsertWithoutEncountersInput = {
    update: XOR<PatientUpdateWithoutEncountersInput, PatientUncheckedUpdateWithoutEncountersInput>
    create: XOR<PatientCreateWithoutEncountersInput, PatientUncheckedCreateWithoutEncountersInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutEncountersInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutEncountersInput, PatientUncheckedUpdateWithoutEncountersInput>
  }

  export type PatientUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type AdmissionUpsertWithWhereUniqueWithoutEncounterInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutEncounterInput, AdmissionUncheckedUpdateWithoutEncounterInput>
    create: XOR<AdmissionCreateWithoutEncounterInput, AdmissionUncheckedCreateWithoutEncounterInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutEncounterInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutEncounterInput, AdmissionUncheckedUpdateWithoutEncounterInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutEncounterInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutEncounterInput>
  }

  export type BranchCreateWithoutWardsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutWardsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutWardsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutWardsInput, BranchUncheckedCreateWithoutWardsInput>
  }

  export type BedCreateWithoutWardInput = {
    id?: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBedInput
    admissions?: AdmissionCreateNestedManyWithoutBedInput
  }

  export type BedUncheckedCreateWithoutWardInput = {
    id?: string
    branchId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutBedInput
  }

  export type BedCreateOrConnectWithoutWardInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput>
  }

  export type BedCreateManyWardInputEnvelope = {
    data: BedCreateManyWardInput | BedCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutWardsInput = {
    update: XOR<BranchUpdateWithoutWardsInput, BranchUncheckedUpdateWithoutWardsInput>
    create: XOR<BranchCreateWithoutWardsInput, BranchUncheckedCreateWithoutWardsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutWardsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutWardsInput, BranchUncheckedUpdateWithoutWardsInput>
  }

  export type BranchUpdateWithoutWardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutWardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BedUpsertWithWhereUniqueWithoutWardInput = {
    where: BedWhereUniqueInput
    update: XOR<BedUpdateWithoutWardInput, BedUncheckedUpdateWithoutWardInput>
    create: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput>
  }

  export type BedUpdateWithWhereUniqueWithoutWardInput = {
    where: BedWhereUniqueInput
    data: XOR<BedUpdateWithoutWardInput, BedUncheckedUpdateWithoutWardInput>
  }

  export type BedUpdateManyWithWhereWithoutWardInput = {
    where: BedScalarWhereInput
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyWithoutWardInput>
  }

  export type BranchCreateWithoutBedInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutBedInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutBedInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutBedInput, BranchUncheckedCreateWithoutBedInput>
  }

  export type WardCreateWithoutBedsInput = {
    id?: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutWardsInput
  }

  export type WardUncheckedCreateWithoutBedsInput = {
    id?: string
    branchId: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardCreateOrConnectWithoutBedsInput = {
    where: WardWhereUniqueInput
    create: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
  }

  export type AdmissionCreateWithoutBedInput = {
    id?: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutAdmissionInput
    encounter?: EncounterCreateNestedOneWithoutAdmissionsInput
    patient: PatientCreateNestedOneWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutBedInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    patientId: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateOrConnectWithoutBedInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput>
  }

  export type AdmissionCreateManyBedInputEnvelope = {
    data: AdmissionCreateManyBedInput | AdmissionCreateManyBedInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutBedInput = {
    update: XOR<BranchUpdateWithoutBedInput, BranchUncheckedUpdateWithoutBedInput>
    create: XOR<BranchCreateWithoutBedInput, BranchUncheckedCreateWithoutBedInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutBedInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutBedInput, BranchUncheckedUpdateWithoutBedInput>
  }

  export type BranchUpdateWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type WardUpsertWithoutBedsInput = {
    update: XOR<WardUpdateWithoutBedsInput, WardUncheckedUpdateWithoutBedsInput>
    create: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
    where?: WardWhereInput
  }

  export type WardUpdateToOneWithWhereWithoutBedsInput = {
    where?: WardWhereInput
    data: XOR<WardUpdateWithoutBedsInput, WardUncheckedUpdateWithoutBedsInput>
  }

  export type WardUpdateWithoutBedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutWardsNestedInput
  }

  export type WardUncheckedUpdateWithoutBedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUpsertWithWhereUniqueWithoutBedInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutBedInput, AdmissionUncheckedUpdateWithoutBedInput>
    create: XOR<AdmissionCreateWithoutBedInput, AdmissionUncheckedCreateWithoutBedInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutBedInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutBedInput, AdmissionUncheckedUpdateWithoutBedInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutBedInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutBedInput>
  }

  export type BranchCreateWithoutAdmissionInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAdmissionInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAdmissionInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAdmissionInput, BranchUncheckedCreateWithoutAdmissionInput>
  }

  export type EncounterCreateWithoutAdmissionsInput = {
    id?: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutEncounterInput
    patient: PatientCreateNestedOneWithoutEncountersInput
  }

  export type EncounterUncheckedCreateWithoutAdmissionsInput = {
    id?: string
    branchId: string
    patientId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterCreateOrConnectWithoutAdmissionsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutAdmissionsInput, EncounterUncheckedCreateWithoutAdmissionsInput>
  }

  export type PatientCreateWithoutAdmissionInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAdmissionInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAdmissionInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAdmissionInput, PatientUncheckedCreateWithoutAdmissionInput>
  }

  export type BedCreateWithoutAdmissionsInput = {
    id?: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutBedInput
    ward: WardCreateNestedOneWithoutBedsInput
  }

  export type BedUncheckedCreateWithoutAdmissionsInput = {
    id?: string
    branchId: string
    wardId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedCreateOrConnectWithoutAdmissionsInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutAdmissionsInput, BedUncheckedCreateWithoutAdmissionsInput>
  }

  export type BranchUpsertWithoutAdmissionInput = {
    update: XOR<BranchUpdateWithoutAdmissionInput, BranchUncheckedUpdateWithoutAdmissionInput>
    create: XOR<BranchCreateWithoutAdmissionInput, BranchUncheckedCreateWithoutAdmissionInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAdmissionInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAdmissionInput, BranchUncheckedUpdateWithoutAdmissionInput>
  }

  export type BranchUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type EncounterUpsertWithoutAdmissionsInput = {
    update: XOR<EncounterUpdateWithoutAdmissionsInput, EncounterUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<EncounterCreateWithoutAdmissionsInput, EncounterUncheckedCreateWithoutAdmissionsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutAdmissionsInput, EncounterUncheckedUpdateWithoutAdmissionsInput>
  }

  export type EncounterUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEncounterNestedInput
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type EncounterUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpsertWithoutAdmissionInput = {
    update: XOR<PatientUpdateWithoutAdmissionInput, PatientUncheckedUpdateWithoutAdmissionInput>
    create: XOR<PatientCreateWithoutAdmissionInput, PatientUncheckedCreateWithoutAdmissionInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAdmissionInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAdmissionInput, PatientUncheckedUpdateWithoutAdmissionInput>
  }

  export type PatientUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type BedUpsertWithoutAdmissionsInput = {
    update: XOR<BedUpdateWithoutAdmissionsInput, BedUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<BedCreateWithoutAdmissionsInput, BedUncheckedCreateWithoutAdmissionsInput>
    where?: BedWhereInput
  }

  export type BedUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: BedWhereInput
    data: XOR<BedUpdateWithoutAdmissionsInput, BedUncheckedUpdateWithoutAdmissionsInput>
  }

  export type BedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBedNestedInput
    ward?: WardUpdateOneRequiredWithoutBedsNestedInput
  }

  export type BedUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchCreateWithoutOTsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutOTsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutOTsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutOTsInput, BranchUncheckedCreateWithoutOTsInput>
  }

  export type BranchUpsertWithoutOTsInput = {
    update: XOR<BranchUpdateWithoutOTsInput, BranchUncheckedUpdateWithoutOTsInput>
    create: XOR<BranchCreateWithoutOTsInput, BranchUncheckedCreateWithoutOTsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutOTsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutOTsInput, BranchUncheckedUpdateWithoutOTsInput>
  }

  export type BranchUpdateWithoutOTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutOTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutAssetsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAssetsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAssetsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAssetsInput, BranchUncheckedCreateWithoutAssetsInput>
  }

  export type BranchUpsertWithoutAssetsInput = {
    update: XOR<BranchUpdateWithoutAssetsInput, BranchUncheckedUpdateWithoutAssetsInput>
    create: XOR<BranchCreateWithoutAssetsInput, BranchUncheckedCreateWithoutAssetsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAssetsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAssetsInput, BranchUncheckedUpdateWithoutAssetsInput>
  }

  export type BranchUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateWithoutTariffPlansInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutTariffPlansInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutTariffPlansInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutTariffPlansInput, BranchUncheckedCreateWithoutTariffPlansInput>
  }

  export type TariffRateCreateWithoutTariffPlanInput = {
    id?: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffRateUncheckedCreateWithoutTariffPlanInput = {
    id?: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffRateCreateOrConnectWithoutTariffPlanInput = {
    where: TariffRateWhereUniqueInput
    create: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput>
  }

  export type TariffRateCreateManyTariffPlanInputEnvelope = {
    data: TariffRateCreateManyTariffPlanInput | TariffRateCreateManyTariffPlanInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutTariffPlansInput = {
    update: XOR<BranchUpdateWithoutTariffPlansInput, BranchUncheckedUpdateWithoutTariffPlansInput>
    create: XOR<BranchCreateWithoutTariffPlansInput, BranchUncheckedCreateWithoutTariffPlansInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutTariffPlansInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutTariffPlansInput, BranchUncheckedUpdateWithoutTariffPlansInput>
  }

  export type BranchUpdateWithoutTariffPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutTariffPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type TariffRateUpsertWithWhereUniqueWithoutTariffPlanInput = {
    where: TariffRateWhereUniqueInput
    update: XOR<TariffRateUpdateWithoutTariffPlanInput, TariffRateUncheckedUpdateWithoutTariffPlanInput>
    create: XOR<TariffRateCreateWithoutTariffPlanInput, TariffRateUncheckedCreateWithoutTariffPlanInput>
  }

  export type TariffRateUpdateWithWhereUniqueWithoutTariffPlanInput = {
    where: TariffRateWhereUniqueInput
    data: XOR<TariffRateUpdateWithoutTariffPlanInput, TariffRateUncheckedUpdateWithoutTariffPlanInput>
  }

  export type TariffRateUpdateManyWithWhereWithoutTariffPlanInput = {
    where: TariffRateScalarWhereInput
    data: XOR<TariffRateUpdateManyMutationInput, TariffRateUncheckedUpdateManyWithoutTariffPlanInput>
  }

  export type TariffRateScalarWhereInput = {
    AND?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
    OR?: TariffRateScalarWhereInput[]
    NOT?: TariffRateScalarWhereInput | TariffRateScalarWhereInput[]
    id?: StringFilter<"TariffRate"> | string
    tariffPlanId?: StringFilter<"TariffRate"> | string
    serviceCode?: StringFilter<"TariffRate"> | string
    amount?: DecimalFilter<"TariffRate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TariffRate"> | Date | string
    updatedAt?: DateTimeFilter<"TariffRate"> | Date | string
  }

  export type TariffPlanCreateWithoutRatesInput = {
    id?: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutTariffPlansInput
  }

  export type TariffPlanUncheckedCreateWithoutRatesInput = {
    id?: string
    branchId: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffPlanCreateOrConnectWithoutRatesInput = {
    where: TariffPlanWhereUniqueInput
    create: XOR<TariffPlanCreateWithoutRatesInput, TariffPlanUncheckedCreateWithoutRatesInput>
  }

  export type TariffPlanUpsertWithoutRatesInput = {
    update: XOR<TariffPlanUpdateWithoutRatesInput, TariffPlanUncheckedUpdateWithoutRatesInput>
    create: XOR<TariffPlanCreateWithoutRatesInput, TariffPlanUncheckedCreateWithoutRatesInput>
    where?: TariffPlanWhereInput
  }

  export type TariffPlanUpdateToOneWithWhereWithoutRatesInput = {
    where?: TariffPlanWhereInput
    data: XOR<TariffPlanUpdateWithoutRatesInput, TariffPlanUncheckedUpdateWithoutRatesInput>
  }

  export type TariffPlanUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutTariffPlansNestedInput
  }

  export type TariffPlanUncheckedUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateWithoutConsentRecordsInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutConsentRecordsInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutConsentRecordsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutConsentRecordsInput, PatientUncheckedCreateWithoutConsentRecordsInput>
  }

  export type PatientUpsertWithoutConsentRecordsInput = {
    update: XOR<PatientUpdateWithoutConsentRecordsInput, PatientUncheckedUpdateWithoutConsentRecordsInput>
    create: XOR<PatientCreateWithoutConsentRecordsInput, PatientUncheckedCreateWithoutConsentRecordsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutConsentRecordsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutConsentRecordsInput, PatientUncheckedUpdateWithoutConsentRecordsInput>
  }

  export type PatientUpdateWithoutConsentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutConsentRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutRtbfRequestsInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutRtbfRequestsInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutRtbfRequestsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutRtbfRequestsInput, PatientUncheckedCreateWithoutRtbfRequestsInput>
  }

  export type PatientUpsertWithoutRtbfRequestsInput = {
    update: XOR<PatientUpdateWithoutRtbfRequestsInput, PatientUncheckedUpdateWithoutRtbfRequestsInput>
    create: XOR<PatientCreateWithoutRtbfRequestsInput, PatientUncheckedCreateWithoutRtbfRequestsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutRtbfRequestsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutRtbfRequestsInput, PatientUncheckedUpdateWithoutRtbfRequestsInput>
  }

  export type PatientUpdateWithoutRtbfRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutRtbfRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type BranchCreateWithoutStatutoryCasesInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutStatutoryCasesInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutStatutoryCasesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutStatutoryCasesInput, BranchUncheckedCreateWithoutStatutoryCasesInput>
  }

  export type PatientCreateWithoutStatutoryCasesInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch: BranchCreateNestedOneWithoutPatientsInput
    encounters?: EncounterCreateNestedManyWithoutPatientInput
    Admission?: AdmissionCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutStatutoryCasesInput = {
    id?: string
    branchId: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutPatientInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    consentRecords?: ConsentRecordUncheckedCreateNestedManyWithoutPatientInput
    rtbfRequests?: RtbfRequestUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutStatutoryCasesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutStatutoryCasesInput, PatientUncheckedCreateWithoutStatutoryCasesInput>
  }

  export type BranchUpsertWithoutStatutoryCasesInput = {
    update: XOR<BranchUpdateWithoutStatutoryCasesInput, BranchUncheckedUpdateWithoutStatutoryCasesInput>
    create: XOR<BranchCreateWithoutStatutoryCasesInput, BranchUncheckedCreateWithoutStatutoryCasesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutStatutoryCasesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutStatutoryCasesInput, BranchUncheckedUpdateWithoutStatutoryCasesInput>
  }

  export type BranchUpdateWithoutStatutoryCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutStatutoryCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type PatientUpsertWithoutStatutoryCasesInput = {
    update: XOR<PatientUpdateWithoutStatutoryCasesInput, PatientUncheckedUpdateWithoutStatutoryCasesInput>
    create: XOR<PatientCreateWithoutStatutoryCasesInput, PatientUncheckedCreateWithoutStatutoryCasesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutStatutoryCasesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutStatutoryCasesInput, PatientUncheckedUpdateWithoutStatutoryCasesInput>
  }

  export type PatientUpdateWithoutStatutoryCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutPatientsNestedInput
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutStatutoryCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type BranchCreateWithoutAuditEventsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutBranchInput
    users?: UserCreateNestedManyWithoutBranchInput
    patients?: PatientCreateNestedManyWithoutBranchInput
    wards?: WardCreateNestedManyWithoutBranchInput
    oTs?: OTCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanCreateNestedManyWithoutBranchInput
    assets?: AssetCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyCreateNestedManyWithoutBranchInput
    Staff?: StaffCreateNestedManyWithoutBranchInput
    Encounter?: EncounterCreateNestedManyWithoutBranchInput
    Bed?: BedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutAuditEventsInput = {
    id?: string
    code: string
    name: string
    city: string
    address?: string | null
    contactPhone1?: string | null
    contactPhone2?: string | null
    contactEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutBranchInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    patients?: PatientUncheckedCreateNestedManyWithoutBranchInput
    wards?: WardUncheckedCreateNestedManyWithoutBranchInput
    oTs?: OTUncheckedCreateNestedManyWithoutBranchInput
    tariffPlans?: TariffPlanUncheckedCreateNestedManyWithoutBranchInput
    assets?: AssetUncheckedCreateNestedManyWithoutBranchInput
    Specialty?: SpecialtyUncheckedCreateNestedManyWithoutBranchInput
    Staff?: StaffUncheckedCreateNestedManyWithoutBranchInput
    Encounter?: EncounterUncheckedCreateNestedManyWithoutBranchInput
    Bed?: BedUncheckedCreateNestedManyWithoutBranchInput
    Admission?: AdmissionUncheckedCreateNestedManyWithoutBranchInput
    statutoryCases?: StatutoryCaseUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutAuditEventsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutAuditEventsInput, BranchUncheckedCreateWithoutAuditEventsInput>
  }

  export type UserCreateWithoutAuditEventsAsActorInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutAuditEventsAsActorInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutAuditEventsAsActorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditEventsAsActorInput, UserUncheckedCreateWithoutAuditEventsAsActorInput>
  }

  export type BranchUpsertWithoutAuditEventsInput = {
    update: XOR<BranchUpdateWithoutAuditEventsInput, BranchUncheckedUpdateWithoutAuditEventsInput>
    create: XOR<BranchCreateWithoutAuditEventsInput, BranchUncheckedCreateWithoutAuditEventsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutAuditEventsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutAuditEventsInput, BranchUncheckedUpdateWithoutAuditEventsInput>
  }

  export type BranchUpdateWithoutAuditEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutBranchNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    patients?: PatientUpdateManyWithoutBranchNestedInput
    wards?: WardUpdateManyWithoutBranchNestedInput
    oTs?: OTUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUpdateManyWithoutBranchNestedInput
    assets?: AssetUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUpdateManyWithoutBranchNestedInput
    Staff?: StaffUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUpdateManyWithoutBranchNestedInput
    Bed?: BedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutAuditEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone1?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone2?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutBranchNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    patients?: PatientUncheckedUpdateManyWithoutBranchNestedInput
    wards?: WardUncheckedUpdateManyWithoutBranchNestedInput
    oTs?: OTUncheckedUpdateManyWithoutBranchNestedInput
    tariffPlans?: TariffPlanUncheckedUpdateManyWithoutBranchNestedInput
    assets?: AssetUncheckedUpdateManyWithoutBranchNestedInput
    Specialty?: SpecialtyUncheckedUpdateManyWithoutBranchNestedInput
    Staff?: StaffUncheckedUpdateManyWithoutBranchNestedInput
    Encounter?: EncounterUncheckedUpdateManyWithoutBranchNestedInput
    Bed?: BedUncheckedUpdateManyWithoutBranchNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutBranchNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type UserUpsertWithoutAuditEventsAsActorInput = {
    update: XOR<UserUpdateWithoutAuditEventsAsActorInput, UserUncheckedUpdateWithoutAuditEventsAsActorInput>
    create: XOR<UserCreateWithoutAuditEventsAsActorInput, UserUncheckedCreateWithoutAuditEventsAsActorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditEventsAsActorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditEventsAsActorInput, UserUncheckedUpdateWithoutAuditEventsAsActorInput>
  }

  export type UserUpdateWithoutAuditEventsAsActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditEventsAsActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type RoleTemplatePermissionCreateWithoutPermissionInput = {
    id?: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roleVersion: RoleTemplateVersionCreateNestedOneWithoutPermissionsInput
  }

  export type RoleTemplatePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleVersionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionCreateOrConnectWithoutPermissionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    create: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RoleTemplatePermissionCreateManyPermissionInputEnvelope = {
    data: RoleTemplatePermissionCreateManyPermissionInput | RoleTemplatePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RoleTemplatePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    update: XOR<RoleTemplatePermissionUpdateWithoutPermissionInput, RoleTemplatePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RoleTemplatePermissionCreateWithoutPermissionInput, RoleTemplatePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RoleTemplatePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    data: XOR<RoleTemplatePermissionUpdateWithoutPermissionInput, RoleTemplatePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RoleTemplatePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RoleTemplatePermissionScalarWhereInput
    data: XOR<RoleTemplatePermissionUpdateManyMutationInput, RoleTemplatePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleTemplatePermissionScalarWhereInput = {
    AND?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
    OR?: RoleTemplatePermissionScalarWhereInput[]
    NOT?: RoleTemplatePermissionScalarWhereInput | RoleTemplatePermissionScalarWhereInput[]
    id?: StringFilter<"RoleTemplatePermission"> | string
    roleVersionId?: StringFilter<"RoleTemplatePermission"> | string
    permissionId?: StringFilter<"RoleTemplatePermission"> | string
    allowed?: BoolFilter<"RoleTemplatePermission"> | boolean
    createdAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
    updatedAt?: DateTimeFilter<"RoleTemplatePermission"> | Date | string
  }

  export type RoleTemplateVersionCreateWithoutRoleTemplateInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUser?: UserCreateNestedOneWithoutCreatedRoleVersionsInput
    permissions?: RoleTemplatePermissionCreateNestedManyWithoutRoleVersionInput
    users?: UserCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RoleTemplatePermissionUncheckedCreateNestedManyWithoutRoleVersionInput
    users?: UserUncheckedCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionCreateOrConnectWithoutRoleTemplateInput = {
    where: RoleTemplateVersionWhereUniqueInput
    create: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput>
  }

  export type RoleTemplateVersionCreateManyRoleTemplateInputEnvelope = {
    data: RoleTemplateVersionCreateManyRoleTemplateInput | RoleTemplateVersionCreateManyRoleTemplateInput[]
    skipDuplicates?: boolean
  }

  export type RoleTemplateVersionUpsertWithWhereUniqueWithoutRoleTemplateInput = {
    where: RoleTemplateVersionWhereUniqueInput
    update: XOR<RoleTemplateVersionUpdateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedUpdateWithoutRoleTemplateInput>
    create: XOR<RoleTemplateVersionCreateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedCreateWithoutRoleTemplateInput>
  }

  export type RoleTemplateVersionUpdateWithWhereUniqueWithoutRoleTemplateInput = {
    where: RoleTemplateVersionWhereUniqueInput
    data: XOR<RoleTemplateVersionUpdateWithoutRoleTemplateInput, RoleTemplateVersionUncheckedUpdateWithoutRoleTemplateInput>
  }

  export type RoleTemplateVersionUpdateManyWithWhereWithoutRoleTemplateInput = {
    where: RoleTemplateVersionScalarWhereInput
    data: XOR<RoleTemplateVersionUpdateManyMutationInput, RoleTemplateVersionUncheckedUpdateManyWithoutRoleTemplateInput>
  }

  export type RoleTemplateCreateWithoutVersionsInput = {
    id?: string
    code: string
    name: string
    scope?: $Enums.RoleScope
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateUncheckedCreateWithoutVersionsInput = {
    id?: string
    code: string
    name: string
    scope?: $Enums.RoleScope
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateCreateOrConnectWithoutVersionsInput = {
    where: RoleTemplateWhereUniqueInput
    create: XOR<RoleTemplateCreateWithoutVersionsInput, RoleTemplateUncheckedCreateWithoutVersionsInput>
  }

  export type UserCreateWithoutCreatedRoleVersionsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    roleVersion?: RoleTemplateVersionCreateNestedOneWithoutUsersInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
  }

  export type UserUncheckedCreateWithoutCreatedRoleVersionsInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
  }

  export type UserCreateOrConnectWithoutCreatedRoleVersionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedRoleVersionsInput, UserUncheckedCreateWithoutCreatedRoleVersionsInput>
  }

  export type RoleTemplatePermissionCreateWithoutRoleVersionInput = {
    id?: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRoleGrantsInput
  }

  export type RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput = {
    id?: string
    permissionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionCreateOrConnectWithoutRoleVersionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    create: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput>
  }

  export type RoleTemplatePermissionCreateManyRoleVersionInputEnvelope = {
    data: RoleTemplatePermissionCreateManyRoleVersionInput | RoleTemplatePermissionCreateManyRoleVersionInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRoleVersionInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutUsersInput
    staff?: StaffCreateNestedOneWithoutUserInput
    createdRoleVersions?: RoleTemplateVersionCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventCreateNestedManyWithoutActorUserInput
  }

  export type UserUncheckedCreateWithoutRoleVersionInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedCreateNestedManyWithoutCreatedByUserInput
    auditEventsAsActor?: AuditEventUncheckedCreateNestedManyWithoutActorUserInput
  }

  export type UserCreateOrConnectWithoutRoleVersionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput>
  }

  export type UserCreateManyRoleVersionInputEnvelope = {
    data: UserCreateManyRoleVersionInput | UserCreateManyRoleVersionInput[]
    skipDuplicates?: boolean
  }

  export type RoleTemplateUpsertWithoutVersionsInput = {
    update: XOR<RoleTemplateUpdateWithoutVersionsInput, RoleTemplateUncheckedUpdateWithoutVersionsInput>
    create: XOR<RoleTemplateCreateWithoutVersionsInput, RoleTemplateUncheckedCreateWithoutVersionsInput>
    where?: RoleTemplateWhereInput
  }

  export type RoleTemplateUpdateToOneWithWhereWithoutVersionsInput = {
    where?: RoleTemplateWhereInput
    data: XOR<RoleTemplateUpdateWithoutVersionsInput, RoleTemplateUncheckedUpdateWithoutVersionsInput>
  }

  export type RoleTemplateUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scope?: EnumRoleScopeFieldUpdateOperationsInput | $Enums.RoleScope
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedRoleVersionsInput = {
    update: XOR<UserUpdateWithoutCreatedRoleVersionsInput, UserUncheckedUpdateWithoutCreatedRoleVersionsInput>
    create: XOR<UserCreateWithoutCreatedRoleVersionsInput, UserUncheckedCreateWithoutCreatedRoleVersionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedRoleVersionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedRoleVersionsInput, UserUncheckedUpdateWithoutCreatedRoleVersionsInput>
  }

  export type UserUpdateWithoutCreatedRoleVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedRoleVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
  }

  export type RoleTemplatePermissionUpsertWithWhereUniqueWithoutRoleVersionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    update: XOR<RoleTemplatePermissionUpdateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedUpdateWithoutRoleVersionInput>
    create: XOR<RoleTemplatePermissionCreateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedCreateWithoutRoleVersionInput>
  }

  export type RoleTemplatePermissionUpdateWithWhereUniqueWithoutRoleVersionInput = {
    where: RoleTemplatePermissionWhereUniqueInput
    data: XOR<RoleTemplatePermissionUpdateWithoutRoleVersionInput, RoleTemplatePermissionUncheckedUpdateWithoutRoleVersionInput>
  }

  export type RoleTemplatePermissionUpdateManyWithWhereWithoutRoleVersionInput = {
    where: RoleTemplatePermissionScalarWhereInput
    data: XOR<RoleTemplatePermissionUpdateManyMutationInput, RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRoleVersionInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleVersionInput, UserUncheckedUpdateWithoutRoleVersionInput>
    create: XOR<UserCreateWithoutRoleVersionInput, UserUncheckedCreateWithoutRoleVersionInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleVersionInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleVersionInput, UserUncheckedUpdateWithoutRoleVersionInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleVersionInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleVersionInput>
  }

  export type RoleTemplateVersionCreateWithoutPermissionsInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleTemplate: RoleTemplateCreateNestedOneWithoutVersionsInput
    createdByUser?: UserCreateNestedOneWithoutCreatedRoleVersionsInput
    users?: UserCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionUncheckedCreateWithoutPermissionsInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleVersionInput
  }

  export type RoleTemplateVersionCreateOrConnectWithoutPermissionsInput = {
    where: RoleTemplateVersionWhereUniqueInput
    create: XOR<RoleTemplateVersionCreateWithoutPermissionsInput, RoleTemplateVersionUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRoleGrantsInput = {
    id?: string
    code: string
    name: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRoleGrantsInput = {
    id?: string
    code: string
    name: string
    category: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRoleGrantsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRoleGrantsInput, PermissionUncheckedCreateWithoutRoleGrantsInput>
  }

  export type RoleTemplateVersionUpsertWithoutPermissionsInput = {
    update: XOR<RoleTemplateVersionUpdateWithoutPermissionsInput, RoleTemplateVersionUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleTemplateVersionCreateWithoutPermissionsInput, RoleTemplateVersionUncheckedCreateWithoutPermissionsInput>
    where?: RoleTemplateVersionWhereInput
  }

  export type RoleTemplateVersionUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleTemplateVersionWhereInput
    data: XOR<RoleTemplateVersionUpdateWithoutPermissionsInput, RoleTemplateVersionUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleTemplateVersionUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleTemplate?: RoleTemplateUpdateOneRequiredWithoutVersionsNestedInput
    createdByUser?: UserUpdateOneWithoutCreatedRoleVersionsNestedInput
    users?: UserUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleVersionNestedInput
  }

  export type PermissionUpsertWithoutRoleGrantsInput = {
    update: XOR<PermissionUpdateWithoutRoleGrantsInput, PermissionUncheckedUpdateWithoutRoleGrantsInput>
    create: XOR<PermissionCreateWithoutRoleGrantsInput, PermissionUncheckedCreateWithoutRoleGrantsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRoleGrantsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRoleGrantsInput, PermissionUncheckedUpdateWithoutRoleGrantsInput>
  }

  export type PermissionUpdateWithoutRoleGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRoleGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyBranchInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    roleVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientCreateManyBranchInput = {
    id?: string
    uhid: string
    name: string
    gender?: string | null
    dob?: Date | string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WardCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    specialty?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OTCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffPlanCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    status: string
    payerType: string
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateManyBranchInput = {
    id?: string
    code: string
    name: string
    category: string
    location?: string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyCreateManyBranchInput = {
    id?: string
    departmentId?: string | null
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateManyBranchInput = {
    id?: string
    departmentId?: string | null
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterCreateManyBranchInput = {
    id?: string
    patientId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedCreateManyBranchInput = {
    id?: string
    wardId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateManyBranchInput = {
    id?: string
    encounterId?: string | null
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseCreateManyBranchInput = {
    id?: string
    patientId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditEventCreateManyBranchInput = {
    id?: string
    actorUserId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DepartmentUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
    specialties?: SpecialtyUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneWithoutUserNestedInput
    roleVersion?: RoleTemplateVersionUpdateOneWithoutUsersNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutPatientNestedInput
    Admission?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    consentRecords?: ConsentRecordUncheckedUpdateManyWithoutPatientNestedInput
    rtbfRequests?: RtbfRequestUncheckedUpdateManyWithoutPatientNestedInput
    statutoryCases?: StatutoryCaseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WardUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beds?: BedUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    beds?: BedUncheckedUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OTUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffPlanUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rates?: TariffRateUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rates?: TariffRateUncheckedUpdateManyWithoutTariffPlanNestedInput
  }

  export type TariffPlanUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    payerType?: StringFieldUpdateOperationsInput | string
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutSpecialtiesNestedInput
    staff?: StaffUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    specialty?: SpecialtyUpdateOneWithoutStaffNestedInput
    user?: UserUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutEncountersNestedInput
    admissions?: AdmissionUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ward?: WardUpdateOneRequiredWithoutBedsNestedInput
    admissions?: AdmissionUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneWithoutAdmissionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAdmissionNestedInput
    bed?: BedUpdateOneWithoutAdmissionsNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutStatutoryCasesNestedInput
  }

  export type StatutoryCaseUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actorUser?: UserUpdateOneWithoutAuditEventsAsActorNestedInput
  }

  export type AuditEventUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorUserId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateManyDepartmentInput = {
    id?: string
    branchId: string
    specialtyId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyCreateManyDepartmentInput = {
    id?: string
    branchId: string
    code: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStaffNestedInput
    specialty?: SpecialtyUpdateOneWithoutStaffNestedInput
    user?: UserUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    specialtyId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSpecialtyNestedInput
    staff?: StaffUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateManySpecialtyInput = {
    id?: string
    branchId: string
    departmentId?: string | null
    empCode: string
    name: string
    designation: string
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    user?: UserUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUncheckedUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateManyWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    empCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateVersionCreateManyCreatedByUserInput = {
    id?: string
    roleTemplateId: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditEventCreateManyActorUserInput = {
    id?: string
    branchId?: string | null
    action: string
    entity: string
    entityId?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RoleTemplateVersionUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleTemplate?: RoleTemplateUpdateOneRequiredWithoutVersionsNestedInput
    permissions?: RoleTemplatePermissionUpdateManyWithoutRoleVersionNestedInput
    users?: UserUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleTemplateId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUpdateWithoutActorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutAuditEventsNestedInput
  }

  export type AuditEventUncheckedUpdateWithoutActorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyWithoutActorUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateManyPatientInput = {
    id?: string
    branchId: string
    type: $Enums.EncounterType
    startedAt?: Date | string
    endedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionCreateManyPatientInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsentRecordCreateManyPatientInput = {
    id?: string
    scope: $Enums.ConsentScope
    purpose: string
    status?: $Enums.ConsentStatus
    createdAt?: Date | string
  }

  export type RtbfRequestCreateManyPatientInput = {
    id?: string
    reason: string
    status?: $Enums.RtbfStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatutoryCaseCreateManyPatientInput = {
    id?: string
    branchId: string
    program: string
    disease: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutEncounterNestedInput
    admissions?: AdmissionUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    type?: EnumEncounterTypeFieldUpdateOperationsInput | $Enums.EncounterType
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutAdmissionNestedInput
    encounter?: EncounterUpdateOneWithoutAdmissionsNestedInput
    bed?: BedUpdateOneWithoutAdmissionsNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsentRecordUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    scope?: EnumConsentScopeFieldUpdateOperationsInput | $Enums.ConsentScope
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumConsentStatusFieldUpdateOperationsInput | $Enums.ConsentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RtbfRequestUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumRtbfStatusFieldUpdateOperationsInput | $Enums.RtbfStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStatutoryCasesNestedInput
  }

  export type StatutoryCaseUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatutoryCaseUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    program?: StringFieldUpdateOperationsInput | string
    disease?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionCreateManyEncounterInput = {
    id?: string
    branchId: string
    patientId: string
    bedId?: string | null
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutAdmissionNestedInput
    patient?: PatientUpdateOneRequiredWithoutAdmissionNestedInput
    bed?: BedUpdateOneWithoutAdmissionsNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    bedId?: NullableStringFieldUpdateOperationsInput | string | null
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BedCreateManyWardInput = {
    id?: string
    branchId: string
    code: string
    state?: $Enums.BedState
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BedUpdateWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutBedNestedInput
    admissions?: AdmissionUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateManyWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    state?: EnumBedStateFieldUpdateOperationsInput | $Enums.BedState
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionCreateManyBedInput = {
    id?: string
    branchId: string
    encounterId?: string | null
    patientId: string
    admittedAt?: Date | string
    dischargedAt?: Date | string | null
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionUpdateWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutAdmissionNestedInput
    encounter?: EncounterUpdateOneWithoutAdmissionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    branchId?: StringFieldUpdateOperationsInput | string
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    admittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateCreateManyTariffPlanInput = {
    id?: string
    serviceCode: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffRateUpdateWithoutTariffPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateUncheckedUpdateWithoutTariffPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffRateUncheckedUpdateManyWithoutTariffPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceCode?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionCreateManyPermissionInput = {
    id?: string
    roleVersionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleVersion?: RoleTemplateVersionUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RoleTemplatePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleVersionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleVersionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplateVersionCreateManyRoleTemplateInput = {
    id?: string
    version: number
    status?: $Enums.RoleVersionStatus
    notes?: string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplateVersionUpdateWithoutRoleTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUser?: UserUpdateOneWithoutCreatedRoleVersionsNestedInput
    permissions?: RoleTemplatePermissionUpdateManyWithoutRoleVersionNestedInput
    users?: UserUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateWithoutRoleTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleVersionNestedInput
  }

  export type RoleTemplateVersionUncheckedUpdateManyWithoutRoleTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumRoleVersionStatusFieldUpdateOperationsInput | $Enums.RoleVersionStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionCreateManyRoleVersionInput = {
    id?: string
    permissionId: string
    allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyRoleVersionInput = {
    id?: string
    email: string
    name: string
    role?: string
    phone?: string | null
    branchId?: string | null
    staffId?: string | null
    isActive?: boolean
    passwordHash?: string | null
    mustChangePassword?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleTemplatePermissionUpdateWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRoleGrantsNestedInput
  }

  export type RoleTemplatePermissionUncheckedUpdateWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleTemplatePermissionUncheckedUpdateManyWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutUsersNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    createdRoleVersions?: RoleTemplateVersionUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUpdateManyWithoutActorUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdRoleVersions?: RoleTemplateVersionUncheckedUpdateManyWithoutCreatedByUserNestedInput
    auditEventsAsActor?: AuditEventUncheckedUpdateManyWithoutActorUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BranchCountOutputTypeDefaultArgs instead
     */
    export type BranchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCountOutputTypeDefaultArgs instead
     */
    export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpecialtyCountOutputTypeDefaultArgs instead
     */
    export type SpecialtyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecialtyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientCountOutputTypeDefaultArgs instead
     */
    export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterCountOutputTypeDefaultArgs instead
     */
    export type EncounterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardCountOutputTypeDefaultArgs instead
     */
    export type WardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BedCountOutputTypeDefaultArgs instead
     */
    export type BedCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BedCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TariffPlanCountOutputTypeDefaultArgs instead
     */
    export type TariffPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TariffPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTemplateCountOutputTypeDefaultArgs instead
     */
    export type RoleTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTemplateVersionCountOutputTypeDefaultArgs instead
     */
    export type RoleTemplateVersionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTemplateVersionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BranchDefaultArgs instead
     */
    export type BranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDefaultArgs instead
     */
    export type DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpecialtyDefaultArgs instead
     */
    export type SpecialtyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpecialtyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StaffDefaultArgs instead
     */
    export type StaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StaffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientDefaultArgs instead
     */
    export type PatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterDefaultArgs instead
     */
    export type EncounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WardDefaultArgs instead
     */
    export type WardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BedDefaultArgs instead
     */
    export type BedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionDefaultArgs instead
     */
    export type AdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OTDefaultArgs instead
     */
    export type OTArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OTDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDefaultArgs instead
     */
    export type AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TariffPlanDefaultArgs instead
     */
    export type TariffPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TariffPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCatalogItemDefaultArgs instead
     */
    export type ServiceCatalogItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCatalogItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TariffRateDefaultArgs instead
     */
    export type TariffRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TariffRateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsentRecordDefaultArgs instead
     */
    export type ConsentRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsentRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RtbfRequestDefaultArgs instead
     */
    export type RtbfRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RtbfRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatutoryCaseDefaultArgs instead
     */
    export type StatutoryCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatutoryCaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditEventDefaultArgs instead
     */
    export type AuditEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutboxEventDefaultArgs instead
     */
    export type OutboxEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OutboxEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTemplateDefaultArgs instead
     */
    export type RoleTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTemplateVersionDefaultArgs instead
     */
    export type RoleTemplateVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTemplateVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleTemplatePermissionDefaultArgs instead
     */
    export type RoleTemplatePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleTemplatePermissionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}